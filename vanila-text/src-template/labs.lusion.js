var Im = Object.defineProperty
  , Dm = Object.defineProperties;
var Fm = Object.getOwnPropertyDescriptors;
var ko = Object.getOwnPropertySymbols;
var Il = Object.prototype.hasOwnProperty
  , Dl = Object.prototype.propertyIsEnumerable;
var cs = (et,$,tt)=>$ in et ? Im(et, $, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: tt
}) : et[$] = tt
  , wn = (et,$)=>{
    for (var tt in $ || ($ = {}))
        Il.call($, tt) && cs(et, tt, $[tt]);
    if (ko)
        for (var tt of ko($))
            Dl.call($, tt) && cs(et, tt, $[tt]);
    return et
}
  , kn = (et,$)=>Dm(et, Fm($));
var nr = (et,$)=>{
    var tt = {};
    for (var nt in et)
        Il.call(et, nt) && $.indexOf(nt) < 0 && (tt[nt] = et[nt]);
    if (et != null && ko)
        for (var nt of ko(et))
            $.indexOf(nt) < 0 && Dl.call(et, nt) && (tt[nt] = et[nt]);
    return tt
}
;
var Et = (et,$,tt)=>(cs(et, typeof $ != "symbol" ? $ + "" : $, tt),
tt);
const p$7 = function() {
    const $ = document.createElement("link").relList;
    if ($ && $.supports && $.supports("modulepreload"))
        return;
    for (const rt of document.querySelectorAll('link[rel="modulepreload"]'))
        nt(rt);
    new MutationObserver(rt=>{
        for (const it of rt)
            if (it.type === "childList")
                for (const ot of it.addedNodes)
                    ot.tagName === "LINK" && ot.rel === "modulepreload" && nt(ot)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function tt(rt) {
        const it = {};
        return rt.integrity && (it.integrity = rt.integrity),
        rt.referrerpolicy && (it.referrerPolicy = rt.referrerpolicy),
        rt.crossorigin === "use-credentials" ? it.credentials = "include" : rt.crossorigin === "anonymous" ? it.credentials = "omit" : it.credentials = "same-origin",
        it
    }
    function nt(rt) {
        if (rt.ep)
            return;
        rt.ep = !0;
        const it = tt(rt);
        fetch(rt.href, it)
    }
};
p$7();
var styles = (()=>`:where(html){line-height:1.15}:where(h1){font-size:2em;-webkit-margin-after:.67em;margin-block-end:.67em;-webkit-margin-before:.67em;margin-block-start:.67em}:where(dl,ol,ul) :where(dl,ol,ul){-webkit-margin-after:0;margin-block-end:0;-webkit-margin-before:0;margin-block-start:0}:where(hr){box-sizing:content-box;color:inherit;height:0}:where(pre){font-family:monospace,monospace;font-size:1em}:where(abbr[title]){text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}:where(b,strong){font-weight:bolder}:where(code,kbd,samp){font-family:monospace,monospace;font-size:1em}:where(small){font-size:80%}:where(table){border-color:currentColor;text-indent:0}:where(button,input,select){margin:0}:where(button){text-transform:none}:where(button,input:is([type="button" i],[type="reset" i],[type="submit" i])){-webkit-appearance:button}:where(progress){vertical-align:baseline}:where(select){text-transform:none}:where(textarea){margin:0}:where(input[type="search" i]){-webkit-appearance:textfield;outline-offset:-2px}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}:where(button,input:is([type="button" i],[type="color" i],[type="reset" i],[type="submit" i]))::-moz-focus-inner{border-style:none;padding:0}:where(button,input:is([type="button" i],[type="color" i],[type="reset" i],[type="submit" i]))::-moz-focusring{outline:1px dotted ButtonText}:where(:-moz-ui-invalid){box-shadow:none}:where(dialog){background-color:#fff;border:solid;color:#000;height:-moz-fit-content;height:-webkit-fit-content;height:fit-content;left:0;margin:auto;padding:1em;position:absolute;right:0;width:-moz-fit-content;width:-webkit-fit-content;width:fit-content}:where(dialog:not([open])){display:none}:where(summary){display:list-item}*,*:before,*:after{box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:none;-webkit-touch-callout:none}*{margin:0;padding:0}html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font:inherit;vertical-align:baseline}button{background:none;border:none;border-radius:none;color:inherit;font:inherit;outline:none;cursor:pointer}input,textarea{-webkit-appearance:none;-moz-appearance:none;appearance:none;background:none;border:none;border-radius:0;outline:none;pointer-events:auto}ol,ul{list-style:none}*:before,*:after{pointer-events:none}.template--no-select{-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.template--no-select:focus{outline:none}.template--no-scroll{-webkit-overflow-scrolling:touch;overflow:hidden;-ms-scroll-chaining:none;overscroll-behavior:none;-ms-overflow-style:none;scrollbar-width:none}.template--no-scroll::-webkit-scrollbar,.template--no-scroll::-webkit-scrollbar-track,.template--no-scroll::-webkit-scrollbar-thumb{-webkit-appearance:none;appearance:none;width:0;height:0;background:transparent;display:none}.template--hide-scrollbar{-ms-overflow-style:none;scrollbar-width:none}.template--hide-scrollbar::-webkit-scrollbar,.template--hide-scrollbar::-webkit-scrollbar-track,.template--hide-scrollbar::-webkit-scrollbar-thumb{-webkit-appearance:none;appearance:none;width:0;height:0;background:transparent;display:none}.template--fixed-full-screen{position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;-ms-scroll-chaining:none;overscroll-behavior:none;touch-action:none}.template--is-active{display:none}.template--is-active.is-active{display:block}.component--active{pointer-events:none;opacity:0}.component--active.--active{opacity:1;pointer-events:auto}.no-transition *{transition:none!important;-webkit-animation:none!important;animation:none!important}.no-transition *:before,.no-transition *:after{transition:none!important;-webkit-animation:none!important;animation:none!important}@font-face{font-family:Aeonik;src:url(https://labs.lusion.co/assets/fonts/Aeonik-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:Aeonik;src:url(https://labs.lusion.co/assets/fonts/Aeonik-RegularItalic.ttf) format("truetype");font-weight:400;font-style:italic}@font-face{font-family:Aeonik;src:url(https://labs.lusion.co/assets/fonts/Aeonik-Medium.ttf) format("truetype");font-weight:500;font-style:normal}@font-face{font-family:Aeonik;src:url(https://labs.lusion.co/assets/fonts/Aeonik-Black.ttf) format("truetype");font-weight:900;font-style:normal}@font-face{font-family:IBMPlexMono-Medium;src:url(https://labs.lusion.co/assets/fonts/IBMPlexMono-Medium.ttf) format("truetype");font-weight:400;font-style:normal}:root{--color-theme: #ffffff;--color-white: #ffffff;--color-white-translucent: rgba(255, 255, 255, .5);--color-black-translucent: rgba(0, 0, 0, .5);--color-white-semitransparent: rgba(255, 255, 255, .2);--color-black-semitransparent: rgba(0, 0, 0, .2);--color-black: #000000;--color-card-white: #ffffff;--color-card-black: #000000}[data-theme=dark]{--color-theme: #000000;--color-white: #000000;--color-white-translucent: rgba(0, 0, 0, .5);--color-black-translucent: rgba(255, 255, 255, .5);--color-white-semitransparent: rgba(0, 0, 0, .2);--color-black-semitransparent: rgba(255, 255, 255, .2);--color-black: #ffffff}*,*:before,*:after{box-sizing:border-box}a{text-decoration:none}a,a:active,a:hover,a:visited{color:currentColor;outline:0}html{-webkit-text-size-adjust:none;-webkit-font-smoothing:subpixel-antialiased;-webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent;font-size:clamp(12px,calc(100vw / 3840 * 32),16px)}@media only screen and (min-width: 768px) and (max-width: 1024px){html{font-size:clamp(12px,calc(100vw / 2482 * 40),16px)}}@media only screen and (min-width: 0px) and (max-width: 768px){html{font-size:clamp(12px,calc(100vw / 1125 * 32),16px)}}h1{margin:0;font-family:Aeonik,sans-serif;font-size:6.15rem;font-style:normal;font-weight:400;line-height:100%;letter-spacing:-.02em}@media only screen and (max-width: 1024px){h1{line-height:auto;font-size:2.5rem}}h2{margin:0;font-family:Aeonik,sans-serif;font-size:2.5rem;font-style:normal;font-weight:400;line-height:120%}h3,h4,h5,h6{margin:0;font-family:Aeonik,sans-serif;font-size:1.25rem;font-style:normal;font-weight:400;line-height:120%}p{font-family:Aeonik,sans-serif;margin:0;line-height:140%;letter-spacing:.05em;font-size:1.45rem;font-weight:400}.t-title-mono{font-family:IBMPlexMono-Medium,monospace;font-size:.8rem;text-transform:uppercase;opacity:.5}.stats{top:initial!important;bottom:0px!important}.hide{visibility:hidden;pointer-events:none}.link{color:var(--color-black);transition:color .25s ease-in-out;cursor:pointer;text-transform:uppercase;text-decoration:none;font-size:1.34rem;line-height:100%}.link:hover{color:var(--color-black-translucent)}.link:focus{color:var(--color-black-translucent)}.link--disable{opacity:.2;cursor:not-allowed}html,body{-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;-ms-scroll-chaining:none;overscroll-behavior:none;touch-action:none}html:focus,body:focus{outline:none}html[data-theme=dark],body[data-theme=dark]{background:black}::-moz-selection{background:var(--color-white);color:var(--color-theme)}::selection{background:var(--color-white);color:var(--color-theme)}html,body,button{font-family:Aeonik,sans-serif;font-weight:400;color:var(--color-black)}html.no-js body{display:none}#ui{transition:height 1s ease-in-out}.no-scroll{pointer-events:none}#canvas{position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;-ms-scroll-chaining:none;overscroll-behavior:none;touch-action:none;background-color:transparent;z-index:-1;pointer-events:none}button{background:none;color:inherit;border:none;padding:0;outline:none;font-size:1rem;cursor:pointer}input[type=submit],input[type=reset]{background:none;color:inherit;border:none;padding:0;outline:none;font-size:1.17rem;cursor:pointer}.input{width:100%;height:4.175rem;padding:1.34rem;border:1px solid var(--color-black);border-radius:8px;background:transparent;font-size:1.45rem;color:var(--color-black)}.input ::-moz-placeholder{color:var(--color-black-translucent);text-transform:uppercase}.input :-ms-input-placeholder{color:var(--color-black-translucent);text-transform:uppercase}.input ::placeholder{color:var(--color-black-translucent);text-transform:uppercase}.input:focus{outline:1px solid var(--color-black)}.input:-webkit-autofill,.input:-webkit-autofill:hover,.input:-webkit-autofill:focus,.input:-webkit-autofill:active{color:var(--color-black);-webkit-box-shadow:0 0 0 30px transparent inset!important;-webkit-text-fill-color:var(--color-black);-webkit-transition:background-color 1000s ease-in-out 0s;transition:background-color 1000s ease-in-out 0s}footer{display:flex;justify-content:flex-end;z-index:1;margin-top:auto}::-moz-placeholder{font-family:Aeonik,sans-serif}:-ms-input-placeholder{font-family:Aeonik,sans-serif}::placeholder{font-family:Aeonik,sans-serif}.o-hide{display:none}.o-invisible{visibility:hidden}@media only screen and (min-width: 0px) and (max-width: 768px){.o-hide-phone{display:none!important}}@media only screen and (min-width: 768px) and (max-width: 1024px){.o-hide-tablet{display:none!important}}@media only screen and (max-width: 1024px){.o-hide-tablet-and-below{display:none!important}}@media only screen and (min-width: 1024px){.o-hide-desktop{display:none!important}}.svgFilterWrapper{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none}.dg.ac{z-index:99999!important}a{text-decoration:none;color:inherit}a:not(.card):hover{opacity:.9}a:focus{opacity:.9}.cursor{--size: 8rem;position:absolute;z-index:99999;top:calc(-1 * var(--size) / 2);left:calc(-1 * var(--size) / 2);width:var(--size);height:var(--size);border-radius:var(--size);pointer-events:none;-webkit-backdrop-filter:invert(1) grayscale(1);backdrop-filter:invert(1) grayscale(1);display:none}.cursor--visible{display:block}#tweakpane{z-index:99999!important;position:absolute}[class^=tp-]{z-index:99999!important}:root{--tp-base-background-color: hsl(230, 7%, 17%);--tp-base-shadow-color: hsla(0, 0%, 0%, .2);--tp-button-background-color: hsl(230, 7%, 70%);--tp-button-background-color-active: hsl(230, 7%, 85%);--tp-button-background-color-focus: hsl(230, 7%, 80%);--tp-button-background-color-hover: hsl(230, 7%, 75%);--tp-button-foreground-color: hsl(230, 7%, 17%);--tp-container-background-color: hsla(230, 7%, 75%, .1);--tp-container-background-color-active: hsla(230, 7%, 75%, .25);--tp-container-background-color-focus: hsla(230, 7%, 75%, .2);--tp-container-background-color-hover: hsla(230, 7%, 75%, .15);--tp-container-foreground-color: hsl(230, 7%, 75%);--tp-groove-foreground-color: hsla(230, 7%, 75%, .1);--tp-input-background-color: hsla(230, 7%, 75%, .1);--tp-input-background-color-active: hsla(230, 7%, 75%, .25);--tp-input-background-color-focus: hsla(230, 7%, 75%, .2);--tp-input-background-color-hover: hsla(230, 7%, 75%, .15);--tp-input-foreground-color: hsl(198, 100%, 50%);--tp-label-foreground-color: hsla(230, 7%, 75%, .7);--tp-monitor-background-color: hsla(0, 0%, 0%, .2);--tp-monitor-foreground-color: hsla(230, 7%, 75%, .7)}.app-wrapper{width:100vw;min-height:100vh;margin:12rem 0 0}@media only screen and (min-width: 768px) and (max-width: 1024px){.app-wrapper{margin:8rem 0 0}}@media only screen and (min-width: 0px) and (max-width: 768px){.app-wrapper{margin:7rem 0 0}}.page-wrapper--hide{display:none}.logo-wrapper{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}.bottom-right-actions{position:fixed;bottom:140px;right:20px;display:flex;flex-flow:column nowrap;justify-content:center;align-items:center;gap:20px}@media only screen and (max-width: 1024px){.bottom-right-actions{display:none}}.about__hero-wrapper{height:80vh;display:flex;align-items:center;padding-bottom:16vh}@media only screen and (max-width: 1024px){.about__hero-wrapper{height:auto;display:block;padding-bottom:0}}.about__hero{max-width:76rem;display:grid;grid-template-columns:repeat(9,1fr);margin:0 auto;padding:0rem 0 8rem}@media only screen and (max-width: 1024px){.about__hero{display:block;padding:8rem 0;margin:0 5rem}}@media only screen and (min-width: 0px) and (max-width: 768px){.about__hero{margin:0 2rem;padding:4rem 0 9.5rem}}.about__hero>*{font-size:10rem;font-weight:400;letter-spacing:-.02em;line-height:100%;white-space:nowrap}@media only screen and (min-width: 768px) and (max-width: 1024px){.about__hero>*{font-size:6.4rem}}@media only screen and (min-width: 0px) and (max-width: 768px){.about__hero>*{font-size:4.8rem}}.about__hero>*:nth-child(1){grid-column:1 / 3;text-align:right;padding-top:.5rem;padding-right:1.5rem}.about__hero>*:nth-child(2){grid-column:3 / 7}.about__hero>*:nth-child(3){grid-column:1 / 6}.about__hero>*:nth-child(4){grid-column:3 / 5;text-align:end}.about__hero>*:nth-child(5){grid-column:6 / -1;align-self:end;padding-bottom:1.8rem;padding-left:1rem}.about__hero>*:nth-child(6){position:relative;grid-column:1 / 9;text-align:center}@media only screen and (max-width: 1024px){.about__hero>*{line-height:103%;white-space:normal;text-align:left!important}.about__hero>*:nth-child(2){padding:1rem 0 2rem}}.about__hero-text--small{font-size:1.17rem;font-weight:400;font-style:normal;text-transform:uppercase;letter-spacing:.1em}@media only screen and (max-width: 1024px){.about__hero-text--small{font-size:1rem}}.about__hero-text--italic{font-weight:400;font-style:italic}@media only screen and (max-width: 1024px){.about__hero-text--offset{margin-left:4rem;margin-right:3rem}}.about__hero a{position:absolute;bottom:8%;right:0;transform:translate(100%,-100%);text-decoration:none;color:inherit;line-height:1}.about__hero a span{margin-right:.25rem}.about__content{display:grid;grid-template-columns:repeat(6,1fr);grid-gap:4rem;padding:0 5rem;margin-bottom:20vh}@media only screen and (max-width: 1024px){.about__content{grid-gap:4rem;grid-template-columns:1fr}}@media only screen and (min-width: 0px) and (max-width: 768px){.about__content{padding:0 2rem}}.about-faq>*{line-height:120%;letter-spacing:.02em}.about-faq__question{text-transform:uppercase;font-size:1.17rem;font-style:italic}.about-faq__answer{font-size:1.8rem;margin-top:2.5rem}@media only screen and (max-width: 1024px){.about-faq__answer{margin-top:1rem;font-size:1.8rem}}.about-faq--large .about-faq__answer{font-size:3rem}@media only screen and (max-width: 1024px){.about-faq--large .about-faq__answer{font-size:2rem}}.about-faq:nth-child(1){grid-column:1 / span 5;margin-bottom:6rem}.about-faq:nth-child(2){grid-column:4 / -1}.about-faq:nth-child(3){grid-column:4 / -1}@media only screen and (max-width: 1024px){.about-faq:nth-child(1){grid-column:auto;margin-bottom:2rem}.about-faq:nth-child(2){grid-column:auto}.about-faq:nth-child(3){grid-column:auto}}.about-categories{line-height:140%;white-space:nowrap}.about-categories svg{width:1rem;height:1rem;margin-right:.5rem}@media only screen and (max-width: 1024px){.about-categories{line-height:120%}}.about__footer{padding:6.667rem 5rem 2.92rem;position:relative}@media only screen and (min-width: 0px) and (max-width: 768px){.about__footer{padding:4rem 2rem}}.about__footer:before{content:"";position:absolute;width:100%;height:1px;top:0;left:0;background:var(--color-black);opacity:.2}.about__footer-grid{display:grid;grid-template-columns:repeat(2,1fr);grid-gap:8rem}@media only screen and (min-width: 0px) and (max-width: 768px){.about__footer-grid{grid-template-columns:1fr;grid-gap:4rem}}.about__footer-desc{grid-row:span 2}.about__footer-desc .about__footer-content{font-size:2.5rem;gap:0}.about__footer-title{margin-bottom:1.5rem}.about__footer-content{text-transform:uppercase;font-size:1.45rem;display:flex;flex-direction:column;gap:.5rem}.about__footer-contact{display:flex;justify-content:space-between;align-items:flex-end}.detail{position:relative;display:grid;grid-template-rows:auto;grid-template-columns:repeat(24,1fr);gap:10vh 1.5rem;padding:0 5rem;height:100vh}@media only screen and (max-width: 1024px){.detail{display:block;grid-template-rows:repeat(2,auto);padding:6rem 5rem 0}}@media only screen and (min-width: 0px) and (max-width: 768px){.detail{padding:6rem 2rem 0}}.detail--first{height:72vh}@media only screen and (max-width: 1024px){.detail--first{height:auto}}.detail--override{height:auto;margin-top:9rem;border-top:1px solid var(--color-black-semitransparent)}@media only screen and (max-width: 1024px){.detail--override{margin-top:5rem}}.detail__hero{font-size:6.15rem;font-weight:400;line-height:100%}.detail__left{display:flex;flex-flow:column;justify-content:space-between;height:100%;padding-bottom:5vh;position:absolute;top:0;grid-column-start:1;grid-column-end:13}@media only screen and (max-width: 1024px){.detail__left{grid-row-start:1;grid-row-end:1;grid-column-start:1;grid-column-end:-1;position:relative;top:0;padding-bottom:4rem}}.detail__left>*{display:flex;flex-flow:column nowrap;gap:2rem}.detail__right{position:absolute;top:0;grid-column-start:13;grid-column-end:25;display:flex;flex-flow:column nowrap;gap:4rem}@media only screen and (max-width: 1024px){.detail__right{position:relative;grid-row-start:2;grid-row-end:2;grid-column-start:1;grid-column-end:-1}}.detail__bottom{grid-column-start:1;grid-column-end:-1}.detail__img{width:100%;height:85vh;border-radius:16px;overflow:hidden;-o-object-fit:cover;object-fit:cover;opacity:0}@media only screen and (max-width: 1024px){.detail__img{width:100%;height:50vh;margin-left:0;margin-top:1rem;margin-bottom:4rem}}.detail__img--show{opacity:1}.detail h3{margin-bottom:2.5rem;font-family:IBMPlexMono-Medium,monospace;line-height:1;letter-spacing:.05em;font-weight:500;font-size:.8rem;color:var(--color-black-translucent);text-transform:uppercase}.detail__description{display:flex;flex-flow:column nowrap;gap:2rem}.detail__cta{display:flex;gap:1rem;color:var(--color-white)}@media only screen and (max-width: 1024px){.detail__cta{margin-bottom:2rem}}.detail__exp-link{display:flex;align-items:center;justify-content:space-between;padding:10px 20px;gap:10px;width:141px;height:44px;font-size:1.17rem!important;letter-spacing:.02em;background:var(--color-black);color:var(--color-white);border-radius:999px;text-transform:uppercase;text-decoration:none;overflow:hidden;cursor:pointer}.detail__likes-btn{box-sizing:border-box;display:flex;align-items:center;justify-content:space-between;padding:10px 20px;gap:10px;width:94px;height:44px;border:1px solid var(--color-black);border-radius:200px}.detail__recognitions{display:flex;flex-flow:column nowrap;gap:.45rem;font-size:1.17rem}@media only screen and (min-width: 0px) and (max-width: 768px){.detail__recognitions{flex-flow:row wrap}}.detail__recognitions>div{flex-basis:100%}@media only screen and (min-width: 0px) and (max-width: 768px){.detail__recognitions>div{flex-basis:49%}}.detail__share{display:flex;gap:1rem}@media only screen and (max-width: 1024px){.detail__share{justify-content:space-around}}.detail__share-btn{display:flex;justify-content:center;align-items:center;width:3.7rem;height:3.7rem;border:1px solid var(--color-black);border-radius:999px;color:var(--color-black);transition:color .15s ease-in-out,background-color .15s ease-in-out}.detail__share-btn:hover{color:var(--color-white);background-color:var(--color-black)}.detail__share-btn svg{width:1.4rem;height:1.4rem}@media only screen and (max-width: 1024px){.detail__share-btn{width:4rem;height:4rem}.detail__share-btn svg{width:2rem;height:2rem}}.detail__description img{width:100%;border-radius:16px}.detail__description h1{font-size:1.375rem;padding:0;margin:2em 0 0}.detail__description h2{font-size:1.8rem;padding:0;margin:2em 0 0}.detail__description h3{font-size:1.45rem;padding:0;margin:2em 0 0}.detail__description hr{background:var(--color-black);width:100%;height:1px;opacity:.2}.detail__description a{color:#006fd6}.detail__description a:hover{text-decoration:underline}.card{position:relative;display:flex;justify-content:center;align-items:center;border-radius:16px;overflow:hidden;pointer-events:all;cursor:pointer;color:var(--color-card-black);transition:color .25s ease-in-out;background-color:var(--color-white)}.card--abs{position:absolute}.card--dark{color:var(--color-card-white)}.card--fixed{width:100%;aspect-ratio:1 / 1.27}@media only screen and (min-width: 768px) and (max-width: 1024px){.card--fixed{aspect-ratio:1.2}}@media only screen and (min-width: 0px) and (max-width: 768px){.card--fixed{aspect-ratio:1 / 1.52;max-height:75vh}}.card__top{display:flex;justify-content:space-between}.card__bottom{display:flex;flex-flow:column nowrap;gap:1rem}.card__title{position:relative;display:flex;flex-flow:column;align-items:flex-start;font-size:2.5rem;overflow:hidden}@media only screen and (max-width: 1024px){.card__title{font-size:2rem}}.card__title--bottom{position:absolute;top:100%}.card__text{position:relative;display:flex;flex-direction:column;justify-content:space-between;width:100%;height:100%;padding:2rem;pointer-events:none}.card__img{position:absolute;width:100%;height:100%}.card__img img{filter:saturate(0);transition:filter .15s;-o-object-fit:cover;object-fit:cover;width:110%;height:110%;transform:translate(-50%,-50%);top:50%;left:50%;position:absolute}.card__img img:hover{filter:saturate(1)}@media only screen and (min-width: 768px) and (max-width: 1024px){.card__img img{width:120%;height:120%}}@media only screen and (min-width: 0px) and (max-width: 768px){.card__img img{width:150%;height:150%}}.cards-wrapper{max-width:1800px;margin:0 5rem}@media only screen and (max-width: 1024px){.cards-wrapper{margin:0 1.8rem}}@media only screen and (min-width: 1450px){.cards-wrapper{margin:0 auto}}.cards-wrapper2{position:relative;padding-top:5rem;grid-column:2 / span 22}@media only screen and (max-width: 1024px){.cards-wrapper2{grid-column:1 / -1}}.filter{display:flex;flex-flow:row nowrap;gap:15px;pointer-events:none;cursor:pointer}.filter--active{pointer-events:auto}.filter__name{font-size:1.45rem;color:var(--color-black-translucent);transition:color .25s ease-in-out}.filter__count{margin-top:.2rem;padding:1px 6px 2px;border-radius:999px;font-family:IBMPlexMono-Medium,monospace;line-height:1;letter-spacing:.05em;font-weight:500;text-align:center;vertical-align:middle;font-size:1rem;color:var(--color-black);border:1px solid var(--color-black);transition:color .25s ease-in-out,background-color .25s ease-in-out}@media only screen and (max-width: 1024px){.filter__count{font-size:.8rem}}.filter__item{display:flex;flex-flow:row nowrap;align-items:center;gap:5px;padding:2px 0}.filter__item--active .filter__name{color:var(--color-black)}.filter__item--active .filter__count{color:var(--color-white);background:var(--color-black)}.filter__item:hover .filter__name{color:var(--color-black)}.footer{display:flex;flex-flow:column nowrap;padding:6.667rem 0 2.92rem;font-size:1.45rem;line-height:1.5;text-transform:uppercase;background-color:var(--color-white)}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer{padding:4rem 0 2.92rem}}.footer__first-row{margin-bottom:6.67rem}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer__first-row{margin-bottom:4rem!important}}.footer__second-row{margin-bottom:7.5rem}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer__second-row{margin-bottom:5rem!important}}.footer__logo{grid-column:span 3}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer__logo{grid-column:span 2}}.footer__logo>svg{min-width:50%;height:100%}.footer__follow{grid-column:span 6}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer__follow{grid-column:span 3}}.footer__share{grid-column:span 2}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer__share{grid-column:span 1}}.footer__share-links{display:flex;flex-flow:column nowrap;gap:1.17rem;grid-column:span 3}.footer__close-btn{margin-left:auto;cursor:pointer;pointer-events:auto}.footer__contact{grid-column:span 3}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer__contact{grid-column:5 / span 3}}.footer__empty{grid-column:span 3}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer__empty{grid-column:none}}.footer__subscribe{grid-column:span 6;max-width:30rem}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer__subscribe{grid-column:span 3}}.footer__current-year{grid-column:span 3;align-self:end;font-size:3.835rem;line-height:1}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer__current-year{font-size:2.5rem;grid-column:span 2}}@media only screen and (min-width: 0px) and (max-width: 768px){.footer__current-year{grid-column:span 5;font-size:1.8rem}}.footer__flex-stuff{grid-column:span 6;display:flex;flex-flow:column nowrap;justify-content:flex-end;font-size:1.34rem;white-space:nowrap}@media only screen and (min-width: 768px) and (max-width: 1024px){.footer__flex-stuff{grid-column:span 4}}.footer__flex-stuff--inline{display:flex;align-items:center;gap:1.5rem}.footer__flex-stuff svg{margin-right:5px}.footer__current-time{grid-column:span 2;display:flex;gap:1rem;align-self:end;font-variant-numeric:tabular-nums;font-size:1.34rem}@media (max-width: 1024px){.footer__current-time{display:none}}.footer__current-time--message{padding:.4rem .6rem;border-radius:1rem;align-self:center;background-color:var(--color-black);color:var(--color-white);line-height:1;letter-spacing:.05em;font-family:IBMPlexMono-Medium,monospace;font-size:.8rem;text-transform:uppercase}.footer__lusion-logo{grid-column:span 1;display:flex;align-self:end;margin-left:auto}.footer__line-wrapper{position:relative;width:139px;height:15px;overflow:hidden}.footer__line{position:absolute;top:50%;-webkit-animation-duration:1s;animation-duration:1s;-webkit-animation-name:looperino;animation-name:looperino;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:linear;animation-timing-function:linear}@-webkit-keyframes looperino{0%{transform:translate(-50px,-50%)}to{transform:translateY(-50%)}}@keyframes looperino{0%{transform:translate(-50px,-50%)}to{transform:translateY(-50%)}}.footer__title{margin-bottom:2.5rem}.footer__desc{text-transform:uppercase;font-size:1.8rem;display:flex;flex-direction:column;font-size:2.5rem;line-height:100%}.grid-view{display:grid;padding:0 5rem;grid-template-columns:repeat(12,1fr);grid-gap:1rem}@media only screen and (max-width: 1024px){.grid-view{padding:0;margin:0 1.8rem;grid-gap:0rem 1rem;grid-template-columns:repeat(7,1fr)}}@media only screen and (min-width: 0px) and (max-width: 768px){.grid-view{grid-template-columns:repeat(6,1fr)}}.grid-view--block{display:block;grid-template-columns:none;grid-gap:0;padding:0;margin:0 5rem}@media only screen and (max-width: 1024px){.grid-view--block{margin:0 1.8rem}}.grid-view--24{grid-template-columns:repeat(24,1fr)}@media only screen and (max-width: 1024px){.grid-view--24{padding:0;margin:0 2rem;grid-gap:0rem 1rem;grid-template-columns:repeat(7,1fr)}}@media only screen and (min-width: 0px) and (max-width: 768px){.grid-view--24{grid-template-columns:repeat(6,1fr)}}.grid-view--full{height:100%}.grid-view--no-gap{grid-gap:1rem 0}.grid-view--no-padding{padding:unset}.header{--padding-top: 9.5rem;padding-top:var(--padding-top)}.header>*{transition:opacity .3s ease-in-out .4s}.header .header__title{transition:transform 1s cubic-bezier(.785,.135,.15,.86);transform:translate(0)}.header .header__title h1{transform:scale(1);transform-origin:left top;transition:transform 1s cubic-bezier(.785,.135,.15,.86)}.header--mini>*:not(.header__title){opacity:0;transition:opacity .3s ease-in-out}.header--mini .header__title{transform:translateY(calc(var(--padding-top) * -1 * .8))}.header--mini .header__title h1{transform:scale(.8)}@media only screen and (max-width: 1024px){.header--mini .header__title h1{transform:scale(1)}}@media only screen and (min-width: 0px) and (max-width: 768px){.header--mini .header__title{transform:translateY(3rem)}}@media only screen and (min-width: 768px) and (max-width: 1024px){.header{--padding-top: 6rem}}@media only screen and (min-width: 0px) and (max-width: 768px){.header{--padding-top: 3rem}}.header__title{grid-column:span 6;display:flex;flex-flow:column;gap:max(30px,4vh);text-transform:uppercase}@media only screen and (min-width: 768px) and (max-width: 1024px){.header__title{grid-column:span 3}}@media only screen and (min-width: 0px) and (max-width: 768px){.header__title{grid-column:1/-1}}.header__description{grid-column:span 4;display:flex;align-items:flex-end;font-size:1.45rem}@media only screen and (min-width: 768px) and (max-width: 1024px){.header__description{grid-column:span 4;font-size:1.17rem}}@media only screen and (min-width: 0px) and (max-width: 768px){.header__description{grid-column:1 / -1;font-size:1.17rem;padding-top:1.8rem;padding-bottom:6rem}}.header__scroll-down{grid-column:span 2;display:flex;justify-content:flex-end;align-items:flex-end;text-transform:uppercase}@media only screen and (min-width: 768px) and (max-width: 1024px){.header__scroll-down{display:none}}@media only screen and (min-width: 0px) and (max-width: 768px){.header__scroll-down{grid-column:1 / -1;font-size:1rem;justify-content:flex-start}}.header--bottom-spaced{padding-bottom:1em}.header__stats-container{margin-top:8vh}.header__word-wrapper{display:inline-block;position:relative}.header__word-wrapper :after{content:"\\a0"}.header__word{display:block}.header__word :after{content:""}.header__letter-wrapper{display:inline-block;overflow:hidden}.header__letter{display:inline-block;vertical-align:text-top}.header-stats{padding-left:0;padding-right:0}.header-stats__row{width:100%;display:flex;justify-content:space-between}.header-stats__theme{grid-column:span 2}.header-stats__content{grid-column:7 / span 2}.header-stats__interaction{grid-column:10 / span 2}.header-stats__last-update{grid-column:4 / span 2}.header-stats__action{grid-column:7 / span 2}@media only screen and (max-width: 1024px){.header-stats__theme,.header-stats__content{grid-column:span 6}.header-stats__interaction{grid-column:7 / span 6}.header-stats__last-update{grid-column:1 / span 12}.header-stats__action{grid-column:7 / span 6}}.header-stat{display:flex;flex-flow:column nowrap;gap:1rem;padding-bottom:50px}.header-stat__label{padding-bottom:10px;font-family:IBMPlexMono-Medium,monospace;line-height:1;letter-spacing:.05em;font-weight:500;font-size:.8rem;color:var(--color-black-translucent);text-transform:uppercase;min-height:20px}@media only screen and (min-width: 0px) and (max-width: 768px){.header-stat__label{min-height:auto}}.header-stat__content{display:flex;flex-flow:column nowrap;justify-content:center;gap:10px;color:var(--color-black);font-size:1.45rem;text-transform:uppercase}.header-stat__content>div{display:flex;gap:10px}.header-stat__content--spaced>div{display:flex;justify-content:space-between;align-items:center;gap:0}.header-stat__content--with-icon{display:flex;align-items:center;gap:8px}@media only screen and (min-width: 0px) and (max-width: 768px){.header-stat__content{font-size:1.17rem}}html.disable-transitions .header{transition:none!important}html.disable-transitions .header>*{transition:none!important}html.disable-transitions .header--mini>*:not(.header__title){transition:none!important}html.disable-transitions .header__title h1{transition:none!important}.exp-list{display:flex;flex-flow:column nowrap;padding:0;padding-bottom:4rem;overflow:hidden}.exp-list--hover>*:not(.exp-list__empty):not(.exp-list__item--hover){opacity:.5!important}.exp-list__item{grid-column:span 12;height:8rem;align-items:center;cursor:pointer;overflow:hidden}.exp-list__empty{padding:0;text-align:center;font-size:1.8rem;opacity:0;transition:none}.exp-list__empty--show{opacity:1;padding:35px 0;transition:opacity .25s ease-in-out .25s,padding .25s ease-in-out .25s}.exp-list__info{grid-column:span 2;font-size:1rem}.exp-list__info *{font-size:1rem!important}@media only screen and (max-width: 1024px){.exp-list__info{grid-column:span 1}.exp-list__info:not(.exp-list__year){display:none!important}}.exp-list__name{grid-column:span 8;font-size:1.8rem}@media only screen and (min-width: 768px) and (max-width: 1024px){.exp-list__name{grid-column:2 / span 5}}@media only screen and (min-width: 0px) and (max-width: 768px){.exp-list__name{grid-column:2 / span 4}}.exp-list__tags{grid-column:span 11;font-size:1rem!important}.exp-list__tags .tags{font-size:1rem}@media only screen and (max-width: 1024px){.exp-list__tags{display:none!important}}.exp-list__link{grid-column:span 1;justify-self:flex-end}.exp-list__filter{margin:0 5rem 2rem;-ms-overflow-style:none;scrollbar-width:none}@media only screen and (max-width: 1024px){.exp-list__filter{margin:0 0 2rem 2rem;overflow-x:auto}}.exp-list__filter::-webkit-scrollbar{display:none}.exp-list__hr>div{height:1px;background:var(--color-black)}.exp-list__back-image{position:absolute;top:50%;left:50%;width:34vw;height:34vw;border-radius:1rem;z-index:-1;-o-object-fit:cover;object-fit:cover}@media only screen and (min-width: 768px) and (max-width: 1024px){.exp-list__back-image{width:50vw;height:50vw}}@media only screen and (min-width: 0px) and (max-width: 768px){.exp-list__back-image{width:70vw;height:70vw}}.loader{z-index:99999;position:fixed;top:0;bottom:0;left:0;right:0;background:var(--color-theme)}.loader span{font-weight:900;vertical-align:middle;display:inline-block;line-height:100%;font-size:15rem}@media only screen and (max-width: 1024px){.loader span{font-size:7.5rem}}.loader__content{width:100%;height:100%}.loader__item{height:1em;position:relative;display:flex;align-items:flex-start;align-self:center;overflow:hidden;font-size:15rem}@media only screen and (max-width: 1024px){.loader__item{font-size:7.5rem}}.loader__item>div{display:flex;flex-direction:column;text-align:center}.loader__item--left{grid-column:1 / span 4}.loader__item--center{grid-column:5 / span 4;justify-self:center}.loader__item--right{grid-column:9 / span 4;justify-self:right}.loader__item--hide{opacity:0}@media only screen and (max-width: 1024px){.loader__item{align-self:start}}.loader__wow-text{position:fixed;left:50%;bottom:5vh;transform:translate(-50%);font-size:1.17rem;text-align:center;text-transform:uppercase;color:var(--color-black)}.loader__lucy{left:50%;top:50%;position:fixed;transform:translate(-50%,-50%)}.exp-info{font-family:IBMPlexMono-Medium,monospace;line-height:1;letter-spacing:.05em;font-weight:500;display:flex;text-transform:uppercase;font-size:1.17rem}@media only screen and (max-width: 1024px){.exp-info{font-size:1rem}}.tags{display:flex;gap:.25rem;font-family:IBMPlexMono-Medium,monospace;line-height:1;letter-spacing:.05em;font-weight:500;text-transform:uppercase;font-size:1.17rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}@media only screen and (min-width: 768px) and (max-width: 1024px){.tags{font-size:1rem}}@media only screen and (min-width: 0px) and (max-width: 768px){.tags{font-size:.8rem}}.tags__item{list-style:none;display:inline}@media only screen and (max-width: 1024px){.tags__item{display:flex}}.tags__item:after{content:" \\b7";padding-right:.5rem}.tags__item:last-child:after{content:none}.card-button{display:flex;align-items:center;justify-content:center;cursor:pointer;width:2.5rem;height:2.5rem;border-radius:999px;background-color:var(--color-card-black);color:var(--color-card-white);transition:color .5s ease-in-out,background-color .15s ease-in-out}.card-button--dark{background-color:var(--color-card-white);color:var(--color-card-black)}@media only screen and (max-width: 1024px){.card-button--dark{color:var(--color-card-white);background-color:transparent}}@media only screen and (max-width: 1024px){.card-button{color:var(--color-card-black);background-color:transparent}}.card-button--hover{color:var(--color-card-black);background-color:var(--color-card-white)}@media only screen and (max-width: 1024px){.card-button--hover{color:var(--color-card-white);background-color:var(--color-card-black)}}[data-theme=dark] .card-button{background-color:var(--color-card-white);color:var(--color-card-black)}@media only screen and (max-width: 1024px){[data-theme=dark] .card-button{color:var(--color-card-white);background-color:transparent}}.ext-lusion-link{display:flex;align-items:center;gap:.54rem}.ext-lusion-link svg{transition:transform .4s cubic-bezier(.33,1,.68,1)}.ext-lusion-link:hover svg{transform:translate(12%,-12%)}.navbar{position:fixed;top:0;left:0;right:0;padding-top:3.4rem;padding-bottom:12rem;color:var(--color-black);background-color:transparent;font-size:1.34rem;line-height:100%;text-align:right;letter-spacing:.02em;text-transform:uppercase;z-index:50;transition:background-color .5s ease-in-out;pointer-events:none}.navbar>*{pointer-events:auto}@media only screen and (min-width: 768px) and (max-width: 1024px){.navbar{padding-top:2rem;padding-bottom:2rem}}@media only screen and (min-width: 0px) and (max-width: 768px){.navbar{padding-top:2rem;padding-bottom:2rem}}.navbar__left{position:relative;grid-column:span 6}@media only screen and (min-width: 768px) and (max-width: 1024px){.navbar__left{grid-column:span 2}}@media only screen and (min-width: 0px) and (max-width: 768px){.navbar__left{grid-column:span 4}}.navbar__wrapper{display:flex;flex-flow:row nowrap;align-items:center}.navbar__buttons{grid-column:span 3;gap:2vw}@media only screen and (min-width: 768px) and (max-width: 1024px){.navbar__buttons{justify-content:center}}@media only screen and (min-width: 0px) and (max-width: 768px){.navbar__buttons{display:none}}.navbar__views{grid-column:span 2;justify-content:center!important}@media only screen and (min-width: 768px) and (max-width: 1024px){.navbar__views{grid-column:span 1}}@media only screen and (min-width: 0px) and (max-width: 768px){.navbar__views{grid-column:span 1}}.navbar__theme{grid-column:span 1;justify-content:flex-end}@media only screen and (min-width: 0px) and (max-width: 768px){.navbar__theme{margin:0 2rem 0 auto;display:none}}.navbar__theme--show{display:flex}@media only screen and (min-width: 0px) and (max-width: 768px){.navbar__theme--show{margin:0 0 0 auto;grid-column:span 1}}.navbar__menu{display:none}@media only screen and (min-width: 0px) and (max-width: 768px){.navbar__menu{display:flex;justify-self:flex-end;cursor:pointer;grid-column:span 1}}.navbar__item{font-size:1.34rem}.navbar__logo{position:absolute;top:50%;left:0;transform:translateY(-50%)}.go_back{display:flex;align-items:center;justify-content:space-between;gap:1.5rem;white-space:nowrap}.go_back svg{transition:transform .4s cubic-bezier(.33,1,.68,1)}.go_back:hover svg{transform:translate(-12%)}@media only screen and (min-width: 0px) and (max-width: 768px){.go_back>span{display:none}}.navbar__item{position:relative}.navbar__item:after{content:" ";position:absolute;left:0;bottom:-.8rem;width:100%;height:.2rem;background:var(--color-black);transform-origin:left center;transform:scaleX(0);transition:transform .4s cubic-bezier(.215,.61,.355,1)}.navbar__item:hover:after{transform:scaleX(1)}.Pill{font-family:IBMPlexMono-Medium,monospace;line-height:1;letter-spacing:.05em;font-weight:500;font-size:1.17rem;padding:0 .25rem;border-radius:9999px;padding:2px 10px;background:none;border:1px solid var(--color-black)}.Pill--small{font-size:1rem;letter-spacing:.05em;padding:2px 6px}.Pill--filled{background:var(--color-black);color:var(--color-white)}.tools-bar{margin:5rem 0 2.5rem}.tools-bar>div{display:flex;align-items:flex-end}.tools-bar__left{grid-column:span 9}.tools-bar__left--filter{margin-top:1rem}.tools-bar__right{grid-column:span 3}.tools-bar__switch{margin-bottom:10px;justify-self:end}.tools-bar__lab-area{margin:0 0 10px 24px;font-family:Aeonik;font-size:1.17rem;line-height:100%;letter-spacing:.1em;text-transform:uppercase;color:var(--color-black)}.view-switch{display:flex;flex-flow:row nowrap;align-items:center;justify-content:space-between;width:100%;transition:opacity .4s cubic-bezier(.33,1,.68,1)}.view-switch--transition{opacity:.7}.view-switch--transition .view-switch__option:hover{color:var(--color-black-translucent)}.view-switch__options{position:relative;display:flex;border:1px solid var(--color-black-translucent);border-radius:999px}.view-switch__option{padding:5px 14px;color:var(--color-black-translucent);font-size:1rem;line-height:100%;letter-spacing:.02em;text-transform:uppercase;cursor:pointer;outline:none;transition:color .25s ease-in-out .25s}.view-switch__option:hover{color:var(--color-black)}.view-switch__option--isActive{color:var(--color-white)!important}@media only screen and (min-width: 768px) and (max-width: 1024px){.view-switch__option{font-size:1rem;padding:4px 12px 4px 8px}}@media only screen and (min-width: 0px) and (max-width: 768px){.view-switch__option{font-size:1rem;padding:4px 12px 4px 8px}}.view-switch__option-background{position:absolute;height:100%;display:flex;justify-content:center;align-items:center;padding:5px 14px 6px;border-radius:70px;background-color:var(--color-black);z-index:-1}.subscribe{text-transform:uppercase}.subscribe__label{font-size:1.45rem;margin-right:.75rem}.subscribe__spam{font-size:1rem}@media only screen and (min-width: 0px) and (max-width: 768px){.subscribe__spam{font-size:.8rem}}.subscribe form,.subscribe .mcForm{position:relative;margin-top:.75rem}.subscribe__submit-btn{position:absolute;top:50%;right:0;transform:translate(-50%,-50%)}.subscribe__submit-btn.--sending svg{-webkit-animation:pulse 1s;animation:pulse 1s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-direction:alternate;animation-direction:alternate}.subscribe__input{width:100%;font-size:1.45rem}.subscribe__input--success{color:var(--color-white)!important;-webkit-box-shadow:0 0 0 30px var(--color-black) inset!important;background-color:var(--color-black)}.subscribe__input--success:-webkit-autofill,.subscribe__input--success:-webkit-autofill:hover,.subscribe__input--success:-webkit-autofill:focus,.subscribe__input--success:-webkit-autofill:active{-webkit-box-shadow:0 0 0 30px var(--color-black) inset!important}.subscribe__input--error{color:red}@media only screen and (max-width: 1024px){.subscribe__input{font-size:max(1.17rem,16px)}}.subscribe-modal{z-index:500;position:fixed;bottom:0;left:0;right:0;--screen-margin: 3.2rem;margin:var(--screen-margin)}@media only screen and (max-width: 1024px){.subscribe-modal{--screen-margin: 1.8rem}}.subscribe-modal__content{position:relative;padding:2.5rem 2rem 2rem;width:100%;max-width:40rem;border-radius:1.6rem;margin:0 auto;color:var(--color-white)!important;background-color:var(--color-black)}@media only screen and (max-width: 1024px){.subscribe-modal__content{padding:2rem 1.5rem 1.5rem}}.subscribe-modal__content input{background-color:var(--color-white)}.subscribe-modal__close-btn{position:absolute;top:0;right:0;margin:1.5rem;cursor:pointer}.subscribe-modal__close-btn *{fill:var(--color-white)}.subscribe__submit-btn{position:absolute;top:50%;right:0;transform:translate(-50%,-50%)}.subscribe__submit-btn svg{width:100%}@media only screen and (max-width: 1024px){.subscribe__submit-btn.--sending svg{-webkit-animation:moveX 1s;animation:moveX 1s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-direction:alternate;animation-direction:alternate}}.subscribe__submit-btn.--sending svg{-webkit-animation:pulse 1s;animation:pulse 1s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-direction:alternate;animation-direction:alternate}@-webkit-keyframes pulse{0%{transform:scale(1)}to{transform:scale(5)}}@keyframes pulse{0%{transform:scale(1)}to{transform:scale(5)}}@-webkit-keyframes moveX{0%{transform:translate(0)}to{transform:translate(10%)}}@keyframes moveX{0%{transform:translate(0)}to{transform:translate(10%)}}.button{display:flex;flex-direction:row;justify-content:space-between;align-items:center;padding:1rem 1.6rem 1rem 1.3rem;gap:2rem;position:relative;min-width:100px;height:3.6rem;background:var(--color-black);border-radius:1.8rem;overflow:hidden;font-weight:500;font-size:1.17rem;letter-spacing:.02em;text-transform:uppercase;text-decoration:none;color:var(--color-white);cursor:pointer}.button--flipped{padding:1rem 1.3rem 1rem 1.6rem}.button__text-wrapper{position:relative;overflow:hidden}.button__text{opacity:1;transition:opacity .25s ease-in-out}.button__hover-text{position:absolute;top:0;height:100%;color:var(--color-black);z-index:2}.button__icon-wrapper{position:relative;z-index:9}.button__icon-wrapper svg{width:1.33rem;height:1.33rem}.button__icon{position:absolute;top:50%;transform:translateY(-50%);opacity:1;transition:opacity .25s ease-in-out 0s}.button__icon *{fill:var(--color-white)}.button__icon--hover{opacity:0}.button__icon--hover *{fill:var(--color-black)}.button--inverse{color:var(--color-black);border:1px solid var(--color-black);background:none}.button--inverse .button__mask{background-color:var(--color-black)}.button--inverse .button__hover-text{color:var(--color-white)}.button--inverse .button__icon *{stroke:var(--color-black);fill:none}.button--inverse .button__icon--hover *{stroke:var(--color-white);fill:var(--color-white)}.button:hover .button__icon{opacity:0}.button:hover .button__icon--hover{opacity:1}.button__mask__container{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:1.8rem;overflow:hidden}.button__mask{width:.5rem;height:.5rem;border-radius:100%;position:absolute;top:1.6rem;left:1.66rem;background-color:var(--color-white);z-index:1}.button--hovering{transition:background .125s ease-out .125s;background:var(--color-white)}.scroll-to-top{opacity:0;transition:opacity .25s ease-in-out}.scroll-to-top--active{opacity:1;pointer-events:auto;cursor:pointer}.scroll-to-top__svg-bg{fill:var(--color-black)}.scroll-to-top__svg-arrow{fill:var(--color-white)}.contact{position:fixed;left:0;right:0;bottom:0;z-index:999}.contact__close-btn{position:absolute;top:0;right:0;margin:1.5rem;cursor:pointer}.contact__blocking-bg{position:fixed;inset:0;background-color:#000;pointer-events:auto;z-index:998}.explore-more{margin:9rem 0;color:var(--color-black);padding-bottom:5rem}@media only screen and (max-width: 1024px){.explore-more{margin-top:0}}.explore-more__title-wrapper{display:flex;align-items:flex-end;gap:20px}@media only screen and (min-width: 0px) and (max-width: 768px){.explore-more__title-wrapper{flex-direction:column;align-items:flex-start}}.explore-more__title{font-size:50px;letter-spacing:.02em;line-height:80%}.explore-more__subtitle{font-size:14px;letter-spacing:.1em;text-transform:uppercase}.explore-more__cards{display:grid;grid-template-columns:repeat(3,1fr);gap:24px;margin-top:max(50px,5vh)}@media only screen and (max-width: 1024px){.explore-more__cards{grid-template-columns:1fr}}.theme-switcher{display:flex;justify-content:center;align-items:center;gap:5px;cursor:pointer}.theme-switcher:hover .theme-switcher__point{opacity:.6}.theme-switcher__point{width:.8rem;height:.8rem;background:var(--color-theme);border:1px solid var(--color-black);border-radius:100%;transition:border,background,opacity .6s cubic-bezier(.215,.61,.355,1)}.theme-switcher__init{font-size:1.34rem;text-align:center;letter-spacing:.02em;text-transform:uppercase;color:var(--color-black);height:1.34rem;overflow:hidden}@media only screen and (min-width: 0px) and (max-width: 768px){.theme-switcher__init{font-size:1.17rem}}@media only screen and (min-width: 0px) and (max-width: 768px){.theme-switcher__init{height:1.17rem}}.svgLogo{z-index:1000;cursor:pointer;position:relative;--aspect-mul: 4.82;height:3rem;max-width:calc(3rem * var(--aspect-mul))}@media only screen and (min-width: 0px) and (max-width: 768px){.svgLogo{--aspect-mul: 2.98}}.svgLogo .svgLogo__lucy{height:3rem;width:3rem}.svgLogo--large{height:4rem;max-width:calc(4rem * var(--aspect-mul))}.svgLogo--large .svgLogo__lucy{height:4rem;width:4rem}@media only screen and (min-width: 0px) and (max-width: 768px){.svgLogo{height:2.4rem;max-width:calc(2.4rem * var(--aspect-mul))}.svgLogo .svgLogo__lucy{height:2.4rem;width:2.4rem}.svgLogo--large{height:3rem;max-width:calc(3rem * var(--aspect-mul))}.svgLogo--large .svgLogo__lucy{height:3rem;width:3rem}}.svgLogo__lucy{position:absolute;top:0;left:0}.svgLogo__svg path{fill:var(--color-white)}.svgLogo__svg circle{stroke:var(--color-white)}.svgLogo__bg,.lucy__rect{fill:var(--color-black)}.lucy__eyeWrapper *{fill:var(--color-white)}.lucy__mouthWrapper *{stroke:var(--color-white)}.TA__line{position:relative;line-height:120%}.TA__lineBlock{position:absolute;left:0;top:10%;height:80%;background:#000;width:100%}.mobile-menu{position:fixed;left:0;right:0;bottom:0;z-index:999;background-color:var(--color-white)}.mobile-menu__blocking-bg{position:fixed;inset:0;background-color:#000;pointer-events:auto;z-index:49}.mobile-menu__row{align-items:center;padding:2.4rem 2rem;margin:0!important;border-top:1px solid rgba(0,0,0,.2)}.mobile-menu__link-label{grid-column:span 5;font-size:2.5rem;text-transform:capitalize;line-height:120%}.mobile-menu__link-icon{justify-self:end}.mobile-menu__subscribe{grid-column:1 / -1}.mobile-menu__ext-links{row-gap:2.4rem}.mobile-menu__ext-links>a{grid-column:span 3;font-size:1.17rem}
`)()
  , commonjsGlobal = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function getDefaultExportFromCjs(et) {
    return et && et.__esModule && Object.prototype.hasOwnProperty.call(et, "default") ? et.default : et
}
var react = {
    exports: {}
}
  , react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$4 = Symbol.for("react.element")
  , n$5 = Symbol.for("react.portal")
  , p$6 = Symbol.for("react.fragment")
  , q$5 = Symbol.for("react.strict_mode")
  , r$3 = Symbol.for("react.profiler")
  , t$5 = Symbol.for("react.provider")
  , u$4 = Symbol.for("react.context")
  , v$3 = Symbol.for("react.forward_ref")
  , w$2 = Symbol.for("react.suspense")
  , x$1 = Symbol.for("react.memo")
  , y$2 = Symbol.for("react.lazy")
  , z$2 = Symbol.iterator;
function A$2(et) {
    return et === null || typeof et != "object" ? null : (et = z$2 && et[z$2] || et["@@iterator"],
    typeof et == "function" ? et : null)
}
var B$2 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , C$1 = Object.assign
  , D$2 = {};
function E$2(et, $, tt) {
    this.props = et,
    this.context = $,
    this.refs = D$2,
    this.updater = tt || B$2
}
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(et, $) {
    if (typeof et != "object" && typeof et != "function" && et != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, et, $, "setState")
}
;
E$2.prototype.forceUpdate = function(et) {
    this.updater.enqueueForceUpdate(this, et, "forceUpdate")
}
;
function F$1() {}
F$1.prototype = E$2.prototype;
function G$2(et, $, tt) {
    this.props = et,
    this.context = $,
    this.refs = D$2,
    this.updater = tt || B$2
}
var H$2 = G$2.prototype = new F$1;
H$2.constructor = G$2;
C$1(H$2, E$2.prototype);
H$2.isPureReactComponent = !0;
var I$2 = Array.isArray
  , J = Object.prototype.hasOwnProperty
  , K$1 = {
    current: null
}
  , L$2 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function M$2(et, $, tt) {
    var nt, rt = {}, it = null, ot = null;
    if ($ != null)
        for (nt in $.ref !== void 0 && (ot = $.ref),
        $.key !== void 0 && (it = "" + $.key),
        $)
            J.call($, nt) && !L$2.hasOwnProperty(nt) && (rt[nt] = $[nt]);
    var st = arguments.length - 2;
    if (st === 1)
        rt.children = tt;
    else if (1 < st) {
        for (var lt = Array(st), ut = 0; ut < st; ut++)
            lt[ut] = arguments[ut + 2];
        rt.children = lt
    }
    if (et && et.defaultProps)
        for (nt in st = et.defaultProps,
        st)
            rt[nt] === void 0 && (rt[nt] = st[nt]);
    return {
        $$typeof: l$4,
        type: et,
        key: it,
        ref: ot,
        props: rt,
        _owner: K$1.current
    }
}
function N$1(et, $) {
    return {
        $$typeof: l$4,
        type: et.type,
        key: $,
        ref: et.ref,
        props: et.props,
        _owner: et._owner
    }
}
function O$2(et) {
    return typeof et == "object" && et !== null && et.$$typeof === l$4
}
function escape$1(et) {
    var $ = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + et.replace(/[=:]/g, function(tt) {
        return $[tt]
    })
}
var P$2 = /\/+/g;
function Q$2(et, $) {
    return typeof et == "object" && et !== null && et.key != null ? escape$1("" + et.key) : $.toString(36)
}
function R$2(et, $, tt, nt, rt) {
    var it = typeof et;
    (it === "undefined" || it === "boolean") && (et = null);
    var ot = !1;
    if (et === null)
        ot = !0;
    else
        switch (it) {
        case "string":
        case "number":
            ot = !0;
            break;
        case "object":
            switch (et.$$typeof) {
            case l$4:
            case n$5:
                ot = !0
            }
        }
    if (ot)
        return ot = et,
        rt = rt(ot),
        et = nt === "" ? "." + Q$2(ot, 0) : nt,
        I$2(rt) ? (tt = "",
        et != null && (tt = et.replace(P$2, "$&/") + "/"),
        R$2(rt, $, tt, "", function(ut) {
            return ut
        })) : rt != null && (O$2(rt) && (rt = N$1(rt, tt + (!rt.key || ot && ot.key === rt.key ? "" : ("" + rt.key).replace(P$2, "$&/") + "/") + et)),
        $.push(rt)),
        1;
    if (ot = 0,
    nt = nt === "" ? "." : nt + ":",
    I$2(et))
        for (var st = 0; st < et.length; st++) {
            it = et[st];
            var lt = nt + Q$2(it, st);
            ot += R$2(it, $, tt, lt, rt)
        }
    else if (lt = A$2(et),
    typeof lt == "function")
        for (et = lt.call(et),
        st = 0; !(it = et.next()).done; )
            it = it.value,
            lt = nt + Q$2(it, st++),
            ot += R$2(it, $, tt, lt, rt);
    else if (it === "object")
        throw $ = String(et),
        Error("Objects are not valid as a React child (found: " + ($ === "[object Object]" ? "object with keys {" + Object.keys(et).join(", ") + "}" : $) + "). If you meant to render a collection of children, use an array instead.");
    return ot
}
function S$2(et, $, tt) {
    if (et == null)
        return et;
    var nt = []
      , rt = 0;
    return R$2(et, nt, "", "", function(it) {
        return $.call(tt, it, rt++)
    }),
    nt
}
function T$1(et) {
    if (et._status === -1) {
        var $ = et._result;
        $ = $(),
        $.then(function(tt) {
            (et._status === 0 || et._status === -1) && (et._status = 1,
            et._result = tt)
        }, function(tt) {
            (et._status === 0 || et._status === -1) && (et._status = 2,
            et._result = tt)
        }),
        et._status === -1 && (et._status = 0,
        et._result = $)
    }
    if (et._status === 1)
        return et._result.default;
    throw et._result
}
var U$2 = {
    current: null
}
  , V$1 = {
    transition: null
}
  , W$2 = {
    ReactCurrentDispatcher: U$2,
    ReactCurrentBatchConfig: V$1,
    ReactCurrentOwner: K$1
};
react_production_min.Children = {
    map: S$2,
    forEach: function(et, $, tt) {
        S$2(et, function() {
            $.apply(this, arguments)
        }, tt)
    },
    count: function(et) {
        var $ = 0;
        return S$2(et, function() {
            $++
        }),
        $
    },
    toArray: function(et) {
        return S$2(et, function($) {
            return $
        }) || []
    },
    only: function(et) {
        if (!O$2(et))
            throw Error("React.Children.only expected to receive a single React element child.");
        return et
    }
};
react_production_min.Component = E$2;
react_production_min.Fragment = p$6;
react_production_min.Profiler = r$3;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$5;
react_production_min.Suspense = w$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(et, $, tt) {
    if (et == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + et + ".");
    var nt = C$1({}, et.props)
      , rt = et.key
      , it = et.ref
      , ot = et._owner;
    if ($ != null) {
        if ($.ref !== void 0 && (it = $.ref,
        ot = K$1.current),
        $.key !== void 0 && (rt = "" + $.key),
        et.type && et.type.defaultProps)
            var st = et.type.defaultProps;
        for (lt in $)
            J.call($, lt) && !L$2.hasOwnProperty(lt) && (nt[lt] = $[lt] === void 0 && st !== void 0 ? st[lt] : $[lt])
    }
    var lt = arguments.length - 2;
    if (lt === 1)
        nt.children = tt;
    else if (1 < lt) {
        st = Array(lt);
        for (var ut = 0; ut < lt; ut++)
            st[ut] = arguments[ut + 2];
        nt.children = st
    }
    return {
        $$typeof: l$4,
        type: et.type,
        key: rt,
        ref: it,
        props: nt,
        _owner: ot
    }
}
;
react_production_min.createContext = function(et) {
    return et = {
        $$typeof: u$4,
        _currentValue: et,
        _currentValue2: et,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    et.Provider = {
        $$typeof: t$5,
        _context: et
    },
    et.Consumer = et
}
;
react_production_min.createElement = M$2;
react_production_min.createFactory = function(et) {
    var $ = M$2.bind(null, et);
    return $.type = et,
    $
}
;
react_production_min.createRef = function() {
    return {
        current: null
    }
}
;
react_production_min.forwardRef = function(et) {
    return {
        $$typeof: v$3,
        render: et
    }
}
;
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(et) {
    return {
        $$typeof: y$2,
        _payload: {
            _status: -1,
            _result: et
        },
        _init: T$1
    }
}
;
react_production_min.memo = function(et, $) {
    return {
        $$typeof: x$1,
        type: et,
        compare: $ === void 0 ? null : $
    }
}
;
react_production_min.startTransition = function(et) {
    var $ = V$1.transition;
    V$1.transition = {};
    try {
        et()
    } finally {
        V$1.transition = $
    }
}
;
react_production_min.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
react_production_min.useCallback = function(et, $) {
    return U$2.current.useCallback(et, $)
}
;
react_production_min.useContext = function(et) {
    return U$2.current.useContext(et)
}
;
react_production_min.useDebugValue = function() {}
;
react_production_min.useDeferredValue = function(et) {
    return U$2.current.useDeferredValue(et)
}
;
react_production_min.useEffect = function(et, $) {
    return U$2.current.useEffect(et, $)
}
;
react_production_min.useId = function() {
    return U$2.current.useId()
}
;
react_production_min.useImperativeHandle = function(et, $, tt) {
    return U$2.current.useImperativeHandle(et, $, tt)
}
;
react_production_min.useInsertionEffect = function(et, $) {
    return U$2.current.useInsertionEffect(et, $)
}
;
react_production_min.useLayoutEffect = function(et, $) {
    return U$2.current.useLayoutEffect(et, $)
}
;
react_production_min.useMemo = function(et, $) {
    return U$2.current.useMemo(et, $)
}
;
react_production_min.useReducer = function(et, $, tt) {
    return U$2.current.useReducer(et, $, tt)
}
;
react_production_min.useRef = function(et) {
    return U$2.current.useRef(et)
}
;
react_production_min.useState = function(et) {
    return U$2.current.useState(et)
}
;
react_production_min.useSyncExternalStore = function(et, $, tt) {
    return U$2.current.useSyncExternalStore(et, $, tt)
}
;
react_production_min.useTransition = function() {
    return U$2.current.useTransition()
}
;
react_production_min.version = "18.1.0";
react.exports = react_production_min;
var React = react.exports
  , client = {}
  , reactDom = {
    exports: {}
}
  , reactDom_production_min = {}
  , scheduler = {
    exports: {}
}
  , scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(et) {
    function $(Bt, Xt) {
        var Jt = Bt.length;
        Bt.push(Xt);
        e: for (; 0 < Jt; ) {
            var Lt = Jt - 1 >>> 1
              , Rt = Bt[Lt];
            if (0 < rt(Rt, Xt))
                Bt[Lt] = Xt,
                Bt[Jt] = Rt,
                Jt = Lt;
            else
                break e
        }
    }
    function tt(Bt) {
        return Bt.length === 0 ? null : Bt[0]
    }
    function nt(Bt) {
        if (Bt.length === 0)
            return null;
        var Xt = Bt[0]
          , Jt = Bt.pop();
        if (Jt !== Xt) {
            Bt[0] = Jt;
            e: for (var Lt = 0, Rt = Bt.length, _n = Rt >>> 1; Lt < _n; ) {
                var Fn = 2 * (Lt + 1) - 1
                  , Vn = Bt[Fn]
                  , sn = Fn + 1
                  , Un = Bt[sn];
                if (0 > rt(Vn, Jt))
                    sn < Rt && 0 > rt(Un, Vn) ? (Bt[Lt] = Un,
                    Bt[sn] = Jt,
                    Lt = sn) : (Bt[Lt] = Vn,
                    Bt[Fn] = Jt,
                    Lt = Fn);
                else if (sn < Rt && 0 > rt(Un, Jt))
                    Bt[Lt] = Un,
                    Bt[sn] = Jt,
                    Lt = sn;
                else
                    break e
            }
        }
        return Xt
    }
    function rt(Bt, Xt) {
        var Jt = Bt.sortIndex - Xt.sortIndex;
        return Jt !== 0 ? Jt : Bt.id - Xt.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var it = performance;
        et.unstable_now = function() {
            return it.now()
        }
    } else {
        var ot = Date
          , st = ot.now();
        et.unstable_now = function() {
            return ot.now() - st
        }
    }
    var lt = []
      , ut = []
      , ct = 1
      , ht = null
      , ft = 3
      , gt = !1
      , vt = !1
      , yt = !1
      , wt = typeof setTimeout == "function" ? setTimeout : null
      , mt = typeof clearTimeout == "function" ? clearTimeout : null
      , _t = typeof setImmediate != "undefined" ? setImmediate : null;
    typeof navigator != "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function bt(Bt) {
        for (var Xt = tt(ut); Xt !== null; ) {
            if (Xt.callback === null)
                nt(ut);
            else if (Xt.startTime <= Bt)
                nt(ut),
                Xt.sortIndex = Xt.expirationTime,
                $(lt, Xt);
            else
                break;
            Xt = tt(ut)
        }
    }
    function Mt(Bt) {
        if (yt = !1,
        bt(Bt),
        !vt)
            if (tt(lt) !== null)
                vt = !0,
                qt(St);
            else {
                var Xt = tt(ut);
                Xt !== null && jt(Mt, Xt.startTime - Bt)
            }
    }
    function St(Bt, Xt) {
        vt = !1,
        yt && (yt = !1,
        mt(Ot),
        Ot = -1),
        gt = !0;
        var Jt = ft;
        try {
            for (bt(Xt),
            ht = tt(lt); ht !== null && (!(ht.expirationTime > Xt) || Bt && !Tt()); ) {
                var Lt = ht.callback;
                if (typeof Lt == "function") {
                    ht.callback = null,
                    ft = ht.priorityLevel;
                    var Rt = Lt(ht.expirationTime <= Xt);
                    Xt = et.unstable_now(),
                    typeof Rt == "function" ? ht.callback = Rt : ht === tt(lt) && nt(lt),
                    bt(Xt)
                } else
                    nt(lt);
                ht = tt(lt)
            }
            if (ht !== null)
                var _n = !0;
            else {
                var Fn = tt(ut);
                Fn !== null && jt(Mt, Fn.startTime - Xt),
                _n = !1
            }
            return _n
        } finally {
            ht = null,
            ft = Jt,
            gt = !1
        }
    }
    var At = !1
      , Pt = null
      , Ot = -1
      , Zt = 5
      , Nt = -1;
    function Tt() {
        return !(et.unstable_now() - Nt < Zt)
    }
    function Ft() {
        if (Pt !== null) {
            var Bt = et.unstable_now();
            Nt = Bt;
            var Xt = !0;
            try {
                Xt = Pt(!0, Bt)
            } finally {
                Xt ? $t() : (At = !1,
                Pt = null)
            }
        } else
            At = !1
    }
    var $t;
    if (typeof _t == "function")
        $t = function() {
            _t(Ft)
        }
        ;
    else if (typeof MessageChannel != "undefined") {
        var Wt = new MessageChannel
          , Kt = Wt.port2;
        Wt.port1.onmessage = Ft,
        $t = function() {
            Kt.postMessage(null)
        }
    } else
        $t = function() {
            wt(Ft, 0)
        }
        ;
    function qt(Bt) {
        Pt = Bt,
        At || (At = !0,
        $t())
    }
    function jt(Bt, Xt) {
        Ot = wt(function() {
            Bt(et.unstable_now())
        }, Xt)
    }
    et.unstable_IdlePriority = 5,
    et.unstable_ImmediatePriority = 1,
    et.unstable_LowPriority = 4,
    et.unstable_NormalPriority = 3,
    et.unstable_Profiling = null,
    et.unstable_UserBlockingPriority = 2,
    et.unstable_cancelCallback = function(Bt) {
        Bt.callback = null
    }
    ,
    et.unstable_continueExecution = function() {
        vt || gt || (vt = !0,
        qt(St))
    }
    ,
    et.unstable_forceFrameRate = function(Bt) {
        0 > Bt || 125 < Bt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Zt = 0 < Bt ? Math.floor(1e3 / Bt) : 5
    }
    ,
    et.unstable_getCurrentPriorityLevel = function() {
        return ft
    }
    ,
    et.unstable_getFirstCallbackNode = function() {
        return tt(lt)
    }
    ,
    et.unstable_next = function(Bt) {
        switch (ft) {
        case 1:
        case 2:
        case 3:
            var Xt = 3;
            break;
        default:
            Xt = ft
        }
        var Jt = ft;
        ft = Xt;
        try {
            return Bt()
        } finally {
            ft = Jt
        }
    }
    ,
    et.unstable_pauseExecution = function() {}
    ,
    et.unstable_requestPaint = function() {}
    ,
    et.unstable_runWithPriority = function(Bt, Xt) {
        switch (Bt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            Bt = 3
        }
        var Jt = ft;
        ft = Bt;
        try {
            return Xt()
        } finally {
            ft = Jt
        }
    }
    ,
    et.unstable_scheduleCallback = function(Bt, Xt, Jt) {
        var Lt = et.unstable_now();
        switch (typeof Jt == "object" && Jt !== null ? (Jt = Jt.delay,
        Jt = typeof Jt == "number" && 0 < Jt ? Lt + Jt : Lt) : Jt = Lt,
        Bt) {
        case 1:
            var Rt = -1;
            break;
        case 2:
            Rt = 250;
            break;
        case 5:
            Rt = 1073741823;
            break;
        case 4:
            Rt = 1e4;
            break;
        default:
            Rt = 5e3
        }
        return Rt = Jt + Rt,
        Bt = {
            id: ct++,
            callback: Xt,
            priorityLevel: Bt,
            startTime: Jt,
            expirationTime: Rt,
            sortIndex: -1
        },
        Jt > Lt ? (Bt.sortIndex = Jt,
        $(ut, Bt),
        tt(lt) === null && Bt === tt(ut) && (yt ? (mt(Ot),
        Ot = -1) : yt = !0,
        jt(Mt, Jt - Lt))) : (Bt.sortIndex = Rt,
        $(lt, Bt),
        vt || gt || (vt = !0,
        qt(St))),
        Bt
    }
    ,
    et.unstable_shouldYield = Tt,
    et.unstable_wrapCallback = function(Bt) {
        var Xt = ft;
        return function() {
            var Jt = ft;
            ft = Xt;
            try {
                return Bt.apply(this, arguments)
            } finally {
                ft = Jt
            }
        }
    }
}
)(scheduler_production_min);
scheduler.exports = scheduler_production_min;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports
  , ba = scheduler.exports;
function p$5(et) {
    for (var $ = "https://reactjs.org/docs/error-decoder.html?invariant=" + et, tt = 1; tt < arguments.length; tt++)
        $ += "&args[]=" + encodeURIComponent(arguments[tt]);
    return "Minified React error #" + et + "; visit " + $ + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var da = new Set
  , ea = {};
function fa(et, $) {
    ha(et, $),
    ha(et + "Capture", $)
}
function ha(et, $) {
    for (ea[et] = $,
    et = 0; et < $.length; et++)
        da.add($[et])
}
var ia = !(typeof window == "undefined" || typeof window.document == "undefined" || typeof window.document.createElement == "undefined")
  , ja = Object.prototype.hasOwnProperty
  , ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , la = {}
  , ma = {};
function na(et) {
    return ja.call(ma, et) ? !0 : ja.call(la, et) ? !1 : ka.test(et) ? ma[et] = !0 : (la[et] = !0,
    !1)
}
function oa(et, $, tt, nt) {
    if (tt !== null && tt.type === 0)
        return !1;
    switch (typeof $) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return nt ? !1 : tt !== null ? !tt.acceptsBooleans : (et = et.toLowerCase().slice(0, 5),
        et !== "data-" && et !== "aria-");
    default:
        return !1
    }
}
function pa(et, $, tt, nt) {
    if ($ === null || typeof $ == "undefined" || oa(et, $, tt, nt))
        return !0;
    if (nt)
        return !1;
    if (tt !== null)
        switch (tt.type) {
        case 3:
            return !$;
        case 4:
            return $ === !1;
        case 5:
            return isNaN($);
        case 6:
            return isNaN($) || 1 > $
        }
    return !1
}
function t$4(et, $, tt, nt, rt, it, ot) {
    this.acceptsBooleans = $ === 2 || $ === 3 || $ === 4,
    this.attributeName = nt,
    this.attributeNamespace = rt,
    this.mustUseProperty = tt,
    this.propertyName = et,
    this.type = $,
    this.sanitizeURL = it,
    this.removeEmptyString = ot
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(et) {
    z$1[et] = new t$4(et,0,!1,et,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(et) {
    var $ = et[0];
    z$1[$] = new t$4($,1,!1,et[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(et) {
    z$1[et] = new t$4(et,2,!1,et.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(et) {
    z$1[et] = new t$4(et,2,!1,et,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(et) {
    z$1[et] = new t$4(et,3,!1,et.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(et) {
    z$1[et] = new t$4(et,3,!0,et,null,!1,!1)
});
["capture", "download"].forEach(function(et) {
    z$1[et] = new t$4(et,4,!1,et,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(et) {
    z$1[et] = new t$4(et,6,!1,et,null,!1,!1)
});
["rowSpan", "start"].forEach(function(et) {
    z$1[et] = new t$4(et,5,!1,et.toLowerCase(),null,!1,!1)
});
var qa = /[\-:]([a-z])/g;
function ra(et) {
    return et[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(et) {
    var $ = et.replace(qa, ra);
    z$1[$] = new t$4($,1,!1,et,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(et) {
    var $ = et.replace(qa, ra);
    z$1[$] = new t$4($,1,!1,et,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(et) {
    var $ = et.replace(qa, ra);
    z$1[$] = new t$4($,1,!1,et,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(et) {
    z$1[et] = new t$4(et,1,!1,et.toLowerCase(),null,!1,!1)
});
z$1.xlinkHref = new t$4("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(et) {
    z$1[et] = new t$4(et,1,!1,et.toLowerCase(),null,!0,!0)
});
function sa(et, $, tt, nt) {
    var rt = z$1.hasOwnProperty($) ? z$1[$] : null;
    (rt !== null ? rt.type !== 0 : nt || !(2 < $.length) || $[0] !== "o" && $[0] !== "O" || $[1] !== "n" && $[1] !== "N") && (pa($, tt, rt, nt) && (tt = null),
    nt || rt === null ? na($) && (tt === null ? et.removeAttribute($) : et.setAttribute($, "" + tt)) : rt.mustUseProperty ? et[rt.propertyName] = tt === null ? rt.type === 3 ? !1 : "" : tt : ($ = rt.attributeName,
    nt = rt.attributeNamespace,
    tt === null ? et.removeAttribute($) : (rt = rt.type,
    tt = rt === 3 || rt === 4 && tt === !0 ? "" : "" + tt,
    nt ? et.setAttributeNS(nt, $, tt) : et.setAttribute($, tt))))
}
var ta = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , ua = Symbol.for("react.element")
  , va = Symbol.for("react.portal")
  , wa = Symbol.for("react.fragment")
  , xa = Symbol.for("react.strict_mode")
  , za = Symbol.for("react.profiler")
  , Aa = Symbol.for("react.provider")
  , Ba = Symbol.for("react.context")
  , Ca = Symbol.for("react.forward_ref")
  , Da = Symbol.for("react.suspense")
  , Ea = Symbol.for("react.suspense_list")
  , Fa = Symbol.for("react.memo")
  , Ga = Symbol.for("react.lazy")
  , Ha = Symbol.for("react.offscreen")
  , Ia = Symbol.iterator;
function Ja(et) {
    return et === null || typeof et != "object" ? null : (et = Ia && et[Ia] || et["@@iterator"],
    typeof et == "function" ? et : null)
}
var A$1 = Object.assign, Ka;
function La(et) {
    if (Ka === void 0)
        try {
            throw Error()
        } catch (tt) {
            var $ = tt.stack.trim().match(/\n( *(at )?)/);
            Ka = $ && $[1] || ""
        }
    return `
` + Ka + et
}
var Ma = !1;
function Na(et, $) {
    if (!et || Ma)
        return "";
    Ma = !0;
    var tt = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if ($)
            if ($ = function() {
                throw Error()
            }
            ,
            Object.defineProperty($.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct($, [])
                } catch (ut) {
                    var nt = ut
                }
                Reflect.construct(et, [], $)
            } else {
                try {
                    $.call()
                } catch (ut) {
                    nt = ut
                }
                et.call($.prototype)
            }
        else {
            try {
                throw Error()
            } catch (ut) {
                nt = ut
            }
            et()
        }
    } catch (ut) {
        if (ut && nt && typeof ut.stack == "string") {
            for (var rt = ut.stack.split(`
`), it = nt.stack.split(`
`), ot = rt.length - 1, st = it.length - 1; 1 <= ot && 0 <= st && rt[ot] !== it[st]; )
                st--;
            for (; 1 <= ot && 0 <= st; ot--,
            st--)
                if (rt[ot] !== it[st]) {
                    if (ot !== 1 || st !== 1)
                        do
                            if (ot--,
                            st--,
                            0 > st || rt[ot] !== it[st]) {
                                var lt = `
` + rt[ot].replace(" at new ", " at ");
                                return et.displayName && lt.includes("<anonymous>") && (lt = lt.replace("<anonymous>", et.displayName)),
                                lt
                            }
                        while (1 <= ot && 0 <= st);
                    break
                }
        }
    } finally {
        Ma = !1,
        Error.prepareStackTrace = tt
    }
    return (et = et ? et.displayName || et.name : "") ? La(et) : ""
}
function Oa(et) {
    switch (et.tag) {
    case 5:
        return La(et.type);
    case 16:
        return La("Lazy");
    case 13:
        return La("Suspense");
    case 19:
        return La("SuspenseList");
    case 0:
    case 2:
    case 15:
        return et = Na(et.type, !1),
        et;
    case 11:
        return et = Na(et.type.render, !1),
        et;
    case 1:
        return et = Na(et.type, !0),
        et;
    default:
        return ""
    }
}
function Pa(et) {
    if (et == null)
        return null;
    if (typeof et == "function")
        return et.displayName || et.name || null;
    if (typeof et == "string")
        return et;
    switch (et) {
    case wa:
        return "Fragment";
    case va:
        return "Portal";
    case za:
        return "Profiler";
    case xa:
        return "StrictMode";
    case Da:
        return "Suspense";
    case Ea:
        return "SuspenseList"
    }
    if (typeof et == "object")
        switch (et.$$typeof) {
        case Ba:
            return (et.displayName || "Context") + ".Consumer";
        case Aa:
            return (et._context.displayName || "Context") + ".Provider";
        case Ca:
            var $ = et.render;
            return et = et.displayName,
            et || (et = $.displayName || $.name || "",
            et = et !== "" ? "ForwardRef(" + et + ")" : "ForwardRef"),
            et;
        case Fa:
            return $ = et.displayName || null,
            $ !== null ? $ : Pa(et.type) || "Memo";
        case Ga:
            $ = et._payload,
            et = et._init;
            try {
                return Pa(et($))
            } catch {}
        }
    return null
}
function Qa(et) {
    var $ = et.type;
    switch (et.tag) {
    case 24:
        return "Cache";
    case 9:
        return ($.displayName || "Context") + ".Consumer";
    case 10:
        return ($._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return et = $.render,
        et = et.displayName || et.name || "",
        $.displayName || (et !== "" ? "ForwardRef(" + et + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return $;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Pa($);
    case 8:
        return $ === xa ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof $ == "function")
            return $.displayName || $.name || null;
        if (typeof $ == "string")
            return $
    }
    return null
}
function Ra(et) {
    switch (typeof et) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return et;
    case "object":
        return et;
    default:
        return ""
    }
}
function Sa(et) {
    var $ = et.type;
    return (et = et.nodeName) && et.toLowerCase() === "input" && ($ === "checkbox" || $ === "radio")
}
function Ta(et) {
    var $ = Sa(et) ? "checked" : "value"
      , tt = Object.getOwnPropertyDescriptor(et.constructor.prototype, $)
      , nt = "" + et[$];
    if (!et.hasOwnProperty($) && typeof tt != "undefined" && typeof tt.get == "function" && typeof tt.set == "function") {
        var rt = tt.get
          , it = tt.set;
        return Object.defineProperty(et, $, {
            configurable: !0,
            get: function() {
                return rt.call(this)
            },
            set: function(ot) {
                nt = "" + ot,
                it.call(this, ot)
            }
        }),
        Object.defineProperty(et, $, {
            enumerable: tt.enumerable
        }),
        {
            getValue: function() {
                return nt
            },
            setValue: function(ot) {
                nt = "" + ot
            },
            stopTracking: function() {
                et._valueTracker = null,
                delete et[$]
            }
        }
    }
}
function Ua(et) {
    et._valueTracker || (et._valueTracker = Ta(et))
}
function Va(et) {
    if (!et)
        return !1;
    var $ = et._valueTracker;
    if (!$)
        return !0;
    var tt = $.getValue()
      , nt = "";
    return et && (nt = Sa(et) ? et.checked ? "true" : "false" : et.value),
    et = nt,
    et !== tt ? ($.setValue(et),
    !0) : !1
}
function Wa(et) {
    if (et = et || (typeof document != "undefined" ? document : void 0),
    typeof et == "undefined")
        return null;
    try {
        return et.activeElement || et.body
    } catch {
        return et.body
    }
}
function Xa(et, $) {
    var tt = $.checked;
    return A$1({}, $, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: tt != null ? tt : et._wrapperState.initialChecked
    })
}
function Ya(et, $) {
    var tt = $.defaultValue == null ? "" : $.defaultValue
      , nt = $.checked != null ? $.checked : $.defaultChecked;
    tt = Ra($.value != null ? $.value : tt),
    et._wrapperState = {
        initialChecked: nt,
        initialValue: tt,
        controlled: $.type === "checkbox" || $.type === "radio" ? $.checked != null : $.value != null
    }
}
function Za(et, $) {
    $ = $.checked,
    $ != null && sa(et, "checked", $, !1)
}
function $a(et, $) {
    Za(et, $);
    var tt = Ra($.value)
      , nt = $.type;
    if (tt != null)
        nt === "number" ? (tt === 0 && et.value === "" || et.value != tt) && (et.value = "" + tt) : et.value !== "" + tt && (et.value = "" + tt);
    else if (nt === "submit" || nt === "reset") {
        et.removeAttribute("value");
        return
    }
    $.hasOwnProperty("value") ? bb(et, $.type, tt) : $.hasOwnProperty("defaultValue") && bb(et, $.type, Ra($.defaultValue)),
    $.checked == null && $.defaultChecked != null && (et.defaultChecked = !!$.defaultChecked)
}
function cb(et, $, tt) {
    if ($.hasOwnProperty("value") || $.hasOwnProperty("defaultValue")) {
        var nt = $.type;
        if (!(nt !== "submit" && nt !== "reset" || $.value !== void 0 && $.value !== null))
            return;
        $ = "" + et._wrapperState.initialValue,
        tt || $ === et.value || (et.value = $),
        et.defaultValue = $
    }
    tt = et.name,
    tt !== "" && (et.name = ""),
    et.defaultChecked = !!et._wrapperState.initialChecked,
    tt !== "" && (et.name = tt)
}
function bb(et, $, tt) {
    ($ !== "number" || Wa(et.ownerDocument) !== et) && (tt == null ? et.defaultValue = "" + et._wrapperState.initialValue : et.defaultValue !== "" + tt && (et.defaultValue = "" + tt))
}
var db = Array.isArray;
function eb(et, $, tt, nt) {
    if (et = et.options,
    $) {
        $ = {};
        for (var rt = 0; rt < tt.length; rt++)
            $["$" + tt[rt]] = !0;
        for (tt = 0; tt < et.length; tt++)
            rt = $.hasOwnProperty("$" + et[tt].value),
            et[tt].selected !== rt && (et[tt].selected = rt),
            rt && nt && (et[tt].defaultSelected = !0)
    } else {
        for (tt = "" + Ra(tt),
        $ = null,
        rt = 0; rt < et.length; rt++) {
            if (et[rt].value === tt) {
                et[rt].selected = !0,
                nt && (et[rt].defaultSelected = !0);
                return
            }
            $ !== null || et[rt].disabled || ($ = et[rt])
        }
        $ !== null && ($.selected = !0)
    }
}
function fb(et, $) {
    if ($.dangerouslySetInnerHTML != null)
        throw Error(p$5(91));
    return A$1({}, $, {
        value: void 0,
        defaultValue: void 0,
        children: "" + et._wrapperState.initialValue
    })
}
function gb(et, $) {
    var tt = $.value;
    if (tt == null) {
        if (tt = $.children,
        $ = $.defaultValue,
        tt != null) {
            if ($ != null)
                throw Error(p$5(92));
            if (db(tt)) {
                if (1 < tt.length)
                    throw Error(p$5(93));
                tt = tt[0]
            }
            $ = tt
        }
        $ == null && ($ = ""),
        tt = $
    }
    et._wrapperState = {
        initialValue: Ra(tt)
    }
}
function hb(et, $) {
    var tt = Ra($.value)
      , nt = Ra($.defaultValue);
    tt != null && (tt = "" + tt,
    tt !== et.value && (et.value = tt),
    $.defaultValue == null && et.defaultValue !== tt && (et.defaultValue = tt)),
    nt != null && (et.defaultValue = "" + nt)
}
function ib(et) {
    var $ = et.textContent;
    $ === et._wrapperState.initialValue && $ !== "" && $ !== null && (et.value = $)
}
function jb(et) {
    switch (et) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function kb(et, $) {
    return et == null || et === "http://www.w3.org/1999/xhtml" ? jb($) : et === "http://www.w3.org/2000/svg" && $ === "foreignObject" ? "http://www.w3.org/1999/xhtml" : et
}
var lb, mb = function(et) {
    return typeof MSApp != "undefined" && MSApp.execUnsafeLocalFunction ? function($, tt, nt, rt) {
        MSApp.execUnsafeLocalFunction(function() {
            return et($, tt, nt, rt)
        })
    }
    : et
}(function(et, $) {
    if (et.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in et)
        et.innerHTML = $;
    else {
        for (lb = lb || document.createElement("div"),
        lb.innerHTML = "<svg>" + $.valueOf().toString() + "</svg>",
        $ = lb.firstChild; et.firstChild; )
            et.removeChild(et.firstChild);
        for (; $.firstChild; )
            et.appendChild($.firstChild)
    }
});
function nb(et, $) {
    if ($) {
        var tt = et.firstChild;
        if (tt && tt === et.lastChild && tt.nodeType === 3) {
            tt.nodeValue = $;
            return
        }
    }
    et.textContent = $
}
var ob = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , pb = ["Webkit", "ms", "Moz", "O"];
Object.keys(ob).forEach(function(et) {
    pb.forEach(function($) {
        $ = $ + et.charAt(0).toUpperCase() + et.substring(1),
        ob[$] = ob[et]
    })
});
function qb(et, $, tt) {
    return $ == null || typeof $ == "boolean" || $ === "" ? "" : tt || typeof $ != "number" || $ === 0 || ob.hasOwnProperty(et) && ob[et] ? ("" + $).trim() : $ + "px"
}
function rb(et, $) {
    et = et.style;
    for (var tt in $)
        if ($.hasOwnProperty(tt)) {
            var nt = tt.indexOf("--") === 0
              , rt = qb(tt, $[tt], nt);
            tt === "float" && (tt = "cssFloat"),
            nt ? et.setProperty(tt, rt) : et[tt] = rt
        }
}
var sb = A$1({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function tb(et, $) {
    if ($) {
        if (sb[et] && ($.children != null || $.dangerouslySetInnerHTML != null))
            throw Error(p$5(137, et));
        if ($.dangerouslySetInnerHTML != null) {
            if ($.children != null)
                throw Error(p$5(60));
            if (typeof $.dangerouslySetInnerHTML != "object" || !("__html"in $.dangerouslySetInnerHTML))
                throw Error(p$5(61))
        }
        if ($.style != null && typeof $.style != "object")
            throw Error(p$5(62))
    }
}
function ub(et, $) {
    if (et.indexOf("-") === -1)
        return typeof $.is == "string";
    switch (et) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var vb = null;
function wb(et) {
    return et = et.target || et.srcElement || window,
    et.correspondingUseElement && (et = et.correspondingUseElement),
    et.nodeType === 3 ? et.parentNode : et
}
var xb = null
  , yb = null
  , zb = null;
function Ab(et) {
    if (et = Bb(et)) {
        if (typeof xb != "function")
            throw Error(p$5(280));
        var $ = et.stateNode;
        $ && ($ = Cb($),
        xb(et.stateNode, et.type, $))
    }
}
function Db(et) {
    yb ? zb ? zb.push(et) : zb = [et] : yb = et
}
function Eb() {
    if (yb) {
        var et = yb
          , $ = zb;
        if (zb = yb = null,
        Ab(et),
        $)
            for (et = 0; et < $.length; et++)
                Ab($[et])
    }
}
function Fb(et, $) {
    return et($)
}
function Gb() {}
var Hb = !1;
function Ib(et, $, tt) {
    if (Hb)
        return et($, tt);
    Hb = !0;
    try {
        return Fb(et, $, tt)
    } finally {
        Hb = !1,
        (yb !== null || zb !== null) && (Gb(),
        Eb())
    }
}
function Jb(et, $) {
    var tt = et.stateNode;
    if (tt === null)
        return null;
    var nt = Cb(tt);
    if (nt === null)
        return null;
    tt = nt[$];
    e: switch ($) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (nt = !nt.disabled) || (et = et.type,
        nt = !(et === "button" || et === "input" || et === "select" || et === "textarea")),
        et = !nt;
        break e;
    default:
        et = !1
    }
    if (et)
        return null;
    if (tt && typeof tt != "function")
        throw Error(p$5(231, $, typeof tt));
    return tt
}
var Kb = !1;
if (ia)
    try {
        var Lb = {};
        Object.defineProperty(Lb, "passive", {
            get: function() {
                Kb = !0
            }
        }),
        window.addEventListener("test", Lb, Lb),
        window.removeEventListener("test", Lb, Lb)
    } catch {
        Kb = !1
    }
function Mb(et, $, tt, nt, rt, it, ot, st, lt) {
    var ut = Array.prototype.slice.call(arguments, 3);
    try {
        $.apply(tt, ut)
    } catch (ct) {
        this.onError(ct)
    }
}
var Nb = !1
  , Ob = null
  , Pb = !1
  , Qb = null
  , Rb = {
    onError: function(et) {
        Nb = !0,
        Ob = et
    }
};
function Sb(et, $, tt, nt, rt, it, ot, st, lt) {
    Nb = !1,
    Ob = null,
    Mb.apply(Rb, arguments)
}
function Tb(et, $, tt, nt, rt, it, ot, st, lt) {
    if (Sb.apply(this, arguments),
    Nb) {
        if (Nb) {
            var ut = Ob;
            Nb = !1,
            Ob = null
        } else
            throw Error(p$5(198));
        Pb || (Pb = !0,
        Qb = ut)
    }
}
function Ub(et) {
    var $ = et
      , tt = et;
    if (et.alternate)
        for (; $.return; )
            $ = $.return;
    else {
        et = $;
        do
            $ = et,
            ($.flags & 4098) !== 0 && (tt = $.return),
            et = $.return;
        while (et)
    }
    return $.tag === 3 ? tt : null
}
function Vb(et) {
    if (et.tag === 13) {
        var $ = et.memoizedState;
        if ($ === null && (et = et.alternate,
        et !== null && ($ = et.memoizedState)),
        $ !== null)
            return $.dehydrated
    }
    return null
}
function Wb(et) {
    if (Ub(et) !== et)
        throw Error(p$5(188))
}
function Xb(et) {
    var $ = et.alternate;
    if (!$) {
        if ($ = Ub(et),
        $ === null)
            throw Error(p$5(188));
        return $ !== et ? null : et
    }
    for (var tt = et, nt = $; ; ) {
        var rt = tt.return;
        if (rt === null)
            break;
        var it = rt.alternate;
        if (it === null) {
            if (nt = rt.return,
            nt !== null) {
                tt = nt;
                continue
            }
            break
        }
        if (rt.child === it.child) {
            for (it = rt.child; it; ) {
                if (it === tt)
                    return Wb(rt),
                    et;
                if (it === nt)
                    return Wb(rt),
                    $;
                it = it.sibling
            }
            throw Error(p$5(188))
        }
        if (tt.return !== nt.return)
            tt = rt,
            nt = it;
        else {
            for (var ot = !1, st = rt.child; st; ) {
                if (st === tt) {
                    ot = !0,
                    tt = rt,
                    nt = it;
                    break
                }
                if (st === nt) {
                    ot = !0,
                    nt = rt,
                    tt = it;
                    break
                }
                st = st.sibling
            }
            if (!ot) {
                for (st = it.child; st; ) {
                    if (st === tt) {
                        ot = !0,
                        tt = it,
                        nt = rt;
                        break
                    }
                    if (st === nt) {
                        ot = !0,
                        nt = it,
                        tt = rt;
                        break
                    }
                    st = st.sibling
                }
                if (!ot)
                    throw Error(p$5(189))
            }
        }
        if (tt.alternate !== nt)
            throw Error(p$5(190))
    }
    if (tt.tag !== 3)
        throw Error(p$5(188));
    return tt.stateNode.current === tt ? et : $
}
function Yb(et) {
    return et = Xb(et),
    et !== null ? Zb(et) : null
}
function Zb(et) {
    if (et.tag === 5 || et.tag === 6)
        return et;
    for (et = et.child; et !== null; ) {
        var $ = Zb(et);
        if ($ !== null)
            return $;
        et = et.sibling
    }
    return null
}
var $b = ba.unstable_scheduleCallback
  , ac = ba.unstable_cancelCallback
  , bc = ba.unstable_shouldYield
  , cc = ba.unstable_requestPaint
  , B$1 = ba.unstable_now
  , dc = ba.unstable_getCurrentPriorityLevel
  , ec = ba.unstable_ImmediatePriority
  , fc = ba.unstable_UserBlockingPriority
  , gc = ba.unstable_NormalPriority
  , hc = ba.unstable_LowPriority
  , ic = ba.unstable_IdlePriority
  , jc = null
  , kc = null;
function lc(et) {
    if (kc && typeof kc.onCommitFiberRoot == "function")
        try {
            kc.onCommitFiberRoot(jc, et, void 0, (et.current.flags & 128) === 128)
        } catch {}
}
var nc = Math.clz32 ? Math.clz32 : mc
  , oc = Math.log
  , pc = Math.LN2;
function mc(et) {
    return et >>>= 0,
    et === 0 ? 32 : 31 - (oc(et) / pc | 0) | 0
}
var qc = 64
  , rc = 4194304;
function sc(et) {
    switch (et & -et) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return et & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return et & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return et
    }
}
function tc(et, $) {
    var tt = et.pendingLanes;
    if (tt === 0)
        return 0;
    var nt = 0
      , rt = et.suspendedLanes
      , it = et.pingedLanes
      , ot = tt & 268435455;
    if (ot !== 0) {
        var st = ot & ~rt;
        st !== 0 ? nt = sc(st) : (it &= ot,
        it !== 0 && (nt = sc(it)))
    } else
        ot = tt & ~rt,
        ot !== 0 ? nt = sc(ot) : it !== 0 && (nt = sc(it));
    if (nt === 0)
        return 0;
    if ($ !== 0 && $ !== nt && ($ & rt) === 0 && (rt = nt & -nt,
    it = $ & -$,
    rt >= it || rt === 16 && (it & 4194240) !== 0))
        return $;
    if ((nt & 4) !== 0 && (nt |= tt & 16),
    $ = et.entangledLanes,
    $ !== 0)
        for (et = et.entanglements,
        $ &= nt; 0 < $; )
            tt = 31 - nc($),
            rt = 1 << tt,
            nt |= et[tt],
            $ &= ~rt;
    return nt
}
function uc(et, $) {
    switch (et) {
    case 1:
    case 2:
    case 4:
        return $ + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return $ + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function vc(et, $) {
    for (var tt = et.suspendedLanes, nt = et.pingedLanes, rt = et.expirationTimes, it = et.pendingLanes; 0 < it; ) {
        var ot = 31 - nc(it)
          , st = 1 << ot
          , lt = rt[ot];
        lt === -1 ? ((st & tt) === 0 || (st & nt) !== 0) && (rt[ot] = uc(st, $)) : lt <= $ && (et.expiredLanes |= st),
        it &= ~st
    }
}
function wc(et) {
    return et = et.pendingLanes & -1073741825,
    et !== 0 ? et : et & 1073741824 ? 1073741824 : 0
}
function xc() {
    var et = qc;
    return qc <<= 1,
    (qc & 4194240) === 0 && (qc = 64),
    et
}
function yc(et) {
    for (var $ = [], tt = 0; 31 > tt; tt++)
        $.push(et);
    return $
}
function zc(et, $, tt) {
    et.pendingLanes |= $,
    $ !== 536870912 && (et.suspendedLanes = 0,
    et.pingedLanes = 0),
    et = et.eventTimes,
    $ = 31 - nc($),
    et[$] = tt
}
function Ac(et, $) {
    var tt = et.pendingLanes & ~$;
    et.pendingLanes = $,
    et.suspendedLanes = 0,
    et.pingedLanes = 0,
    et.expiredLanes &= $,
    et.mutableReadLanes &= $,
    et.entangledLanes &= $,
    $ = et.entanglements;
    var nt = et.eventTimes;
    for (et = et.expirationTimes; 0 < tt; ) {
        var rt = 31 - nc(tt)
          , it = 1 << rt;
        $[rt] = 0,
        nt[rt] = -1,
        et[rt] = -1,
        tt &= ~it
    }
}
function Bc(et, $) {
    var tt = et.entangledLanes |= $;
    for (et = et.entanglements; tt; ) {
        var nt = 31 - nc(tt)
          , rt = 1 << nt;
        rt & $ | et[nt] & $ && (et[nt] |= $),
        tt &= ~rt
    }
}
var C = 0;
function Cc(et) {
    return et &= -et,
    1 < et ? 4 < et ? (et & 268435455) !== 0 ? 16 : 536870912 : 4 : 1
}
var Dc, Ec, Fc, Gc, Hc, Ic = !1, Jc = [], Kc = null, Lc = null, Mc = null, Nc = new Map, Oc = new Map, Pc = [], Qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Rc(et, $) {
    switch (et) {
    case "focusin":
    case "focusout":
        Kc = null;
        break;
    case "dragenter":
    case "dragleave":
        Lc = null;
        break;
    case "mouseover":
    case "mouseout":
        Mc = null;
        break;
    case "pointerover":
    case "pointerout":
        Nc.delete($.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Oc.delete($.pointerId)
    }
}
function Sc(et, $, tt, nt, rt, it) {
    return et === null || et.nativeEvent !== it ? (et = {
        blockedOn: $,
        domEventName: tt,
        eventSystemFlags: nt,
        nativeEvent: it,
        targetContainers: [rt]
    },
    $ !== null && ($ = Bb($),
    $ !== null && Ec($)),
    et) : (et.eventSystemFlags |= nt,
    $ = et.targetContainers,
    rt !== null && $.indexOf(rt) === -1 && $.push(rt),
    et)
}
function Tc(et, $, tt, nt, rt) {
    switch ($) {
    case "focusin":
        return Kc = Sc(Kc, et, $, tt, nt, rt),
        !0;
    case "dragenter":
        return Lc = Sc(Lc, et, $, tt, nt, rt),
        !0;
    case "mouseover":
        return Mc = Sc(Mc, et, $, tt, nt, rt),
        !0;
    case "pointerover":
        var it = rt.pointerId;
        return Nc.set(it, Sc(Nc.get(it) || null, et, $, tt, nt, rt)),
        !0;
    case "gotpointercapture":
        return it = rt.pointerId,
        Oc.set(it, Sc(Oc.get(it) || null, et, $, tt, nt, rt)),
        !0
    }
    return !1
}
function Uc(et) {
    var $ = Vc(et.target);
    if ($ !== null) {
        var tt = Ub($);
        if (tt !== null) {
            if ($ = tt.tag,
            $ === 13) {
                if ($ = Vb(tt),
                $ !== null) {
                    et.blockedOn = $,
                    Hc(et.priority, function() {
                        Fc(tt)
                    });
                    return
                }
            } else if ($ === 3 && tt.stateNode.current.memoizedState.isDehydrated) {
                et.blockedOn = tt.tag === 3 ? tt.stateNode.containerInfo : null;
                return
            }
        }
    }
    et.blockedOn = null
}
function Wc(et) {
    if (et.blockedOn !== null)
        return !1;
    for (var $ = et.targetContainers; 0 < $.length; ) {
        var tt = Xc(et.domEventName, et.eventSystemFlags, $[0], et.nativeEvent);
        if (tt === null) {
            tt = et.nativeEvent;
            var nt = new tt.constructor(tt.type,tt);
            vb = nt,
            tt.target.dispatchEvent(nt),
            vb = null
        } else
            return $ = Bb(tt),
            $ !== null && Ec($),
            et.blockedOn = tt,
            !1;
        $.shift()
    }
    return !0
}
function Yc(et, $, tt) {
    Wc(et) && tt.delete($)
}
function Zc() {
    Ic = !1,
    Kc !== null && Wc(Kc) && (Kc = null),
    Lc !== null && Wc(Lc) && (Lc = null),
    Mc !== null && Wc(Mc) && (Mc = null),
    Nc.forEach(Yc),
    Oc.forEach(Yc)
}
function $c(et, $) {
    et.blockedOn === $ && (et.blockedOn = null,
    Ic || (Ic = !0,
    ba.unstable_scheduleCallback(ba.unstable_NormalPriority, Zc)))
}
function ad(et) {
    function $(rt) {
        return $c(rt, et)
    }
    if (0 < Jc.length) {
        $c(Jc[0], et);
        for (var tt = 1; tt < Jc.length; tt++) {
            var nt = Jc[tt];
            nt.blockedOn === et && (nt.blockedOn = null)
        }
    }
    for (Kc !== null && $c(Kc, et),
    Lc !== null && $c(Lc, et),
    Mc !== null && $c(Mc, et),
    Nc.forEach($),
    Oc.forEach($),
    tt = 0; tt < Pc.length; tt++)
        nt = Pc[tt],
        nt.blockedOn === et && (nt.blockedOn = null);
    for (; 0 < Pc.length && (tt = Pc[0],
    tt.blockedOn === null); )
        Uc(tt),
        tt.blockedOn === null && Pc.shift()
}
var bd = ta.ReactCurrentBatchConfig
  , cd = !0;
function dd(et, $, tt, nt) {
    var rt = C
      , it = bd.transition;
    bd.transition = null;
    try {
        C = 1,
        ed(et, $, tt, nt)
    } finally {
        C = rt,
        bd.transition = it
    }
}
function fd(et, $, tt, nt) {
    var rt = C
      , it = bd.transition;
    bd.transition = null;
    try {
        C = 4,
        ed(et, $, tt, nt)
    } finally {
        C = rt,
        bd.transition = it
    }
}
function ed(et, $, tt, nt) {
    if (cd) {
        var rt = Xc(et, $, tt, nt);
        if (rt === null)
            gd(et, $, nt, hd, tt),
            Rc(et, nt);
        else if (Tc(rt, et, $, tt, nt))
            nt.stopPropagation();
        else if (Rc(et, nt),
        $ & 4 && -1 < Qc.indexOf(et)) {
            for (; rt !== null; ) {
                var it = Bb(rt);
                if (it !== null && Dc(it),
                it = Xc(et, $, tt, nt),
                it === null && gd(et, $, nt, hd, tt),
                it === rt)
                    break;
                rt = it
            }
            rt !== null && nt.stopPropagation()
        } else
            gd(et, $, nt, null, tt)
    }
}
var hd = null;
function Xc(et, $, tt, nt) {
    if (hd = null,
    et = wb(nt),
    et = Vc(et),
    et !== null)
        if ($ = Ub(et),
        $ === null)
            et = null;
        else if (tt = $.tag,
        tt === 13) {
            if (et = Vb($),
            et !== null)
                return et;
            et = null
        } else if (tt === 3) {
            if ($.stateNode.current.memoizedState.isDehydrated)
                return $.tag === 3 ? $.stateNode.containerInfo : null;
            et = null
        } else
            $ !== et && (et = null);
    return hd = et,
    null
}
function id(et) {
    switch (et) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (dc()) {
        case ec:
            return 1;
        case fc:
            return 4;
        case gc:
        case hc:
            return 16;
        case ic:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var jd = null
  , kd = null
  , ld = null;
function md() {
    if (ld)
        return ld;
    var et, $ = kd, tt = $.length, nt, rt = "value"in jd ? jd.value : jd.textContent, it = rt.length;
    for (et = 0; et < tt && $[et] === rt[et]; et++)
        ;
    var ot = tt - et;
    for (nt = 1; nt <= ot && $[tt - nt] === rt[it - nt]; nt++)
        ;
    return ld = rt.slice(et, 1 < nt ? 1 - nt : void 0)
}
function nd(et) {
    var $ = et.keyCode;
    return "charCode"in et ? (et = et.charCode,
    et === 0 && $ === 13 && (et = 13)) : et = $,
    et === 10 && (et = 13),
    32 <= et || et === 13 ? et : 0
}
function od() {
    return !0
}
function pd() {
    return !1
}
function qd(et) {
    function $(tt, nt, rt, it, ot) {
        this._reactName = tt,
        this._targetInst = rt,
        this.type = nt,
        this.nativeEvent = it,
        this.target = ot,
        this.currentTarget = null;
        for (var st in et)
            et.hasOwnProperty(st) && (tt = et[st],
            this[st] = tt ? tt(it) : it[st]);
        return this.isDefaultPrevented = (it.defaultPrevented != null ? it.defaultPrevented : it.returnValue === !1) ? od : pd,
        this.isPropagationStopped = pd,
        this
    }
    return A$1($.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var tt = this.nativeEvent;
            tt && (tt.preventDefault ? tt.preventDefault() : typeof tt.returnValue != "unknown" && (tt.returnValue = !1),
            this.isDefaultPrevented = od)
        },
        stopPropagation: function() {
            var tt = this.nativeEvent;
            tt && (tt.stopPropagation ? tt.stopPropagation() : typeof tt.cancelBubble != "unknown" && (tt.cancelBubble = !0),
            this.isPropagationStopped = od)
        },
        persist: function() {},
        isPersistent: od
    }),
    $
}
var rd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(et) {
        return et.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, sd = qd(rd), td = A$1({}, rd, {
    view: 0,
    detail: 0
}), ud = qd(td), vd, wd, xd, zd = A$1({}, td, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: yd,
    button: 0,
    buttons: 0,
    relatedTarget: function(et) {
        return et.relatedTarget === void 0 ? et.fromElement === et.srcElement ? et.toElement : et.fromElement : et.relatedTarget
    },
    movementX: function(et) {
        return "movementX"in et ? et.movementX : (et !== xd && (xd && et.type === "mousemove" ? (vd = et.screenX - xd.screenX,
        wd = et.screenY - xd.screenY) : wd = vd = 0,
        xd = et),
        vd)
    },
    movementY: function(et) {
        return "movementY"in et ? et.movementY : wd
    }
}), Ad = qd(zd), Bd = A$1({}, zd, {
    dataTransfer: 0
}), Cd = qd(Bd), Dd = A$1({}, td, {
    relatedTarget: 0
}), Ed = qd(Dd), Fd = A$1({}, rd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Gd = qd(Fd), Hd = A$1({}, rd, {
    clipboardData: function(et) {
        return "clipboardData"in et ? et.clipboardData : window.clipboardData
    }
}), Id = qd(Hd), Jd = A$1({}, rd, {
    data: 0
}), Kd = qd(Jd), Ld = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, Md = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, Nd = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function Od(et) {
    var $ = this.nativeEvent;
    return $.getModifierState ? $.getModifierState(et) : (et = Nd[et]) ? !!$[et] : !1
}
function yd() {
    return Od
}
var Pd = A$1({}, td, {
    key: function(et) {
        if (et.key) {
            var $ = Ld[et.key] || et.key;
            if ($ !== "Unidentified")
                return $
        }
        return et.type === "keypress" ? (et = nd(et),
        et === 13 ? "Enter" : String.fromCharCode(et)) : et.type === "keydown" || et.type === "keyup" ? Md[et.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: yd,
    charCode: function(et) {
        return et.type === "keypress" ? nd(et) : 0
    },
    keyCode: function(et) {
        return et.type === "keydown" || et.type === "keyup" ? et.keyCode : 0
    },
    which: function(et) {
        return et.type === "keypress" ? nd(et) : et.type === "keydown" || et.type === "keyup" ? et.keyCode : 0
    }
})
  , Qd = qd(Pd)
  , Rd = A$1({}, zd, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Sd = qd(Rd)
  , Td = A$1({}, td, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: yd
})
  , Ud = qd(Td)
  , Vd = A$1({}, rd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , Wd = qd(Vd)
  , Xd = A$1({}, zd, {
    deltaX: function(et) {
        return "deltaX"in et ? et.deltaX : "wheelDeltaX"in et ? -et.wheelDeltaX : 0
    },
    deltaY: function(et) {
        return "deltaY"in et ? et.deltaY : "wheelDeltaY"in et ? -et.wheelDeltaY : "wheelDelta"in et ? -et.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , Yd = qd(Xd)
  , Zd = [9, 13, 27, 32]
  , $d = ia && "CompositionEvent"in window
  , ae = null;
ia && "documentMode"in document && (ae = document.documentMode);
var be = ia && "TextEvent"in window && !ae
  , ce = ia && (!$d || ae && 8 < ae && 11 >= ae)
  , de = String.fromCharCode(32)
  , ee = !1;
function fe(et, $) {
    switch (et) {
    case "keyup":
        return Zd.indexOf($.keyCode) !== -1;
    case "keydown":
        return $.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function ge(et) {
    return et = et.detail,
    typeof et == "object" && "data"in et ? et.data : null
}
var he = !1;
function ie(et, $) {
    switch (et) {
    case "compositionend":
        return ge($);
    case "keypress":
        return $.which !== 32 ? null : (ee = !0,
        de);
    case "textInput":
        return et = $.data,
        et === de && ee ? null : et;
    default:
        return null
    }
}
function je(et, $) {
    if (he)
        return et === "compositionend" || !$d && fe(et, $) ? (et = md(),
        ld = kd = jd = null,
        he = !1,
        et) : null;
    switch (et) {
    case "paste":
        return null;
    case "keypress":
        if (!($.ctrlKey || $.altKey || $.metaKey) || $.ctrlKey && $.altKey) {
            if ($.char && 1 < $.char.length)
                return $.char;
            if ($.which)
                return String.fromCharCode($.which)
        }
        return null;
    case "compositionend":
        return ce && $.locale !== "ko" ? null : $.data;
    default:
        return null
    }
}
var ke = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function le(et) {
    var $ = et && et.nodeName && et.nodeName.toLowerCase();
    return $ === "input" ? !!ke[et.type] : $ === "textarea"
}
function me(et, $, tt, nt) {
    Db(nt),
    $ = ne($, "onChange"),
    0 < $.length && (tt = new sd("onChange","change",null,tt,nt),
    et.push({
        event: tt,
        listeners: $
    }))
}
var oe = null
  , pe = null;
function qe(et) {
    re(et, 0)
}
function se(et) {
    var $ = te(et);
    if (Va($))
        return et
}
function ue(et, $) {
    if (et === "change")
        return $
}
var ve = !1;
if (ia) {
    var we;
    if (ia) {
        var xe = "oninput"in document;
        if (!xe) {
            var ye = document.createElement("div");
            ye.setAttribute("oninput", "return;"),
            xe = typeof ye.oninput == "function"
        }
        we = xe
    } else
        we = !1;
    ve = we && (!document.documentMode || 9 < document.documentMode)
}
function ze() {
    oe && (oe.detachEvent("onpropertychange", Ae),
    pe = oe = null)
}
function Ae(et) {
    if (et.propertyName === "value" && se(pe)) {
        var $ = [];
        me($, pe, et, wb(et)),
        Ib(qe, $)
    }
}
function Be(et, $, tt) {
    et === "focusin" ? (ze(),
    oe = $,
    pe = tt,
    oe.attachEvent("onpropertychange", Ae)) : et === "focusout" && ze()
}
function Ce(et) {
    if (et === "selectionchange" || et === "keyup" || et === "keydown")
        return se(pe)
}
function De(et, $) {
    if (et === "click")
        return se($)
}
function Ee(et, $) {
    if (et === "input" || et === "change")
        return se($)
}
function Fe(et, $) {
    return et === $ && (et !== 0 || 1 / et === 1 / $) || et !== et && $ !== $
}
var Ge = typeof Object.is == "function" ? Object.is : Fe;
function He(et, $) {
    if (Ge(et, $))
        return !0;
    if (typeof et != "object" || et === null || typeof $ != "object" || $ === null)
        return !1;
    var tt = Object.keys(et)
      , nt = Object.keys($);
    if (tt.length !== nt.length)
        return !1;
    for (nt = 0; nt < tt.length; nt++) {
        var rt = tt[nt];
        if (!ja.call($, rt) || !Ge(et[rt], $[rt]))
            return !1
    }
    return !0
}
function Ie(et) {
    for (; et && et.firstChild; )
        et = et.firstChild;
    return et
}
function Je(et, $) {
    var tt = Ie(et);
    et = 0;
    for (var nt; tt; ) {
        if (tt.nodeType === 3) {
            if (nt = et + tt.textContent.length,
            et <= $ && nt >= $)
                return {
                    node: tt,
                    offset: $ - et
                };
            et = nt
        }
        e: {
            for (; tt; ) {
                if (tt.nextSibling) {
                    tt = tt.nextSibling;
                    break e
                }
                tt = tt.parentNode
            }
            tt = void 0
        }
        tt = Ie(tt)
    }
}
function Ke(et, $) {
    return et && $ ? et === $ ? !0 : et && et.nodeType === 3 ? !1 : $ && $.nodeType === 3 ? Ke(et, $.parentNode) : "contains"in et ? et.contains($) : et.compareDocumentPosition ? !!(et.compareDocumentPosition($) & 16) : !1 : !1
}
function Le() {
    for (var et = window, $ = Wa(); $ instanceof et.HTMLIFrameElement; ) {
        try {
            var tt = typeof $.contentWindow.location.href == "string"
        } catch {
            tt = !1
        }
        if (tt)
            et = $.contentWindow;
        else
            break;
        $ = Wa(et.document)
    }
    return $
}
function Me(et) {
    var $ = et && et.nodeName && et.nodeName.toLowerCase();
    return $ && ($ === "input" && (et.type === "text" || et.type === "search" || et.type === "tel" || et.type === "url" || et.type === "password") || $ === "textarea" || et.contentEditable === "true")
}
function Ne(et) {
    var $ = Le()
      , tt = et.focusedElem
      , nt = et.selectionRange;
    if ($ !== tt && tt && tt.ownerDocument && Ke(tt.ownerDocument.documentElement, tt)) {
        if (nt !== null && Me(tt)) {
            if ($ = nt.start,
            et = nt.end,
            et === void 0 && (et = $),
            "selectionStart"in tt)
                tt.selectionStart = $,
                tt.selectionEnd = Math.min(et, tt.value.length);
            else if (et = ($ = tt.ownerDocument || document) && $.defaultView || window,
            et.getSelection) {
                et = et.getSelection();
                var rt = tt.textContent.length
                  , it = Math.min(nt.start, rt);
                nt = nt.end === void 0 ? it : Math.min(nt.end, rt),
                !et.extend && it > nt && (rt = nt,
                nt = it,
                it = rt),
                rt = Je(tt, it);
                var ot = Je(tt, nt);
                rt && ot && (et.rangeCount !== 1 || et.anchorNode !== rt.node || et.anchorOffset !== rt.offset || et.focusNode !== ot.node || et.focusOffset !== ot.offset) && ($ = $.createRange(),
                $.setStart(rt.node, rt.offset),
                et.removeAllRanges(),
                it > nt ? (et.addRange($),
                et.extend(ot.node, ot.offset)) : ($.setEnd(ot.node, ot.offset),
                et.addRange($)))
            }
        }
        for ($ = [],
        et = tt; et = et.parentNode; )
            et.nodeType === 1 && $.push({
                element: et,
                left: et.scrollLeft,
                top: et.scrollTop
            });
        for (typeof tt.focus == "function" && tt.focus(),
        tt = 0; tt < $.length; tt++)
            et = $[tt],
            et.element.scrollLeft = et.left,
            et.element.scrollTop = et.top
    }
}
var Oe = ia && "documentMode"in document && 11 >= document.documentMode
  , Pe = null
  , Qe = null
  , Re = null
  , Se = !1;
function Te(et, $, tt) {
    var nt = tt.window === tt ? tt.document : tt.nodeType === 9 ? tt : tt.ownerDocument;
    Se || Pe == null || Pe !== Wa(nt) || (nt = Pe,
    "selectionStart"in nt && Me(nt) ? nt = {
        start: nt.selectionStart,
        end: nt.selectionEnd
    } : (nt = (nt.ownerDocument && nt.ownerDocument.defaultView || window).getSelection(),
    nt = {
        anchorNode: nt.anchorNode,
        anchorOffset: nt.anchorOffset,
        focusNode: nt.focusNode,
        focusOffset: nt.focusOffset
    }),
    Re && He(Re, nt) || (Re = nt,
    nt = ne(Qe, "onSelect"),
    0 < nt.length && ($ = new sd("onSelect","select",null,$,tt),
    et.push({
        event: $,
        listeners: nt
    }),
    $.target = Pe)))
}
function Ue(et, $) {
    var tt = {};
    return tt[et.toLowerCase()] = $.toLowerCase(),
    tt["Webkit" + et] = "webkit" + $,
    tt["Moz" + et] = "moz" + $,
    tt
}
var Ve = {
    animationend: Ue("Animation", "AnimationEnd"),
    animationiteration: Ue("Animation", "AnimationIteration"),
    animationstart: Ue("Animation", "AnimationStart"),
    transitionend: Ue("Transition", "TransitionEnd")
}
  , We = {}
  , Xe = {};
ia && (Xe = document.createElement("div").style,
"AnimationEvent"in window || (delete Ve.animationend.animation,
delete Ve.animationiteration.animation,
delete Ve.animationstart.animation),
"TransitionEvent"in window || delete Ve.transitionend.transition);
function Ye(et) {
    if (We[et])
        return We[et];
    if (!Ve[et])
        return et;
    var $ = Ve[et], tt;
    for (tt in $)
        if ($.hasOwnProperty(tt) && tt in Xe)
            return We[et] = $[tt];
    return et
}
var Ze = Ye("animationend")
  , $e = Ye("animationiteration")
  , af = Ye("animationstart")
  , bf = Ye("transitionend")
  , cf = new Map
  , df = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ef(et, $) {
    cf.set(et, $),
    fa($, [et])
}
for (var ff = 0; ff < df.length; ff++) {
    var gf = df[ff]
      , hf = gf.toLowerCase()
      , jf = gf[0].toUpperCase() + gf.slice(1);
    ef(hf, "on" + jf)
}
ef(Ze, "onAnimationEnd");
ef($e, "onAnimationIteration");
ef(af, "onAnimationStart");
ef("dblclick", "onDoubleClick");
ef("focusin", "onFocus");
ef("focusout", "onBlur");
ef(bf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var kf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , lf = new Set("cancel close invalid load scroll toggle".split(" ").concat(kf));
function mf(et, $, tt) {
    var nt = et.type || "unknown-event";
    et.currentTarget = tt,
    Tb(nt, $, void 0, et),
    et.currentTarget = null
}
function re(et, $) {
    $ = ($ & 4) !== 0;
    for (var tt = 0; tt < et.length; tt++) {
        var nt = et[tt]
          , rt = nt.event;
        nt = nt.listeners;
        e: {
            var it = void 0;
            if ($)
                for (var ot = nt.length - 1; 0 <= ot; ot--) {
                    var st = nt[ot]
                      , lt = st.instance
                      , ut = st.currentTarget;
                    if (st = st.listener,
                    lt !== it && rt.isPropagationStopped())
                        break e;
                    mf(rt, st, ut),
                    it = lt
                }
            else
                for (ot = 0; ot < nt.length; ot++) {
                    if (st = nt[ot],
                    lt = st.instance,
                    ut = st.currentTarget,
                    st = st.listener,
                    lt !== it && rt.isPropagationStopped())
                        break e;
                    mf(rt, st, ut),
                    it = lt
                }
        }
    }
    if (Pb)
        throw et = Qb,
        Pb = !1,
        Qb = null,
        et
}
function D$1(et, $) {
    var tt = $[nf];
    tt === void 0 && (tt = $[nf] = new Set);
    var nt = et + "__bubble";
    tt.has(nt) || (of($, et, 2, !1),
    tt.add(nt))
}
function pf(et, $, tt) {
    var nt = 0;
    $ && (nt |= 4),
    of(tt, et, nt, $)
}
var qf = "_reactListening" + Math.random().toString(36).slice(2);
function rf(et) {
    if (!et[qf]) {
        et[qf] = !0,
        da.forEach(function(tt) {
            tt !== "selectionchange" && (lf.has(tt) || pf(tt, !1, et),
            pf(tt, !0, et))
        });
        var $ = et.nodeType === 9 ? et : et.ownerDocument;
        $ === null || $[qf] || ($[qf] = !0,
        pf("selectionchange", !1, $))
    }
}
function of(et, $, tt, nt) {
    switch (id($)) {
    case 1:
        var rt = dd;
        break;
    case 4:
        rt = fd;
        break;
    default:
        rt = ed
    }
    tt = rt.bind(null, $, tt, et),
    rt = void 0,
    !Kb || $ !== "touchstart" && $ !== "touchmove" && $ !== "wheel" || (rt = !0),
    nt ? rt !== void 0 ? et.addEventListener($, tt, {
        capture: !0,
        passive: rt
    }) : et.addEventListener($, tt, !0) : rt !== void 0 ? et.addEventListener($, tt, {
        passive: rt
    }) : et.addEventListener($, tt, !1)
}
function gd(et, $, tt, nt, rt) {
    var it = nt;
    if (($ & 1) === 0 && ($ & 2) === 0 && nt !== null)
        e: for (; ; ) {
            if (nt === null)
                return;
            var ot = nt.tag;
            if (ot === 3 || ot === 4) {
                var st = nt.stateNode.containerInfo;
                if (st === rt || st.nodeType === 8 && st.parentNode === rt)
                    break;
                if (ot === 4)
                    for (ot = nt.return; ot !== null; ) {
                        var lt = ot.tag;
                        if ((lt === 3 || lt === 4) && (lt = ot.stateNode.containerInfo,
                        lt === rt || lt.nodeType === 8 && lt.parentNode === rt))
                            return;
                        ot = ot.return
                    }
                for (; st !== null; ) {
                    if (ot = Vc(st),
                    ot === null)
                        return;
                    if (lt = ot.tag,
                    lt === 5 || lt === 6) {
                        nt = it = ot;
                        continue e
                    }
                    st = st.parentNode
                }
            }
            nt = nt.return
        }
    Ib(function() {
        var ut = it
          , ct = wb(tt)
          , ht = [];
        e: {
            var ft = cf.get(et);
            if (ft !== void 0) {
                var gt = sd
                  , vt = et;
                switch (et) {
                case "keypress":
                    if (nd(tt) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    gt = Qd;
                    break;
                case "focusin":
                    vt = "focus",
                    gt = Ed;
                    break;
                case "focusout":
                    vt = "blur",
                    gt = Ed;
                    break;
                case "beforeblur":
                case "afterblur":
                    gt = Ed;
                    break;
                case "click":
                    if (tt.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    gt = Ad;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    gt = Cd;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    gt = Ud;
                    break;
                case Ze:
                case $e:
                case af:
                    gt = Gd;
                    break;
                case bf:
                    gt = Wd;
                    break;
                case "scroll":
                    gt = ud;
                    break;
                case "wheel":
                    gt = Yd;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    gt = Id;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    gt = Sd
                }
                var yt = ($ & 4) !== 0
                  , wt = !yt && et === "scroll"
                  , mt = yt ? ft !== null ? ft + "Capture" : null : ft;
                yt = [];
                for (var _t = ut, bt; _t !== null; ) {
                    bt = _t;
                    var Mt = bt.stateNode;
                    if (bt.tag === 5 && Mt !== null && (bt = Mt,
                    mt !== null && (Mt = Jb(_t, mt),
                    Mt != null && yt.push(sf(_t, Mt, bt)))),
                    wt)
                        break;
                    _t = _t.return
                }
                0 < yt.length && (ft = new gt(ft,vt,null,tt,ct),
                ht.push({
                    event: ft,
                    listeners: yt
                }))
            }
        }
        if (($ & 7) === 0) {
            e: {
                if (ft = et === "mouseover" || et === "pointerover",
                gt = et === "mouseout" || et === "pointerout",
                ft && tt !== vb && (vt = tt.relatedTarget || tt.fromElement) && (Vc(vt) || vt[tf]))
                    break e;
                if ((gt || ft) && (ft = ct.window === ct ? ct : (ft = ct.ownerDocument) ? ft.defaultView || ft.parentWindow : window,
                gt ? (vt = tt.relatedTarget || tt.toElement,
                gt = ut,
                vt = vt ? Vc(vt) : null,
                vt !== null && (wt = Ub(vt),
                vt !== wt || vt.tag !== 5 && vt.tag !== 6) && (vt = null)) : (gt = null,
                vt = ut),
                gt !== vt)) {
                    if (yt = Ad,
                    Mt = "onMouseLeave",
                    mt = "onMouseEnter",
                    _t = "mouse",
                    (et === "pointerout" || et === "pointerover") && (yt = Sd,
                    Mt = "onPointerLeave",
                    mt = "onPointerEnter",
                    _t = "pointer"),
                    wt = gt == null ? ft : te(gt),
                    bt = vt == null ? ft : te(vt),
                    ft = new yt(Mt,_t + "leave",gt,tt,ct),
                    ft.target = wt,
                    ft.relatedTarget = bt,
                    Mt = null,
                    Vc(ct) === ut && (yt = new yt(mt,_t + "enter",vt,tt,ct),
                    yt.target = bt,
                    yt.relatedTarget = wt,
                    Mt = yt),
                    wt = Mt,
                    gt && vt)
                        t: {
                            for (yt = gt,
                            mt = vt,
                            _t = 0,
                            bt = yt; bt; bt = uf(bt))
                                _t++;
                            for (bt = 0,
                            Mt = mt; Mt; Mt = uf(Mt))
                                bt++;
                            for (; 0 < _t - bt; )
                                yt = uf(yt),
                                _t--;
                            for (; 0 < bt - _t; )
                                mt = uf(mt),
                                bt--;
                            for (; _t--; ) {
                                if (yt === mt || mt !== null && yt === mt.alternate)
                                    break t;
                                yt = uf(yt),
                                mt = uf(mt)
                            }
                            yt = null
                        }
                    else
                        yt = null;
                    gt !== null && vf(ht, ft, gt, yt, !1),
                    vt !== null && wt !== null && vf(ht, wt, vt, yt, !0)
                }
            }
            e: {
                if (ft = ut ? te(ut) : window,
                gt = ft.nodeName && ft.nodeName.toLowerCase(),
                gt === "select" || gt === "input" && ft.type === "file")
                    var St = ue;
                else if (le(ft))
                    if (ve)
                        St = Ee;
                    else {
                        St = Ce;
                        var At = Be
                    }
                else
                    (gt = ft.nodeName) && gt.toLowerCase() === "input" && (ft.type === "checkbox" || ft.type === "radio") && (St = De);
                if (St && (St = St(et, ut))) {
                    me(ht, St, tt, ct);
                    break e
                }
                At && At(et, ft, ut),
                et === "focusout" && (At = ft._wrapperState) && At.controlled && ft.type === "number" && bb(ft, "number", ft.value)
            }
            switch (At = ut ? te(ut) : window,
            et) {
            case "focusin":
                (le(At) || At.contentEditable === "true") && (Pe = At,
                Qe = ut,
                Re = null);
                break;
            case "focusout":
                Re = Qe = Pe = null;
                break;
            case "mousedown":
                Se = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Se = !1,
                Te(ht, tt, ct);
                break;
            case "selectionchange":
                if (Oe)
                    break;
            case "keydown":
            case "keyup":
                Te(ht, tt, ct)
            }
            var Pt;
            if ($d)
                e: {
                    switch (et) {
                    case "compositionstart":
                        var Ot = "onCompositionStart";
                        break e;
                    case "compositionend":
                        Ot = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        Ot = "onCompositionUpdate";
                        break e
                    }
                    Ot = void 0
                }
            else
                he ? fe(et, tt) && (Ot = "onCompositionEnd") : et === "keydown" && tt.keyCode === 229 && (Ot = "onCompositionStart");
            Ot && (ce && tt.locale !== "ko" && (he || Ot !== "onCompositionStart" ? Ot === "onCompositionEnd" && he && (Pt = md()) : (jd = ct,
            kd = "value"in jd ? jd.value : jd.textContent,
            he = !0)),
            At = ne(ut, Ot),
            0 < At.length && (Ot = new Kd(Ot,et,null,tt,ct),
            ht.push({
                event: Ot,
                listeners: At
            }),
            Pt ? Ot.data = Pt : (Pt = ge(tt),
            Pt !== null && (Ot.data = Pt)))),
            (Pt = be ? ie(et, tt) : je(et, tt)) && (ut = ne(ut, "onBeforeInput"),
            0 < ut.length && (ct = new Kd("onBeforeInput","beforeinput",null,tt,ct),
            ht.push({
                event: ct,
                listeners: ut
            }),
            ct.data = Pt))
        }
        re(ht, $)
    })
}
function sf(et, $, tt) {
    return {
        instance: et,
        listener: $,
        currentTarget: tt
    }
}
function ne(et, $) {
    for (var tt = $ + "Capture", nt = []; et !== null; ) {
        var rt = et
          , it = rt.stateNode;
        rt.tag === 5 && it !== null && (rt = it,
        it = Jb(et, tt),
        it != null && nt.unshift(sf(et, it, rt)),
        it = Jb(et, $),
        it != null && nt.push(sf(et, it, rt))),
        et = et.return
    }
    return nt
}
function uf(et) {
    if (et === null)
        return null;
    do
        et = et.return;
    while (et && et.tag !== 5);
    return et || null
}
function vf(et, $, tt, nt, rt) {
    for (var it = $._reactName, ot = []; tt !== null && tt !== nt; ) {
        var st = tt
          , lt = st.alternate
          , ut = st.stateNode;
        if (lt !== null && lt === nt)
            break;
        st.tag === 5 && ut !== null && (st = ut,
        rt ? (lt = Jb(tt, it),
        lt != null && ot.unshift(sf(tt, lt, st))) : rt || (lt = Jb(tt, it),
        lt != null && ot.push(sf(tt, lt, st)))),
        tt = tt.return
    }
    ot.length !== 0 && et.push({
        event: $,
        listeners: ot
    })
}
var wf = /\r\n?/g
  , xf = /\u0000|\uFFFD/g;
function yf(et) {
    return (typeof et == "string" ? et : "" + et).replace(wf, `
`).replace(xf, "")
}
function zf(et, $, tt) {
    if ($ = yf($),
    yf(et) !== $ && tt)
        throw Error(p$5(425))
}
function Af() {}
var Bf = null
  , Cf = null;
function Df(et, $) {
    return et === "textarea" || et === "noscript" || typeof $.children == "string" || typeof $.children == "number" || typeof $.dangerouslySetInnerHTML == "object" && $.dangerouslySetInnerHTML !== null && $.dangerouslySetInnerHTML.__html != null
}
var Ef = typeof setTimeout == "function" ? setTimeout : void 0
  , Ff = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Gf = typeof Promise == "function" ? Promise : void 0
  , If = typeof queueMicrotask == "function" ? queueMicrotask : typeof Gf != "undefined" ? function(et) {
    return Gf.resolve(null).then(et).catch(Hf)
}
: Ef;
function Hf(et) {
    setTimeout(function() {
        throw et
    })
}
function Jf(et, $) {
    var tt = $
      , nt = 0;
    do {
        var rt = tt.nextSibling;
        if (et.removeChild(tt),
        rt && rt.nodeType === 8)
            if (tt = rt.data,
            tt === "/$") {
                if (nt === 0) {
                    et.removeChild(rt),
                    ad($);
                    return
                }
                nt--
            } else
                tt !== "$" && tt !== "$?" && tt !== "$!" || nt++;
        tt = rt
    } while (tt);
    ad($)
}
function Kf(et) {
    for (; et != null; et = et.nextSibling) {
        var $ = et.nodeType;
        if ($ === 1 || $ === 3)
            break;
        if ($ === 8) {
            if ($ = et.data,
            $ === "$" || $ === "$!" || $ === "$?")
                break;
            if ($ === "/$")
                return null
        }
    }
    return et
}
function Lf(et) {
    et = et.previousSibling;
    for (var $ = 0; et; ) {
        if (et.nodeType === 8) {
            var tt = et.data;
            if (tt === "$" || tt === "$!" || tt === "$?") {
                if ($ === 0)
                    return et;
                $--
            } else
                tt === "/$" && $++
        }
        et = et.previousSibling
    }
    return null
}
var Mf = Math.random().toString(36).slice(2)
  , Nf = "__reactFiber$" + Mf
  , Of = "__reactProps$" + Mf
  , tf = "__reactContainer$" + Mf
  , nf = "__reactEvents$" + Mf
  , Pf = "__reactListeners$" + Mf
  , Qf = "__reactHandles$" + Mf;
function Vc(et) {
    var $ = et[Nf];
    if ($)
        return $;
    for (var tt = et.parentNode; tt; ) {
        if ($ = tt[tf] || tt[Nf]) {
            if (tt = $.alternate,
            $.child !== null || tt !== null && tt.child !== null)
                for (et = Lf(et); et !== null; ) {
                    if (tt = et[Nf])
                        return tt;
                    et = Lf(et)
                }
            return $
        }
        et = tt,
        tt = et.parentNode
    }
    return null
}
function Bb(et) {
    return et = et[Nf] || et[tf],
    !et || et.tag !== 5 && et.tag !== 6 && et.tag !== 13 && et.tag !== 3 ? null : et
}
function te(et) {
    if (et.tag === 5 || et.tag === 6)
        return et.stateNode;
    throw Error(p$5(33))
}
function Cb(et) {
    return et[Of] || null
}
var Rf = []
  , Sf = -1;
function Tf(et) {
    return {
        current: et
    }
}
function E$1(et) {
    0 > Sf || (et.current = Rf[Sf],
    Rf[Sf] = null,
    Sf--)
}
function G$1(et, $) {
    Sf++,
    Rf[Sf] = et.current,
    et.current = $
}
var Uf = {}
  , H$1 = Tf(Uf)
  , Vf = Tf(!1)
  , Wf = Uf;
function Xf(et, $) {
    var tt = et.type.contextTypes;
    if (!tt)
        return Uf;
    var nt = et.stateNode;
    if (nt && nt.__reactInternalMemoizedUnmaskedChildContext === $)
        return nt.__reactInternalMemoizedMaskedChildContext;
    var rt = {}, it;
    for (it in tt)
        rt[it] = $[it];
    return nt && (et = et.stateNode,
    et.__reactInternalMemoizedUnmaskedChildContext = $,
    et.__reactInternalMemoizedMaskedChildContext = rt),
    rt
}
function Yf(et) {
    return et = et.childContextTypes,
    et != null
}
function Zf() {
    E$1(Vf),
    E$1(H$1)
}
function $f(et, $, tt) {
    if (H$1.current !== Uf)
        throw Error(p$5(168));
    G$1(H$1, $),
    G$1(Vf, tt)
}
function ag(et, $, tt) {
    var nt = et.stateNode;
    if ($ = $.childContextTypes,
    typeof nt.getChildContext != "function")
        return tt;
    nt = nt.getChildContext();
    for (var rt in nt)
        if (!(rt in $))
            throw Error(p$5(108, Qa(et) || "Unknown", rt));
    return A$1({}, tt, nt)
}
function bg(et) {
    return et = (et = et.stateNode) && et.__reactInternalMemoizedMergedChildContext || Uf,
    Wf = H$1.current,
    G$1(H$1, et),
    G$1(Vf, Vf.current),
    !0
}
function cg(et, $, tt) {
    var nt = et.stateNode;
    if (!nt)
        throw Error(p$5(169));
    tt ? (et = ag(et, $, Wf),
    nt.__reactInternalMemoizedMergedChildContext = et,
    E$1(Vf),
    E$1(H$1),
    G$1(H$1, et)) : E$1(Vf),
    G$1(Vf, tt)
}
var dg = null
  , eg = !1
  , fg = !1;
function gg(et) {
    dg === null ? dg = [et] : dg.push(et)
}
function hg(et) {
    eg = !0,
    gg(et)
}
function ig() {
    if (!fg && dg !== null) {
        fg = !0;
        var et = 0
          , $ = C;
        try {
            var tt = dg;
            for (C = 1; et < tt.length; et++) {
                var nt = tt[et];
                do
                    nt = nt(!0);
                while (nt !== null)
            }
            dg = null,
            eg = !1
        } catch (rt) {
            throw dg !== null && (dg = dg.slice(et + 1)),
            $b(ec, ig),
            rt
        } finally {
            C = $,
            fg = !1
        }
    }
    return null
}
var jg = ta.ReactCurrentBatchConfig;
function kg(et, $) {
    if (et && et.defaultProps) {
        $ = A$1({}, $),
        et = et.defaultProps;
        for (var tt in et)
            $[tt] === void 0 && ($[tt] = et[tt]);
        return $
    }
    return $
}
var lg = Tf(null)
  , mg = null
  , ng = null
  , og = null;
function pg() {
    og = ng = mg = null
}
function qg(et) {
    var $ = lg.current;
    E$1(lg),
    et._currentValue = $
}
function rg(et, $, tt) {
    for (; et !== null; ) {
        var nt = et.alternate;
        if ((et.childLanes & $) !== $ ? (et.childLanes |= $,
        nt !== null && (nt.childLanes |= $)) : nt !== null && (nt.childLanes & $) !== $ && (nt.childLanes |= $),
        et === tt)
            break;
        et = et.return
    }
}
function sg(et, $) {
    mg = et,
    og = ng = null,
    et = et.dependencies,
    et !== null && et.firstContext !== null && ((et.lanes & $) !== 0 && (tg = !0),
    et.firstContext = null)
}
function ug(et) {
    var $ = et._currentValue;
    if (og !== et)
        if (et = {
            context: et,
            memoizedValue: $,
            next: null
        },
        ng === null) {
            if (mg === null)
                throw Error(p$5(308));
            ng = et,
            mg.dependencies = {
                lanes: 0,
                firstContext: et
            }
        } else
            ng = ng.next = et;
    return $
}
var vg = null
  , wg = !1;
function xg(et) {
    et.updateQueue = {
        baseState: et.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function yg(et, $) {
    et = et.updateQueue,
    $.updateQueue === et && ($.updateQueue = {
        baseState: et.baseState,
        firstBaseUpdate: et.firstBaseUpdate,
        lastBaseUpdate: et.lastBaseUpdate,
        shared: et.shared,
        effects: et.effects
    })
}
function zg(et, $) {
    return {
        eventTime: et,
        lane: $,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function Ag(et, $) {
    var tt = et.updateQueue;
    tt !== null && (tt = tt.shared,
    Bg(et) ? (et = tt.interleaved,
    et === null ? ($.next = $,
    vg === null ? vg = [tt] : vg.push(tt)) : ($.next = et.next,
    et.next = $),
    tt.interleaved = $) : (et = tt.pending,
    et === null ? $.next = $ : ($.next = et.next,
    et.next = $),
    tt.pending = $))
}
function Cg(et, $, tt) {
    if ($ = $.updateQueue,
    $ !== null && ($ = $.shared,
    (tt & 4194240) !== 0)) {
        var nt = $.lanes;
        nt &= et.pendingLanes,
        tt |= nt,
        $.lanes = tt,
        Bc(et, tt)
    }
}
function Dg(et, $) {
    var tt = et.updateQueue
      , nt = et.alternate;
    if (nt !== null && (nt = nt.updateQueue,
    tt === nt)) {
        var rt = null
          , it = null;
        if (tt = tt.firstBaseUpdate,
        tt !== null) {
            do {
                var ot = {
                    eventTime: tt.eventTime,
                    lane: tt.lane,
                    tag: tt.tag,
                    payload: tt.payload,
                    callback: tt.callback,
                    next: null
                };
                it === null ? rt = it = ot : it = it.next = ot,
                tt = tt.next
            } while (tt !== null);
            it === null ? rt = it = $ : it = it.next = $
        } else
            rt = it = $;
        tt = {
            baseState: nt.baseState,
            firstBaseUpdate: rt,
            lastBaseUpdate: it,
            shared: nt.shared,
            effects: nt.effects
        },
        et.updateQueue = tt;
        return
    }
    et = tt.lastBaseUpdate,
    et === null ? tt.firstBaseUpdate = $ : et.next = $,
    tt.lastBaseUpdate = $
}
function Eg(et, $, tt, nt) {
    var rt = et.updateQueue;
    wg = !1;
    var it = rt.firstBaseUpdate
      , ot = rt.lastBaseUpdate
      , st = rt.shared.pending;
    if (st !== null) {
        rt.shared.pending = null;
        var lt = st
          , ut = lt.next;
        lt.next = null,
        ot === null ? it = ut : ot.next = ut,
        ot = lt;
        var ct = et.alternate;
        ct !== null && (ct = ct.updateQueue,
        st = ct.lastBaseUpdate,
        st !== ot && (st === null ? ct.firstBaseUpdate = ut : st.next = ut,
        ct.lastBaseUpdate = lt))
    }
    if (it !== null) {
        var ht = rt.baseState;
        ot = 0,
        ct = ut = lt = null,
        st = it;
        do {
            var ft = st.lane
              , gt = st.eventTime;
            if ((nt & ft) === ft) {
                ct !== null && (ct = ct.next = {
                    eventTime: gt,
                    lane: 0,
                    tag: st.tag,
                    payload: st.payload,
                    callback: st.callback,
                    next: null
                });
                e: {
                    var vt = et
                      , yt = st;
                    switch (ft = $,
                    gt = tt,
                    yt.tag) {
                    case 1:
                        if (vt = yt.payload,
                        typeof vt == "function") {
                            ht = vt.call(gt, ht, ft);
                            break e
                        }
                        ht = vt;
                        break e;
                    case 3:
                        vt.flags = vt.flags & -65537 | 128;
                    case 0:
                        if (vt = yt.payload,
                        ft = typeof vt == "function" ? vt.call(gt, ht, ft) : vt,
                        ft == null)
                            break e;
                        ht = A$1({}, ht, ft);
                        break e;
                    case 2:
                        wg = !0
                    }
                }
                st.callback !== null && st.lane !== 0 && (et.flags |= 64,
                ft = rt.effects,
                ft === null ? rt.effects = [st] : ft.push(st))
            } else
                gt = {
                    eventTime: gt,
                    lane: ft,
                    tag: st.tag,
                    payload: st.payload,
                    callback: st.callback,
                    next: null
                },
                ct === null ? (ut = ct = gt,
                lt = ht) : ct = ct.next = gt,
                ot |= ft;
            if (st = st.next,
            st === null) {
                if (st = rt.shared.pending,
                st === null)
                    break;
                ft = st,
                st = ft.next,
                ft.next = null,
                rt.lastBaseUpdate = ft,
                rt.shared.pending = null
            }
        } while (1);
        if (ct === null && (lt = ht),
        rt.baseState = lt,
        rt.firstBaseUpdate = ut,
        rt.lastBaseUpdate = ct,
        $ = rt.shared.interleaved,
        $ !== null) {
            rt = $;
            do
                ot |= rt.lane,
                rt = rt.next;
            while (rt !== $)
        } else
            it === null && (rt.shared.lanes = 0);
        Fg |= ot,
        et.lanes = ot,
        et.memoizedState = ht
    }
}
function Gg(et, $, tt) {
    if (et = $.effects,
    $.effects = null,
    et !== null)
        for ($ = 0; $ < et.length; $++) {
            var nt = et[$]
              , rt = nt.callback;
            if (rt !== null) {
                if (nt.callback = null,
                nt = tt,
                typeof rt != "function")
                    throw Error(p$5(191, rt));
                rt.call(nt)
            }
        }
}
var Hg = new aa.Component().refs;
function Ig(et, $, tt, nt) {
    $ = et.memoizedState,
    tt = tt(nt, $),
    tt = tt == null ? $ : A$1({}, $, tt),
    et.memoizedState = tt,
    et.lanes === 0 && (et.updateQueue.baseState = tt)
}
var Mg = {
    isMounted: function(et) {
        return (et = et._reactInternals) ? Ub(et) === et : !1
    },
    enqueueSetState: function(et, $, tt) {
        et = et._reactInternals;
        var nt = Jg()
          , rt = Kg(et)
          , it = zg(nt, rt);
        it.payload = $,
        tt != null && (it.callback = tt),
        Ag(et, it),
        $ = Lg(et, rt, nt),
        $ !== null && Cg($, et, rt)
    },
    enqueueReplaceState: function(et, $, tt) {
        et = et._reactInternals;
        var nt = Jg()
          , rt = Kg(et)
          , it = zg(nt, rt);
        it.tag = 1,
        it.payload = $,
        tt != null && (it.callback = tt),
        Ag(et, it),
        $ = Lg(et, rt, nt),
        $ !== null && Cg($, et, rt)
    },
    enqueueForceUpdate: function(et, $) {
        et = et._reactInternals;
        var tt = Jg()
          , nt = Kg(et)
          , rt = zg(tt, nt);
        rt.tag = 2,
        $ != null && (rt.callback = $),
        Ag(et, rt),
        $ = Lg(et, nt, tt),
        $ !== null && Cg($, et, nt)
    }
};
function Ng(et, $, tt, nt, rt, it, ot) {
    return et = et.stateNode,
    typeof et.shouldComponentUpdate == "function" ? et.shouldComponentUpdate(nt, it, ot) : $.prototype && $.prototype.isPureReactComponent ? !He(tt, nt) || !He(rt, it) : !0
}
function Og(et, $, tt) {
    var nt = !1
      , rt = Uf
      , it = $.contextType;
    return typeof it == "object" && it !== null ? it = ug(it) : (rt = Yf($) ? Wf : H$1.current,
    nt = $.contextTypes,
    it = (nt = nt != null) ? Xf(et, rt) : Uf),
    $ = new $(tt,it),
    et.memoizedState = $.state !== null && $.state !== void 0 ? $.state : null,
    $.updater = Mg,
    et.stateNode = $,
    $._reactInternals = et,
    nt && (et = et.stateNode,
    et.__reactInternalMemoizedUnmaskedChildContext = rt,
    et.__reactInternalMemoizedMaskedChildContext = it),
    $
}
function Pg(et, $, tt, nt) {
    et = $.state,
    typeof $.componentWillReceiveProps == "function" && $.componentWillReceiveProps(tt, nt),
    typeof $.UNSAFE_componentWillReceiveProps == "function" && $.UNSAFE_componentWillReceiveProps(tt, nt),
    $.state !== et && Mg.enqueueReplaceState($, $.state, null)
}
function Qg(et, $, tt, nt) {
    var rt = et.stateNode;
    rt.props = tt,
    rt.state = et.memoizedState,
    rt.refs = Hg,
    xg(et);
    var it = $.contextType;
    typeof it == "object" && it !== null ? rt.context = ug(it) : (it = Yf($) ? Wf : H$1.current,
    rt.context = Xf(et, it)),
    rt.state = et.memoizedState,
    it = $.getDerivedStateFromProps,
    typeof it == "function" && (Ig(et, $, it, tt),
    rt.state = et.memoizedState),
    typeof $.getDerivedStateFromProps == "function" || typeof rt.getSnapshotBeforeUpdate == "function" || typeof rt.UNSAFE_componentWillMount != "function" && typeof rt.componentWillMount != "function" || ($ = rt.state,
    typeof rt.componentWillMount == "function" && rt.componentWillMount(),
    typeof rt.UNSAFE_componentWillMount == "function" && rt.UNSAFE_componentWillMount(),
    $ !== rt.state && Mg.enqueueReplaceState(rt, rt.state, null),
    Eg(et, tt, rt, nt),
    rt.state = et.memoizedState),
    typeof rt.componentDidMount == "function" && (et.flags |= 4194308)
}
var Rg = []
  , Sg = 0
  , Tg = null
  , Ug = 0
  , Vg = []
  , Wg = 0
  , Xg = null
  , Yg = 1
  , Zg = "";
function $g(et, $) {
    Rg[Sg++] = Ug,
    Rg[Sg++] = Tg,
    Tg = et,
    Ug = $
}
function ah(et, $, tt) {
    Vg[Wg++] = Yg,
    Vg[Wg++] = Zg,
    Vg[Wg++] = Xg,
    Xg = et;
    var nt = Yg;
    et = Zg;
    var rt = 32 - nc(nt) - 1;
    nt &= ~(1 << rt),
    tt += 1;
    var it = 32 - nc($) + rt;
    if (30 < it) {
        var ot = rt - rt % 5;
        it = (nt & (1 << ot) - 1).toString(32),
        nt >>= ot,
        rt -= ot,
        Yg = 1 << 32 - nc($) + rt | tt << rt | nt,
        Zg = it + et
    } else
        Yg = 1 << it | tt << rt | nt,
        Zg = et
}
function bh(et) {
    et.return !== null && ($g(et, 1),
    ah(et, 1, 0))
}
function ch(et) {
    for (; et === Tg; )
        Tg = Rg[--Sg],
        Rg[Sg] = null,
        Ug = Rg[--Sg],
        Rg[Sg] = null;
    for (; et === Xg; )
        Xg = Vg[--Wg],
        Vg[Wg] = null,
        Zg = Vg[--Wg],
        Vg[Wg] = null,
        Yg = Vg[--Wg],
        Vg[Wg] = null
}
var dh = null
  , eh = null
  , I$1 = !1
  , fh = null;
function gh(et, $) {
    var tt = hh(5, null, null, 0);
    tt.elementType = "DELETED",
    tt.stateNode = $,
    tt.return = et,
    $ = et.deletions,
    $ === null ? (et.deletions = [tt],
    et.flags |= 16) : $.push(tt)
}
function ih(et, $) {
    switch (et.tag) {
    case 5:
        var tt = et.type;
        return $ = $.nodeType !== 1 || tt.toLowerCase() !== $.nodeName.toLowerCase() ? null : $,
        $ !== null ? (et.stateNode = $,
        dh = et,
        eh = Kf($.firstChild),
        !0) : !1;
    case 6:
        return $ = et.pendingProps === "" || $.nodeType !== 3 ? null : $,
        $ !== null ? (et.stateNode = $,
        dh = et,
        eh = null,
        !0) : !1;
    case 13:
        return $ = $.nodeType !== 8 ? null : $,
        $ !== null ? (tt = Xg !== null ? {
            id: Yg,
            overflow: Zg
        } : null,
        et.memoizedState = {
            dehydrated: $,
            treeContext: tt,
            retryLane: 1073741824
        },
        tt = hh(18, null, null, 0),
        tt.stateNode = $,
        tt.return = et,
        et.child = tt,
        dh = et,
        eh = null,
        !0) : !1;
    default:
        return !1
    }
}
function jh(et) {
    return (et.mode & 1) !== 0 && (et.flags & 128) === 0
}
function kh(et) {
    if (I$1) {
        var $ = eh;
        if ($) {
            var tt = $;
            if (!ih(et, $)) {
                if (jh(et))
                    throw Error(p$5(418));
                $ = Kf(tt.nextSibling);
                var nt = dh;
                $ && ih(et, $) ? gh(nt, tt) : (et.flags = et.flags & -4097 | 2,
                I$1 = !1,
                dh = et)
            }
        } else {
            if (jh(et))
                throw Error(p$5(418));
            et.flags = et.flags & -4097 | 2,
            I$1 = !1,
            dh = et
        }
    }
}
function lh(et) {
    for (et = et.return; et !== null && et.tag !== 5 && et.tag !== 3 && et.tag !== 13; )
        et = et.return;
    dh = et
}
function mh(et) {
    if (et !== dh)
        return !1;
    if (!I$1)
        return lh(et),
        I$1 = !0,
        !1;
    var $;
    if (($ = et.tag !== 3) && !($ = et.tag !== 5) && ($ = et.type,
    $ = $ !== "head" && $ !== "body" && !Df(et.type, et.memoizedProps)),
    $ && ($ = eh)) {
        if (jh(et)) {
            for (et = eh; et; )
                et = Kf(et.nextSibling);
            throw Error(p$5(418))
        }
        for (; $; )
            gh(et, $),
            $ = Kf($.nextSibling)
    }
    if (lh(et),
    et.tag === 13) {
        if (et = et.memoizedState,
        et = et !== null ? et.dehydrated : null,
        !et)
            throw Error(p$5(317));
        e: {
            for (et = et.nextSibling,
            $ = 0; et; ) {
                if (et.nodeType === 8) {
                    var tt = et.data;
                    if (tt === "/$") {
                        if ($ === 0) {
                            eh = Kf(et.nextSibling);
                            break e
                        }
                        $--
                    } else
                        tt !== "$" && tt !== "$!" && tt !== "$?" || $++
                }
                et = et.nextSibling
            }
            eh = null
        }
    } else
        eh = dh ? Kf(et.stateNode.nextSibling) : null;
    return !0
}
function nh() {
    eh = dh = null,
    I$1 = !1
}
function oh(et) {
    fh === null ? fh = [et] : fh.push(et)
}
function ph(et, $, tt) {
    if (et = tt.ref,
    et !== null && typeof et != "function" && typeof et != "object") {
        if (tt._owner) {
            if (tt = tt._owner,
            tt) {
                if (tt.tag !== 1)
                    throw Error(p$5(309));
                var nt = tt.stateNode
            }
            if (!nt)
                throw Error(p$5(147, et));
            var rt = nt
              , it = "" + et;
            return $ !== null && $.ref !== null && typeof $.ref == "function" && $.ref._stringRef === it ? $.ref : ($ = function(ot) {
                var st = rt.refs;
                st === Hg && (st = rt.refs = {}),
                ot === null ? delete st[it] : st[it] = ot
            }
            ,
            $._stringRef = it,
            $)
        }
        if (typeof et != "string")
            throw Error(p$5(284));
        if (!tt._owner)
            throw Error(p$5(290, et))
    }
    return et
}
function qh(et, $) {
    throw et = Object.prototype.toString.call($),
    Error(p$5(31, et === "[object Object]" ? "object with keys {" + Object.keys($).join(", ") + "}" : et))
}
function rh(et) {
    var $ = et._init;
    return $(et._payload)
}
function sh(et) {
    function $(mt, _t) {
        if (et) {
            var bt = mt.deletions;
            bt === null ? (mt.deletions = [_t],
            mt.flags |= 16) : bt.push(_t)
        }
    }
    function tt(mt, _t) {
        if (!et)
            return null;
        for (; _t !== null; )
            $(mt, _t),
            _t = _t.sibling;
        return null
    }
    function nt(mt, _t) {
        for (mt = new Map; _t !== null; )
            _t.key !== null ? mt.set(_t.key, _t) : mt.set(_t.index, _t),
            _t = _t.sibling;
        return mt
    }
    function rt(mt, _t) {
        return mt = th(mt, _t),
        mt.index = 0,
        mt.sibling = null,
        mt
    }
    function it(mt, _t, bt) {
        return mt.index = bt,
        et ? (bt = mt.alternate,
        bt !== null ? (bt = bt.index,
        bt < _t ? (mt.flags |= 2,
        _t) : bt) : (mt.flags |= 2,
        _t)) : (mt.flags |= 1048576,
        _t)
    }
    function ot(mt) {
        return et && mt.alternate === null && (mt.flags |= 2),
        mt
    }
    function st(mt, _t, bt, Mt) {
        return _t === null || _t.tag !== 6 ? (_t = uh(bt, mt.mode, Mt),
        _t.return = mt,
        _t) : (_t = rt(_t, bt),
        _t.return = mt,
        _t)
    }
    function lt(mt, _t, bt, Mt) {
        var St = bt.type;
        return St === wa ? ct(mt, _t, bt.props.children, Mt, bt.key) : _t !== null && (_t.elementType === St || typeof St == "object" && St !== null && St.$$typeof === Ga && rh(St) === _t.type) ? (Mt = rt(_t, bt.props),
        Mt.ref = ph(mt, _t, bt),
        Mt.return = mt,
        Mt) : (Mt = vh(bt.type, bt.key, bt.props, null, mt.mode, Mt),
        Mt.ref = ph(mt, _t, bt),
        Mt.return = mt,
        Mt)
    }
    function ut(mt, _t, bt, Mt) {
        return _t === null || _t.tag !== 4 || _t.stateNode.containerInfo !== bt.containerInfo || _t.stateNode.implementation !== bt.implementation ? (_t = wh(bt, mt.mode, Mt),
        _t.return = mt,
        _t) : (_t = rt(_t, bt.children || []),
        _t.return = mt,
        _t)
    }
    function ct(mt, _t, bt, Mt, St) {
        return _t === null || _t.tag !== 7 ? (_t = xh(bt, mt.mode, Mt, St),
        _t.return = mt,
        _t) : (_t = rt(_t, bt),
        _t.return = mt,
        _t)
    }
    function ht(mt, _t, bt) {
        if (typeof _t == "string" && _t !== "" || typeof _t == "number")
            return _t = uh("" + _t, mt.mode, bt),
            _t.return = mt,
            _t;
        if (typeof _t == "object" && _t !== null) {
            switch (_t.$$typeof) {
            case ua:
                return bt = vh(_t.type, _t.key, _t.props, null, mt.mode, bt),
                bt.ref = ph(mt, null, _t),
                bt.return = mt,
                bt;
            case va:
                return _t = wh(_t, mt.mode, bt),
                _t.return = mt,
                _t;
            case Ga:
                var Mt = _t._init;
                return ht(mt, Mt(_t._payload), bt)
            }
            if (db(_t) || Ja(_t))
                return _t = xh(_t, mt.mode, bt, null),
                _t.return = mt,
                _t;
            qh(mt, _t)
        }
        return null
    }
    function ft(mt, _t, bt, Mt) {
        var St = _t !== null ? _t.key : null;
        if (typeof bt == "string" && bt !== "" || typeof bt == "number")
            return St !== null ? null : st(mt, _t, "" + bt, Mt);
        if (typeof bt == "object" && bt !== null) {
            switch (bt.$$typeof) {
            case ua:
                return bt.key === St ? lt(mt, _t, bt, Mt) : null;
            case va:
                return bt.key === St ? ut(mt, _t, bt, Mt) : null;
            case Ga:
                return St = bt._init,
                ft(mt, _t, St(bt._payload), Mt)
            }
            if (db(bt) || Ja(bt))
                return St !== null ? null : ct(mt, _t, bt, Mt, null);
            qh(mt, bt)
        }
        return null
    }
    function gt(mt, _t, bt, Mt, St) {
        if (typeof Mt == "string" && Mt !== "" || typeof Mt == "number")
            return mt = mt.get(bt) || null,
            st(_t, mt, "" + Mt, St);
        if (typeof Mt == "object" && Mt !== null) {
            switch (Mt.$$typeof) {
            case ua:
                return mt = mt.get(Mt.key === null ? bt : Mt.key) || null,
                lt(_t, mt, Mt, St);
            case va:
                return mt = mt.get(Mt.key === null ? bt : Mt.key) || null,
                ut(_t, mt, Mt, St);
            case Ga:
                var At = Mt._init;
                return gt(mt, _t, bt, At(Mt._payload), St)
            }
            if (db(Mt) || Ja(Mt))
                return mt = mt.get(bt) || null,
                ct(_t, mt, Mt, St, null);
            qh(_t, Mt)
        }
        return null
    }
    function vt(mt, _t, bt, Mt) {
        for (var St = null, At = null, Pt = _t, Ot = _t = 0, Zt = null; Pt !== null && Ot < bt.length; Ot++) {
            Pt.index > Ot ? (Zt = Pt,
            Pt = null) : Zt = Pt.sibling;
            var Nt = ft(mt, Pt, bt[Ot], Mt);
            if (Nt === null) {
                Pt === null && (Pt = Zt);
                break
            }
            et && Pt && Nt.alternate === null && $(mt, Pt),
            _t = it(Nt, _t, Ot),
            At === null ? St = Nt : At.sibling = Nt,
            At = Nt,
            Pt = Zt
        }
        if (Ot === bt.length)
            return tt(mt, Pt),
            I$1 && $g(mt, Ot),
            St;
        if (Pt === null) {
            for (; Ot < bt.length; Ot++)
                Pt = ht(mt, bt[Ot], Mt),
                Pt !== null && (_t = it(Pt, _t, Ot),
                At === null ? St = Pt : At.sibling = Pt,
                At = Pt);
            return I$1 && $g(mt, Ot),
            St
        }
        for (Pt = nt(mt, Pt); Ot < bt.length; Ot++)
            Zt = gt(Pt, mt, Ot, bt[Ot], Mt),
            Zt !== null && (et && Zt.alternate !== null && Pt.delete(Zt.key === null ? Ot : Zt.key),
            _t = it(Zt, _t, Ot),
            At === null ? St = Zt : At.sibling = Zt,
            At = Zt);
        return et && Pt.forEach(function(Tt) {
            return $(mt, Tt)
        }),
        I$1 && $g(mt, Ot),
        St
    }
    function yt(mt, _t, bt, Mt) {
        var St = Ja(bt);
        if (typeof St != "function")
            throw Error(p$5(150));
        if (bt = St.call(bt),
        bt == null)
            throw Error(p$5(151));
        for (var At = St = null, Pt = _t, Ot = _t = 0, Zt = null, Nt = bt.next(); Pt !== null && !Nt.done; Ot++,
        Nt = bt.next()) {
            Pt.index > Ot ? (Zt = Pt,
            Pt = null) : Zt = Pt.sibling;
            var Tt = ft(mt, Pt, Nt.value, Mt);
            if (Tt === null) {
                Pt === null && (Pt = Zt);
                break
            }
            et && Pt && Tt.alternate === null && $(mt, Pt),
            _t = it(Tt, _t, Ot),
            At === null ? St = Tt : At.sibling = Tt,
            At = Tt,
            Pt = Zt
        }
        if (Nt.done)
            return tt(mt, Pt),
            I$1 && $g(mt, Ot),
            St;
        if (Pt === null) {
            for (; !Nt.done; Ot++,
            Nt = bt.next())
                Nt = ht(mt, Nt.value, Mt),
                Nt !== null && (_t = it(Nt, _t, Ot),
                At === null ? St = Nt : At.sibling = Nt,
                At = Nt);
            return I$1 && $g(mt, Ot),
            St
        }
        for (Pt = nt(mt, Pt); !Nt.done; Ot++,
        Nt = bt.next())
            Nt = gt(Pt, mt, Ot, Nt.value, Mt),
            Nt !== null && (et && Nt.alternate !== null && Pt.delete(Nt.key === null ? Ot : Nt.key),
            _t = it(Nt, _t, Ot),
            At === null ? St = Nt : At.sibling = Nt,
            At = Nt);
        return et && Pt.forEach(function(Ft) {
            return $(mt, Ft)
        }),
        I$1 && $g(mt, Ot),
        St
    }
    function wt(mt, _t, bt, Mt) {
        if (typeof bt == "object" && bt !== null && bt.type === wa && bt.key === null && (bt = bt.props.children),
        typeof bt == "object" && bt !== null) {
            switch (bt.$$typeof) {
            case ua:
                e: {
                    for (var St = bt.key, At = _t; At !== null; ) {
                        if (At.key === St) {
                            if (St = bt.type,
                            St === wa) {
                                if (At.tag === 7) {
                                    tt(mt, At.sibling),
                                    _t = rt(At, bt.props.children),
                                    _t.return = mt,
                                    mt = _t;
                                    break e
                                }
                            } else if (At.elementType === St || typeof St == "object" && St !== null && St.$$typeof === Ga && rh(St) === At.type) {
                                tt(mt, At.sibling),
                                _t = rt(At, bt.props),
                                _t.ref = ph(mt, At, bt),
                                _t.return = mt,
                                mt = _t;
                                break e
                            }
                            tt(mt, At);
                            break
                        } else
                            $(mt, At);
                        At = At.sibling
                    }
                    bt.type === wa ? (_t = xh(bt.props.children, mt.mode, Mt, bt.key),
                    _t.return = mt,
                    mt = _t) : (Mt = vh(bt.type, bt.key, bt.props, null, mt.mode, Mt),
                    Mt.ref = ph(mt, _t, bt),
                    Mt.return = mt,
                    mt = Mt)
                }
                return ot(mt);
            case va:
                e: {
                    for (At = bt.key; _t !== null; ) {
                        if (_t.key === At)
                            if (_t.tag === 4 && _t.stateNode.containerInfo === bt.containerInfo && _t.stateNode.implementation === bt.implementation) {
                                tt(mt, _t.sibling),
                                _t = rt(_t, bt.children || []),
                                _t.return = mt,
                                mt = _t;
                                break e
                            } else {
                                tt(mt, _t);
                                break
                            }
                        else
                            $(mt, _t);
                        _t = _t.sibling
                    }
                    _t = wh(bt, mt.mode, Mt),
                    _t.return = mt,
                    mt = _t
                }
                return ot(mt);
            case Ga:
                return At = bt._init,
                wt(mt, _t, At(bt._payload), Mt)
            }
            if (db(bt))
                return vt(mt, _t, bt, Mt);
            if (Ja(bt))
                return yt(mt, _t, bt, Mt);
            qh(mt, bt)
        }
        return typeof bt == "string" && bt !== "" || typeof bt == "number" ? (bt = "" + bt,
        _t !== null && _t.tag === 6 ? (tt(mt, _t.sibling),
        _t = rt(_t, bt),
        _t.return = mt,
        mt = _t) : (tt(mt, _t),
        _t = uh(bt, mt.mode, Mt),
        _t.return = mt,
        mt = _t),
        ot(mt)) : tt(mt, _t)
    }
    return wt
}
var yh = sh(!0)
  , zh = sh(!1)
  , Ah = {}
  , Bh = Tf(Ah)
  , Ch = Tf(Ah)
  , Dh = Tf(Ah);
function Eh(et) {
    if (et === Ah)
        throw Error(p$5(174));
    return et
}
function Fh(et, $) {
    switch (G$1(Dh, $),
    G$1(Ch, et),
    G$1(Bh, Ah),
    et = $.nodeType,
    et) {
    case 9:
    case 11:
        $ = ($ = $.documentElement) ? $.namespaceURI : kb(null, "");
        break;
    default:
        et = et === 8 ? $.parentNode : $,
        $ = et.namespaceURI || null,
        et = et.tagName,
        $ = kb($, et)
    }
    E$1(Bh),
    G$1(Bh, $)
}
function Gh() {
    E$1(Bh),
    E$1(Ch),
    E$1(Dh)
}
function Hh(et) {
    Eh(Dh.current);
    var $ = Eh(Bh.current)
      , tt = kb($, et.type);
    $ !== tt && (G$1(Ch, et),
    G$1(Bh, tt))
}
function Ih(et) {
    Ch.current === et && (E$1(Bh),
    E$1(Ch))
}
var K = Tf(0);
function Jh(et) {
    for (var $ = et; $ !== null; ) {
        if ($.tag === 13) {
            var tt = $.memoizedState;
            if (tt !== null && (tt = tt.dehydrated,
            tt === null || tt.data === "$?" || tt.data === "$!"))
                return $
        } else if ($.tag === 19 && $.memoizedProps.revealOrder !== void 0) {
            if (($.flags & 128) !== 0)
                return $
        } else if ($.child !== null) {
            $.child.return = $,
            $ = $.child;
            continue
        }
        if ($ === et)
            break;
        for (; $.sibling === null; ) {
            if ($.return === null || $.return === et)
                return null;
            $ = $.return
        }
        $.sibling.return = $.return,
        $ = $.sibling
    }
    return null
}
var Kh = [];
function Lh() {
    for (var et = 0; et < Kh.length; et++)
        Kh[et]._workInProgressVersionPrimary = null;
    Kh.length = 0
}
var Mh = ta.ReactCurrentDispatcher
  , Nh = ta.ReactCurrentBatchConfig
  , Oh = 0
  , L$1 = null
  , M$1 = null
  , N = null
  , Ph = !1
  , Qh = !1
  , Rh = 0
  , Sh = 0;
function O$1() {
    throw Error(p$5(321))
}
function Th(et, $) {
    if ($ === null)
        return !1;
    for (var tt = 0; tt < $.length && tt < et.length; tt++)
        if (!Ge(et[tt], $[tt]))
            return !1;
    return !0
}
function Uh(et, $, tt, nt, rt, it) {
    if (Oh = it,
    L$1 = $,
    $.memoizedState = null,
    $.updateQueue = null,
    $.lanes = 0,
    Mh.current = et === null || et.memoizedState === null ? Vh : Wh,
    et = tt(nt, rt),
    Qh) {
        it = 0;
        do {
            if (Qh = !1,
            Rh = 0,
            25 <= it)
                throw Error(p$5(301));
            it += 1,
            N = M$1 = null,
            $.updateQueue = null,
            Mh.current = Xh,
            et = tt(nt, rt)
        } while (Qh)
    }
    if (Mh.current = Yh,
    $ = M$1 !== null && M$1.next !== null,
    Oh = 0,
    N = M$1 = L$1 = null,
    Ph = !1,
    $)
        throw Error(p$5(300));
    return et
}
function Zh() {
    var et = Rh !== 0;
    return Rh = 0,
    et
}
function $h() {
    var et = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return N === null ? L$1.memoizedState = N = et : N = N.next = et,
    N
}
function ai() {
    if (M$1 === null) {
        var et = L$1.alternate;
        et = et !== null ? et.memoizedState : null
    } else
        et = M$1.next;
    var $ = N === null ? L$1.memoizedState : N.next;
    if ($ !== null)
        N = $,
        M$1 = et;
    else {
        if (et === null)
            throw Error(p$5(310));
        M$1 = et,
        et = {
            memoizedState: M$1.memoizedState,
            baseState: M$1.baseState,
            baseQueue: M$1.baseQueue,
            queue: M$1.queue,
            next: null
        },
        N === null ? L$1.memoizedState = N = et : N = N.next = et
    }
    return N
}
function bi(et, $) {
    return typeof $ == "function" ? $(et) : $
}
function ci(et) {
    var $ = ai()
      , tt = $.queue;
    if (tt === null)
        throw Error(p$5(311));
    tt.lastRenderedReducer = et;
    var nt = M$1
      , rt = nt.baseQueue
      , it = tt.pending;
    if (it !== null) {
        if (rt !== null) {
            var ot = rt.next;
            rt.next = it.next,
            it.next = ot
        }
        nt.baseQueue = rt = it,
        tt.pending = null
    }
    if (rt !== null) {
        it = rt.next,
        nt = nt.baseState;
        var st = ot = null
          , lt = null
          , ut = it;
        do {
            var ct = ut.lane;
            if ((Oh & ct) === ct)
                lt !== null && (lt = lt.next = {
                    lane: 0,
                    action: ut.action,
                    hasEagerState: ut.hasEagerState,
                    eagerState: ut.eagerState,
                    next: null
                }),
                nt = ut.hasEagerState ? ut.eagerState : et(nt, ut.action);
            else {
                var ht = {
                    lane: ct,
                    action: ut.action,
                    hasEagerState: ut.hasEagerState,
                    eagerState: ut.eagerState,
                    next: null
                };
                lt === null ? (st = lt = ht,
                ot = nt) : lt = lt.next = ht,
                L$1.lanes |= ct,
                Fg |= ct
            }
            ut = ut.next
        } while (ut !== null && ut !== it);
        lt === null ? ot = nt : lt.next = st,
        Ge(nt, $.memoizedState) || (tg = !0),
        $.memoizedState = nt,
        $.baseState = ot,
        $.baseQueue = lt,
        tt.lastRenderedState = nt
    }
    if (et = tt.interleaved,
    et !== null) {
        rt = et;
        do
            it = rt.lane,
            L$1.lanes |= it,
            Fg |= it,
            rt = rt.next;
        while (rt !== et)
    } else
        rt === null && (tt.lanes = 0);
    return [$.memoizedState, tt.dispatch]
}
function di(et) {
    var $ = ai()
      , tt = $.queue;
    if (tt === null)
        throw Error(p$5(311));
    tt.lastRenderedReducer = et;
    var nt = tt.dispatch
      , rt = tt.pending
      , it = $.memoizedState;
    if (rt !== null) {
        tt.pending = null;
        var ot = rt = rt.next;
        do
            it = et(it, ot.action),
            ot = ot.next;
        while (ot !== rt);
        Ge(it, $.memoizedState) || (tg = !0),
        $.memoizedState = it,
        $.baseQueue === null && ($.baseState = it),
        tt.lastRenderedState = it
    }
    return [it, nt]
}
function ei() {}
function fi(et, $) {
    var tt = L$1
      , nt = ai()
      , rt = $()
      , it = !Ge(nt.memoizedState, rt);
    if (it && (nt.memoizedState = rt,
    tg = !0),
    nt = nt.queue,
    gi(hi.bind(null, tt, nt, et), [et]),
    nt.getSnapshot !== $ || it || N !== null && N.memoizedState.tag & 1) {
        if (tt.flags |= 2048,
        ii(9, ji.bind(null, tt, nt, rt, $), void 0, null),
        P$1 === null)
            throw Error(p$5(349));
        (Oh & 30) !== 0 || ki(tt, $, rt)
    }
    return rt
}
function ki(et, $, tt) {
    et.flags |= 16384,
    et = {
        getSnapshot: $,
        value: tt
    },
    $ = L$1.updateQueue,
    $ === null ? ($ = {
        lastEffect: null,
        stores: null
    },
    L$1.updateQueue = $,
    $.stores = [et]) : (tt = $.stores,
    tt === null ? $.stores = [et] : tt.push(et))
}
function ji(et, $, tt, nt) {
    $.value = tt,
    $.getSnapshot = nt,
    li($) && Lg(et, 1, -1)
}
function hi(et, $, tt) {
    return tt(function() {
        li($) && Lg(et, 1, -1)
    })
}
function li(et) {
    var $ = et.getSnapshot;
    et = et.value;
    try {
        var tt = $();
        return !Ge(et, tt)
    } catch {
        return !0
    }
}
function mi(et) {
    var $ = $h();
    return typeof et == "function" && (et = et()),
    $.memoizedState = $.baseState = et,
    et = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: bi,
        lastRenderedState: et
    },
    $.queue = et,
    et = et.dispatch = ni.bind(null, L$1, et),
    [$.memoizedState, et]
}
function ii(et, $, tt, nt) {
    return et = {
        tag: et,
        create: $,
        destroy: tt,
        deps: nt,
        next: null
    },
    $ = L$1.updateQueue,
    $ === null ? ($ = {
        lastEffect: null,
        stores: null
    },
    L$1.updateQueue = $,
    $.lastEffect = et.next = et) : (tt = $.lastEffect,
    tt === null ? $.lastEffect = et.next = et : (nt = tt.next,
    tt.next = et,
    et.next = nt,
    $.lastEffect = et)),
    et
}
function oi() {
    return ai().memoizedState
}
function pi(et, $, tt, nt) {
    var rt = $h();
    L$1.flags |= et,
    rt.memoizedState = ii(1 | $, tt, void 0, nt === void 0 ? null : nt)
}
function qi(et, $, tt, nt) {
    var rt = ai();
    nt = nt === void 0 ? null : nt;
    var it = void 0;
    if (M$1 !== null) {
        var ot = M$1.memoizedState;
        if (it = ot.destroy,
        nt !== null && Th(nt, ot.deps)) {
            rt.memoizedState = ii($, tt, it, nt);
            return
        }
    }
    L$1.flags |= et,
    rt.memoizedState = ii(1 | $, tt, it, nt)
}
function ri(et, $) {
    return pi(8390656, 8, et, $)
}
function gi(et, $) {
    return qi(2048, 8, et, $)
}
function si(et, $) {
    return qi(4, 2, et, $)
}
function ti(et, $) {
    return qi(4, 4, et, $)
}
function ui(et, $) {
    if (typeof $ == "function")
        return et = et(),
        $(et),
        function() {
            $(null)
        }
        ;
    if ($ != null)
        return et = et(),
        $.current = et,
        function() {
            $.current = null
        }
}
function vi(et, $, tt) {
    return tt = tt != null ? tt.concat([et]) : null,
    qi(4, 4, ui.bind(null, $, et), tt)
}
function wi() {}
function xi(et, $) {
    var tt = ai();
    $ = $ === void 0 ? null : $;
    var nt = tt.memoizedState;
    return nt !== null && $ !== null && Th($, nt[1]) ? nt[0] : (tt.memoizedState = [et, $],
    et)
}
function yi(et, $) {
    var tt = ai();
    $ = $ === void 0 ? null : $;
    var nt = tt.memoizedState;
    return nt !== null && $ !== null && Th($, nt[1]) ? nt[0] : (et = et(),
    tt.memoizedState = [et, $],
    et)
}
function zi(et, $, tt) {
    return (Oh & 21) === 0 ? (et.baseState && (et.baseState = !1,
    tg = !0),
    et.memoizedState = tt) : (Ge(tt, $) || (tt = xc(),
    L$1.lanes |= tt,
    Fg |= tt,
    et.baseState = !0),
    $)
}
function Ai(et, $) {
    var tt = C;
    C = tt !== 0 && 4 > tt ? tt : 4,
    et(!0);
    var nt = Nh.transition;
    Nh.transition = {};
    try {
        et(!1),
        $()
    } finally {
        C = tt,
        Nh.transition = nt
    }
}
function Bi() {
    return ai().memoizedState
}
function Ci(et, $, tt) {
    var nt = Kg(et);
    tt = {
        lane: nt,
        action: tt,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    Di(et) ? Ei($, tt) : (Fi(et, $, tt),
    tt = Jg(),
    et = Lg(et, nt, tt),
    et !== null && Gi(et, $, nt))
}
function ni(et, $, tt) {
    var nt = Kg(et)
      , rt = {
        lane: nt,
        action: tt,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (Di(et))
        Ei($, rt);
    else {
        Fi(et, $, rt);
        var it = et.alternate;
        if (et.lanes === 0 && (it === null || it.lanes === 0) && (it = $.lastRenderedReducer,
        it !== null))
            try {
                var ot = $.lastRenderedState
                  , st = it(ot, tt);
                if (rt.hasEagerState = !0,
                rt.eagerState = st,
                Ge(st, ot))
                    return
            } catch {} finally {}
        tt = Jg(),
        et = Lg(et, nt, tt),
        et !== null && Gi(et, $, nt)
    }
}
function Di(et) {
    var $ = et.alternate;
    return et === L$1 || $ !== null && $ === L$1
}
function Ei(et, $) {
    Qh = Ph = !0;
    var tt = et.pending;
    tt === null ? $.next = $ : ($.next = tt.next,
    tt.next = $),
    et.pending = $
}
function Fi(et, $, tt) {
    Bg(et) ? (et = $.interleaved,
    et === null ? (tt.next = tt,
    vg === null ? vg = [$] : vg.push($)) : (tt.next = et.next,
    et.next = tt),
    $.interleaved = tt) : (et = $.pending,
    et === null ? tt.next = tt : (tt.next = et.next,
    et.next = tt),
    $.pending = tt)
}
function Gi(et, $, tt) {
    if ((tt & 4194240) !== 0) {
        var nt = $.lanes;
        nt &= et.pendingLanes,
        tt |= nt,
        $.lanes = tt,
        Bc(et, tt)
    }
}
var Yh = {
    readContext: ug,
    useCallback: O$1,
    useContext: O$1,
    useEffect: O$1,
    useImperativeHandle: O$1,
    useInsertionEffect: O$1,
    useLayoutEffect: O$1,
    useMemo: O$1,
    useReducer: O$1,
    useRef: O$1,
    useState: O$1,
    useDebugValue: O$1,
    useDeferredValue: O$1,
    useTransition: O$1,
    useMutableSource: O$1,
    useSyncExternalStore: O$1,
    useId: O$1,
    unstable_isNewReconciler: !1
}
  , Vh = {
    readContext: ug,
    useCallback: function(et, $) {
        return $h().memoizedState = [et, $ === void 0 ? null : $],
        et
    },
    useContext: ug,
    useEffect: ri,
    useImperativeHandle: function(et, $, tt) {
        return tt = tt != null ? tt.concat([et]) : null,
        pi(4194308, 4, ui.bind(null, $, et), tt)
    },
    useLayoutEffect: function(et, $) {
        return pi(4194308, 4, et, $)
    },
    useInsertionEffect: function(et, $) {
        return pi(4, 2, et, $)
    },
    useMemo: function(et, $) {
        var tt = $h();
        return $ = $ === void 0 ? null : $,
        et = et(),
        tt.memoizedState = [et, $],
        et
    },
    useReducer: function(et, $, tt) {
        var nt = $h();
        return $ = tt !== void 0 ? tt($) : $,
        nt.memoizedState = nt.baseState = $,
        et = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: et,
            lastRenderedState: $
        },
        nt.queue = et,
        et = et.dispatch = Ci.bind(null, L$1, et),
        [nt.memoizedState, et]
    },
    useRef: function(et) {
        var $ = $h();
        return et = {
            current: et
        },
        $.memoizedState = et
    },
    useState: mi,
    useDebugValue: wi,
    useDeferredValue: function(et) {
        return $h().memoizedState = et
    },
    useTransition: function() {
        var et = mi(!1)
          , $ = et[0];
        return et = Ai.bind(null, et[1]),
        $h().memoizedState = et,
        [$, et]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(et, $, tt) {
        var nt = L$1
          , rt = $h();
        if (I$1) {
            if (tt === void 0)
                throw Error(p$5(407));
            tt = tt()
        } else {
            if (tt = $(),
            P$1 === null)
                throw Error(p$5(349));
            (Oh & 30) !== 0 || ki(nt, $, tt)
        }
        rt.memoizedState = tt;
        var it = {
            value: tt,
            getSnapshot: $
        };
        return rt.queue = it,
        ri(hi.bind(null, nt, it, et), [et]),
        nt.flags |= 2048,
        ii(9, ji.bind(null, nt, it, tt, $), void 0, null),
        tt
    },
    useId: function() {
        var et = $h()
          , $ = P$1.identifierPrefix;
        if (I$1) {
            var tt = Zg
              , nt = Yg;
            tt = (nt & ~(1 << 32 - nc(nt) - 1)).toString(32) + tt,
            $ = ":" + $ + "R" + tt,
            tt = Rh++,
            0 < tt && ($ += "H" + tt.toString(32)),
            $ += ":"
        } else
            tt = Sh++,
            $ = ":" + $ + "r" + tt.toString(32) + ":";
        return et.memoizedState = $
    },
    unstable_isNewReconciler: !1
}
  , Wh = {
    readContext: ug,
    useCallback: xi,
    useContext: ug,
    useEffect: gi,
    useImperativeHandle: vi,
    useInsertionEffect: si,
    useLayoutEffect: ti,
    useMemo: yi,
    useReducer: ci,
    useRef: oi,
    useState: function() {
        return ci(bi)
    },
    useDebugValue: wi,
    useDeferredValue: function(et) {
        var $ = ai();
        return zi($, M$1.memoizedState, et)
    },
    useTransition: function() {
        var et = ci(bi)[0]
          , $ = ai().memoizedState;
        return [et, $]
    },
    useMutableSource: ei,
    useSyncExternalStore: fi,
    useId: Bi,
    unstable_isNewReconciler: !1
}
  , Xh = {
    readContext: ug,
    useCallback: xi,
    useContext: ug,
    useEffect: gi,
    useImperativeHandle: vi,
    useInsertionEffect: si,
    useLayoutEffect: ti,
    useMemo: yi,
    useReducer: di,
    useRef: oi,
    useState: function() {
        return di(bi)
    },
    useDebugValue: wi,
    useDeferredValue: function(et) {
        var $ = ai();
        return M$1 === null ? $.memoizedState = et : zi($, M$1.memoizedState, et)
    },
    useTransition: function() {
        var et = di(bi)[0]
          , $ = ai().memoizedState;
        return [et, $]
    },
    useMutableSource: ei,
    useSyncExternalStore: fi,
    useId: Bi,
    unstable_isNewReconciler: !1
};
function Hi(et, $) {
    try {
        var tt = ""
          , nt = $;
        do
            tt += Oa(nt),
            nt = nt.return;
        while (nt);
        var rt = tt
    } catch (it) {
        rt = `
Error generating stack: ` + it.message + `
` + it.stack
    }
    return {
        value: et,
        source: $,
        stack: rt
    }
}
function Ii(et, $) {
    try {
        console.error($.value)
    } catch (tt) {
        setTimeout(function() {
            throw tt
        })
    }
}
var Ji = typeof WeakMap == "function" ? WeakMap : Map;
function Ki(et, $, tt) {
    tt = zg(-1, tt),
    tt.tag = 3,
    tt.payload = {
        element: null
    };
    var nt = $.value;
    return tt.callback = function() {
        Li || (Li = !0,
        Mi = nt),
        Ii(et, $)
    }
    ,
    tt
}
function Ni(et, $, tt) {
    tt = zg(-1, tt),
    tt.tag = 3;
    var nt = et.type.getDerivedStateFromError;
    if (typeof nt == "function") {
        var rt = $.value;
        tt.payload = function() {
            return nt(rt)
        }
        ,
        tt.callback = function() {
            Ii(et, $)
        }
    }
    var it = et.stateNode;
    return it !== null && typeof it.componentDidCatch == "function" && (tt.callback = function() {
        Ii(et, $),
        typeof nt != "function" && (Oi === null ? Oi = new Set([this]) : Oi.add(this));
        var ot = $.stack;
        this.componentDidCatch($.value, {
            componentStack: ot !== null ? ot : ""
        })
    }
    ),
    tt
}
function Pi(et, $, tt) {
    var nt = et.pingCache;
    if (nt === null) {
        nt = et.pingCache = new Ji;
        var rt = new Set;
        nt.set($, rt)
    } else
        rt = nt.get($),
        rt === void 0 && (rt = new Set,
        nt.set($, rt));
    rt.has(tt) || (rt.add(tt),
    et = Qi.bind(null, et, $, tt),
    $.then(et, et))
}
function Ri(et) {
    do {
        var $;
        if (($ = et.tag === 13) && ($ = et.memoizedState,
        $ = $ !== null ? $.dehydrated !== null : !0),
        $)
            return et;
        et = et.return
    } while (et !== null);
    return null
}
function Si(et, $, tt, nt, rt) {
    return (et.mode & 1) === 0 ? (et === $ ? et.flags |= 65536 : (et.flags |= 128,
    tt.flags |= 131072,
    tt.flags &= -52805,
    tt.tag === 1 && (tt.alternate === null ? tt.tag = 17 : ($ = zg(-1, 1),
    $.tag = 2,
    Ag(tt, $))),
    tt.lanes |= 1),
    et) : (et.flags |= 65536,
    et.lanes = rt,
    et)
}
var Ti, Ui, Vi, Wi;
Ti = function(et, $) {
    for (var tt = $.child; tt !== null; ) {
        if (tt.tag === 5 || tt.tag === 6)
            et.appendChild(tt.stateNode);
        else if (tt.tag !== 4 && tt.child !== null) {
            tt.child.return = tt,
            tt = tt.child;
            continue
        }
        if (tt === $)
            break;
        for (; tt.sibling === null; ) {
            if (tt.return === null || tt.return === $)
                return;
            tt = tt.return
        }
        tt.sibling.return = tt.return,
        tt = tt.sibling
    }
}
;
Ui = function() {}
;
Vi = function(et, $, tt, nt) {
    var rt = et.memoizedProps;
    if (rt !== nt) {
        et = $.stateNode,
        Eh(Bh.current);
        var it = null;
        switch (tt) {
        case "input":
            rt = Xa(et, rt),
            nt = Xa(et, nt),
            it = [];
            break;
        case "select":
            rt = A$1({}, rt, {
                value: void 0
            }),
            nt = A$1({}, nt, {
                value: void 0
            }),
            it = [];
            break;
        case "textarea":
            rt = fb(et, rt),
            nt = fb(et, nt),
            it = [];
            break;
        default:
            typeof rt.onClick != "function" && typeof nt.onClick == "function" && (et.onclick = Af)
        }
        tb(tt, nt);
        var ot;
        tt = null;
        for (ut in rt)
            if (!nt.hasOwnProperty(ut) && rt.hasOwnProperty(ut) && rt[ut] != null)
                if (ut === "style") {
                    var st = rt[ut];
                    for (ot in st)
                        st.hasOwnProperty(ot) && (tt || (tt = {}),
                        tt[ot] = "")
                } else
                    ut !== "dangerouslySetInnerHTML" && ut !== "children" && ut !== "suppressContentEditableWarning" && ut !== "suppressHydrationWarning" && ut !== "autoFocus" && (ea.hasOwnProperty(ut) ? it || (it = []) : (it = it || []).push(ut, null));
        for (ut in nt) {
            var lt = nt[ut];
            if (st = rt != null ? rt[ut] : void 0,
            nt.hasOwnProperty(ut) && lt !== st && (lt != null || st != null))
                if (ut === "style")
                    if (st) {
                        for (ot in st)
                            !st.hasOwnProperty(ot) || lt && lt.hasOwnProperty(ot) || (tt || (tt = {}),
                            tt[ot] = "");
                        for (ot in lt)
                            lt.hasOwnProperty(ot) && st[ot] !== lt[ot] && (tt || (tt = {}),
                            tt[ot] = lt[ot])
                    } else
                        tt || (it || (it = []),
                        it.push(ut, tt)),
                        tt = lt;
                else
                    ut === "dangerouslySetInnerHTML" ? (lt = lt ? lt.__html : void 0,
                    st = st ? st.__html : void 0,
                    lt != null && st !== lt && (it = it || []).push(ut, lt)) : ut === "children" ? typeof lt != "string" && typeof lt != "number" || (it = it || []).push(ut, "" + lt) : ut !== "suppressContentEditableWarning" && ut !== "suppressHydrationWarning" && (ea.hasOwnProperty(ut) ? (lt != null && ut === "onScroll" && D$1("scroll", et),
                    it || st === lt || (it = [])) : (it = it || []).push(ut, lt))
        }
        tt && (it = it || []).push("style", tt);
        var ut = it;
        ($.updateQueue = ut) && ($.flags |= 4)
    }
}
;
Wi = function(et, $, tt, nt) {
    tt !== nt && ($.flags |= 4)
}
;
function Xi(et, $) {
    if (!I$1)
        switch (et.tailMode) {
        case "hidden":
            $ = et.tail;
            for (var tt = null; $ !== null; )
                $.alternate !== null && (tt = $),
                $ = $.sibling;
            tt === null ? et.tail = null : tt.sibling = null;
            break;
        case "collapsed":
            tt = et.tail;
            for (var nt = null; tt !== null; )
                tt.alternate !== null && (nt = tt),
                tt = tt.sibling;
            nt === null ? $ || et.tail === null ? et.tail = null : et.tail.sibling = null : nt.sibling = null
        }
}
function Q$1(et) {
    var $ = et.alternate !== null && et.alternate.child === et.child
      , tt = 0
      , nt = 0;
    if ($)
        for (var rt = et.child; rt !== null; )
            tt |= rt.lanes | rt.childLanes,
            nt |= rt.subtreeFlags & 14680064,
            nt |= rt.flags & 14680064,
            rt.return = et,
            rt = rt.sibling;
    else
        for (rt = et.child; rt !== null; )
            tt |= rt.lanes | rt.childLanes,
            nt |= rt.subtreeFlags,
            nt |= rt.flags,
            rt.return = et,
            rt = rt.sibling;
    return et.subtreeFlags |= nt,
    et.childLanes = tt,
    $
}
function Yi(et, $, tt) {
    var nt = $.pendingProps;
    switch (ch($),
    $.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return Q$1($),
        null;
    case 1:
        return Yf($.type) && Zf(),
        Q$1($),
        null;
    case 3:
        return nt = $.stateNode,
        Gh(),
        E$1(Vf),
        E$1(H$1),
        Lh(),
        nt.pendingContext && (nt.context = nt.pendingContext,
        nt.pendingContext = null),
        (et === null || et.child === null) && (mh($) ? $.flags |= 4 : et === null || et.memoizedState.isDehydrated && ($.flags & 256) === 0 || ($.flags |= 1024,
        fh !== null && (Zi(fh),
        fh = null))),
        Ui(et, $),
        Q$1($),
        null;
    case 5:
        Ih($);
        var rt = Eh(Dh.current);
        if (tt = $.type,
        et !== null && $.stateNode != null)
            Vi(et, $, tt, nt, rt),
            et.ref !== $.ref && ($.flags |= 512,
            $.flags |= 2097152);
        else {
            if (!nt) {
                if ($.stateNode === null)
                    throw Error(p$5(166));
                return Q$1($),
                null
            }
            if (et = Eh(Bh.current),
            mh($)) {
                nt = $.stateNode,
                tt = $.type;
                var it = $.memoizedProps;
                switch (nt[Nf] = $,
                nt[Of] = it,
                et = ($.mode & 1) !== 0,
                tt) {
                case "dialog":
                    D$1("cancel", nt),
                    D$1("close", nt);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    D$1("load", nt);
                    break;
                case "video":
                case "audio":
                    for (rt = 0; rt < kf.length; rt++)
                        D$1(kf[rt], nt);
                    break;
                case "source":
                    D$1("error", nt);
                    break;
                case "img":
                case "image":
                case "link":
                    D$1("error", nt),
                    D$1("load", nt);
                    break;
                case "details":
                    D$1("toggle", nt);
                    break;
                case "input":
                    Ya(nt, it),
                    D$1("invalid", nt);
                    break;
                case "select":
                    nt._wrapperState = {
                        wasMultiple: !!it.multiple
                    },
                    D$1("invalid", nt);
                    break;
                case "textarea":
                    gb(nt, it),
                    D$1("invalid", nt)
                }
                tb(tt, it),
                rt = null;
                for (var ot in it)
                    if (it.hasOwnProperty(ot)) {
                        var st = it[ot];
                        ot === "children" ? typeof st == "string" ? nt.textContent !== st && (it.suppressHydrationWarning !== !0 && zf(nt.textContent, st, et),
                        rt = ["children", st]) : typeof st == "number" && nt.textContent !== "" + st && (it.suppressHydrationWarning !== !0 && zf(nt.textContent, st, et),
                        rt = ["children", "" + st]) : ea.hasOwnProperty(ot) && st != null && ot === "onScroll" && D$1("scroll", nt)
                    }
                switch (tt) {
                case "input":
                    Ua(nt),
                    cb(nt, it, !0);
                    break;
                case "textarea":
                    Ua(nt),
                    ib(nt);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof it.onClick == "function" && (nt.onclick = Af)
                }
                nt = rt,
                $.updateQueue = nt,
                nt !== null && ($.flags |= 4)
            } else {
                ot = rt.nodeType === 9 ? rt : rt.ownerDocument,
                et === "http://www.w3.org/1999/xhtml" && (et = jb(tt)),
                et === "http://www.w3.org/1999/xhtml" ? tt === "script" ? (et = ot.createElement("div"),
                et.innerHTML = "<script><\/script>",
                et = et.removeChild(et.firstChild)) : typeof nt.is == "string" ? et = ot.createElement(tt, {
                    is: nt.is
                }) : (et = ot.createElement(tt),
                tt === "select" && (ot = et,
                nt.multiple ? ot.multiple = !0 : nt.size && (ot.size = nt.size))) : et = ot.createElementNS(et, tt),
                et[Nf] = $,
                et[Of] = nt,
                Ti(et, $, !1, !1),
                $.stateNode = et;
                e: {
                    switch (ot = ub(tt, nt),
                    tt) {
                    case "dialog":
                        D$1("cancel", et),
                        D$1("close", et),
                        rt = nt;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        D$1("load", et),
                        rt = nt;
                        break;
                    case "video":
                    case "audio":
                        for (rt = 0; rt < kf.length; rt++)
                            D$1(kf[rt], et);
                        rt = nt;
                        break;
                    case "source":
                        D$1("error", et),
                        rt = nt;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        D$1("error", et),
                        D$1("load", et),
                        rt = nt;
                        break;
                    case "details":
                        D$1("toggle", et),
                        rt = nt;
                        break;
                    case "input":
                        Ya(et, nt),
                        rt = Xa(et, nt),
                        D$1("invalid", et);
                        break;
                    case "option":
                        rt = nt;
                        break;
                    case "select":
                        et._wrapperState = {
                            wasMultiple: !!nt.multiple
                        },
                        rt = A$1({}, nt, {
                            value: void 0
                        }),
                        D$1("invalid", et);
                        break;
                    case "textarea":
                        gb(et, nt),
                        rt = fb(et, nt),
                        D$1("invalid", et);
                        break;
                    default:
                        rt = nt
                    }
                    tb(tt, rt),
                    st = rt;
                    for (it in st)
                        if (st.hasOwnProperty(it)) {
                            var lt = st[it];
                            it === "style" ? rb(et, lt) : it === "dangerouslySetInnerHTML" ? (lt = lt ? lt.__html : void 0,
                            lt != null && mb(et, lt)) : it === "children" ? typeof lt == "string" ? (tt !== "textarea" || lt !== "") && nb(et, lt) : typeof lt == "number" && nb(et, "" + lt) : it !== "suppressContentEditableWarning" && it !== "suppressHydrationWarning" && it !== "autoFocus" && (ea.hasOwnProperty(it) ? lt != null && it === "onScroll" && D$1("scroll", et) : lt != null && sa(et, it, lt, ot))
                        }
                    switch (tt) {
                    case "input":
                        Ua(et),
                        cb(et, nt, !1);
                        break;
                    case "textarea":
                        Ua(et),
                        ib(et);
                        break;
                    case "option":
                        nt.value != null && et.setAttribute("value", "" + Ra(nt.value));
                        break;
                    case "select":
                        et.multiple = !!nt.multiple,
                        it = nt.value,
                        it != null ? eb(et, !!nt.multiple, it, !1) : nt.defaultValue != null && eb(et, !!nt.multiple, nt.defaultValue, !0);
                        break;
                    default:
                        typeof rt.onClick == "function" && (et.onclick = Af)
                    }
                    switch (tt) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        nt = !!nt.autoFocus;
                        break e;
                    case "img":
                        nt = !0;
                        break e;
                    default:
                        nt = !1
                    }
                }
                nt && ($.flags |= 4)
            }
            $.ref !== null && ($.flags |= 512,
            $.flags |= 2097152)
        }
        return Q$1($),
        null;
    case 6:
        if (et && $.stateNode != null)
            Wi(et, $, et.memoizedProps, nt);
        else {
            if (typeof nt != "string" && $.stateNode === null)
                throw Error(p$5(166));
            if (tt = Eh(Dh.current),
            Eh(Bh.current),
            mh($)) {
                if (nt = $.stateNode,
                tt = $.memoizedProps,
                nt[Nf] = $,
                (it = nt.nodeValue !== tt) && (et = dh,
                et !== null))
                    switch (et.tag) {
                    case 3:
                        zf(nt.nodeValue, tt, (et.mode & 1) !== 0);
                        break;
                    case 5:
                        et.memoizedProps.suppressHydrationWarning !== !0 && zf(nt.nodeValue, tt, (et.mode & 1) !== 0)
                    }
                it && ($.flags |= 4)
            } else
                nt = (tt.nodeType === 9 ? tt : tt.ownerDocument).createTextNode(nt),
                nt[Nf] = $,
                $.stateNode = nt
        }
        return Q$1($),
        null;
    case 13:
        if (E$1(K),
        nt = $.memoizedState,
        I$1 && eh !== null && ($.mode & 1) !== 0 && ($.flags & 128) === 0) {
            for (nt = eh; nt; )
                nt = Kf(nt.nextSibling);
            return nh(),
            $.flags |= 98560,
            $
        }
        if (nt !== null && nt.dehydrated !== null) {
            if (nt = mh($),
            et === null) {
                if (!nt)
                    throw Error(p$5(318));
                if (nt = $.memoizedState,
                nt = nt !== null ? nt.dehydrated : null,
                !nt)
                    throw Error(p$5(317));
                nt[Nf] = $
            } else
                nh(),
                ($.flags & 128) === 0 && ($.memoizedState = null),
                $.flags |= 4;
            return Q$1($),
            null
        }
        return fh !== null && (Zi(fh),
        fh = null),
        ($.flags & 128) !== 0 ? ($.lanes = tt,
        $) : (nt = nt !== null,
        tt = !1,
        et === null ? mh($) : tt = et.memoizedState !== null,
        nt !== tt && nt && ($.child.flags |= 8192,
        ($.mode & 1) !== 0 && (et === null || (K.current & 1) !== 0 ? R$1 === 0 && (R$1 = 3) : $i())),
        $.updateQueue !== null && ($.flags |= 4),
        Q$1($),
        null);
    case 4:
        return Gh(),
        Ui(et, $),
        et === null && rf($.stateNode.containerInfo),
        Q$1($),
        null;
    case 10:
        return qg($.type._context),
        Q$1($),
        null;
    case 17:
        return Yf($.type) && Zf(),
        Q$1($),
        null;
    case 19:
        if (E$1(K),
        it = $.memoizedState,
        it === null)
            return Q$1($),
            null;
        if (nt = ($.flags & 128) !== 0,
        ot = it.rendering,
        ot === null)
            if (nt)
                Xi(it, !1);
            else {
                if (R$1 !== 0 || et !== null && (et.flags & 128) !== 0)
                    for (et = $.child; et !== null; ) {
                        if (ot = Jh(et),
                        ot !== null) {
                            for ($.flags |= 128,
                            Xi(it, !1),
                            nt = ot.updateQueue,
                            nt !== null && ($.updateQueue = nt,
                            $.flags |= 4),
                            $.subtreeFlags = 0,
                            nt = tt,
                            tt = $.child; tt !== null; )
                                it = tt,
                                et = nt,
                                it.flags &= 14680066,
                                ot = it.alternate,
                                ot === null ? (it.childLanes = 0,
                                it.lanes = et,
                                it.child = null,
                                it.subtreeFlags = 0,
                                it.memoizedProps = null,
                                it.memoizedState = null,
                                it.updateQueue = null,
                                it.dependencies = null,
                                it.stateNode = null) : (it.childLanes = ot.childLanes,
                                it.lanes = ot.lanes,
                                it.child = ot.child,
                                it.subtreeFlags = 0,
                                it.deletions = null,
                                it.memoizedProps = ot.memoizedProps,
                                it.memoizedState = ot.memoizedState,
                                it.updateQueue = ot.updateQueue,
                                it.type = ot.type,
                                et = ot.dependencies,
                                it.dependencies = et === null ? null : {
                                    lanes: et.lanes,
                                    firstContext: et.firstContext
                                }),
                                tt = tt.sibling;
                            return G$1(K, K.current & 1 | 2),
                            $.child
                        }
                        et = et.sibling
                    }
                it.tail !== null && B$1() > aj && ($.flags |= 128,
                nt = !0,
                Xi(it, !1),
                $.lanes = 4194304)
            }
        else {
            if (!nt)
                if (et = Jh(ot),
                et !== null) {
                    if ($.flags |= 128,
                    nt = !0,
                    tt = et.updateQueue,
                    tt !== null && ($.updateQueue = tt,
                    $.flags |= 4),
                    Xi(it, !0),
                    it.tail === null && it.tailMode === "hidden" && !ot.alternate && !I$1)
                        return Q$1($),
                        null
                } else
                    2 * B$1() - it.renderingStartTime > aj && tt !== 1073741824 && ($.flags |= 128,
                    nt = !0,
                    Xi(it, !1),
                    $.lanes = 4194304);
            it.isBackwards ? (ot.sibling = $.child,
            $.child = ot) : (tt = it.last,
            tt !== null ? tt.sibling = ot : $.child = ot,
            it.last = ot)
        }
        return it.tail !== null ? ($ = it.tail,
        it.rendering = $,
        it.tail = $.sibling,
        it.renderingStartTime = B$1(),
        $.sibling = null,
        tt = K.current,
        G$1(K, nt ? tt & 1 | 2 : tt & 1),
        $) : (Q$1($),
        null);
    case 22:
    case 23:
        return bj(),
        nt = $.memoizedState !== null,
        et !== null && et.memoizedState !== null !== nt && ($.flags |= 8192),
        nt && ($.mode & 1) !== 0 ? (cj & 1073741824) !== 0 && (Q$1($),
        $.subtreeFlags & 6 && ($.flags |= 8192)) : Q$1($),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(p$5(156, $.tag))
}
var dj = ta.ReactCurrentOwner
  , tg = !1;
function ej(et, $, tt, nt) {
    $.child = et === null ? zh($, null, tt, nt) : yh($, et.child, tt, nt)
}
function fj(et, $, tt, nt, rt) {
    tt = tt.render;
    var it = $.ref;
    return sg($, rt),
    nt = Uh(et, $, tt, nt, it, rt),
    tt = Zh(),
    et !== null && !tg ? ($.updateQueue = et.updateQueue,
    $.flags &= -2053,
    et.lanes &= ~rt,
    gj(et, $, rt)) : (I$1 && tt && bh($),
    $.flags |= 1,
    ej(et, $, nt, rt),
    $.child)
}
function hj(et, $, tt, nt, rt) {
    if (et === null) {
        var it = tt.type;
        return typeof it == "function" && !ij(it) && it.defaultProps === void 0 && tt.compare === null && tt.defaultProps === void 0 ? ($.tag = 15,
        $.type = it,
        jj(et, $, it, nt, rt)) : (et = vh(tt.type, null, nt, $, $.mode, rt),
        et.ref = $.ref,
        et.return = $,
        $.child = et)
    }
    if (it = et.child,
    (et.lanes & rt) === 0) {
        var ot = it.memoizedProps;
        if (tt = tt.compare,
        tt = tt !== null ? tt : He,
        tt(ot, nt) && et.ref === $.ref)
            return gj(et, $, rt)
    }
    return $.flags |= 1,
    et = th(it, nt),
    et.ref = $.ref,
    et.return = $,
    $.child = et
}
function jj(et, $, tt, nt, rt) {
    if (et !== null) {
        var it = et.memoizedProps;
        if (He(it, nt) && et.ref === $.ref)
            if (tg = !1,
            $.pendingProps = nt = it,
            (et.lanes & rt) !== 0)
                (et.flags & 131072) !== 0 && (tg = !0);
            else
                return $.lanes = et.lanes,
                gj(et, $, rt)
    }
    return kj(et, $, tt, nt, rt)
}
function lj(et, $, tt) {
    var nt = $.pendingProps
      , rt = nt.children
      , it = et !== null ? et.memoizedState : null;
    if (nt.mode === "hidden")
        if (($.mode & 1) === 0)
            $.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            G$1(mj, cj),
            cj |= tt;
        else if ((tt & 1073741824) !== 0)
            $.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            nt = it !== null ? it.baseLanes : tt,
            G$1(mj, cj),
            cj |= nt;
        else
            return et = it !== null ? it.baseLanes | tt : tt,
            $.lanes = $.childLanes = 1073741824,
            $.memoizedState = {
                baseLanes: et,
                cachePool: null,
                transitions: null
            },
            $.updateQueue = null,
            G$1(mj, cj),
            cj |= et,
            null;
    else
        it !== null ? (nt = it.baseLanes | tt,
        $.memoizedState = null) : nt = tt,
        G$1(mj, cj),
        cj |= nt;
    return ej(et, $, rt, tt),
    $.child
}
function nj(et, $) {
    var tt = $.ref;
    (et === null && tt !== null || et !== null && et.ref !== tt) && ($.flags |= 512,
    $.flags |= 2097152)
}
function kj(et, $, tt, nt, rt) {
    var it = Yf(tt) ? Wf : H$1.current;
    return it = Xf($, it),
    sg($, rt),
    tt = Uh(et, $, tt, nt, it, rt),
    nt = Zh(),
    et !== null && !tg ? ($.updateQueue = et.updateQueue,
    $.flags &= -2053,
    et.lanes &= ~rt,
    gj(et, $, rt)) : (I$1 && nt && bh($),
    $.flags |= 1,
    ej(et, $, tt, rt),
    $.child)
}
function oj(et, $, tt, nt, rt) {
    if (Yf(tt)) {
        var it = !0;
        bg($)
    } else
        it = !1;
    if (sg($, rt),
    $.stateNode === null)
        et !== null && (et.alternate = null,
        $.alternate = null,
        $.flags |= 2),
        Og($, tt, nt),
        Qg($, tt, nt, rt),
        nt = !0;
    else if (et === null) {
        var ot = $.stateNode
          , st = $.memoizedProps;
        ot.props = st;
        var lt = ot.context
          , ut = tt.contextType;
        typeof ut == "object" && ut !== null ? ut = ug(ut) : (ut = Yf(tt) ? Wf : H$1.current,
        ut = Xf($, ut));
        var ct = tt.getDerivedStateFromProps
          , ht = typeof ct == "function" || typeof ot.getSnapshotBeforeUpdate == "function";
        ht || typeof ot.UNSAFE_componentWillReceiveProps != "function" && typeof ot.componentWillReceiveProps != "function" || (st !== nt || lt !== ut) && Pg($, ot, nt, ut),
        wg = !1;
        var ft = $.memoizedState;
        ot.state = ft,
        Eg($, nt, ot, rt),
        lt = $.memoizedState,
        st !== nt || ft !== lt || Vf.current || wg ? (typeof ct == "function" && (Ig($, tt, ct, nt),
        lt = $.memoizedState),
        (st = wg || Ng($, tt, st, nt, ft, lt, ut)) ? (ht || typeof ot.UNSAFE_componentWillMount != "function" && typeof ot.componentWillMount != "function" || (typeof ot.componentWillMount == "function" && ot.componentWillMount(),
        typeof ot.UNSAFE_componentWillMount == "function" && ot.UNSAFE_componentWillMount()),
        typeof ot.componentDidMount == "function" && ($.flags |= 4194308)) : (typeof ot.componentDidMount == "function" && ($.flags |= 4194308),
        $.memoizedProps = nt,
        $.memoizedState = lt),
        ot.props = nt,
        ot.state = lt,
        ot.context = ut,
        nt = st) : (typeof ot.componentDidMount == "function" && ($.flags |= 4194308),
        nt = !1)
    } else {
        ot = $.stateNode,
        yg(et, $),
        st = $.memoizedProps,
        ut = $.type === $.elementType ? st : kg($.type, st),
        ot.props = ut,
        ht = $.pendingProps,
        ft = ot.context,
        lt = tt.contextType,
        typeof lt == "object" && lt !== null ? lt = ug(lt) : (lt = Yf(tt) ? Wf : H$1.current,
        lt = Xf($, lt));
        var gt = tt.getDerivedStateFromProps;
        (ct = typeof gt == "function" || typeof ot.getSnapshotBeforeUpdate == "function") || typeof ot.UNSAFE_componentWillReceiveProps != "function" && typeof ot.componentWillReceiveProps != "function" || (st !== ht || ft !== lt) && Pg($, ot, nt, lt),
        wg = !1,
        ft = $.memoizedState,
        ot.state = ft,
        Eg($, nt, ot, rt);
        var vt = $.memoizedState;
        st !== ht || ft !== vt || Vf.current || wg ? (typeof gt == "function" && (Ig($, tt, gt, nt),
        vt = $.memoizedState),
        (ut = wg || Ng($, tt, ut, nt, ft, vt, lt) || !1) ? (ct || typeof ot.UNSAFE_componentWillUpdate != "function" && typeof ot.componentWillUpdate != "function" || (typeof ot.componentWillUpdate == "function" && ot.componentWillUpdate(nt, vt, lt),
        typeof ot.UNSAFE_componentWillUpdate == "function" && ot.UNSAFE_componentWillUpdate(nt, vt, lt)),
        typeof ot.componentDidUpdate == "function" && ($.flags |= 4),
        typeof ot.getSnapshotBeforeUpdate == "function" && ($.flags |= 1024)) : (typeof ot.componentDidUpdate != "function" || st === et.memoizedProps && ft === et.memoizedState || ($.flags |= 4),
        typeof ot.getSnapshotBeforeUpdate != "function" || st === et.memoizedProps && ft === et.memoizedState || ($.flags |= 1024),
        $.memoizedProps = nt,
        $.memoizedState = vt),
        ot.props = nt,
        ot.state = vt,
        ot.context = lt,
        nt = ut) : (typeof ot.componentDidUpdate != "function" || st === et.memoizedProps && ft === et.memoizedState || ($.flags |= 4),
        typeof ot.getSnapshotBeforeUpdate != "function" || st === et.memoizedProps && ft === et.memoizedState || ($.flags |= 1024),
        nt = !1)
    }
    return pj(et, $, tt, nt, it, rt)
}
function pj(et, $, tt, nt, rt, it) {
    nj(et, $);
    var ot = ($.flags & 128) !== 0;
    if (!nt && !ot)
        return rt && cg($, tt, !1),
        gj(et, $, it);
    nt = $.stateNode,
    dj.current = $;
    var st = ot && typeof tt.getDerivedStateFromError != "function" ? null : nt.render();
    return $.flags |= 1,
    et !== null && ot ? ($.child = yh($, et.child, null, it),
    $.child = yh($, null, st, it)) : ej(et, $, st, it),
    $.memoizedState = nt.state,
    rt && cg($, tt, !0),
    $.child
}
function qj(et) {
    var $ = et.stateNode;
    $.pendingContext ? $f(et, $.pendingContext, $.pendingContext !== $.context) : $.context && $f(et, $.context, !1),
    Fh(et, $.containerInfo)
}
function rj(et, $, tt, nt, rt) {
    return nh(),
    oh(rt),
    $.flags |= 256,
    ej(et, $, tt, nt),
    $.child
}
var sj = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function tj(et) {
    return {
        baseLanes: et,
        cachePool: null,
        transitions: null
    }
}
function uj(et, $) {
    return {
        baseLanes: et.baseLanes | $,
        cachePool: null,
        transitions: et.transitions
    }
}
function vj(et, $, tt) {
    var nt = $.pendingProps, rt = K.current, it = !1, ot = ($.flags & 128) !== 0, st;
    if ((st = ot) || (st = et !== null && et.memoizedState === null ? !1 : (rt & 2) !== 0),
    st ? (it = !0,
    $.flags &= -129) : (et === null || et.memoizedState !== null) && (rt |= 1),
    G$1(K, rt & 1),
    et === null)
        return kh($),
        et = $.memoizedState,
        et !== null && (et = et.dehydrated,
        et !== null) ? (($.mode & 1) === 0 ? $.lanes = 1 : et.data === "$!" ? $.lanes = 8 : $.lanes = 1073741824,
        null) : (rt = nt.children,
        et = nt.fallback,
        it ? (nt = $.mode,
        it = $.child,
        rt = {
            mode: "hidden",
            children: rt
        },
        (nt & 1) === 0 && it !== null ? (it.childLanes = 0,
        it.pendingProps = rt) : it = wj(rt, nt, 0, null),
        et = xh(et, nt, tt, null),
        it.return = $,
        et.return = $,
        it.sibling = et,
        $.child = it,
        $.child.memoizedState = tj(tt),
        $.memoizedState = sj,
        et) : xj($, rt));
    if (rt = et.memoizedState,
    rt !== null) {
        if (st = rt.dehydrated,
        st !== null) {
            if (ot)
                return $.flags & 256 ? ($.flags &= -257,
                yj(et, $, tt, Error(p$5(422)))) : $.memoizedState !== null ? ($.child = et.child,
                $.flags |= 128,
                null) : (it = nt.fallback,
                rt = $.mode,
                nt = wj({
                    mode: "visible",
                    children: nt.children
                }, rt, 0, null),
                it = xh(it, rt, tt, null),
                it.flags |= 2,
                nt.return = $,
                it.return = $,
                nt.sibling = it,
                $.child = nt,
                ($.mode & 1) !== 0 && yh($, et.child, null, tt),
                $.child.memoizedState = tj(tt),
                $.memoizedState = sj,
                it);
            if (($.mode & 1) === 0)
                $ = yj(et, $, tt, null);
            else if (st.data === "$!")
                $ = yj(et, $, tt, Error(p$5(419)));
            else if (nt = (tt & et.childLanes) !== 0,
            tg || nt) {
                if (nt = P$1,
                nt !== null) {
                    switch (tt & -tt) {
                    case 4:
                        it = 2;
                        break;
                    case 16:
                        it = 8;
                        break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                        it = 32;
                        break;
                    case 536870912:
                        it = 268435456;
                        break;
                    default:
                        it = 0
                    }
                    nt = (it & (nt.suspendedLanes | tt)) !== 0 ? 0 : it,
                    nt !== 0 && nt !== rt.retryLane && (rt.retryLane = nt,
                    Lg(et, nt, -1))
                }
                $i(),
                $ = yj(et, $, tt, Error(p$5(421)))
            } else
                st.data === "$?" ? ($.flags |= 128,
                $.child = et.child,
                $ = zj.bind(null, et),
                st._reactRetry = $,
                $ = null) : (tt = rt.treeContext,
                eh = Kf(st.nextSibling),
                dh = $,
                I$1 = !0,
                fh = null,
                tt !== null && (Vg[Wg++] = Yg,
                Vg[Wg++] = Zg,
                Vg[Wg++] = Xg,
                Yg = tt.id,
                Zg = tt.overflow,
                Xg = $),
                $ = xj($, $.pendingProps.children),
                $.flags |= 4096);
            return $
        }
        return it ? (nt = Aj(et, $, nt.children, nt.fallback, tt),
        it = $.child,
        rt = et.child.memoizedState,
        it.memoizedState = rt === null ? tj(tt) : uj(rt, tt),
        it.childLanes = et.childLanes & ~tt,
        $.memoizedState = sj,
        nt) : (tt = Bj(et, $, nt.children, tt),
        $.memoizedState = null,
        tt)
    }
    return it ? (nt = Aj(et, $, nt.children, nt.fallback, tt),
    it = $.child,
    rt = et.child.memoizedState,
    it.memoizedState = rt === null ? tj(tt) : uj(rt, tt),
    it.childLanes = et.childLanes & ~tt,
    $.memoizedState = sj,
    nt) : (tt = Bj(et, $, nt.children, tt),
    $.memoizedState = null,
    tt)
}
function xj(et, $) {
    return $ = wj({
        mode: "visible",
        children: $
    }, et.mode, 0, null),
    $.return = et,
    et.child = $
}
function Bj(et, $, tt, nt) {
    var rt = et.child;
    return et = rt.sibling,
    tt = th(rt, {
        mode: "visible",
        children: tt
    }),
    ($.mode & 1) === 0 && (tt.lanes = nt),
    tt.return = $,
    tt.sibling = null,
    et !== null && (nt = $.deletions,
    nt === null ? ($.deletions = [et],
    $.flags |= 16) : nt.push(et)),
    $.child = tt
}
function Aj(et, $, tt, nt, rt) {
    var it = $.mode;
    et = et.child;
    var ot = et.sibling
      , st = {
        mode: "hidden",
        children: tt
    };
    return (it & 1) === 0 && $.child !== et ? (tt = $.child,
    tt.childLanes = 0,
    tt.pendingProps = st,
    $.deletions = null) : (tt = th(et, st),
    tt.subtreeFlags = et.subtreeFlags & 14680064),
    ot !== null ? nt = th(ot, nt) : (nt = xh(nt, it, rt, null),
    nt.flags |= 2),
    nt.return = $,
    tt.return = $,
    tt.sibling = nt,
    $.child = tt,
    nt
}
function yj(et, $, tt, nt) {
    return nt !== null && oh(nt),
    yh($, et.child, null, tt),
    et = xj($, $.pendingProps.children),
    et.flags |= 2,
    $.memoizedState = null,
    et
}
function Cj(et, $, tt) {
    et.lanes |= $;
    var nt = et.alternate;
    nt !== null && (nt.lanes |= $),
    rg(et.return, $, tt)
}
function Dj(et, $, tt, nt, rt) {
    var it = et.memoizedState;
    it === null ? et.memoizedState = {
        isBackwards: $,
        rendering: null,
        renderingStartTime: 0,
        last: nt,
        tail: tt,
        tailMode: rt
    } : (it.isBackwards = $,
    it.rendering = null,
    it.renderingStartTime = 0,
    it.last = nt,
    it.tail = tt,
    it.tailMode = rt)
}
function Ej(et, $, tt) {
    var nt = $.pendingProps
      , rt = nt.revealOrder
      , it = nt.tail;
    if (ej(et, $, nt.children, tt),
    nt = K.current,
    (nt & 2) !== 0)
        nt = nt & 1 | 2,
        $.flags |= 128;
    else {
        if (et !== null && (et.flags & 128) !== 0)
            e: for (et = $.child; et !== null; ) {
                if (et.tag === 13)
                    et.memoizedState !== null && Cj(et, tt, $);
                else if (et.tag === 19)
                    Cj(et, tt, $);
                else if (et.child !== null) {
                    et.child.return = et,
                    et = et.child;
                    continue
                }
                if (et === $)
                    break e;
                for (; et.sibling === null; ) {
                    if (et.return === null || et.return === $)
                        break e;
                    et = et.return
                }
                et.sibling.return = et.return,
                et = et.sibling
            }
        nt &= 1
    }
    if (G$1(K, nt),
    ($.mode & 1) === 0)
        $.memoizedState = null;
    else
        switch (rt) {
        case "forwards":
            for (tt = $.child,
            rt = null; tt !== null; )
                et = tt.alternate,
                et !== null && Jh(et) === null && (rt = tt),
                tt = tt.sibling;
            tt = rt,
            tt === null ? (rt = $.child,
            $.child = null) : (rt = tt.sibling,
            tt.sibling = null),
            Dj($, !1, rt, tt, it);
            break;
        case "backwards":
            for (tt = null,
            rt = $.child,
            $.child = null; rt !== null; ) {
                if (et = rt.alternate,
                et !== null && Jh(et) === null) {
                    $.child = rt;
                    break
                }
                et = rt.sibling,
                rt.sibling = tt,
                tt = rt,
                rt = et
            }
            Dj($, !0, tt, null, it);
            break;
        case "together":
            Dj($, !1, null, null, void 0);
            break;
        default:
            $.memoizedState = null
        }
    return $.child
}
function gj(et, $, tt) {
    if (et !== null && ($.dependencies = et.dependencies),
    Fg |= $.lanes,
    (tt & $.childLanes) === 0)
        return null;
    if (et !== null && $.child !== et.child)
        throw Error(p$5(153));
    if ($.child !== null) {
        for (et = $.child,
        tt = th(et, et.pendingProps),
        $.child = tt,
        tt.return = $; et.sibling !== null; )
            et = et.sibling,
            tt = tt.sibling = th(et, et.pendingProps),
            tt.return = $;
        tt.sibling = null
    }
    return $.child
}
function Fj(et, $, tt) {
    switch ($.tag) {
    case 3:
        qj($),
        nh();
        break;
    case 5:
        Hh($);
        break;
    case 1:
        Yf($.type) && bg($);
        break;
    case 4:
        Fh($, $.stateNode.containerInfo);
        break;
    case 10:
        var nt = $.type._context
          , rt = $.memoizedProps.value;
        G$1(lg, nt._currentValue),
        nt._currentValue = rt;
        break;
    case 13:
        if (nt = $.memoizedState,
        nt !== null)
            return nt.dehydrated !== null ? (G$1(K, K.current & 1),
            $.flags |= 128,
            null) : (tt & $.child.childLanes) !== 0 ? vj(et, $, tt) : (G$1(K, K.current & 1),
            et = gj(et, $, tt),
            et !== null ? et.sibling : null);
        G$1(K, K.current & 1);
        break;
    case 19:
        if (nt = (tt & $.childLanes) !== 0,
        (et.flags & 128) !== 0) {
            if (nt)
                return Ej(et, $, tt);
            $.flags |= 128
        }
        if (rt = $.memoizedState,
        rt !== null && (rt.rendering = null,
        rt.tail = null,
        rt.lastEffect = null),
        G$1(K, K.current),
        nt)
            break;
        return null;
    case 22:
    case 23:
        return $.lanes = 0,
        lj(et, $, tt)
    }
    return gj(et, $, tt)
}
function Gj(et, $) {
    switch (ch($),
    $.tag) {
    case 1:
        return Yf($.type) && Zf(),
        et = $.flags,
        et & 65536 ? ($.flags = et & -65537 | 128,
        $) : null;
    case 3:
        return Gh(),
        E$1(Vf),
        E$1(H$1),
        Lh(),
        et = $.flags,
        (et & 65536) !== 0 && (et & 128) === 0 ? ($.flags = et & -65537 | 128,
        $) : null;
    case 5:
        return Ih($),
        null;
    case 13:
        if (E$1(K),
        et = $.memoizedState,
        et !== null && et.dehydrated !== null) {
            if ($.alternate === null)
                throw Error(p$5(340));
            nh()
        }
        return et = $.flags,
        et & 65536 ? ($.flags = et & -65537 | 128,
        $) : null;
    case 19:
        return E$1(K),
        null;
    case 4:
        return Gh(),
        null;
    case 10:
        return qg($.type._context),
        null;
    case 22:
    case 23:
        return bj(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Hj = !1
  , S$1 = !1
  , Ij = typeof WeakSet == "function" ? WeakSet : Set
  , T = null;
function Jj(et, $) {
    var tt = et.ref;
    if (tt !== null)
        if (typeof tt == "function")
            try {
                tt(null)
            } catch (nt) {
                U$1(et, $, nt)
            }
        else
            tt.current = null
}
function Kj(et, $, tt) {
    try {
        tt()
    } catch (nt) {
        U$1(et, $, nt)
    }
}
var Lj = !1;
function Mj(et, $) {
    if (Bf = cd,
    et = Le(),
    Me(et)) {
        if ("selectionStart"in et)
            var tt = {
                start: et.selectionStart,
                end: et.selectionEnd
            };
        else
            e: {
                tt = (tt = et.ownerDocument) && tt.defaultView || window;
                var nt = tt.getSelection && tt.getSelection();
                if (nt && nt.rangeCount !== 0) {
                    tt = nt.anchorNode;
                    var rt = nt.anchorOffset
                      , it = nt.focusNode;
                    nt = nt.focusOffset;
                    try {
                        tt.nodeType,
                        it.nodeType
                    } catch {
                        tt = null;
                        break e
                    }
                    var ot = 0
                      , st = -1
                      , lt = -1
                      , ut = 0
                      , ct = 0
                      , ht = et
                      , ft = null;
                    t: for (; ; ) {
                        for (var gt; ht !== tt || rt !== 0 && ht.nodeType !== 3 || (st = ot + rt),
                        ht !== it || nt !== 0 && ht.nodeType !== 3 || (lt = ot + nt),
                        ht.nodeType === 3 && (ot += ht.nodeValue.length),
                        (gt = ht.firstChild) !== null; )
                            ft = ht,
                            ht = gt;
                        for (; ; ) {
                            if (ht === et)
                                break t;
                            if (ft === tt && ++ut === rt && (st = ot),
                            ft === it && ++ct === nt && (lt = ot),
                            (gt = ht.nextSibling) !== null)
                                break;
                            ht = ft,
                            ft = ht.parentNode
                        }
                        ht = gt
                    }
                    tt = st === -1 || lt === -1 ? null : {
                        start: st,
                        end: lt
                    }
                } else
                    tt = null
            }
        tt = tt || {
            start: 0,
            end: 0
        }
    } else
        tt = null;
    for (Cf = {
        focusedElem: et,
        selectionRange: tt
    },
    cd = !1,
    T = $; T !== null; )
        if ($ = T,
        et = $.child,
        ($.subtreeFlags & 1028) !== 0 && et !== null)
            et.return = $,
            T = et;
        else
            for (; T !== null; ) {
                $ = T;
                try {
                    var vt = $.alternate;
                    if (($.flags & 1024) !== 0)
                        switch ($.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (vt !== null) {
                                var yt = vt.memoizedProps
                                  , wt = vt.memoizedState
                                  , mt = $.stateNode
                                  , _t = mt.getSnapshotBeforeUpdate($.elementType === $.type ? yt : kg($.type, yt), wt);
                                mt.__reactInternalSnapshotBeforeUpdate = _t
                            }
                            break;
                        case 3:
                            var bt = $.stateNode.containerInfo;
                            if (bt.nodeType === 1)
                                bt.textContent = "";
                            else if (bt.nodeType === 9) {
                                var Mt = bt.body;
                                Mt != null && (Mt.textContent = "")
                            }
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(p$5(163))
                        }
                } catch (St) {
                    U$1($, $.return, St)
                }
                if (et = $.sibling,
                et !== null) {
                    et.return = $.return,
                    T = et;
                    break
                }
                T = $.return
            }
    return vt = Lj,
    Lj = !1,
    vt
}
function Nj(et, $, tt) {
    var nt = $.updateQueue;
    if (nt = nt !== null ? nt.lastEffect : null,
    nt !== null) {
        var rt = nt = nt.next;
        do {
            if ((rt.tag & et) === et) {
                var it = rt.destroy;
                rt.destroy = void 0,
                it !== void 0 && Kj($, tt, it)
            }
            rt = rt.next
        } while (rt !== nt)
    }
}
function Oj(et, $) {
    if ($ = $.updateQueue,
    $ = $ !== null ? $.lastEffect : null,
    $ !== null) {
        var tt = $ = $.next;
        do {
            if ((tt.tag & et) === et) {
                var nt = tt.create;
                tt.destroy = nt()
            }
            tt = tt.next
        } while (tt !== $)
    }
}
function Pj(et) {
    var $ = et.ref;
    if ($ !== null) {
        var tt = et.stateNode;
        switch (et.tag) {
        case 5:
            et = tt;
            break;
        default:
            et = tt
        }
        typeof $ == "function" ? $(et) : $.current = et
    }
}
function Qj(et) {
    var $ = et.alternate;
    $ !== null && (et.alternate = null,
    Qj($)),
    et.child = null,
    et.deletions = null,
    et.sibling = null,
    et.tag === 5 && ($ = et.stateNode,
    $ !== null && (delete $[Nf],
    delete $[Of],
    delete $[nf],
    delete $[Pf],
    delete $[Qf])),
    et.stateNode = null,
    et.return = null,
    et.dependencies = null,
    et.memoizedProps = null,
    et.memoizedState = null,
    et.pendingProps = null,
    et.stateNode = null,
    et.updateQueue = null
}
function Rj(et) {
    return et.tag === 5 || et.tag === 3 || et.tag === 4
}
function Sj(et) {
    e: for (; ; ) {
        for (; et.sibling === null; ) {
            if (et.return === null || Rj(et.return))
                return null;
            et = et.return
        }
        for (et.sibling.return = et.return,
        et = et.sibling; et.tag !== 5 && et.tag !== 6 && et.tag !== 18; ) {
            if (et.flags & 2 || et.child === null || et.tag === 4)
                continue e;
            et.child.return = et,
            et = et.child
        }
        if (!(et.flags & 2))
            return et.stateNode
    }
}
function Tj(et, $, tt) {
    var nt = et.tag;
    if (nt === 5 || nt === 6)
        et = et.stateNode,
        $ ? tt.nodeType === 8 ? tt.parentNode.insertBefore(et, $) : tt.insertBefore(et, $) : (tt.nodeType === 8 ? ($ = tt.parentNode,
        $.insertBefore(et, tt)) : ($ = tt,
        $.appendChild(et)),
        tt = tt._reactRootContainer,
        tt != null || $.onclick !== null || ($.onclick = Af));
    else if (nt !== 4 && (et = et.child,
    et !== null))
        for (Tj(et, $, tt),
        et = et.sibling; et !== null; )
            Tj(et, $, tt),
            et = et.sibling
}
function Uj(et, $, tt) {
    var nt = et.tag;
    if (nt === 5 || nt === 6)
        et = et.stateNode,
        $ ? tt.insertBefore(et, $) : tt.appendChild(et);
    else if (nt !== 4 && (et = et.child,
    et !== null))
        for (Uj(et, $, tt),
        et = et.sibling; et !== null; )
            Uj(et, $, tt),
            et = et.sibling
}
var V = null
  , Vj = !1;
function Wj(et, $, tt) {
    for (tt = tt.child; tt !== null; )
        Xj(et, $, tt),
        tt = tt.sibling
}
function Xj(et, $, tt) {
    if (kc && typeof kc.onCommitFiberUnmount == "function")
        try {
            kc.onCommitFiberUnmount(jc, tt)
        } catch {}
    switch (tt.tag) {
    case 5:
        S$1 || Jj(tt, $);
    case 6:
        var nt = V
          , rt = Vj;
        V = null,
        Wj(et, $, tt),
        V = nt,
        Vj = rt,
        V !== null && (Vj ? (et = V,
        tt = tt.stateNode,
        et.nodeType === 8 ? et.parentNode.removeChild(tt) : et.removeChild(tt)) : V.removeChild(tt.stateNode));
        break;
    case 18:
        V !== null && (Vj ? (et = V,
        tt = tt.stateNode,
        et.nodeType === 8 ? Jf(et.parentNode, tt) : et.nodeType === 1 && Jf(et, tt),
        ad(et)) : Jf(V, tt.stateNode));
        break;
    case 4:
        nt = V,
        rt = Vj,
        V = tt.stateNode.containerInfo,
        Vj = !0,
        Wj(et, $, tt),
        V = nt,
        Vj = rt;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!S$1 && (nt = tt.updateQueue,
        nt !== null && (nt = nt.lastEffect,
        nt !== null))) {
            rt = nt = nt.next;
            do {
                var it = rt
                  , ot = it.destroy;
                it = it.tag,
                ot !== void 0 && ((it & 2) !== 0 || (it & 4) !== 0) && Kj(tt, $, ot),
                rt = rt.next
            } while (rt !== nt)
        }
        Wj(et, $, tt);
        break;
    case 1:
        if (!S$1 && (Jj(tt, $),
        nt = tt.stateNode,
        typeof nt.componentWillUnmount == "function"))
            try {
                nt.props = tt.memoizedProps,
                nt.state = tt.memoizedState,
                nt.componentWillUnmount()
            } catch (st) {
                U$1(tt, $, st)
            }
        Wj(et, $, tt);
        break;
    case 21:
        Wj(et, $, tt);
        break;
    case 22:
        tt.mode & 1 ? (S$1 = (nt = S$1) || tt.memoizedState !== null,
        Wj(et, $, tt),
        S$1 = nt) : Wj(et, $, tt);
        break;
    default:
        Wj(et, $, tt)
    }
}
function Yj(et) {
    var $ = et.updateQueue;
    if ($ !== null) {
        et.updateQueue = null;
        var tt = et.stateNode;
        tt === null && (tt = et.stateNode = new Ij),
        $.forEach(function(nt) {
            var rt = Zj.bind(null, et, nt);
            tt.has(nt) || (tt.add(nt),
            nt.then(rt, rt))
        })
    }
}
function ak(et, $) {
    var tt = $.deletions;
    if (tt !== null)
        for (var nt = 0; nt < tt.length; nt++) {
            var rt = tt[nt];
            try {
                var it = et
                  , ot = $
                  , st = ot;
                e: for (; st !== null; ) {
                    switch (st.tag) {
                    case 5:
                        V = st.stateNode,
                        Vj = !1;
                        break e;
                    case 3:
                        V = st.stateNode.containerInfo,
                        Vj = !0;
                        break e;
                    case 4:
                        V = st.stateNode.containerInfo,
                        Vj = !0;
                        break e
                    }
                    st = st.return
                }
                if (V === null)
                    throw Error(p$5(160));
                Xj(it, ot, rt),
                V = null,
                Vj = !1;
                var lt = rt.alternate;
                lt !== null && (lt.return = null),
                rt.return = null
            } catch (ut) {
                U$1(rt, $, ut)
            }
        }
    if ($.subtreeFlags & 12854)
        for ($ = $.child; $ !== null; )
            bk($, et),
            $ = $.sibling
}
function bk(et, $) {
    var tt = et.alternate
      , nt = et.flags;
    switch (et.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (ak($, et),
        ck(et),
        nt & 4) {
            try {
                Nj(3, et, et.return),
                Oj(3, et)
            } catch (vt) {
                U$1(et, et.return, vt)
            }
            try {
                Nj(5, et, et.return)
            } catch (vt) {
                U$1(et, et.return, vt)
            }
        }
        break;
    case 1:
        ak($, et),
        ck(et),
        nt & 512 && tt !== null && Jj(tt, tt.return);
        break;
    case 5:
        if (ak($, et),
        ck(et),
        nt & 512 && tt !== null && Jj(tt, tt.return),
        et.flags & 32) {
            var rt = et.stateNode;
            try {
                nb(rt, "")
            } catch (vt) {
                U$1(et, et.return, vt)
            }
        }
        if (nt & 4 && (rt = et.stateNode,
        rt != null)) {
            var it = et.memoizedProps
              , ot = tt !== null ? tt.memoizedProps : it
              , st = et.type
              , lt = et.updateQueue;
            if (et.updateQueue = null,
            lt !== null)
                try {
                    st === "input" && it.type === "radio" && it.name != null && Za(rt, it),
                    ub(st, ot);
                    var ut = ub(st, it);
                    for (ot = 0; ot < lt.length; ot += 2) {
                        var ct = lt[ot]
                          , ht = lt[ot + 1];
                        ct === "style" ? rb(rt, ht) : ct === "dangerouslySetInnerHTML" ? mb(rt, ht) : ct === "children" ? nb(rt, ht) : sa(rt, ct, ht, ut)
                    }
                    switch (st) {
                    case "input":
                        $a(rt, it);
                        break;
                    case "textarea":
                        hb(rt, it);
                        break;
                    case "select":
                        var ft = rt._wrapperState.wasMultiple;
                        rt._wrapperState.wasMultiple = !!it.multiple;
                        var gt = it.value;
                        gt != null ? eb(rt, !!it.multiple, gt, !1) : ft !== !!it.multiple && (it.defaultValue != null ? eb(rt, !!it.multiple, it.defaultValue, !0) : eb(rt, !!it.multiple, it.multiple ? [] : "", !1))
                    }
                    rt[Of] = it
                } catch (vt) {
                    U$1(et, et.return, vt)
                }
        }
        break;
    case 6:
        if (ak($, et),
        ck(et),
        nt & 4) {
            if (et.stateNode === null)
                throw Error(p$5(162));
            ut = et.stateNode,
            ct = et.memoizedProps;
            try {
                ut.nodeValue = ct
            } catch (vt) {
                U$1(et, et.return, vt)
            }
        }
        break;
    case 3:
        if (ak($, et),
        ck(et),
        nt & 4 && tt !== null && tt.memoizedState.isDehydrated)
            try {
                ad($.containerInfo)
            } catch (vt) {
                U$1(et, et.return, vt)
            }
        break;
    case 4:
        ak($, et),
        ck(et);
        break;
    case 13:
        ak($, et),
        ck(et),
        ut = et.child,
        ut.flags & 8192 && ut.memoizedState !== null && (ut.alternate === null || ut.alternate.memoizedState === null) && (dk = B$1()),
        nt & 4 && Yj(et);
        break;
    case 22:
        if (ut = tt !== null && tt.memoizedState !== null,
        et.mode & 1 ? (S$1 = (ct = S$1) || ut,
        ak($, et),
        S$1 = ct) : ak($, et),
        ck(et),
        nt & 8192) {
            ct = et.memoizedState !== null;
            e: for (ht = null,
            ft = et; ; ) {
                if (ft.tag === 5) {
                    if (ht === null) {
                        ht = ft;
                        try {
                            rt = ft.stateNode,
                            ct ? (it = rt.style,
                            typeof it.setProperty == "function" ? it.setProperty("display", "none", "important") : it.display = "none") : (st = ft.stateNode,
                            lt = ft.memoizedProps.style,
                            ot = lt != null && lt.hasOwnProperty("display") ? lt.display : null,
                            st.style.display = qb("display", ot))
                        } catch (vt) {
                            U$1(et, et.return, vt)
                        }
                    }
                } else if (ft.tag === 6) {
                    if (ht === null)
                        try {
                            ft.stateNode.nodeValue = ct ? "" : ft.memoizedProps
                        } catch (vt) {
                            U$1(et, et.return, vt)
                        }
                } else if ((ft.tag !== 22 && ft.tag !== 23 || ft.memoizedState === null || ft === et) && ft.child !== null) {
                    ft.child.return = ft,
                    ft = ft.child;
                    continue
                }
                if (ft === et)
                    break e;
                for (; ft.sibling === null; ) {
                    if (ft.return === null || ft.return === et)
                        break e;
                    ht === ft && (ht = null),
                    ft = ft.return
                }
                ht === ft && (ht = null),
                ft.sibling.return = ft.return,
                ft = ft.sibling
            }
            if (ct && !ut && (et.mode & 1) !== 0)
                for (T = et,
                et = et.child; et !== null; ) {
                    for (ut = T = et; T !== null; ) {
                        switch (ct = T,
                        ht = ct.child,
                        ct.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Nj(4, ct, ct.return);
                            break;
                        case 1:
                            if (Jj(ct, ct.return),
                            it = ct.stateNode,
                            typeof it.componentWillUnmount == "function") {
                                ft = ct,
                                gt = ct.return;
                                try {
                                    rt = ft,
                                    it.props = rt.memoizedProps,
                                    it.state = rt.memoizedState,
                                    it.componentWillUnmount()
                                } catch (vt) {
                                    U$1(ft, gt, vt)
                                }
                            }
                            break;
                        case 5:
                            Jj(ct, ct.return);
                            break;
                        case 22:
                            if (ct.memoizedState !== null) {
                                ek(ut);
                                continue
                            }
                        }
                        ht !== null ? (ht.return = ct,
                        T = ht) : ek(ut)
                    }
                    et = et.sibling
                }
        }
        break;
    case 19:
        ak($, et),
        ck(et),
        nt & 4 && Yj(et);
        break;
    case 21:
        break;
    default:
        ak($, et),
        ck(et)
    }
}
function ck(et) {
    var $ = et.flags;
    if ($ & 2) {
        try {
            e: {
                for (var tt = et.return; tt !== null; ) {
                    if (Rj(tt)) {
                        var nt = tt;
                        break e
                    }
                    tt = tt.return
                }
                throw Error(p$5(160))
            }
            switch (nt.tag) {
            case 5:
                var rt = nt.stateNode;
                nt.flags & 32 && (nb(rt, ""),
                nt.flags &= -33);
                var it = Sj(et);
                Uj(et, it, rt);
                break;
            case 3:
            case 4:
                var ot = nt.stateNode.containerInfo
                  , st = Sj(et);
                Tj(et, st, ot);
                break;
            default:
                throw Error(p$5(161))
            }
        } catch (lt) {
            U$1(et, et.return, lt)
        }
        et.flags &= -3
    }
    $ & 4096 && (et.flags &= -4097)
}
function fk(et, $, tt) {
    T = et,
    gk(et)
}
function gk(et, $, tt) {
    for (var nt = (et.mode & 1) !== 0; T !== null; ) {
        var rt = T
          , it = rt.child;
        if (rt.tag === 22 && nt) {
            var ot = rt.memoizedState !== null || Hj;
            if (!ot) {
                var st = rt.alternate
                  , lt = st !== null && st.memoizedState !== null || S$1;
                st = Hj;
                var ut = S$1;
                if (Hj = ot,
                (S$1 = lt) && !ut)
                    for (T = rt; T !== null; )
                        ot = T,
                        lt = ot.child,
                        ot.tag === 22 && ot.memoizedState !== null ? hk(rt) : lt !== null ? (lt.return = ot,
                        T = lt) : hk(rt);
                for (; it !== null; )
                    T = it,
                    gk(it),
                    it = it.sibling;
                T = rt,
                Hj = st,
                S$1 = ut
            }
            ik(et)
        } else
            (rt.subtreeFlags & 8772) !== 0 && it !== null ? (it.return = rt,
            T = it) : ik(et)
    }
}
function ik(et) {
    for (; T !== null; ) {
        var $ = T;
        if (($.flags & 8772) !== 0) {
            var tt = $.alternate;
            try {
                if (($.flags & 8772) !== 0)
                    switch ($.tag) {
                    case 0:
                    case 11:
                    case 15:
                        S$1 || Oj(5, $);
                        break;
                    case 1:
                        var nt = $.stateNode;
                        if ($.flags & 4 && !S$1)
                            if (tt === null)
                                nt.componentDidMount();
                            else {
                                var rt = $.elementType === $.type ? tt.memoizedProps : kg($.type, tt.memoizedProps);
                                nt.componentDidUpdate(rt, tt.memoizedState, nt.__reactInternalSnapshotBeforeUpdate)
                            }
                        var it = $.updateQueue;
                        it !== null && Gg($, it, nt);
                        break;
                    case 3:
                        var ot = $.updateQueue;
                        if (ot !== null) {
                            if (tt = null,
                            $.child !== null)
                                switch ($.child.tag) {
                                case 5:
                                    tt = $.child.stateNode;
                                    break;
                                case 1:
                                    tt = $.child.stateNode
                                }
                            Gg($, ot, tt)
                        }
                        break;
                    case 5:
                        var st = $.stateNode;
                        if (tt === null && $.flags & 4) {
                            tt = st;
                            var lt = $.memoizedProps;
                            switch ($.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                lt.autoFocus && tt.focus();
                                break;
                            case "img":
                                lt.src && (tt.src = lt.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if ($.memoizedState === null) {
                            var ut = $.alternate;
                            if (ut !== null) {
                                var ct = ut.memoizedState;
                                if (ct !== null) {
                                    var ht = ct.dehydrated;
                                    ht !== null && ad(ht)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                        break;
                    default:
                        throw Error(p$5(163))
                    }
                S$1 || $.flags & 512 && Pj($)
            } catch (ft) {
                U$1($, $.return, ft)
            }
        }
        if ($ === et) {
            T = null;
            break
        }
        if (tt = $.sibling,
        tt !== null) {
            tt.return = $.return,
            T = tt;
            break
        }
        T = $.return
    }
}
function ek(et) {
    for (; T !== null; ) {
        var $ = T;
        if ($ === et) {
            T = null;
            break
        }
        var tt = $.sibling;
        if (tt !== null) {
            tt.return = $.return,
            T = tt;
            break
        }
        T = $.return
    }
}
function hk(et) {
    for (; T !== null; ) {
        var $ = T;
        try {
            switch ($.tag) {
            case 0:
            case 11:
            case 15:
                var tt = $.return;
                try {
                    Oj(4, $)
                } catch (lt) {
                    U$1($, tt, lt)
                }
                break;
            case 1:
                var nt = $.stateNode;
                if (typeof nt.componentDidMount == "function") {
                    var rt = $.return;
                    try {
                        nt.componentDidMount()
                    } catch (lt) {
                        U$1($, rt, lt)
                    }
                }
                var it = $.return;
                try {
                    Pj($)
                } catch (lt) {
                    U$1($, it, lt)
                }
                break;
            case 5:
                var ot = $.return;
                try {
                    Pj($)
                } catch (lt) {
                    U$1($, ot, lt)
                }
            }
        } catch (lt) {
            U$1($, $.return, lt)
        }
        if ($ === et) {
            T = null;
            break
        }
        var st = $.sibling;
        if (st !== null) {
            st.return = $.return,
            T = st;
            break
        }
        T = $.return
    }
}
var jk = Math.ceil
  , kk = ta.ReactCurrentDispatcher
  , lk = ta.ReactCurrentOwner
  , mk = ta.ReactCurrentBatchConfig
  , W$1 = 0
  , P$1 = null
  , X$1 = null
  , Y = 0
  , cj = 0
  , mj = Tf(0)
  , R$1 = 0
  , nk = null
  , Fg = 0
  , ok$1 = 0
  , pk = 0
  , qk = null
  , rk = null
  , dk = 0
  , aj = 1 / 0
  , sk = null
  , Li = !1
  , Mi = null
  , Oi = null
  , tk = !1
  , uk = null
  , vk = 0
  , wk = 0
  , xk = null
  , yk = -1
  , zk = 0;
function Jg() {
    return (W$1 & 6) !== 0 ? B$1() : yk !== -1 ? yk : yk = B$1()
}
function Kg(et) {
    return (et.mode & 1) === 0 ? 1 : (W$1 & 2) !== 0 && Y !== 0 ? Y & -Y : jg.transition !== null ? (zk === 0 && (zk = xc()),
    zk) : (et = C,
    et !== 0 || (et = window.event,
    et = et === void 0 ? 16 : id(et.type)),
    et)
}
function Lg(et, $, tt) {
    if (50 < wk)
        throw wk = 0,
        xk = null,
        Error(p$5(185));
    var nt = Ak(et, $);
    return nt === null ? null : (zc(nt, $, tt),
    ((W$1 & 2) === 0 || nt !== P$1) && (nt === P$1 && ((W$1 & 2) === 0 && (ok$1 |= $),
    R$1 === 4 && Bk(nt, Y)),
    Ck(nt, tt),
    $ === 1 && W$1 === 0 && (et.mode & 1) === 0 && (aj = B$1() + 500,
    eg && ig())),
    nt)
}
function Ak(et, $) {
    et.lanes |= $;
    var tt = et.alternate;
    for (tt !== null && (tt.lanes |= $),
    tt = et,
    et = et.return; et !== null; )
        et.childLanes |= $,
        tt = et.alternate,
        tt !== null && (tt.childLanes |= $),
        tt = et,
        et = et.return;
    return tt.tag === 3 ? tt.stateNode : null
}
function Bg(et) {
    return (P$1 !== null || vg !== null) && (et.mode & 1) !== 0 && (W$1 & 2) === 0
}
function Ck(et, $) {
    var tt = et.callbackNode;
    vc(et, $);
    var nt = tc(et, et === P$1 ? Y : 0);
    if (nt === 0)
        tt !== null && ac(tt),
        et.callbackNode = null,
        et.callbackPriority = 0;
    else if ($ = nt & -nt,
    et.callbackPriority !== $) {
        if (tt != null && ac(tt),
        $ === 1)
            et.tag === 0 ? hg(Dk.bind(null, et)) : gg(Dk.bind(null, et)),
            If(function() {
                W$1 === 0 && ig()
            }),
            tt = null;
        else {
            switch (Cc(nt)) {
            case 1:
                tt = ec;
                break;
            case 4:
                tt = fc;
                break;
            case 16:
                tt = gc;
                break;
            case 536870912:
                tt = ic;
                break;
            default:
                tt = gc
            }
            tt = Ek(tt, Fk.bind(null, et))
        }
        et.callbackPriority = $,
        et.callbackNode = tt
    }
}
function Fk(et, $) {
    if (yk = -1,
    zk = 0,
    (W$1 & 6) !== 0)
        throw Error(p$5(327));
    var tt = et.callbackNode;
    if (Gk() && et.callbackNode !== tt)
        return null;
    var nt = tc(et, et === P$1 ? Y : 0);
    if (nt === 0)
        return null;
    if ((nt & 30) !== 0 || (nt & et.expiredLanes) !== 0 || $)
        $ = Hk(et, nt);
    else {
        $ = nt;
        var rt = W$1;
        W$1 |= 2;
        var it = Ik();
        (P$1 !== et || Y !== $) && (sk = null,
        aj = B$1() + 500,
        Jk(et, $));
        do
            try {
                Kk();
                break
            } catch (st) {
                Lk(et, st)
            }
        while (1);
        pg(),
        kk.current = it,
        W$1 = rt,
        X$1 !== null ? $ = 0 : (P$1 = null,
        Y = 0,
        $ = R$1)
    }
    if ($ !== 0) {
        if ($ === 2 && (rt = wc(et),
        rt !== 0 && (nt = rt,
        $ = Mk(et, rt))),
        $ === 1)
            throw tt = nk,
            Jk(et, 0),
            Bk(et, nt),
            Ck(et, B$1()),
            tt;
        if ($ === 6)
            Bk(et, nt);
        else {
            if (rt = et.current.alternate,
            (nt & 30) === 0 && !Nk(rt) && ($ = Hk(et, nt),
            $ === 2 && (it = wc(et),
            it !== 0 && (nt = it,
            $ = Mk(et, it))),
            $ === 1))
                throw tt = nk,
                Jk(et, 0),
                Bk(et, nt),
                Ck(et, B$1()),
                tt;
            switch (et.finishedWork = rt,
            et.finishedLanes = nt,
            $) {
            case 0:
            case 1:
                throw Error(p$5(345));
            case 2:
                Ok(et, rk, sk);
                break;
            case 3:
                if (Bk(et, nt),
                (nt & 130023424) === nt && ($ = dk + 500 - B$1(),
                10 < $)) {
                    if (tc(et, 0) !== 0)
                        break;
                    if (rt = et.suspendedLanes,
                    (rt & nt) !== nt) {
                        Jg(),
                        et.pingedLanes |= et.suspendedLanes & rt;
                        break
                    }
                    et.timeoutHandle = Ef(Ok.bind(null, et, rk, sk), $);
                    break
                }
                Ok(et, rk, sk);
                break;
            case 4:
                if (Bk(et, nt),
                (nt & 4194240) === nt)
                    break;
                for ($ = et.eventTimes,
                rt = -1; 0 < nt; ) {
                    var ot = 31 - nc(nt);
                    it = 1 << ot,
                    ot = $[ot],
                    ot > rt && (rt = ot),
                    nt &= ~it
                }
                if (nt = rt,
                nt = B$1() - nt,
                nt = (120 > nt ? 120 : 480 > nt ? 480 : 1080 > nt ? 1080 : 1920 > nt ? 1920 : 3e3 > nt ? 3e3 : 4320 > nt ? 4320 : 1960 * jk(nt / 1960)) - nt,
                10 < nt) {
                    et.timeoutHandle = Ef(Ok.bind(null, et, rk, sk), nt);
                    break
                }
                Ok(et, rk, sk);
                break;
            case 5:
                Ok(et, rk, sk);
                break;
            default:
                throw Error(p$5(329))
            }
        }
    }
    return Ck(et, B$1()),
    et.callbackNode === tt ? Fk.bind(null, et) : null
}
function Mk(et, $) {
    var tt = qk;
    return et.current.memoizedState.isDehydrated && (Jk(et, $).flags |= 256),
    et = Hk(et, $),
    et !== 2 && ($ = rk,
    rk = tt,
    $ !== null && Zi($)),
    et
}
function Zi(et) {
    rk === null ? rk = et : rk.push.apply(rk, et)
}
function Nk(et) {
    for (var $ = et; ; ) {
        if ($.flags & 16384) {
            var tt = $.updateQueue;
            if (tt !== null && (tt = tt.stores,
            tt !== null))
                for (var nt = 0; nt < tt.length; nt++) {
                    var rt = tt[nt]
                      , it = rt.getSnapshot;
                    rt = rt.value;
                    try {
                        if (!Ge(it(), rt))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (tt = $.child,
        $.subtreeFlags & 16384 && tt !== null)
            tt.return = $,
            $ = tt;
        else {
            if ($ === et)
                break;
            for (; $.sibling === null; ) {
                if ($.return === null || $.return === et)
                    return !0;
                $ = $.return
            }
            $.sibling.return = $.return,
            $ = $.sibling
        }
    }
    return !0
}
function Bk(et, $) {
    for ($ &= ~pk,
    $ &= ~ok$1,
    et.suspendedLanes |= $,
    et.pingedLanes &= ~$,
    et = et.expirationTimes; 0 < $; ) {
        var tt = 31 - nc($)
          , nt = 1 << tt;
        et[tt] = -1,
        $ &= ~nt
    }
}
function Dk(et) {
    if ((W$1 & 6) !== 0)
        throw Error(p$5(327));
    Gk();
    var $ = tc(et, 0);
    if (($ & 1) === 0)
        return Ck(et, B$1()),
        null;
    var tt = Hk(et, $);
    if (et.tag !== 0 && tt === 2) {
        var nt = wc(et);
        nt !== 0 && ($ = nt,
        tt = Mk(et, nt))
    }
    if (tt === 1)
        throw tt = nk,
        Jk(et, 0),
        Bk(et, $),
        Ck(et, B$1()),
        tt;
    if (tt === 6)
        throw Error(p$5(345));
    return et.finishedWork = et.current.alternate,
    et.finishedLanes = $,
    Ok(et, rk, sk),
    Ck(et, B$1()),
    null
}
function Pk(et, $) {
    var tt = W$1;
    W$1 |= 1;
    try {
        return et($)
    } finally {
        W$1 = tt,
        W$1 === 0 && (aj = B$1() + 500,
        eg && ig())
    }
}
function Qk(et) {
    uk !== null && uk.tag === 0 && (W$1 & 6) === 0 && Gk();
    var $ = W$1;
    W$1 |= 1;
    var tt = mk.transition
      , nt = C;
    try {
        if (mk.transition = null,
        C = 1,
        et)
            return et()
    } finally {
        C = nt,
        mk.transition = tt,
        W$1 = $,
        (W$1 & 6) === 0 && ig()
    }
}
function bj() {
    cj = mj.current,
    E$1(mj)
}
function Jk(et, $) {
    et.finishedWork = null,
    et.finishedLanes = 0;
    var tt = et.timeoutHandle;
    if (tt !== -1 && (et.timeoutHandle = -1,
    Ff(tt)),
    X$1 !== null)
        for (tt = X$1.return; tt !== null; ) {
            var nt = tt;
            switch (ch(nt),
            nt.tag) {
            case 1:
                nt = nt.type.childContextTypes,
                nt != null && Zf();
                break;
            case 3:
                Gh(),
                E$1(Vf),
                E$1(H$1),
                Lh();
                break;
            case 5:
                Ih(nt);
                break;
            case 4:
                Gh();
                break;
            case 13:
                E$1(K);
                break;
            case 19:
                E$1(K);
                break;
            case 10:
                qg(nt.type._context);
                break;
            case 22:
            case 23:
                bj()
            }
            tt = tt.return
        }
    if (P$1 = et,
    X$1 = et = th(et.current, null),
    Y = cj = $,
    R$1 = 0,
    nk = null,
    pk = ok$1 = Fg = 0,
    rk = qk = null,
    vg !== null) {
        for ($ = 0; $ < vg.length; $++)
            if (tt = vg[$],
            nt = tt.interleaved,
            nt !== null) {
                tt.interleaved = null;
                var rt = nt.next
                  , it = tt.pending;
                if (it !== null) {
                    var ot = it.next;
                    it.next = rt,
                    nt.next = ot
                }
                tt.pending = nt
            }
        vg = null
    }
    return et
}
function Lk(et, $) {
    do {
        var tt = X$1;
        try {
            if (pg(),
            Mh.current = Yh,
            Ph) {
                for (var nt = L$1.memoizedState; nt !== null; ) {
                    var rt = nt.queue;
                    rt !== null && (rt.pending = null),
                    nt = nt.next
                }
                Ph = !1
            }
            if (Oh = 0,
            N = M$1 = L$1 = null,
            Qh = !1,
            Rh = 0,
            lk.current = null,
            tt === null || tt.return === null) {
                R$1 = 1,
                nk = $,
                X$1 = null;
                break
            }
            e: {
                var it = et
                  , ot = tt.return
                  , st = tt
                  , lt = $;
                if ($ = Y,
                st.flags |= 32768,
                lt !== null && typeof lt == "object" && typeof lt.then == "function") {
                    var ut = lt
                      , ct = st
                      , ht = ct.tag;
                    if ((ct.mode & 1) === 0 && (ht === 0 || ht === 11 || ht === 15)) {
                        var ft = ct.alternate;
                        ft ? (ct.updateQueue = ft.updateQueue,
                        ct.memoizedState = ft.memoizedState,
                        ct.lanes = ft.lanes) : (ct.updateQueue = null,
                        ct.memoizedState = null)
                    }
                    var gt = Ri(ot);
                    if (gt !== null) {
                        gt.flags &= -257,
                        Si(gt, ot, st, it, $),
                        gt.mode & 1 && Pi(it, ut, $),
                        $ = gt,
                        lt = ut;
                        var vt = $.updateQueue;
                        if (vt === null) {
                            var yt = new Set;
                            yt.add(lt),
                            $.updateQueue = yt
                        } else
                            vt.add(lt);
                        break e
                    } else {
                        if (($ & 1) === 0) {
                            Pi(it, ut, $),
                            $i();
                            break e
                        }
                        lt = Error(p$5(426))
                    }
                } else if (I$1 && st.mode & 1) {
                    var wt = Ri(ot);
                    if (wt !== null) {
                        (wt.flags & 65536) === 0 && (wt.flags |= 256),
                        Si(wt, ot, st, it, $),
                        oh(lt);
                        break e
                    }
                }
                it = lt,
                R$1 !== 4 && (R$1 = 2),
                qk === null ? qk = [it] : qk.push(it),
                lt = Hi(lt, st),
                st = ot;
                do {
                    switch (st.tag) {
                    case 3:
                        st.flags |= 65536,
                        $ &= -$,
                        st.lanes |= $;
                        var mt = Ki(st, lt, $);
                        Dg(st, mt);
                        break e;
                    case 1:
                        it = lt;
                        var _t = st.type
                          , bt = st.stateNode;
                        if ((st.flags & 128) === 0 && (typeof _t.getDerivedStateFromError == "function" || bt !== null && typeof bt.componentDidCatch == "function" && (Oi === null || !Oi.has(bt)))) {
                            st.flags |= 65536,
                            $ &= -$,
                            st.lanes |= $;
                            var Mt = Ni(st, it, $);
                            Dg(st, Mt);
                            break e
                        }
                    }
                    st = st.return
                } while (st !== null)
            }
            Rk(tt)
        } catch (St) {
            $ = St,
            X$1 === tt && tt !== null && (X$1 = tt = tt.return);
            continue
        }
        break
    } while (1)
}
function Ik() {
    var et = kk.current;
    return kk.current = Yh,
    et === null ? Yh : et
}
function $i() {
    (R$1 === 0 || R$1 === 3 || R$1 === 2) && (R$1 = 4),
    P$1 === null || (Fg & 268435455) === 0 && (ok$1 & 268435455) === 0 || Bk(P$1, Y)
}
function Hk(et, $) {
    var tt = W$1;
    W$1 |= 2;
    var nt = Ik();
    (P$1 !== et || Y !== $) && (sk = null,
    Jk(et, $));
    do
        try {
            Sk();
            break
        } catch (rt) {
            Lk(et, rt)
        }
    while (1);
    if (pg(),
    W$1 = tt,
    kk.current = nt,
    X$1 !== null)
        throw Error(p$5(261));
    return P$1 = null,
    Y = 0,
    R$1
}
function Sk() {
    for (; X$1 !== null; )
        Tk(X$1)
}
function Kk() {
    for (; X$1 !== null && !bc(); )
        Tk(X$1)
}
function Tk(et) {
    var $ = Uk(et.alternate, et, cj);
    et.memoizedProps = et.pendingProps,
    $ === null ? Rk(et) : X$1 = $,
    lk.current = null
}
function Rk(et) {
    var $ = et;
    do {
        var tt = $.alternate;
        if (et = $.return,
        ($.flags & 32768) === 0) {
            if (tt = Yi(tt, $, cj),
            tt !== null) {
                X$1 = tt;
                return
            }
        } else {
            if (tt = Gj(tt, $),
            tt !== null) {
                tt.flags &= 32767,
                X$1 = tt;
                return
            }
            if (et !== null)
                et.flags |= 32768,
                et.subtreeFlags = 0,
                et.deletions = null;
            else {
                R$1 = 6,
                X$1 = null;
                return
            }
        }
        if ($ = $.sibling,
        $ !== null) {
            X$1 = $;
            return
        }
        X$1 = $ = et
    } while ($ !== null);
    R$1 === 0 && (R$1 = 5)
}
function Ok(et, $, tt) {
    var nt = C
      , rt = mk.transition;
    try {
        mk.transition = null,
        C = 1,
        Vk(et, $, tt, nt)
    } finally {
        mk.transition = rt,
        C = nt
    }
    return null
}
function Vk(et, $, tt, nt) {
    do
        Gk();
    while (uk !== null);
    if ((W$1 & 6) !== 0)
        throw Error(p$5(327));
    tt = et.finishedWork;
    var rt = et.finishedLanes;
    if (tt === null)
        return null;
    if (et.finishedWork = null,
    et.finishedLanes = 0,
    tt === et.current)
        throw Error(p$5(177));
    et.callbackNode = null,
    et.callbackPriority = 0;
    var it = tt.lanes | tt.childLanes;
    if (Ac(et, it),
    et === P$1 && (X$1 = P$1 = null,
    Y = 0),
    (tt.subtreeFlags & 2064) === 0 && (tt.flags & 2064) === 0 || tk || (tk = !0,
    Ek(gc, function() {
        return Gk(),
        null
    })),
    it = (tt.flags & 15990) !== 0,
    (tt.subtreeFlags & 15990) !== 0 || it) {
        it = mk.transition,
        mk.transition = null;
        var ot = C;
        C = 1;
        var st = W$1;
        W$1 |= 4,
        lk.current = null,
        Mj(et, tt),
        bk(tt, et),
        Ne(Cf),
        cd = !!Bf,
        Cf = Bf = null,
        et.current = tt,
        fk(tt),
        cc(),
        W$1 = st,
        C = ot,
        mk.transition = it
    } else
        et.current = tt;
    if (tk && (tk = !1,
    uk = et,
    vk = rt),
    it = et.pendingLanes,
    it === 0 && (Oi = null),
    lc(tt.stateNode),
    Ck(et, B$1()),
    $ !== null)
        for (nt = et.onRecoverableError,
        tt = 0; tt < $.length; tt++)
            nt($[tt]);
    if (Li)
        throw Li = !1,
        et = Mi,
        Mi = null,
        et;
    return (vk & 1) !== 0 && et.tag !== 0 && Gk(),
    it = et.pendingLanes,
    (it & 1) !== 0 ? et === xk ? wk++ : (wk = 0,
    xk = et) : wk = 0,
    ig(),
    null
}
function Gk() {
    if (uk !== null) {
        var et = Cc(vk)
          , $ = mk.transition
          , tt = C;
        try {
            if (mk.transition = null,
            C = 16 > et ? 16 : et,
            uk === null)
                var nt = !1;
            else {
                if (et = uk,
                uk = null,
                vk = 0,
                (W$1 & 6) !== 0)
                    throw Error(p$5(331));
                var rt = W$1;
                for (W$1 |= 4,
                T = et.current; T !== null; ) {
                    var it = T
                      , ot = it.child;
                    if ((T.flags & 16) !== 0) {
                        var st = it.deletions;
                        if (st !== null) {
                            for (var lt = 0; lt < st.length; lt++) {
                                var ut = st[lt];
                                for (T = ut; T !== null; ) {
                                    var ct = T;
                                    switch (ct.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Nj(8, ct, it)
                                    }
                                    var ht = ct.child;
                                    if (ht !== null)
                                        ht.return = ct,
                                        T = ht;
                                    else
                                        for (; T !== null; ) {
                                            ct = T;
                                            var ft = ct.sibling
                                              , gt = ct.return;
                                            if (Qj(ct),
                                            ct === ut) {
                                                T = null;
                                                break
                                            }
                                            if (ft !== null) {
                                                ft.return = gt,
                                                T = ft;
                                                break
                                            }
                                            T = gt
                                        }
                                }
                            }
                            var vt = it.alternate;
                            if (vt !== null) {
                                var yt = vt.child;
                                if (yt !== null) {
                                    vt.child = null;
                                    do {
                                        var wt = yt.sibling;
                                        yt.sibling = null,
                                        yt = wt
                                    } while (yt !== null)
                                }
                            }
                            T = it
                        }
                    }
                    if ((it.subtreeFlags & 2064) !== 0 && ot !== null)
                        ot.return = it,
                        T = ot;
                    else
                        e: for (; T !== null; ) {
                            if (it = T,
                            (it.flags & 2048) !== 0)
                                switch (it.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Nj(9, it, it.return)
                                }
                            var mt = it.sibling;
                            if (mt !== null) {
                                mt.return = it.return,
                                T = mt;
                                break e
                            }
                            T = it.return
                        }
                }
                var _t = et.current;
                for (T = _t; T !== null; ) {
                    ot = T;
                    var bt = ot.child;
                    if ((ot.subtreeFlags & 2064) !== 0 && bt !== null)
                        bt.return = ot,
                        T = bt;
                    else
                        e: for (ot = _t; T !== null; ) {
                            if (st = T,
                            (st.flags & 2048) !== 0)
                                try {
                                    switch (st.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Oj(9, st)
                                    }
                                } catch (St) {
                                    U$1(st, st.return, St)
                                }
                            if (st === ot) {
                                T = null;
                                break e
                            }
                            var Mt = st.sibling;
                            if (Mt !== null) {
                                Mt.return = st.return,
                                T = Mt;
                                break e
                            }
                            T = st.return
                        }
                }
                if (W$1 = rt,
                ig(),
                kc && typeof kc.onPostCommitFiberRoot == "function")
                    try {
                        kc.onPostCommitFiberRoot(jc, et)
                    } catch {}
                nt = !0
            }
            return nt
        } finally {
            C = tt,
            mk.transition = $
        }
    }
    return !1
}
function Wk(et, $, tt) {
    $ = Hi(tt, $),
    $ = Ki(et, $, 1),
    Ag(et, $),
    $ = Jg(),
    et = Ak(et, 1),
    et !== null && (zc(et, 1, $),
    Ck(et, $))
}
function U$1(et, $, tt) {
    if (et.tag === 3)
        Wk(et, et, tt);
    else
        for (; $ !== null; ) {
            if ($.tag === 3) {
                Wk($, et, tt);
                break
            } else if ($.tag === 1) {
                var nt = $.stateNode;
                if (typeof $.type.getDerivedStateFromError == "function" || typeof nt.componentDidCatch == "function" && (Oi === null || !Oi.has(nt))) {
                    et = Hi(tt, et),
                    et = Ni($, et, 1),
                    Ag($, et),
                    et = Jg(),
                    $ = Ak($, 1),
                    $ !== null && (zc($, 1, et),
                    Ck($, et));
                    break
                }
            }
            $ = $.return
        }
}
function Qi(et, $, tt) {
    var nt = et.pingCache;
    nt !== null && nt.delete($),
    $ = Jg(),
    et.pingedLanes |= et.suspendedLanes & tt,
    P$1 === et && (Y & tt) === tt && (R$1 === 4 || R$1 === 3 && (Y & 130023424) === Y && 500 > B$1() - dk ? Jk(et, 0) : pk |= tt),
    Ck(et, $)
}
function Xk(et, $) {
    $ === 0 && ((et.mode & 1) === 0 ? $ = 1 : ($ = rc,
    rc <<= 1,
    (rc & 130023424) === 0 && (rc = 4194304)));
    var tt = Jg();
    et = Ak(et, $),
    et !== null && (zc(et, $, tt),
    Ck(et, tt))
}
function zj(et) {
    var $ = et.memoizedState
      , tt = 0;
    $ !== null && (tt = $.retryLane),
    Xk(et, tt)
}
function Zj(et, $) {
    var tt = 0;
    switch (et.tag) {
    case 13:
        var nt = et.stateNode
          , rt = et.memoizedState;
        rt !== null && (tt = rt.retryLane);
        break;
    case 19:
        nt = et.stateNode;
        break;
    default:
        throw Error(p$5(314))
    }
    nt !== null && nt.delete($),
    Xk(et, tt)
}
var Uk;
Uk = function(et, $, tt) {
    if (et !== null)
        if (et.memoizedProps !== $.pendingProps || Vf.current)
            tg = !0;
        else {
            if ((et.lanes & tt) === 0 && ($.flags & 128) === 0)
                return tg = !1,
                Fj(et, $, tt);
            tg = (et.flags & 131072) !== 0
        }
    else
        tg = !1,
        I$1 && ($.flags & 1048576) !== 0 && ah($, Ug, $.index);
    switch ($.lanes = 0,
    $.tag) {
    case 2:
        var nt = $.type;
        et !== null && (et.alternate = null,
        $.alternate = null,
        $.flags |= 2),
        et = $.pendingProps;
        var rt = Xf($, H$1.current);
        sg($, tt),
        rt = Uh(null, $, nt, et, rt, tt);
        var it = Zh();
        return $.flags |= 1,
        typeof rt == "object" && rt !== null && typeof rt.render == "function" && rt.$$typeof === void 0 ? ($.tag = 1,
        $.memoizedState = null,
        $.updateQueue = null,
        Yf(nt) ? (it = !0,
        bg($)) : it = !1,
        $.memoizedState = rt.state !== null && rt.state !== void 0 ? rt.state : null,
        xg($),
        rt.updater = Mg,
        $.stateNode = rt,
        rt._reactInternals = $,
        Qg($, nt, et, tt),
        $ = pj(null, $, nt, !0, it, tt)) : ($.tag = 0,
        I$1 && it && bh($),
        ej(null, $, rt, tt),
        $ = $.child),
        $;
    case 16:
        nt = $.elementType;
        e: {
            switch (et !== null && (et.alternate = null,
            $.alternate = null,
            $.flags |= 2),
            et = $.pendingProps,
            rt = nt._init,
            nt = rt(nt._payload),
            $.type = nt,
            rt = $.tag = Yk(nt),
            et = kg(nt, et),
            rt) {
            case 0:
                $ = kj(null, $, nt, et, tt);
                break e;
            case 1:
                $ = oj(null, $, nt, et, tt);
                break e;
            case 11:
                $ = fj(null, $, nt, et, tt);
                break e;
            case 14:
                $ = hj(null, $, nt, kg(nt.type, et), tt);
                break e
            }
            throw Error(p$5(306, nt, ""))
        }
        return $;
    case 0:
        return nt = $.type,
        rt = $.pendingProps,
        rt = $.elementType === nt ? rt : kg(nt, rt),
        kj(et, $, nt, rt, tt);
    case 1:
        return nt = $.type,
        rt = $.pendingProps,
        rt = $.elementType === nt ? rt : kg(nt, rt),
        oj(et, $, nt, rt, tt);
    case 3:
        e: {
            if (qj($),
            et === null)
                throw Error(p$5(387));
            nt = $.pendingProps,
            it = $.memoizedState,
            rt = it.element,
            yg(et, $),
            Eg($, nt, null, tt);
            var ot = $.memoizedState;
            if (nt = ot.element,
            it.isDehydrated)
                if (it = {
                    element: nt,
                    isDehydrated: !1,
                    cache: ot.cache,
                    pendingSuspenseBoundaries: ot.pendingSuspenseBoundaries,
                    transitions: ot.transitions
                },
                $.updateQueue.baseState = it,
                $.memoizedState = it,
                $.flags & 256) {
                    rt = Error(p$5(423)),
                    $ = rj(et, $, nt, tt, rt);
                    break e
                } else if (nt !== rt) {
                    rt = Error(p$5(424)),
                    $ = rj(et, $, nt, tt, rt);
                    break e
                } else
                    for (eh = Kf($.stateNode.containerInfo.firstChild),
                    dh = $,
                    I$1 = !0,
                    fh = null,
                    tt = zh($, null, nt, tt),
                    $.child = tt; tt; )
                        tt.flags = tt.flags & -3 | 4096,
                        tt = tt.sibling;
            else {
                if (nh(),
                nt === rt) {
                    $ = gj(et, $, tt);
                    break e
                }
                ej(et, $, nt, tt)
            }
            $ = $.child
        }
        return $;
    case 5:
        return Hh($),
        et === null && kh($),
        nt = $.type,
        rt = $.pendingProps,
        it = et !== null ? et.memoizedProps : null,
        ot = rt.children,
        Df(nt, rt) ? ot = null : it !== null && Df(nt, it) && ($.flags |= 32),
        nj(et, $),
        ej(et, $, ot, tt),
        $.child;
    case 6:
        return et === null && kh($),
        null;
    case 13:
        return vj(et, $, tt);
    case 4:
        return Fh($, $.stateNode.containerInfo),
        nt = $.pendingProps,
        et === null ? $.child = yh($, null, nt, tt) : ej(et, $, nt, tt),
        $.child;
    case 11:
        return nt = $.type,
        rt = $.pendingProps,
        rt = $.elementType === nt ? rt : kg(nt, rt),
        fj(et, $, nt, rt, tt);
    case 7:
        return ej(et, $, $.pendingProps, tt),
        $.child;
    case 8:
        return ej(et, $, $.pendingProps.children, tt),
        $.child;
    case 12:
        return ej(et, $, $.pendingProps.children, tt),
        $.child;
    case 10:
        e: {
            if (nt = $.type._context,
            rt = $.pendingProps,
            it = $.memoizedProps,
            ot = rt.value,
            G$1(lg, nt._currentValue),
            nt._currentValue = ot,
            it !== null)
                if (Ge(it.value, ot)) {
                    if (it.children === rt.children && !Vf.current) {
                        $ = gj(et, $, tt);
                        break e
                    }
                } else
                    for (it = $.child,
                    it !== null && (it.return = $); it !== null; ) {
                        var st = it.dependencies;
                        if (st !== null) {
                            ot = it.child;
                            for (var lt = st.firstContext; lt !== null; ) {
                                if (lt.context === nt) {
                                    if (it.tag === 1) {
                                        lt = zg(-1, tt & -tt),
                                        lt.tag = 2;
                                        var ut = it.updateQueue;
                                        if (ut !== null) {
                                            ut = ut.shared;
                                            var ct = ut.pending;
                                            ct === null ? lt.next = lt : (lt.next = ct.next,
                                            ct.next = lt),
                                            ut.pending = lt
                                        }
                                    }
                                    it.lanes |= tt,
                                    lt = it.alternate,
                                    lt !== null && (lt.lanes |= tt),
                                    rg(it.return, tt, $),
                                    st.lanes |= tt;
                                    break
                                }
                                lt = lt.next
                            }
                        } else if (it.tag === 10)
                            ot = it.type === $.type ? null : it.child;
                        else if (it.tag === 18) {
                            if (ot = it.return,
                            ot === null)
                                throw Error(p$5(341));
                            ot.lanes |= tt,
                            st = ot.alternate,
                            st !== null && (st.lanes |= tt),
                            rg(ot, tt, $),
                            ot = it.sibling
                        } else
                            ot = it.child;
                        if (ot !== null)
                            ot.return = it;
                        else
                            for (ot = it; ot !== null; ) {
                                if (ot === $) {
                                    ot = null;
                                    break
                                }
                                if (it = ot.sibling,
                                it !== null) {
                                    it.return = ot.return,
                                    ot = it;
                                    break
                                }
                                ot = ot.return
                            }
                        it = ot
                    }
            ej(et, $, rt.children, tt),
            $ = $.child
        }
        return $;
    case 9:
        return rt = $.type,
        nt = $.pendingProps.children,
        sg($, tt),
        rt = ug(rt),
        nt = nt(rt),
        $.flags |= 1,
        ej(et, $, nt, tt),
        $.child;
    case 14:
        return nt = $.type,
        rt = kg(nt, $.pendingProps),
        rt = kg(nt.type, rt),
        hj(et, $, nt, rt, tt);
    case 15:
        return jj(et, $, $.type, $.pendingProps, tt);
    case 17:
        return nt = $.type,
        rt = $.pendingProps,
        rt = $.elementType === nt ? rt : kg(nt, rt),
        et !== null && (et.alternate = null,
        $.alternate = null,
        $.flags |= 2),
        $.tag = 1,
        Yf(nt) ? (et = !0,
        bg($)) : et = !1,
        sg($, tt),
        Og($, nt, rt),
        Qg($, nt, rt, tt),
        pj(null, $, nt, !0, et, tt);
    case 19:
        return Ej(et, $, tt);
    case 22:
        return lj(et, $, tt)
    }
    throw Error(p$5(156, $.tag))
}
;
function Ek(et, $) {
    return $b(et, $)
}
function Zk(et, $, tt, nt) {
    this.tag = et,
    this.key = tt,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = $,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = nt,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function hh(et, $, tt, nt) {
    return new Zk(et,$,tt,nt)
}
function ij(et) {
    return et = et.prototype,
    !(!et || !et.isReactComponent)
}
function Yk(et) {
    if (typeof et == "function")
        return ij(et) ? 1 : 0;
    if (et != null) {
        if (et = et.$$typeof,
        et === Ca)
            return 11;
        if (et === Fa)
            return 14
    }
    return 2
}
function th(et, $) {
    var tt = et.alternate;
    return tt === null ? (tt = hh(et.tag, $, et.key, et.mode),
    tt.elementType = et.elementType,
    tt.type = et.type,
    tt.stateNode = et.stateNode,
    tt.alternate = et,
    et.alternate = tt) : (tt.pendingProps = $,
    tt.type = et.type,
    tt.flags = 0,
    tt.subtreeFlags = 0,
    tt.deletions = null),
    tt.flags = et.flags & 14680064,
    tt.childLanes = et.childLanes,
    tt.lanes = et.lanes,
    tt.child = et.child,
    tt.memoizedProps = et.memoizedProps,
    tt.memoizedState = et.memoizedState,
    tt.updateQueue = et.updateQueue,
    $ = et.dependencies,
    tt.dependencies = $ === null ? null : {
        lanes: $.lanes,
        firstContext: $.firstContext
    },
    tt.sibling = et.sibling,
    tt.index = et.index,
    tt.ref = et.ref,
    tt
}
function vh(et, $, tt, nt, rt, it) {
    var ot = 2;
    if (nt = et,
    typeof et == "function")
        ij(et) && (ot = 1);
    else if (typeof et == "string")
        ot = 5;
    else
        e: switch (et) {
        case wa:
            return xh(tt.children, rt, it, $);
        case xa:
            ot = 8,
            rt |= 8;
            break;
        case za:
            return et = hh(12, tt, $, rt | 2),
            et.elementType = za,
            et.lanes = it,
            et;
        case Da:
            return et = hh(13, tt, $, rt),
            et.elementType = Da,
            et.lanes = it,
            et;
        case Ea:
            return et = hh(19, tt, $, rt),
            et.elementType = Ea,
            et.lanes = it,
            et;
        case Ha:
            return wj(tt, rt, it, $);
        default:
            if (typeof et == "object" && et !== null)
                switch (et.$$typeof) {
                case Aa:
                    ot = 10;
                    break e;
                case Ba:
                    ot = 9;
                    break e;
                case Ca:
                    ot = 11;
                    break e;
                case Fa:
                    ot = 14;
                    break e;
                case Ga:
                    ot = 16,
                    nt = null;
                    break e
                }
            throw Error(p$5(130, et == null ? et : typeof et, ""))
        }
    return $ = hh(ot, tt, $, rt),
    $.elementType = et,
    $.type = nt,
    $.lanes = it,
    $
}
function xh(et, $, tt, nt) {
    return et = hh(7, et, nt, $),
    et.lanes = tt,
    et
}
function wj(et, $, tt, nt) {
    return et = hh(22, et, nt, $),
    et.elementType = Ha,
    et.lanes = tt,
    et.stateNode = {},
    et
}
function uh(et, $, tt) {
    return et = hh(6, et, null, $),
    et.lanes = tt,
    et
}
function wh(et, $, tt) {
    return $ = hh(4, et.children !== null ? et.children : [], et.key, $),
    $.lanes = tt,
    $.stateNode = {
        containerInfo: et.containerInfo,
        pendingChildren: null,
        implementation: et.implementation
    },
    $
}
function $k(et, $, tt, nt, rt) {
    this.tag = $,
    this.containerInfo = et,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = yc(0),
    this.expirationTimes = yc(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = yc(0),
    this.identifierPrefix = nt,
    this.onRecoverableError = rt,
    this.mutableSourceEagerHydrationData = null
}
function al(et, $, tt, nt, rt, it, ot, st, lt) {
    return et = new $k(et,$,tt,st,lt),
    $ === 1 ? ($ = 1,
    it === !0 && ($ |= 8)) : $ = 0,
    it = hh(3, null, null, $),
    et.current = it,
    it.stateNode = et,
    it.memoizedState = {
        element: nt,
        isDehydrated: tt,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    xg(it),
    et
}
function bl(et, $, tt) {
    var nt = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: va,
        key: nt == null ? null : "" + nt,
        children: et,
        containerInfo: $,
        implementation: tt
    }
}
function cl(et) {
    if (!et)
        return Uf;
    et = et._reactInternals;
    e: {
        if (Ub(et) !== et || et.tag !== 1)
            throw Error(p$5(170));
        var $ = et;
        do {
            switch ($.tag) {
            case 3:
                $ = $.stateNode.context;
                break e;
            case 1:
                if (Yf($.type)) {
                    $ = $.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            $ = $.return
        } while ($ !== null);
        throw Error(p$5(171))
    }
    if (et.tag === 1) {
        var tt = et.type;
        if (Yf(tt))
            return ag(et, tt, $)
    }
    return $
}
function dl(et, $, tt, nt, rt, it, ot, st, lt) {
    return et = al(tt, nt, !0, et, rt, it, ot, st, lt),
    et.context = cl(null),
    tt = et.current,
    nt = Jg(),
    rt = Kg(tt),
    it = zg(nt, rt),
    it.callback = $ != null ? $ : null,
    Ag(tt, it),
    et.current.lanes = rt,
    zc(et, rt, nt),
    Ck(et, nt),
    et
}
function el(et, $, tt, nt) {
    var rt = $.current
      , it = Jg()
      , ot = Kg(rt);
    return tt = cl(tt),
    $.context === null ? $.context = tt : $.pendingContext = tt,
    $ = zg(it, ot),
    $.payload = {
        element: et
    },
    nt = nt === void 0 ? null : nt,
    nt !== null && ($.callback = nt),
    Ag(rt, $),
    et = Lg(rt, ot, it),
    et !== null && Cg(et, rt, ot),
    ot
}
function fl(et) {
    if (et = et.current,
    !et.child)
        return null;
    switch (et.child.tag) {
    case 5:
        return et.child.stateNode;
    default:
        return et.child.stateNode
    }
}
function gl(et, $) {
    if (et = et.memoizedState,
    et !== null && et.dehydrated !== null) {
        var tt = et.retryLane;
        et.retryLane = tt !== 0 && tt < $ ? tt : $
    }
}
function hl(et, $) {
    gl(et, $),
    (et = et.alternate) && gl(et, $)
}
function il() {
    return null
}
var jl = typeof reportError == "function" ? reportError : function(et) {
    console.error(et)
}
;
function kl(et) {
    this._internalRoot = et
}
ll.prototype.render = kl.prototype.render = function(et) {
    var $ = this._internalRoot;
    if ($ === null)
        throw Error(p$5(409));
    el(et, $, null, null)
}
;
ll.prototype.unmount = kl.prototype.unmount = function() {
    var et = this._internalRoot;
    if (et !== null) {
        this._internalRoot = null;
        var $ = et.containerInfo;
        Qk(function() {
            el(null, et, null, null)
        }),
        $[tf] = null
    }
}
;
function ll(et) {
    this._internalRoot = et
}
ll.prototype.unstable_scheduleHydration = function(et) {
    if (et) {
        var $ = Gc();
        et = {
            blockedOn: null,
            target: et,
            priority: $
        };
        for (var tt = 0; tt < Pc.length && $ !== 0 && $ < Pc[tt].priority; tt++)
            ;
        Pc.splice(tt, 0, et),
        tt === 0 && Uc(et)
    }
}
;
function ml(et) {
    return !(!et || et.nodeType !== 1 && et.nodeType !== 9 && et.nodeType !== 11)
}
function nl(et) {
    return !(!et || et.nodeType !== 1 && et.nodeType !== 9 && et.nodeType !== 11 && (et.nodeType !== 8 || et.nodeValue !== " react-mount-point-unstable "))
}
function ol() {}
function pl(et, $, tt, nt, rt) {
    if (rt) {
        if (typeof nt == "function") {
            var it = nt;
            nt = function() {
                var ut = fl(ot);
                it.call(ut)
            }
        }
        var ot = dl($, nt, et, 0, null, !1, !1, "", ol);
        return et._reactRootContainer = ot,
        et[tf] = ot.current,
        rf(et.nodeType === 8 ? et.parentNode : et),
        Qk(),
        ot
    }
    for (; rt = et.lastChild; )
        et.removeChild(rt);
    if (typeof nt == "function") {
        var st = nt;
        nt = function() {
            var ut = fl(lt);
            st.call(ut)
        }
    }
    var lt = al(et, 0, !1, null, null, !1, !1, "", ol);
    return et._reactRootContainer = lt,
    et[tf] = lt.current,
    rf(et.nodeType === 8 ? et.parentNode : et),
    Qk(function() {
        el($, lt, tt, nt)
    }),
    lt
}
function ql(et, $, tt, nt, rt) {
    var it = tt._reactRootContainer;
    if (it) {
        var ot = it;
        if (typeof rt == "function") {
            var st = rt;
            rt = function() {
                var lt = fl(ot);
                st.call(lt)
            }
        }
        el($, ot, et, rt)
    } else
        ot = pl(tt, $, et, rt, nt);
    return fl(ot)
}
Dc = function(et) {
    switch (et.tag) {
    case 3:
        var $ = et.stateNode;
        if ($.current.memoizedState.isDehydrated) {
            var tt = sc($.pendingLanes);
            tt !== 0 && (Bc($, tt | 1),
            Ck($, B$1()),
            (W$1 & 6) === 0 && (aj = B$1() + 500,
            ig()))
        }
        break;
    case 13:
        var nt = Jg();
        Qk(function() {
            return Lg(et, 1, nt)
        }),
        hl(et, 1)
    }
}
;
Ec = function(et) {
    if (et.tag === 13) {
        var $ = Jg();
        Lg(et, 134217728, $),
        hl(et, 134217728)
    }
}
;
Fc = function(et) {
    if (et.tag === 13) {
        var $ = Jg()
          , tt = Kg(et);
        Lg(et, tt, $),
        hl(et, tt)
    }
}
;
Gc = function() {
    return C
}
;
Hc = function(et, $) {
    var tt = C;
    try {
        return C = et,
        $()
    } finally {
        C = tt
    }
}
;
xb = function(et, $, tt) {
    switch ($) {
    case "input":
        if ($a(et, tt),
        $ = tt.name,
        tt.type === "radio" && $ != null) {
            for (tt = et; tt.parentNode; )
                tt = tt.parentNode;
            for (tt = tt.querySelectorAll("input[name=" + JSON.stringify("" + $) + '][type="radio"]'),
            $ = 0; $ < tt.length; $++) {
                var nt = tt[$];
                if (nt !== et && nt.form === et.form) {
                    var rt = Cb(nt);
                    if (!rt)
                        throw Error(p$5(90));
                    Va(nt),
                    $a(nt, rt)
                }
            }
        }
        break;
    case "textarea":
        hb(et, tt);
        break;
    case "select":
        $ = tt.value,
        $ != null && eb(et, !!tt.multiple, $, !1)
    }
}
;
Fb = Pk;
Gb = Qk;
var rl = {
    usingClientEntryPoint: !1,
    Events: [Bb, te, Cb, Db, Eb, Pk]
}
  , sl = {
    findFiberByHostInstance: Vc,
    bundleType: 0,
    version: "18.1.0",
    rendererPackageName: "react-dom"
}
  , tl = {
    bundleType: sl.bundleType,
    version: sl.version,
    rendererPackageName: sl.rendererPackageName,
    rendererConfig: sl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ta.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(et) {
        return et = Yb(et),
        et === null ? null : et.stateNode
    },
    findFiberByHostInstance: sl.findFiberByHostInstance || il,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.1.0-next-22edb9f77-20220426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined") {
    var ul = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!ul.isDisabled && ul.supportsFiber)
        try {
            jc = ul.inject(tl),
            kc = ul
        } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = rl;
reactDom_production_min.createPortal = function(et, $) {
    var tt = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!ml($))
        throw Error(p$5(200));
    return bl(et, $, null, tt)
}
;
reactDom_production_min.createRoot = function(et, $) {
    if (!ml(et))
        throw Error(p$5(299));
    var tt = !1
      , nt = ""
      , rt = jl;
    return $ != null && ($.unstable_strictMode === !0 && (tt = !0),
    $.identifierPrefix !== void 0 && (nt = $.identifierPrefix),
    $.onRecoverableError !== void 0 && (rt = $.onRecoverableError)),
    $ = al(et, 1, !1, null, null, tt, !1, nt, rt),
    et[tf] = $.current,
    rf(et.nodeType === 8 ? et.parentNode : et),
    new kl($)
}
;
reactDom_production_min.findDOMNode = function(et) {
    if (et == null)
        return null;
    if (et.nodeType === 1)
        return et;
    var $ = et._reactInternals;
    if ($ === void 0)
        throw typeof et.render == "function" ? Error(p$5(188)) : (et = Object.keys(et).join(","),
        Error(p$5(268, et)));
    return et = Yb($),
    et = et === null ? null : et.stateNode,
    et
}
;
reactDom_production_min.flushSync = function(et) {
    return Qk(et)
}
;
reactDom_production_min.hydrate = function(et, $, tt) {
    if (!nl($))
        throw Error(p$5(200));
    return ql(null, et, $, !0, tt)
}
;
reactDom_production_min.hydrateRoot = function(et, $, tt) {
    if (!ml(et))
        throw Error(p$5(405));
    var nt = tt != null && tt.hydratedSources || null
      , rt = !1
      , it = ""
      , ot = jl;
    if (tt != null && (tt.unstable_strictMode === !0 && (rt = !0),
    tt.identifierPrefix !== void 0 && (it = tt.identifierPrefix),
    tt.onRecoverableError !== void 0 && (ot = tt.onRecoverableError)),
    $ = dl($, null, et, 1, tt != null ? tt : null, rt, !1, it, ot),
    et[tf] = $.current,
    rf(et),
    nt)
        for (et = 0; et < nt.length; et++)
            tt = nt[et],
            rt = tt._getVersion,
            rt = rt(tt._source),
            $.mutableSourceEagerHydrationData == null ? $.mutableSourceEagerHydrationData = [tt, rt] : $.mutableSourceEagerHydrationData.push(tt, rt);
    return new ll($)
}
;
reactDom_production_min.render = function(et, $, tt) {
    if (!nl($))
        throw Error(p$5(200));
    return ql(null, et, $, !1, tt)
}
;
reactDom_production_min.unmountComponentAtNode = function(et) {
    if (!nl(et))
        throw Error(p$5(40));
    return et._reactRootContainer ? (Qk(function() {
        ql(null, null, et, !1, function() {
            et._reactRootContainer = null,
            et[tf] = null
        })
    }),
    !0) : !1
}
;
reactDom_production_min.unstable_batchedUpdates = Pk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(et, $, tt, nt) {
    if (!nl(tt))
        throw Error(p$5(200));
    if (et == null || et._reactInternals === void 0)
        throw Error(p$5(38));
    return ql(et, $, tt, !1, nt)
}
;
reactDom_production_min.version = "18.1.0-next-22edb9f77-20220426";
function checkDCE() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch (et) {
            console.error(et)
        }
}
checkDCE(),
reactDom.exports = reactDom_production_min;
var m$4 = reactDom.exports;
client.createRoot = m$4.createRoot,
client.hydrateRoot = m$4.hydrateRoot;
const eventPopstate = "popstate"
  , eventPushState$1 = "pushState"
  , eventReplaceState$1 = "replaceState"
  , events = [eventPopstate, eventPushState$1, eventReplaceState$1];
var locationHook = ({base: et=""}={})=>{
    const [{path: $, search: tt},nt] = react.exports.useState(()=>({
        path: currentPathname(et),
        search: location.search
    }))
      , rt = react.exports.useRef($ + tt);
    react.exports.useEffect(()=>{
        const ot = ()=>{
            const st = currentPathname(et)
              , lt = location.search
              , ut = st + lt;
            rt.current !== ut && (rt.current = ut,
            nt({
                path: st,
                search: lt
            }))
        }
        ;
        return events.forEach(st=>addEventListener(st, ot)),
        ot(),
        ()=>events.forEach(st=>removeEventListener(st, ot))
    }
    , [et]);
    const it = react.exports.useCallback((ot,{replace: st=!1}={})=>history[st ? eventReplaceState$1 : eventPushState$1](null, "", ot[0] === "~" ? ot.slice(1) : et + ot), [et]);
    return [$, it]
}
;
if (typeof history != "undefined")
    for (const et of [eventPushState$1, eventReplaceState$1]) {
        const $ = history[et];
        history[et] = function() {
            const tt = $.apply(this, arguments)
              , nt = new Event(et);
            return nt.arguments = arguments,
            dispatchEvent(nt),
            tt
        }
    }
const currentPathname = (et,$=location.pathname)=>$.toLowerCase().indexOf(et.toLowerCase()) ? "~" + $ : $.slice(et.length) || "/";
function makeMatcher(et=pathToRegexp) {
    let $ = {};
    const tt = nt=>$[nt] || ($[nt] = et(nt));
    return (nt,rt)=>{
        const {regexp: it, keys: ot} = tt(nt || "")
          , st = it.exec(rt);
        if (!st)
            return [!1, null];
        const lt = ot.reduce((ut,ct,ht)=>(ut[ct.name] = st[ht + 1],
        ut), {});
        return [!0, lt]
    }
}
const escapeRx = et=>et.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
  , rxForSegment = (et,$,tt)=>{
    let nt = et ? "((?:[^\\/]+?)(?:\\/(?:[^\\/]+?))*)" : "([^\\/]+?)";
    return $ && tt && (nt = "(?:\\/" + nt + ")"),
    nt + ($ ? "?" : "")
}
  , pathToRegexp = et=>{
    const $ = /:([A-Za-z0-9_]+)([?+*]?)/g;
    let tt = null
      , nt = 0
      , rt = []
      , it = "";
    for (; (tt = $.exec(et)) !== null; ) {
        const [ot,st,lt] = tt
          , ut = lt === "+" || lt === "*"
          , ct = lt === "?" || lt === "*"
          , ht = ct && et[tt.index - 1] === "/" ? 1 : 0
          , ft = et.substring(nt, tt.index - ht);
        rt.push({
            name: st
        }),
        nt = $.lastIndex,
        it += escapeRx(ft) + rxForSegment(ut, ct, ht)
    }
    return it += escapeRx(et.substring(nt)),
    {
        keys: rt,
        regexp: new RegExp("^" + it + "(?:\\/)?$","i")
    }
}
  , RouterCtx = react.exports.createContext({})
  , buildRouter = ({hook: et=locationHook, base: $="", matcher: tt=makeMatcher()}={})=>({
    hook: et,
    base: $,
    matcher: tt
})
  , useRouter = ()=>{
    const et = react.exports.useContext(RouterCtx);
    return et.v || (et.v = buildRouter())
}
  , useLocation = ()=>{
    const et = useRouter();
    return et.hook(et)
}
  , useNavigate = et=>{
    const $ = react.exports.useRef()
      , [,tt] = useLocation();
    return $.current = ()=>tt(et.to || et.href, et),
    $
}
  , Link = et=>{
    const $ = useNavigate(et)
      , {base: tt} = useRouter();
    let {to: nt, href: rt=nt, children: it, onClick: ot} = et;
    const st = react.exports.useCallback(ct=>{
        ct.ctrlKey || ct.metaKey || ct.altKey || ct.shiftKey || ct.button !== 0 || (ct.preventDefault(),
        $.current(),
        ot && ot(ct))
    }
    , [ot])
      , lt = {
        href: rt[0] === "~" ? rt.slice(1) : tt + rt,
        onClick: st,
        to: null
    }
      , ut = react.exports.isValidElement(it) ? it : react.exports.createElement("a", et);
    return react.exports.cloneElement(ut, lt)
}
;
function shallow(et, $) {
    if (Object.is(et, $))
        return !0;
    if (typeof et != "object" || et === null || typeof $ != "object" || $ === null)
        return !1;
    const tt = Object.keys(et);
    if (tt.length !== Object.keys($).length)
        return !1;
    for (let nt = 0; nt < tt.length; nt++)
        if (!Object.prototype.hasOwnProperty.call($, tt[nt]) || !Object.is(et[tt[nt]], $[tt[nt]]))
            return !1;
    return !0
}
function toVal(et) {
    var $, tt, nt = "";
    if (typeof et == "string" || typeof et == "number")
        nt += et;
    else if (typeof et == "object")
        if (Array.isArray(et))
            for ($ = 0; $ < et.length; $++)
                et[$] && (tt = toVal(et[$])) && (nt && (nt += " "),
                nt += tt);
        else
            for ($ in et)
                et[$] && (nt && (nt += " "),
                nt += $);
    return nt
}
function clsx() {
    for (var et = 0, $, tt, nt = ""; et < arguments.length; )
        ($ = arguments[et++]) && (tt = toVal($)) && (nt && (nt += " "),
        nt += tt);
    return nt
}
let updateQueue = makeQueue();
const raf = et=>schedule(et, updateQueue);
let writeQueue = makeQueue();
raf.write = et=>schedule(et, writeQueue);
let onStartQueue = makeQueue();
raf.onStart = et=>schedule(et, onStartQueue);
let onFrameQueue = makeQueue();
raf.onFrame = et=>schedule(et, onFrameQueue);
let onFinishQueue = makeQueue();
raf.onFinish = et=>schedule(et, onFinishQueue);
let timeouts = [];
raf.setTimeout = (et,$)=>{
    let tt = raf.now() + $
      , nt = ()=>{
        let it = timeouts.findIndex(ot=>ot.cancel == nt);
        ~it && timeouts.splice(it, 1),
        pendingCount -= ~it ? 1 : 0
    }
      , rt = {
        time: tt,
        handler: et,
        cancel: nt
    };
    return timeouts.splice(findTimeout(tt), 0, rt),
    pendingCount += 1,
    start$1(),
    rt
}
;
let findTimeout = et=>~(~timeouts.findIndex($=>$.time > et) || ~timeouts.length);
raf.cancel = et=>{
    onStartQueue.delete(et),
    onFrameQueue.delete(et),
    updateQueue.delete(et),
    writeQueue.delete(et),
    onFinishQueue.delete(et)
}
;
raf.sync = et=>{
    sync = !0,
    raf.batchedUpdates(et),
    sync = !1
}
;
raf.throttle = et=>{
    let $;
    function tt() {
        try {
            et(...$)
        } finally {
            $ = null
        }
    }
    function nt(...rt) {
        $ = rt,
        raf.onStart(tt)
    }
    return nt.handler = et,
    nt.cancel = ()=>{
        onStartQueue.delete(tt),
        $ = null
    }
    ,
    nt
}
;
let nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : ()=>{}
;
raf.use = et=>nativeRaf = et;
raf.now = typeof performance != "undefined" ? ()=>performance.now() : Date.now;
raf.batchedUpdates = et=>et();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = ()=>{
    raf.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : update()
}
;
let ts = -1
  , pendingCount = 0
  , sync = !1;
function schedule(et, $) {
    sync ? ($.delete(et),
    et(0)) : ($.add(et),
    start$1())
}
function start$1() {
    ts < 0 && (ts = 0,
    raf.frameLoop !== "demand" && nativeRaf(loop))
}
function stop() {
    ts = -1
}
function loop() {
    ~ts && (nativeRaf(loop),
    raf.batchedUpdates(update))
}
function update() {
    let et = ts;
    ts = raf.now();
    let $ = findTimeout(ts);
    $ && (eachSafely(timeouts.splice(0, $), tt=>tt.handler()),
    pendingCount -= $),
    onStartQueue.flush(),
    updateQueue.flush(et ? Math.min(64, ts - et) : 16.667),
    onFrameQueue.flush(),
    writeQueue.flush(),
    onFinishQueue.flush(),
    pendingCount || stop()
}
function makeQueue() {
    let et = new Set
      , $ = et;
    return {
        add(tt) {
            pendingCount += $ == et && !et.has(tt) ? 1 : 0,
            et.add(tt)
        },
        delete(tt) {
            return pendingCount -= $ == et && et.has(tt) ? 1 : 0,
            et.delete(tt)
        },
        flush(tt) {
            $.size && (et = new Set,
            pendingCount -= $.size,
            eachSafely($, nt=>nt(tt) && et.add(nt)),
            pendingCount += et.size,
            $ = et)
        }
    }
}
function eachSafely(et, $) {
    et.forEach(tt=>{
        try {
            $(tt)
        } catch (nt) {
            raf.catch(nt)
        }
    }
    )
}
function noop$1() {}
const defineHidden = (et,$,tt)=>Object.defineProperty(et, $, {
    value: tt,
    writable: !0,
    configurable: !0
})
  , is = {
    arr: Array.isArray,
    obj: et=>!!et && et.constructor.name === "Object",
    fun: et=>typeof et == "function",
    str: et=>typeof et == "string",
    num: et=>typeof et == "number",
    und: et=>et === void 0
};
function isEqual(et, $) {
    if (is.arr(et)) {
        if (!is.arr($) || et.length !== $.length)
            return !1;
        for (let tt = 0; tt < et.length; tt++)
            if (et[tt] !== $[tt])
                return !1;
        return !0
    }
    return et === $
}
const each = (et,$)=>et.forEach($);
function eachProp(et, $, tt) {
    if (is.arr(et)) {
        for (let nt = 0; nt < et.length; nt++)
            $.call(tt, et[nt], `${nt}`);
        return
    }
    for (const nt in et)
        et.hasOwnProperty(nt) && $.call(tt, et[nt], nt)
}
const toArray = et=>is.und(et) ? [] : is.arr(et) ? et : [et];
function flush(et, $) {
    if (et.size) {
        const tt = Array.from(et);
        et.clear(),
        each(tt, $)
    }
}
const flushCalls = (et,...$)=>flush(et, tt=>tt(...$))
  , isSSR$1 = ()=>typeof window == "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
let createStringInterpolator$1, to, colors$1 = null, skipAnimation = !1, willAdvance = noop$1;
const assign = et=>{
    et.to && (to = et.to),
    et.now && (raf.now = et.now),
    et.colors !== void 0 && (colors$1 = et.colors),
    et.skipAnimation != null && (skipAnimation = et.skipAnimation),
    et.createStringInterpolator && (createStringInterpolator$1 = et.createStringInterpolator),
    et.requestAnimationFrame && raf.use(et.requestAnimationFrame),
    et.batchedUpdates && (raf.batchedUpdates = et.batchedUpdates),
    et.willAdvance && (willAdvance = et.willAdvance),
    et.frameLoop && (raf.frameLoop = et.frameLoop)
}
;
var globals = Object.freeze({
    __proto__: null,
    get createStringInterpolator() {
        return createStringInterpolator$1
    },
    get to() {
        return to
    },
    get colors() {
        return colors$1
    },
    get skipAnimation() {
        return skipAnimation
    },
    get willAdvance() {
        return willAdvance
    },
    assign
});
const startQueue = new Set;
let currentFrame = []
  , prevFrame = []
  , priority = 0;
const frameLoop = {
    get idle() {
        return !startQueue.size && !currentFrame.length
    },
    start(et) {
        priority > et.priority ? (startQueue.add(et),
        raf.onStart(flushStartQueue)) : (startSafely(et),
        raf(advance))
    },
    advance,
    sort(et) {
        if (priority)
            raf.onFrame(()=>frameLoop.sort(et));
        else {
            const $ = currentFrame.indexOf(et);
            ~$ && (currentFrame.splice($, 1),
            startUnsafely(et))
        }
    },
    clear() {
        currentFrame = [],
        startQueue.clear()
    }
};
function flushStartQueue() {
    startQueue.forEach(startSafely),
    startQueue.clear(),
    raf(advance)
}
function startSafely(et) {
    currentFrame.includes(et) || startUnsafely(et)
}
function startUnsafely(et) {
    currentFrame.splice(findIndex(currentFrame, $=>$.priority > et.priority), 0, et)
}
function advance(et) {
    const $ = prevFrame;
    for (let tt = 0; tt < currentFrame.length; tt++) {
        const nt = currentFrame[tt];
        priority = nt.priority,
        nt.idle || (willAdvance(nt),
        nt.advance(et),
        nt.idle || $.push(nt))
    }
    return priority = 0,
    prevFrame = currentFrame,
    prevFrame.length = 0,
    currentFrame = $,
    currentFrame.length > 0
}
function findIndex(et, $) {
    const tt = et.findIndex($);
    return tt < 0 ? et.length : tt
}
const colors = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
}
  , NUMBER = "[-+]?\\d*\\.?\\d+"
  , PERCENTAGE = NUMBER + "%";
function call(...et) {
    return "\\(\\s*(" + et.join(")\\s*,\\s*(") + ")\\s*\\)"
}
const rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER))
  , rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER))
  , hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE))
  , hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER))
  , hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/
  , hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/
  , hex6 = /^#([0-9a-fA-F]{6})$/
  , hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(et) {
    let $;
    return typeof et == "number" ? et >>> 0 === et && et >= 0 && et <= 4294967295 ? et : null : ($ = hex6.exec(et)) ? parseInt($[1] + "ff", 16) >>> 0 : colors$1 && colors$1[et] !== void 0 ? colors$1[et] : ($ = rgb.exec(et)) ? (parse255($[1]) << 24 | parse255($[2]) << 16 | parse255($[3]) << 8 | 255) >>> 0 : ($ = rgba.exec(et)) ? (parse255($[1]) << 24 | parse255($[2]) << 16 | parse255($[3]) << 8 | parse1($[4])) >>> 0 : ($ = hex3.exec(et)) ? parseInt($[1] + $[1] + $[2] + $[2] + $[3] + $[3] + "ff", 16) >>> 0 : ($ = hex8.exec(et)) ? parseInt($[1], 16) >>> 0 : ($ = hex4.exec(et)) ? parseInt($[1] + $[1] + $[2] + $[2] + $[3] + $[3] + $[4] + $[4], 16) >>> 0 : ($ = hsl.exec(et)) ? (hslToRgb(parse360($[1]), parsePercentage($[2]), parsePercentage($[3])) | 255) >>> 0 : ($ = hsla.exec(et)) ? (hslToRgb(parse360($[1]), parsePercentage($[2]), parsePercentage($[3])) | parse1($[4])) >>> 0 : null
}
function hue2rgb$1(et, $, tt) {
    return tt < 0 && (tt += 1),
    tt > 1 && (tt -= 1),
    tt < 1 / 6 ? et + ($ - et) * 6 * tt : tt < 1 / 2 ? $ : tt < 2 / 3 ? et + ($ - et) * (2 / 3 - tt) * 6 : et
}
function hslToRgb(et, $, tt) {
    const nt = tt < .5 ? tt * (1 + $) : tt + $ - tt * $
      , rt = 2 * tt - nt
      , it = hue2rgb$1(rt, nt, et + 1 / 3)
      , ot = hue2rgb$1(rt, nt, et)
      , st = hue2rgb$1(rt, nt, et - 1 / 3);
    return Math.round(it * 255) << 24 | Math.round(ot * 255) << 16 | Math.round(st * 255) << 8
}
function parse255(et) {
    const $ = parseInt(et, 10);
    return $ < 0 ? 0 : $ > 255 ? 255 : $
}
function parse360(et) {
    return (parseFloat(et) % 360 + 360) % 360 / 360
}
function parse1(et) {
    const $ = parseFloat(et);
    return $ < 0 ? 0 : $ > 1 ? 255 : Math.round($ * 255)
}
function parsePercentage(et) {
    const $ = parseFloat(et);
    return $ < 0 ? 0 : $ > 100 ? 1 : $ / 100
}
function colorToRgba(et) {
    let $ = normalizeColor(et);
    if ($ === null)
        return et;
    $ = $ || 0;
    let tt = ($ & 4278190080) >>> 24
      , nt = ($ & 16711680) >>> 16
      , rt = ($ & 65280) >>> 8
      , it = ($ & 255) / 255;
    return `rgba(${tt}, ${nt}, ${rt}, ${it})`
}
const createInterpolator = (et,$,tt)=>{
    if (is.fun(et))
        return et;
    if (is.arr(et))
        return createInterpolator({
            range: et,
            output: $,
            extrapolate: tt
        });
    if (is.str(et.output[0]))
        return createStringInterpolator$1(et);
    const nt = et
      , rt = nt.output
      , it = nt.range || [0, 1]
      , ot = nt.extrapolateLeft || nt.extrapolate || "extend"
      , st = nt.extrapolateRight || nt.extrapolate || "extend"
      , lt = nt.easing || (ut=>ut);
    return ut=>{
        const ct = findRange(ut, it);
        return interpolate(ut, it[ct], it[ct + 1], rt[ct], rt[ct + 1], lt, ot, st, nt.map)
    }
}
;
function interpolate(et, $, tt, nt, rt, it, ot, st, lt) {
    let ut = lt ? lt(et) : et;
    if (ut < $) {
        if (ot === "identity")
            return ut;
        ot === "clamp" && (ut = $)
    }
    if (ut > tt) {
        if (st === "identity")
            return ut;
        st === "clamp" && (ut = tt)
    }
    return nt === rt ? nt : $ === tt ? et <= $ ? nt : rt : ($ === -1 / 0 ? ut = -ut : tt === 1 / 0 ? ut = ut - $ : ut = (ut - $) / (tt - $),
    ut = it(ut),
    nt === -1 / 0 ? ut = -ut : rt === 1 / 0 ? ut = ut + nt : ut = ut * (rt - nt) + nt,
    ut)
}
function findRange(et, $) {
    for (var tt = 1; tt < $.length - 1 && !($[tt] >= et); ++tt)
        ;
    return tt - 1
}
function _extends$2() {
    return _extends$2 = Object.assign || function(et) {
        for (var $ = 1; $ < arguments.length; $++) {
            var tt = arguments[$];
            for (var nt in tt)
                Object.prototype.hasOwnProperty.call(tt, nt) && (et[nt] = tt[nt])
        }
        return et
    }
    ,
    _extends$2.apply(this, arguments)
}
const $get = Symbol.for("FluidValue.get")
  , $observers = Symbol.for("FluidValue.observers")
  , hasFluidValue = et=>Boolean(et && et[$get])
  , getFluidValue = et=>et && et[$get] ? et[$get]() : et
  , getFluidObservers = et=>et[$observers] || null;
function callFluidObserver(et, $) {
    et.eventObserved ? et.eventObserved($) : et($)
}
function callFluidObservers(et, $) {
    let tt = et[$observers];
    tt && tt.forEach(nt=>{
        callFluidObserver(nt, $)
    }
    )
}
class FluidValue {
    constructor($) {
        if (this[$get] = void 0,
        this[$observers] = void 0,
        !$ && !($ = this.get))
            throw Error("Unknown getter");
        setFluidGetter(this, $)
    }
}
const setFluidGetter = (et,$)=>setHidden(et, $get, $);
function addFluidObserver(et, $) {
    if (et[$get]) {
        let tt = et[$observers];
        tt || setHidden(et, $observers, tt = new Set),
        tt.has($) || (tt.add($),
        et.observerAdded && et.observerAdded(tt.size, $))
    }
    return $
}
function removeFluidObserver(et, $) {
    let tt = et[$observers];
    if (tt && tt.has($)) {
        const nt = tt.size - 1;
        nt ? tt.delete($) : et[$observers] = null,
        et.observerRemoved && et.observerRemoved(nt, $)
    }
}
const setHidden = (et,$,tt)=>Object.defineProperty(et, $, {
    value: tt,
    writable: !0,
    configurable: !0
})
  , numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g
  , colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi
  , unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`,"i")
  , rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi
  , cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/
  , variableToRgba = et=>{
    const [$,tt] = parseCSSVariable(et);
    if (!$ || isSSR$1())
        return et;
    const nt = window.getComputedStyle(document.documentElement).getPropertyValue($);
    if (nt)
        return nt.trim();
    if (tt && tt.startsWith("--")) {
        const rt = window.getComputedStyle(document.documentElement).getPropertyValue(tt);
        return rt || et
    } else {
        if (tt && cssVariableRegex.test(tt))
            return variableToRgba(tt);
        if (tt)
            return tt
    }
    return et
}
  , parseCSSVariable = et=>{
    const $ = cssVariableRegex.exec(et);
    if (!$)
        return [, ];
    const [,tt,nt] = $;
    return [tt, nt]
}
;
let namedColorRegex;
const rgbaRound = (et,$,tt,nt,rt)=>`rgba(${Math.round($)}, ${Math.round(tt)}, ${Math.round(nt)}, ${rt})`
  , createStringInterpolator = et=>{
    namedColorRegex || (namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`,"g") : /^\b$/);
    const $ = et.output.map(it=>getFluidValue(it).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba))
      , tt = $.map(it=>it.match(numberRegex).map(Number))
      , rt = tt[0].map((it,ot)=>tt.map(st=>{
        if (!(ot in st))
            throw Error('The arity of each "output" value must be equal');
        return st[ot]
    }
    )).map(it=>createInterpolator(_extends$2({}, et, {
        output: it
    })));
    return it=>{
        var ot;
        const st = !unitRegex.test($[0]) && ((ot = $.find(ut=>unitRegex.test(ut))) == null ? void 0 : ot.replace(numberRegex, ""));
        let lt = 0;
        return $[0].replace(numberRegex, ()=>`${rt[lt++](it)}${st || ""}`).replace(rgbaRegex, rgbaRound)
    }
}
  , prefix = "react-spring: "
  , once = et=>{
    const $ = et;
    let tt = !1;
    if (typeof $ != "function")
        throw new TypeError(`${prefix}once requires a function parameter`);
    return (...nt)=>{
        tt || ($(...nt),
        tt = !0)
    }
}
  , warnInterpolate = once(console.warn);
function deprecateInterpolate() {
    warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`)
}
const warnDirectCall = once(console.warn);
function deprecateDirectCall() {
    warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`)
}
function isAnimatedString(et) {
    return is.str(et) && (et[0] == "#" || /\d/.test(et) || !isSSR$1() && cssVariableRegex.test(et) || et in (colors$1 || {}))
}
const useLayoutEffect = typeof window != "undefined" && window.document && window.document.createElement ? react.exports.useLayoutEffect : react.exports.useEffect
  , useIsMounted = ()=>{
    const et = react.exports.useRef(!1);
    return useLayoutEffect(()=>(et.current = !0,
    ()=>{
        et.current = !1
    }
    ), []),
    et
}
;
function useForceUpdate() {
    const et = react.exports.useState()[1]
      , $ = useIsMounted();
    return ()=>{
        $.current && et(Math.random())
    }
}
function useMemoOne(et, $) {
    const [tt] = react.exports.useState(()=>({
        inputs: $,
        result: et()
    }))
      , nt = react.exports.useRef()
      , rt = nt.current;
    let it = rt;
    return it ? Boolean($ && it.inputs && areInputsEqual($, it.inputs)) || (it = {
        inputs: $,
        result: et()
    }) : it = tt,
    react.exports.useEffect(()=>{
        nt.current = it,
        rt == tt && (tt.inputs = tt.result = void 0)
    }
    , [it]),
    it.result
}
function areInputsEqual(et, $) {
    if (et.length !== $.length)
        return !1;
    for (let tt = 0; tt < et.length; tt++)
        if (et[tt] !== $[tt])
            return !1;
    return !0
}
const useOnce = et=>react.exports.useEffect(et, emptyDeps)
  , emptyDeps = [];
function usePrev(et) {
    const $ = react.exports.useRef();
    return react.exports.useEffect(()=>{
        $.current = et
    }
    ),
    $.current
}
const $node = Symbol.for("Animated:node")
  , isAnimated = et=>!!et && et[$node] === et
  , getAnimated = et=>et && et[$node]
  , setAnimated = (et,$)=>defineHidden(et, $node, $)
  , getPayload = et=>et && et[$node] && et[$node].getPayload();
class Animated {
    constructor() {
        this.payload = void 0,
        setAnimated(this, this)
    }
    getPayload() {
        return this.payload || []
    }
}
class AnimatedValue extends Animated {
    constructor($) {
        super(),
        this.done = !0,
        this.elapsedTime = void 0,
        this.lastPosition = void 0,
        this.lastVelocity = void 0,
        this.v0 = void 0,
        this.durationProgress = 0,
        this._value = $,
        is.num(this._value) && (this.lastPosition = this._value)
    }
    static create($) {
        return new AnimatedValue($)
    }
    getPayload() {
        return [this]
    }
    getValue() {
        return this._value
    }
    setValue($, tt) {
        return is.num($) && (this.lastPosition = $,
        tt && ($ = Math.round($ / tt) * tt,
        this.done && (this.lastPosition = $))),
        this._value === $ ? !1 : (this._value = $,
        !0)
    }
    reset() {
        const {done: $} = this;
        this.done = !1,
        is.num(this._value) && (this.elapsedTime = 0,
        this.durationProgress = 0,
        this.lastPosition = this._value,
        $ && (this.lastVelocity = null),
        this.v0 = null)
    }
}
class AnimatedString extends AnimatedValue {
    constructor($) {
        super(0),
        this._string = null,
        this._toString = void 0,
        this._toString = createInterpolator({
            output: [$, $]
        })
    }
    static create($) {
        return new AnimatedString($)
    }
    getValue() {
        let $ = this._string;
        return $ == null ? this._string = this._toString(this._value) : $
    }
    setValue($) {
        if (is.str($)) {
            if ($ == this._string)
                return !1;
            this._string = $,
            this._value = 1
        } else if (super.setValue($))
            this._string = null;
        else
            return !1;
        return !0
    }
    reset($) {
        $ && (this._toString = createInterpolator({
            output: [this.getValue(), $]
        })),
        this._value = 0,
        super.reset()
    }
}
const TreeContext = {
    dependencies: null
};
class AnimatedObject extends Animated {
    constructor($) {
        super(),
        this.source = $,
        this.setValue($)
    }
    getValue($) {
        const tt = {};
        return eachProp(this.source, (nt,rt)=>{
            isAnimated(nt) ? tt[rt] = nt.getValue($) : hasFluidValue(nt) ? tt[rt] = getFluidValue(nt) : $ || (tt[rt] = nt)
        }
        ),
        tt
    }
    setValue($) {
        this.source = $,
        this.payload = this._makePayload($)
    }
    reset() {
        this.payload && each(this.payload, $=>$.reset())
    }
    _makePayload($) {
        if ($) {
            const tt = new Set;
            return eachProp($, this._addToPayload, tt),
            Array.from(tt)
        }
    }
    _addToPayload($) {
        TreeContext.dependencies && hasFluidValue($) && TreeContext.dependencies.add($);
        const tt = getPayload($);
        tt && each(tt, nt=>this.add(nt))
    }
}
class AnimatedArray extends AnimatedObject {
    constructor($) {
        super($)
    }
    static create($) {
        return new AnimatedArray($)
    }
    getValue() {
        return this.source.map($=>$.getValue())
    }
    setValue($) {
        const tt = this.getPayload();
        return $.length == tt.length ? tt.map((nt,rt)=>nt.setValue($[rt])).some(Boolean) : (super.setValue($.map(makeAnimated)),
        !0)
    }
}
function makeAnimated(et) {
    return (isAnimatedString(et) ? AnimatedString : AnimatedValue).create(et)
}
function getAnimatedType(et) {
    const $ = getAnimated(et);
    return $ ? $.constructor : is.arr(et) ? AnimatedArray : isAnimatedString(et) ? AnimatedString : AnimatedValue
}
function _extends$1() {
    return _extends$1 = Object.assign || function(et) {
        for (var $ = 1; $ < arguments.length; $++) {
            var tt = arguments[$];
            for (var nt in tt)
                Object.prototype.hasOwnProperty.call(tt, nt) && (et[nt] = tt[nt])
        }
        return et
    }
    ,
    _extends$1.apply(this, arguments)
}
const withAnimated = (et,$)=>{
    const tt = !is.fun(et) || et.prototype && et.prototype.isReactComponent;
    return react.exports.forwardRef((nt,rt)=>{
        const it = react.exports.useRef(null)
          , ot = tt && react.exports.useCallback(vt=>{
            it.current = updateRef(rt, vt)
        }
        , [rt])
          , [st,lt] = getAnimatedState(nt, $)
          , ut = useForceUpdate()
          , ct = ()=>{
            const vt = it.current;
            if (tt && !vt)
                return;
            (vt ? $.applyAnimatedValues(vt, st.getValue(!0)) : !1) === !1 && ut()
        }
          , ht = new PropsObserver(ct,lt)
          , ft = react.exports.useRef();
        useLayoutEffect(()=>(ft.current = ht,
        each(lt, vt=>addFluidObserver(vt, ht)),
        ()=>{
            ft.current && (each(ft.current.deps, vt=>removeFluidObserver(vt, ft.current)),
            raf.cancel(ft.current.update))
        }
        )),
        react.exports.useEffect(ct, []),
        useOnce(()=>()=>{
            const vt = ft.current;
            each(vt.deps, yt=>removeFluidObserver(yt, vt))
        }
        );
        const gt = $.getComponentProps(st.getValue());
        return react.exports.createElement(et, _extends$1({}, gt, {
            ref: ot
        }))
    }
    )
}
;
class PropsObserver {
    constructor($, tt) {
        this.update = $,
        this.deps = tt
    }
    eventObserved($) {
        $.type == "change" && raf.write(this.update)
    }
}
function getAnimatedState(et, $) {
    const tt = new Set;
    return TreeContext.dependencies = tt,
    et.style && (et = _extends$1({}, et, {
        style: $.createAnimatedStyle(et.style)
    })),
    et = new AnimatedObject(et),
    TreeContext.dependencies = null,
    [et, tt]
}
function updateRef(et, $) {
    return et && (is.fun(et) ? et($) : et.current = $),
    $
}
const cacheKey = Symbol.for("AnimatedComponent")
  , createHost = (et,{applyAnimatedValues: $=()=>!1, createAnimatedStyle: tt=rt=>new AnimatedObject(rt), getComponentProps: nt=rt=>rt}={})=>{
    const rt = {
        applyAnimatedValues: $,
        createAnimatedStyle: tt,
        getComponentProps: nt
    }
      , it = ot=>{
        const st = getDisplayName(ot) || "Anonymous";
        return is.str(ot) ? ot = it[ot] || (it[ot] = withAnimated(ot, rt)) : ot = ot[cacheKey] || (ot[cacheKey] = withAnimated(ot, rt)),
        ot.displayName = `Animated(${st})`,
        ot
    }
    ;
    return eachProp(et, (ot,st)=>{
        is.arr(et) && (st = getDisplayName(ot)),
        it[st] = it(ot)
    }
    ),
    {
        animated: it
    }
}
  , getDisplayName = et=>is.str(et) ? et : et && is.str(et.displayName) ? et.displayName : is.fun(et) && et.name || null;
function _extends() {
    return _extends = Object.assign || function(et) {
        for (var $ = 1; $ < arguments.length; $++) {
            var tt = arguments[$];
            for (var nt in tt)
                Object.prototype.hasOwnProperty.call(tt, nt) && (et[nt] = tt[nt])
        }
        return et
    }
    ,
    _extends.apply(this, arguments)
}
function callProp(et, ...$) {
    return is.fun(et) ? et(...$) : et
}
const matchProp = (et,$)=>et === !0 || !!($ && et && (is.fun(et) ? et($) : toArray(et).includes($)))
  , resolveProp = (et,$)=>is.obj(et) ? $ && et[$] : et
  , getDefaultProp = (et,$)=>et.default === !0 ? et[$] : et.default ? et.default[$] : void 0
  , noopTransform = et=>et
  , getDefaultProps = (et,$=noopTransform)=>{
    let tt = DEFAULT_PROPS;
    et.default && et.default !== !0 && (et = et.default,
    tt = Object.keys(et));
    const nt = {};
    for (const rt of tt) {
        const it = $(et[rt], rt);
        is.und(it) || (nt[rt] = it)
    }
    return nt
}
  , DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"]
  , RESERVED_PROPS = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    keys: 1,
    callId: 1,
    parentId: 1
};
function getForwardProps(et) {
    const $ = {};
    let tt = 0;
    if (eachProp(et, (nt,rt)=>{
        RESERVED_PROPS[rt] || ($[rt] = nt,
        tt++)
    }
    ),
    tt)
        return $
}
function inferTo(et) {
    const $ = getForwardProps(et);
    if ($) {
        const tt = {
            to: $
        };
        return eachProp(et, (nt,rt)=>rt in $ || (tt[rt] = nt)),
        tt
    }
    return _extends({}, et)
}
function computeGoal(et) {
    return et = getFluidValue(et),
    is.arr(et) ? et.map(computeGoal) : isAnimatedString(et) ? globals.createStringInterpolator({
        range: [0, 1],
        output: [et, et]
    })(1) : et
}
function hasProps(et) {
    for (const $ in et)
        return !0;
    return !1
}
function isAsyncTo(et) {
    return is.fun(et) || is.arr(et) && is.obj(et[0])
}
function detachRefs(et, $) {
    var tt;
    (tt = et.ref) == null || tt.delete(et),
    $ == null || $.delete(et)
}
function replaceRef(et, $) {
    if ($ && et.ref !== $) {
        var tt;
        (tt = et.ref) == null || tt.delete(et),
        $.add(et),
        et.ref = $
    }
}
const config = {
    default: {
        tension: 170,
        friction: 26
    },
    gentle: {
        tension: 120,
        friction: 14
    },
    wobbly: {
        tension: 180,
        friction: 12
    },
    stiff: {
        tension: 210,
        friction: 20
    },
    slow: {
        tension: 280,
        friction: 60
    },
    molasses: {
        tension: 280,
        friction: 120
    }
}
  , c1 = 1.70158
  , c2 = c1 * 1.525
  , c3 = c1 + 1
  , c4 = 2 * Math.PI / 3
  , c5 = 2 * Math.PI / 4.5
  , bounceOut = et=>et < 1 / 2.75 ? 7.5625 * et * et : et < 2 / 2.75 ? 7.5625 * (et -= 1.5 / 2.75) * et + .75 : et < 2.5 / 2.75 ? 7.5625 * (et -= 2.25 / 2.75) * et + .9375 : 7.5625 * (et -= 2.625 / 2.75) * et + .984375
  , easings = {
    linear: et=>et,
    easeInQuad: et=>et * et,
    easeOutQuad: et=>1 - (1 - et) * (1 - et),
    easeInOutQuad: et=>et < .5 ? 2 * et * et : 1 - Math.pow(-2 * et + 2, 2) / 2,
    easeInCubic: et=>et * et * et,
    easeOutCubic: et=>1 - Math.pow(1 - et, 3),
    easeInOutCubic: et=>et < .5 ? 4 * et * et * et : 1 - Math.pow(-2 * et + 2, 3) / 2,
    easeInQuart: et=>et * et * et * et,
    easeOutQuart: et=>1 - Math.pow(1 - et, 4),
    easeInOutQuart: et=>et < .5 ? 8 * et * et * et * et : 1 - Math.pow(-2 * et + 2, 4) / 2,
    easeInQuint: et=>et * et * et * et * et,
    easeOutQuint: et=>1 - Math.pow(1 - et, 5),
    easeInOutQuint: et=>et < .5 ? 16 * et * et * et * et * et : 1 - Math.pow(-2 * et + 2, 5) / 2,
    easeInSine: et=>1 - Math.cos(et * Math.PI / 2),
    easeOutSine: et=>Math.sin(et * Math.PI / 2),
    easeInOutSine: et=>-(Math.cos(Math.PI * et) - 1) / 2,
    easeInExpo: et=>et === 0 ? 0 : Math.pow(2, 10 * et - 10),
    easeOutExpo: et=>et === 1 ? 1 : 1 - Math.pow(2, -10 * et),
    easeInOutExpo: et=>et === 0 ? 0 : et === 1 ? 1 : et < .5 ? Math.pow(2, 20 * et - 10) / 2 : (2 - Math.pow(2, -20 * et + 10)) / 2,
    easeInCirc: et=>1 - Math.sqrt(1 - Math.pow(et, 2)),
    easeOutCirc: et=>Math.sqrt(1 - Math.pow(et - 1, 2)),
    easeInOutCirc: et=>et < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * et, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * et + 2, 2)) + 1) / 2,
    easeInBack: et=>c3 * et * et * et - c1 * et * et,
    easeOutBack: et=>1 + c3 * Math.pow(et - 1, 3) + c1 * Math.pow(et - 1, 2),
    easeInOutBack: et=>et < .5 ? Math.pow(2 * et, 2) * ((c2 + 1) * 2 * et - c2) / 2 : (Math.pow(2 * et - 2, 2) * ((c2 + 1) * (et * 2 - 2) + c2) + 2) / 2,
    easeInElastic: et=>et === 0 ? 0 : et === 1 ? 1 : -Math.pow(2, 10 * et - 10) * Math.sin((et * 10 - 10.75) * c4),
    easeOutElastic: et=>et === 0 ? 0 : et === 1 ? 1 : Math.pow(2, -10 * et) * Math.sin((et * 10 - .75) * c4) + 1,
    easeInOutElastic: et=>et === 0 ? 0 : et === 1 ? 1 : et < .5 ? -(Math.pow(2, 20 * et - 10) * Math.sin((20 * et - 11.125) * c5)) / 2 : Math.pow(2, -20 * et + 10) * Math.sin((20 * et - 11.125) * c5) / 2 + 1,
    easeInBounce: et=>1 - bounceOut(1 - et),
    easeOutBounce: bounceOut,
    easeInOutBounce: et=>et < .5 ? (1 - bounceOut(1 - 2 * et)) / 2 : (1 + bounceOut(2 * et - 1)) / 2
}
  , defaults = _extends({}, config.default, {
    mass: 1,
    damping: 1,
    easing: easings.linear,
    clamp: !1
});
class AnimationConfig {
    constructor() {
        this.tension = void 0,
        this.friction = void 0,
        this.frequency = void 0,
        this.damping = void 0,
        this.mass = void 0,
        this.velocity = 0,
        this.restVelocity = void 0,
        this.precision = void 0,
        this.progress = void 0,
        this.duration = void 0,
        this.easing = void 0,
        this.clamp = void 0,
        this.bounce = void 0,
        this.decay = void 0,
        this.round = void 0,
        Object.assign(this, defaults)
    }
}
function mergeConfig(et, $, tt) {
    tt && (tt = _extends({}, tt),
    sanitizeConfig(tt, $),
    $ = _extends({}, tt, $)),
    sanitizeConfig(et, $),
    Object.assign(et, $);
    for (const ot in defaults)
        et[ot] == null && (et[ot] = defaults[ot]);
    let {mass: nt, frequency: rt, damping: it} = et;
    return is.und(rt) || (rt < .01 && (rt = .01),
    it < 0 && (it = 0),
    et.tension = Math.pow(2 * Math.PI / rt, 2) * nt,
    et.friction = 4 * Math.PI * it * nt / rt),
    et
}
function sanitizeConfig(et, $) {
    if (!is.und($.decay))
        et.duration = void 0;
    else {
        const tt = !is.und($.tension) || !is.und($.friction);
        (tt || !is.und($.frequency) || !is.und($.damping) || !is.und($.mass)) && (et.duration = void 0,
        et.decay = void 0),
        tt && (et.frequency = void 0)
    }
}
const emptyArray = [];
class Animation {
    constructor() {
        this.changed = !1,
        this.values = emptyArray,
        this.toValues = null,
        this.fromValues = emptyArray,
        this.to = void 0,
        this.from = void 0,
        this.config = new AnimationConfig,
        this.immediate = !1
    }
}
function scheduleProps(et, {key: $, props: tt, defaultProps: nt, state: rt, actions: it}) {
    return new Promise((ot,st)=>{
        var lt;
        let ut, ct, ht = matchProp((lt = tt.cancel) != null ? lt : nt == null ? void 0 : nt.cancel, $);
        if (ht)
            vt();
        else {
            is.und(tt.pause) || (rt.paused = matchProp(tt.pause, $));
            let yt = nt == null ? void 0 : nt.pause;
            yt !== !0 && (yt = rt.paused || matchProp(yt, $)),
            ut = callProp(tt.delay || 0, $),
            yt ? (rt.resumeQueue.add(gt),
            it.pause()) : (it.resume(),
            gt())
        }
        function ft() {
            rt.resumeQueue.add(gt),
            rt.timeouts.delete(ct),
            ct.cancel(),
            ut = ct.time - raf.now()
        }
        function gt() {
            ut > 0 && !globals.skipAnimation ? (rt.delayed = !0,
            ct = raf.setTimeout(vt, ut),
            rt.pauseQueue.add(ft),
            rt.timeouts.add(ct)) : vt()
        }
        function vt() {
            rt.delayed && (rt.delayed = !1),
            rt.pauseQueue.delete(ft),
            rt.timeouts.delete(ct),
            et <= (rt.cancelId || 0) && (ht = !0);
            try {
                it.start(_extends({}, tt, {
                    callId: et,
                    cancel: ht
                }), ot)
            } catch (yt) {
                st(yt)
            }
        }
    }
    )
}
const getCombinedResult = (et,$)=>$.length == 1 ? $[0] : $.some(tt=>tt.cancelled) ? getCancelledResult(et.get()) : $.every(tt=>tt.noop) ? getNoopResult(et.get()) : getFinishedResult(et.get(), $.every(tt=>tt.finished))
  , getNoopResult = et=>({
    value: et,
    noop: !0,
    finished: !0,
    cancelled: !1
})
  , getFinishedResult = (et,$,tt=!1)=>({
    value: et,
    finished: $,
    cancelled: tt
})
  , getCancelledResult = et=>({
    value: et,
    cancelled: !0,
    finished: !1
});
function runAsync(et, $, tt, nt) {
    const {callId: rt, parentId: it, onRest: ot} = $
      , {asyncTo: st, promise: lt} = tt;
    return !it && et === st && !$.reset ? lt : tt.promise = (async()=>{
        tt.asyncId = rt,
        tt.asyncTo = et;
        const ut = getDefaultProps($, (wt,mt)=>mt === "onRest" ? void 0 : wt);
        let ct, ht;
        const ft = new Promise((wt,mt)=>(ct = wt,
        ht = mt))
          , gt = wt=>{
            const mt = rt <= (tt.cancelId || 0) && getCancelledResult(nt) || rt !== tt.asyncId && getFinishedResult(nt, !1);
            if (mt)
                throw wt.result = mt,
                ht(wt),
                wt
        }
          , vt = (wt,mt)=>{
            const _t = new BailSignal
              , bt = new SkipAniamtionSignal;
            return (async()=>{
                if (globals.skipAnimation)
                    throw stopAsync(tt),
                    bt.result = getFinishedResult(nt, !1),
                    ht(bt),
                    bt;
                gt(_t);
                const Mt = is.obj(wt) ? _extends({}, wt) : _extends({}, mt, {
                    to: wt
                });
                Mt.parentId = rt,
                eachProp(ut, (At,Pt)=>{
                    is.und(Mt[Pt]) && (Mt[Pt] = At)
                }
                );
                const St = await nt.start(Mt);
                return gt(_t),
                tt.paused && await new Promise(At=>{
                    tt.resumeQueue.add(At)
                }
                ),
                St
            }
            )()
        }
        ;
        let yt;
        if (globals.skipAnimation)
            return stopAsync(tt),
            getFinishedResult(nt, !1);
        try {
            let wt;
            is.arr(et) ? wt = (async mt=>{
                for (const _t of mt)
                    await vt(_t)
            }
            )(et) : wt = Promise.resolve(et(vt, nt.stop.bind(nt))),
            await Promise.all([wt.then(ct), ft]),
            yt = getFinishedResult(nt.get(), !0, !1)
        } catch (wt) {
            if (wt instanceof BailSignal)
                yt = wt.result;
            else if (wt instanceof SkipAniamtionSignal)
                yt = wt.result;
            else
                throw wt
        } finally {
            rt == tt.asyncId && (tt.asyncId = it,
            tt.asyncTo = it ? st : void 0,
            tt.promise = it ? lt : void 0)
        }
        return is.fun(ot) && raf.batchedUpdates(()=>{
            ot(yt, nt, nt.item)
        }
        ),
        yt
    }
    )()
}
function stopAsync(et, $) {
    flush(et.timeouts, tt=>tt.cancel()),
    et.pauseQueue.clear(),
    et.resumeQueue.clear(),
    et.asyncId = et.asyncTo = et.promise = void 0,
    $ && (et.cancelId = $)
}
class BailSignal extends Error {
    constructor() {
        super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."),
        this.result = void 0
    }
}
class SkipAniamtionSignal extends Error {
    constructor() {
        super("SkipAnimationSignal"),
        this.result = void 0
    }
}
const isFrameValue = et=>et instanceof FrameValue;
let nextId$1 = 1;
class FrameValue extends FluidValue {
    constructor(...$) {
        super(...$),
        this.id = nextId$1++,
        this.key = void 0,
        this._priority = 0
    }
    get priority() {
        return this._priority
    }
    set priority($) {
        this._priority != $ && (this._priority = $,
        this._onPriorityChange($))
    }
    get() {
        const $ = getAnimated(this);
        return $ && $.getValue()
    }
    to(...$) {
        return globals.to(this, $)
    }
    interpolate(...$) {
        return deprecateInterpolate(),
        globals.to(this, $)
    }
    toJSON() {
        return this.get()
    }
    observerAdded($) {
        $ == 1 && this._attach()
    }
    observerRemoved($) {
        $ == 0 && this._detach()
    }
    _attach() {}
    _detach() {}
    _onChange($, tt=!1) {
        callFluidObservers(this, {
            type: "change",
            parent: this,
            value: $,
            idle: tt
        })
    }
    _onPriorityChange($) {
        this.idle || frameLoop.sort(this),
        callFluidObservers(this, {
            type: "priority",
            parent: this,
            priority: $
        })
    }
}
const $P = Symbol.for("SpringPhase")
  , HAS_ANIMATED = 1
  , IS_ANIMATING = 2
  , IS_PAUSED = 4
  , hasAnimated = et=>(et[$P] & HAS_ANIMATED) > 0
  , isAnimating = et=>(et[$P] & IS_ANIMATING) > 0
  , isPaused = et=>(et[$P] & IS_PAUSED) > 0
  , setActiveBit = (et,$)=>$ ? et[$P] |= IS_ANIMATING | HAS_ANIMATED : et[$P] &= ~IS_ANIMATING
  , setPausedBit = (et,$)=>$ ? et[$P] |= IS_PAUSED : et[$P] &= ~IS_PAUSED;
class SpringValue extends FrameValue {
    constructor($, tt) {
        if (super(),
        this.key = void 0,
        this.animation = new Animation,
        this.queue = void 0,
        this.defaultProps = {},
        this._state = {
            paused: !1,
            delayed: !1,
            pauseQueue: new Set,
            resumeQueue: new Set,
            timeouts: new Set
        },
        this._pendingCalls = new Set,
        this._lastCallId = 0,
        this._lastToId = 0,
        this._memoizedDuration = 0,
        !is.und($) || !is.und(tt)) {
            const nt = is.obj($) ? _extends({}, $) : _extends({}, tt, {
                from: $
            });
            is.und(nt.default) && (nt.default = !0),
            this.start(nt)
        }
    }
    get idle() {
        return !(isAnimating(this) || this._state.asyncTo) || isPaused(this)
    }
    get goal() {
        return getFluidValue(this.animation.to)
    }
    get velocity() {
        const $ = getAnimated(this);
        return $ instanceof AnimatedValue ? $.lastVelocity || 0 : $.getPayload().map(tt=>tt.lastVelocity || 0)
    }
    get hasAnimated() {
        return hasAnimated(this)
    }
    get isAnimating() {
        return isAnimating(this)
    }
    get isPaused() {
        return isPaused(this)
    }
    get isDelayed() {
        return this._state.delayed
    }
    advance($) {
        let tt = !0
          , nt = !1;
        const rt = this.animation;
        let {config: it, toValues: ot} = rt;
        const st = getPayload(rt.to);
        !st && hasFluidValue(rt.to) && (ot = toArray(getFluidValue(rt.to))),
        rt.values.forEach((ct,ht)=>{
            if (ct.done)
                return;
            const ft = ct.constructor == AnimatedString ? 1 : st ? st[ht].lastPosition : ot[ht];
            let gt = rt.immediate
              , vt = ft;
            if (!gt) {
                if (vt = ct.lastPosition,
                it.tension <= 0) {
                    ct.done = !0;
                    return
                }
                let yt = ct.elapsedTime += $;
                const wt = rt.fromValues[ht]
                  , mt = ct.v0 != null ? ct.v0 : ct.v0 = is.arr(it.velocity) ? it.velocity[ht] : it.velocity;
                let _t;
                if (is.und(it.duration))
                    if (it.decay) {
                        const bt = it.decay === !0 ? .998 : it.decay
                          , Mt = Math.exp(-(1 - bt) * yt);
                        vt = wt + mt / (1 - bt) * (1 - Mt),
                        gt = Math.abs(ct.lastPosition - vt) < .1,
                        _t = mt * Mt
                    } else {
                        _t = ct.lastVelocity == null ? mt : ct.lastVelocity;
                        const bt = it.precision || (wt == ft ? .005 : Math.min(1, Math.abs(ft - wt) * .001))
                          , Mt = it.restVelocity || bt / 10
                          , St = it.clamp ? 0 : it.bounce
                          , At = !is.und(St)
                          , Pt = wt == ft ? ct.v0 > 0 : wt < ft;
                        let Ot, Zt = !1;
                        const Nt = 1
                          , Tt = Math.ceil($ / Nt);
                        for (let Ft = 0; Ft < Tt && (Ot = Math.abs(_t) > Mt,
                        !(!Ot && (gt = Math.abs(ft - vt) <= bt,
                        gt))); ++Ft) {
                            At && (Zt = vt == ft || vt > ft == Pt,
                            Zt && (_t = -_t * St,
                            vt = ft));
                            const $t = -it.tension * 1e-6 * (vt - ft)
                              , Wt = -it.friction * .001 * _t
                              , Kt = ($t + Wt) / it.mass;
                            _t = _t + Kt * Nt,
                            vt = vt + _t * Nt
                        }
                    }
                else {
                    let bt = 1;
                    it.duration > 0 && (this._memoizedDuration !== it.duration && (this._memoizedDuration = it.duration,
                    ct.durationProgress > 0 && (ct.elapsedTime = it.duration * ct.durationProgress,
                    yt = ct.elapsedTime += $)),
                    bt = (it.progress || 0) + yt / this._memoizedDuration,
                    bt = bt > 1 ? 1 : bt < 0 ? 0 : bt,
                    ct.durationProgress = bt),
                    vt = wt + it.easing(bt) * (ft - wt),
                    _t = (vt - ct.lastPosition) / $,
                    gt = bt == 1
                }
                ct.lastVelocity = _t,
                Number.isNaN(vt) && (console.warn("Got NaN while animating:", this),
                gt = !0)
            }
            st && !st[ht].done && (gt = !1),
            gt ? ct.done = !0 : tt = !1,
            ct.setValue(vt, it.round) && (nt = !0)
        }
        );
        const lt = getAnimated(this)
          , ut = lt.getValue();
        if (tt) {
            const ct = getFluidValue(rt.to);
            (ut !== ct || nt) && !it.decay ? (lt.setValue(ct),
            this._onChange(ct)) : nt && it.decay && this._onChange(ut),
            this._stop()
        } else
            nt && this._onChange(ut)
    }
    set($) {
        return raf.batchedUpdates(()=>{
            this._stop(),
            this._focus($),
            this._set($)
        }
        ),
        this
    }
    pause() {
        this._update({
            pause: !0
        })
    }
    resume() {
        this._update({
            pause: !1
        })
    }
    finish() {
        if (isAnimating(this)) {
            const {to: $, config: tt} = this.animation;
            raf.batchedUpdates(()=>{
                this._onStart(),
                tt.decay || this._set($, !1),
                this._stop()
            }
            )
        }
        return this
    }
    update($) {
        return (this.queue || (this.queue = [])).push($),
        this
    }
    start($, tt) {
        let nt;
        return is.und($) ? (nt = this.queue || [],
        this.queue = []) : nt = [is.obj($) ? $ : _extends({}, tt, {
            to: $
        })],
        Promise.all(nt.map(rt=>this._update(rt))).then(rt=>getCombinedResult(this, rt))
    }
    stop($) {
        const {to: tt} = this.animation;
        return this._focus(this.get()),
        stopAsync(this._state, $ && this._lastCallId),
        raf.batchedUpdates(()=>this._stop(tt, $)),
        this
    }
    reset() {
        this._update({
            reset: !0
        })
    }
    eventObserved($) {
        $.type == "change" ? this._start() : $.type == "priority" && (this.priority = $.priority + 1)
    }
    _prepareNode($) {
        const tt = this.key || "";
        let {to: nt, from: rt} = $;
        nt = is.obj(nt) ? nt[tt] : nt,
        (nt == null || isAsyncTo(nt)) && (nt = void 0),
        rt = is.obj(rt) ? rt[tt] : rt,
        rt == null && (rt = void 0);
        const it = {
            to: nt,
            from: rt
        };
        return hasAnimated(this) || ($.reverse && ([nt,rt] = [rt, nt]),
        rt = getFluidValue(rt),
        is.und(rt) ? getAnimated(this) || this._set(nt) : this._set(rt)),
        it
    }
    _update($, tt) {
        let nt = _extends({}, $);
        const {key: rt, defaultProps: it} = this;
        nt.default && Object.assign(it, getDefaultProps(nt, (lt,ut)=>/^on/.test(ut) ? resolveProp(lt, rt) : lt)),
        mergeActiveFn(this, nt, "onProps"),
        sendEvent(this, "onProps", nt, this);
        const ot = this._prepareNode(nt);
        if (Object.isFrozen(this))
            throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
        const st = this._state;
        return scheduleProps(++this._lastCallId, {
            key: rt,
            props: nt,
            defaultProps: it,
            state: st,
            actions: {
                pause: ()=>{
                    isPaused(this) || (setPausedBit(this, !0),
                    flushCalls(st.pauseQueue),
                    sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this))
                }
                ,
                resume: ()=>{
                    isPaused(this) && (setPausedBit(this, !1),
                    isAnimating(this) && this._resume(),
                    flushCalls(st.resumeQueue),
                    sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this))
                }
                ,
                start: this._merge.bind(this, ot)
            }
        }).then(lt=>{
            if (nt.loop && lt.finished && !(tt && lt.noop)) {
                const ut = createLoopUpdate(nt);
                if (ut)
                    return this._update(ut, !0)
            }
            return lt
        }
        )
    }
    _merge($, tt, nt) {
        if (tt.cancel)
            return this.stop(!0),
            nt(getCancelledResult(this));
        const rt = !is.und($.to)
          , it = !is.und($.from);
        if (rt || it)
            if (tt.callId > this._lastToId)
                this._lastToId = tt.callId;
            else
                return nt(getCancelledResult(this));
        const {key: ot, defaultProps: st, animation: lt} = this
          , {to: ut, from: ct} = lt;
        let {to: ht=ut, from: ft=ct} = $;
        it && !rt && (!tt.default || is.und(ht)) && (ht = ft),
        tt.reverse && ([ht,ft] = [ft, ht]);
        const gt = !isEqual(ft, ct);
        gt && (lt.from = ft),
        ft = getFluidValue(ft);
        const vt = !isEqual(ht, ut);
        vt && this._focus(ht);
        const yt = isAsyncTo(tt.to)
          , {config: wt} = lt
          , {decay: mt, velocity: _t} = wt;
        (rt || it) && (wt.velocity = 0),
        tt.config && !yt && mergeConfig(wt, callProp(tt.config, ot), tt.config !== st.config ? callProp(st.config, ot) : void 0);
        let bt = getAnimated(this);
        if (!bt || is.und(ht))
            return nt(getFinishedResult(this, !0));
        const Mt = is.und(tt.reset) ? it && !tt.default : !is.und(ft) && matchProp(tt.reset, ot)
          , St = Mt ? ft : this.get()
          , At = computeGoal(ht)
          , Pt = is.num(At) || is.arr(At) || isAnimatedString(At)
          , Ot = !yt && (!Pt || matchProp(st.immediate || tt.immediate, ot));
        if (vt) {
            const Ft = getAnimatedType(ht);
            if (Ft !== bt.constructor)
                if (Ot)
                    bt = this._set(At);
                else
                    throw Error(`Cannot animate between ${bt.constructor.name} and ${Ft.name}, as the "to" prop suggests`)
        }
        const Zt = bt.constructor;
        let Nt = hasFluidValue(ht)
          , Tt = !1;
        if (!Nt) {
            const Ft = Mt || !hasAnimated(this) && gt;
            (vt || Ft) && (Tt = isEqual(computeGoal(St), At),
            Nt = !Tt),
            (!isEqual(lt.immediate, Ot) && !Ot || !isEqual(wt.decay, mt) || !isEqual(wt.velocity, _t)) && (Nt = !0)
        }
        if (Tt && isAnimating(this) && (lt.changed && !Mt ? Nt = !0 : Nt || this._stop(ut)),
        !yt && ((Nt || hasFluidValue(ut)) && (lt.values = bt.getPayload(),
        lt.toValues = hasFluidValue(ht) ? null : Zt == AnimatedString ? [1] : toArray(At)),
        lt.immediate != Ot && (lt.immediate = Ot,
        !Ot && !Mt && this._set(ut)),
        Nt)) {
            const {onRest: Ft} = lt;
            each(ACTIVE_EVENTS, Wt=>mergeActiveFn(this, tt, Wt));
            const $t = getFinishedResult(this, checkFinished(this, ut));
            flushCalls(this._pendingCalls, $t),
            this._pendingCalls.add(nt),
            lt.changed && raf.batchedUpdates(()=>{
                lt.changed = !Mt,
                Ft == null || Ft($t, this),
                Mt ? callProp(st.onRest, $t) : lt.onStart == null || lt.onStart($t, this)
            }
            )
        }
        Mt && this._set(St),
        yt ? nt(runAsync(tt.to, tt, this._state, this)) : Nt ? this._start() : isAnimating(this) && !vt ? this._pendingCalls.add(nt) : nt(getNoopResult(St))
    }
    _focus($) {
        const tt = this.animation;
        $ !== tt.to && (getFluidObservers(this) && this._detach(),
        tt.to = $,
        getFluidObservers(this) && this._attach())
    }
    _attach() {
        let $ = 0;
        const {to: tt} = this.animation;
        hasFluidValue(tt) && (addFluidObserver(tt, this),
        isFrameValue(tt) && ($ = tt.priority + 1)),
        this.priority = $
    }
    _detach() {
        const {to: $} = this.animation;
        hasFluidValue($) && removeFluidObserver($, this)
    }
    _set($, tt=!0) {
        const nt = getFluidValue($);
        if (!is.und(nt)) {
            const rt = getAnimated(this);
            if (!rt || !isEqual(nt, rt.getValue())) {
                const it = getAnimatedType(nt);
                !rt || rt.constructor != it ? setAnimated(this, it.create(nt)) : rt.setValue(nt),
                rt && raf.batchedUpdates(()=>{
                    this._onChange(nt, tt)
                }
                )
            }
        }
        return getAnimated(this)
    }
    _onStart() {
        const $ = this.animation;
        $.changed || ($.changed = !0,
        sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, $.to)), this))
    }
    _onChange($, tt) {
        tt || (this._onStart(),
        callProp(this.animation.onChange, $, this)),
        callProp(this.defaultProps.onChange, $, this),
        super._onChange($, tt)
    }
    _start() {
        const $ = this.animation;
        getAnimated(this).reset(getFluidValue($.to)),
        $.immediate || ($.fromValues = $.values.map(tt=>tt.lastPosition)),
        isAnimating(this) || (setActiveBit(this, !0),
        isPaused(this) || this._resume())
    }
    _resume() {
        globals.skipAnimation ? this.finish() : frameLoop.start(this)
    }
    _stop($, tt) {
        if (isAnimating(this)) {
            setActiveBit(this, !1);
            const nt = this.animation;
            each(nt.values, it=>{
                it.done = !0
            }
            ),
            nt.toValues && (nt.onChange = nt.onPause = nt.onResume = void 0),
            callFluidObservers(this, {
                type: "idle",
                parent: this
            });
            const rt = tt ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, $ != null ? $ : nt.to));
            flushCalls(this._pendingCalls, rt),
            nt.changed && (nt.changed = !1,
            sendEvent(this, "onRest", rt, this))
        }
    }
}
function checkFinished(et, $) {
    const tt = computeGoal($)
      , nt = computeGoal(et.get());
    return isEqual(nt, tt)
}
function createLoopUpdate(et, $=et.loop, tt=et.to) {
    let nt = callProp($);
    if (nt) {
        const rt = nt !== !0 && inferTo(nt)
          , it = (rt || et).reverse
          , ot = !rt || rt.reset;
        return createUpdate(_extends({}, et, {
            loop: $,
            default: !1,
            pause: void 0,
            to: !it || isAsyncTo(tt) ? tt : void 0,
            from: ot ? et.from : void 0,
            reset: ot
        }, rt))
    }
}
function createUpdate(et) {
    const {to: $, from: tt} = et = inferTo(et)
      , nt = new Set;
    return is.obj($) && findDefined($, nt),
    is.obj(tt) && findDefined(tt, nt),
    et.keys = nt.size ? Array.from(nt) : null,
    et
}
function declareUpdate(et) {
    const $ = createUpdate(et);
    return is.und($.default) && ($.default = getDefaultProps($)),
    $
}
function findDefined(et, $) {
    eachProp(et, (tt,nt)=>tt != null && $.add(nt))
}
const ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function mergeActiveFn(et, $, tt) {
    et.animation[tt] = $[tt] !== getDefaultProp($, tt) ? resolveProp($[tt], et.key) : void 0
}
function sendEvent(et, $, ...tt) {
    var nt, rt, it, ot;
    (nt = (rt = et.animation)[$]) == null || nt.call(rt, ...tt),
    (it = (ot = et.defaultProps)[$]) == null || it.call(ot, ...tt)
}
const BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
let nextId = 1;
class Controller {
    constructor($, tt) {
        this.id = nextId++,
        this.springs = {},
        this.queue = [],
        this.ref = void 0,
        this._flush = void 0,
        this._initialProps = void 0,
        this._lastAsyncId = 0,
        this._active = new Set,
        this._changed = new Set,
        this._started = !1,
        this._item = void 0,
        this._state = {
            paused: !1,
            pauseQueue: new Set,
            resumeQueue: new Set,
            timeouts: new Set
        },
        this._events = {
            onStart: new Map,
            onChange: new Map,
            onRest: new Map
        },
        this._onFrame = this._onFrame.bind(this),
        tt && (this._flush = tt),
        $ && this.start(_extends({
            default: !0
        }, $))
    }
    get idle() {
        return !this._state.asyncTo && Object.values(this.springs).every($=>$.idle && !$.isDelayed && !$.isPaused)
    }
    get item() {
        return this._item
    }
    set item($) {
        this._item = $
    }
    get() {
        const $ = {};
        return this.each((tt,nt)=>$[nt] = tt.get()),
        $
    }
    set($) {
        for (const tt in $) {
            const nt = $[tt];
            is.und(nt) || this.springs[tt].set(nt)
        }
    }
    update($) {
        return $ && this.queue.push(createUpdate($)),
        this
    }
    start($) {
        let {queue: tt} = this;
        return $ ? tt = toArray($).map(createUpdate) : this.queue = [],
        this._flush ? this._flush(this, tt) : (prepareKeys(this, tt),
        flushUpdateQueue(this, tt))
    }
    stop($, tt) {
        if ($ !== !!$ && (tt = $),
        tt) {
            const nt = this.springs;
            each(toArray(tt), rt=>nt[rt].stop(!!$))
        } else
            stopAsync(this._state, this._lastAsyncId),
            this.each(nt=>nt.stop(!!$));
        return this
    }
    pause($) {
        if (is.und($))
            this.start({
                pause: !0
            });
        else {
            const tt = this.springs;
            each(toArray($), nt=>tt[nt].pause())
        }
        return this
    }
    resume($) {
        if (is.und($))
            this.start({
                pause: !1
            });
        else {
            const tt = this.springs;
            each(toArray($), nt=>tt[nt].resume())
        }
        return this
    }
    each($) {
        eachProp(this.springs, $)
    }
    _onFrame() {
        const {onStart: $, onChange: tt, onRest: nt} = this._events
          , rt = this._active.size > 0
          , it = this._changed.size > 0;
        (rt && !this._started || it && !this._started) && (this._started = !0,
        flush($, ([lt,ut])=>{
            ut.value = this.get(),
            lt(ut, this, this._item)
        }
        ));
        const ot = !rt && this._started
          , st = it || ot && nt.size ? this.get() : null;
        it && tt.size && flush(tt, ([lt,ut])=>{
            ut.value = st,
            lt(ut, this, this._item)
        }
        ),
        ot && (this._started = !1,
        flush(nt, ([lt,ut])=>{
            ut.value = st,
            lt(ut, this, this._item)
        }
        ))
    }
    eventObserved($) {
        if ($.type == "change")
            this._changed.add($.parent),
            $.idle || this._active.add($.parent);
        else if ($.type == "idle")
            this._active.delete($.parent);
        else
            return;
        raf.onFrame(this._onFrame)
    }
}
function flushUpdateQueue(et, $) {
    return Promise.all($.map(tt=>flushUpdate(et, tt))).then(tt=>getCombinedResult(et, tt))
}
async function flushUpdate(et, $, tt) {
    const {keys: nt, to: rt, from: it, loop: ot, onRest: st, onResolve: lt} = $
      , ut = is.obj($.default) && $.default;
    ot && ($.loop = !1),
    rt === !1 && ($.to = null),
    it === !1 && ($.from = null);
    const ct = is.arr(rt) || is.fun(rt) ? rt : void 0;
    ct ? ($.to = void 0,
    $.onRest = void 0,
    ut && (ut.onRest = void 0)) : each(BATCHED_EVENTS, yt=>{
        const wt = $[yt];
        if (is.fun(wt)) {
            const mt = et._events[yt];
            $[yt] = ({finished: _t, cancelled: bt})=>{
                const Mt = mt.get(wt);
                Mt ? (_t || (Mt.finished = !1),
                bt && (Mt.cancelled = !0)) : mt.set(wt, {
                    value: null,
                    finished: _t || !1,
                    cancelled: bt || !1
                })
            }
            ,
            ut && (ut[yt] = $[yt])
        }
    }
    );
    const ht = et._state;
    $.pause === !ht.paused ? (ht.paused = $.pause,
    flushCalls($.pause ? ht.pauseQueue : ht.resumeQueue)) : ht.paused && ($.pause = !0);
    const ft = (nt || Object.keys(et.springs)).map(yt=>et.springs[yt].start($))
      , gt = $.cancel === !0 || getDefaultProp($, "cancel") === !0;
    (ct || gt && ht.asyncId) && ft.push(scheduleProps(++et._lastAsyncId, {
        props: $,
        state: ht,
        actions: {
            pause: noop$1,
            resume: noop$1,
            start(yt, wt) {
                gt ? (stopAsync(ht, et._lastAsyncId),
                wt(getCancelledResult(et))) : (yt.onRest = st,
                wt(runAsync(ct, yt, ht, et)))
            }
        }
    })),
    ht.paused && await new Promise(yt=>{
        ht.resumeQueue.add(yt)
    }
    );
    const vt = getCombinedResult(et, await Promise.all(ft));
    if (ot && vt.finished && !(tt && vt.noop)) {
        const yt = createLoopUpdate($, ot, rt);
        if (yt)
            return prepareKeys(et, [yt]),
            flushUpdate(et, yt, !0)
    }
    return lt && raf.batchedUpdates(()=>lt(vt, et, et.item)),
    vt
}
function getSprings(et, $) {
    const tt = _extends({}, et.springs);
    return $ && each(toArray($), nt=>{
        is.und(nt.keys) && (nt = createUpdate(nt)),
        is.obj(nt.to) || (nt = _extends({}, nt, {
            to: void 0
        })),
        prepareSprings(tt, nt, rt=>createSpring(rt))
    }
    ),
    setSprings(et, tt),
    tt
}
function setSprings(et, $) {
    eachProp($, (tt,nt)=>{
        et.springs[nt] || (et.springs[nt] = tt,
        addFluidObserver(tt, et))
    }
    )
}
function createSpring(et, $) {
    const tt = new SpringValue;
    return tt.key = et,
    $ && addFluidObserver(tt, $),
    tt
}
function prepareSprings(et, $, tt) {
    $.keys && each($.keys, nt=>{
        (et[nt] || (et[nt] = tt(nt)))._prepareNode($)
    }
    )
}
function prepareKeys(et, $) {
    each($, tt=>{
        prepareSprings(et.springs, tt, nt=>createSpring(nt, et))
    }
    )
}
function _objectWithoutPropertiesLoose$1(et, $) {
    if (et == null)
        return {};
    var tt = {}, nt = Object.keys(et), rt, it;
    for (it = 0; it < nt.length; it++)
        rt = nt[it],
        !($.indexOf(rt) >= 0) && (tt[rt] = et[rt]);
    return tt
}
const _excluded$3 = ["children"]
  , SpringContext = et=>{
    let {children: $} = et
      , tt = _objectWithoutPropertiesLoose$1(et, _excluded$3);
    const nt = react.exports.useContext(ctx)
      , rt = tt.pause || !!nt.pause
      , it = tt.immediate || !!nt.immediate;
    tt = useMemoOne(()=>({
        pause: rt,
        immediate: it
    }), [rt, it]);
    const {Provider: ot} = ctx;
    return react.exports.createElement(ot, {
        value: tt
    }, $)
}
  , ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(et, $) {
    return Object.assign(et, react.exports.createContext($)),
    et.Provider._context = et,
    et.Consumer._context = et,
    et
}
const SpringRef = ()=>{
    const et = []
      , $ = function(rt) {
        deprecateDirectCall();
        const it = [];
        return each(et, (ot,st)=>{
            if (is.und(rt))
                it.push(ot.start());
            else {
                const lt = tt(rt, ot, st);
                lt && it.push(ot.start(lt))
            }
        }
        ),
        it
    };
    $.current = et,
    $.add = function(nt) {
        et.includes(nt) || et.push(nt)
    }
    ,
    $.delete = function(nt) {
        const rt = et.indexOf(nt);
        ~rt && et.splice(rt, 1)
    }
    ,
    $.pause = function() {
        return each(et, nt=>nt.pause(...arguments)),
        this
    }
    ,
    $.resume = function() {
        return each(et, nt=>nt.resume(...arguments)),
        this
    }
    ,
    $.set = function(nt) {
        each(et, rt=>rt.set(nt))
    }
    ,
    $.start = function(nt) {
        const rt = [];
        return each(et, (it,ot)=>{
            if (is.und(nt))
                rt.push(it.start());
            else {
                const st = this._getProps(nt, it, ot);
                st && rt.push(it.start(st))
            }
        }
        ),
        rt
    }
    ,
    $.stop = function() {
        return each(et, nt=>nt.stop(...arguments)),
        this
    }
    ,
    $.update = function(nt) {
        return each(et, (rt,it)=>rt.update(this._getProps(nt, rt, it))),
        this
    }
    ;
    const tt = function(rt, it, ot) {
        return is.fun(rt) ? rt(ot, it) : rt
    };
    return $._getProps = tt,
    $
}
;
function useSprings(et, $, tt) {
    const nt = is.fun($) && $;
    nt && !tt && (tt = []);
    const rt = react.exports.useMemo(()=>nt || arguments.length == 3 ? SpringRef() : void 0, [])
      , it = react.exports.useRef(0)
      , ot = useForceUpdate()
      , st = react.exports.useMemo(()=>({
        ctrls: [],
        queue: [],
        flush(mt, _t) {
            const bt = getSprings(mt, _t);
            return it.current > 0 && !st.queue.length && !Object.keys(bt).some(St=>!mt.springs[St]) ? flushUpdateQueue(mt, _t) : new Promise(St=>{
                setSprings(mt, bt),
                st.queue.push(()=>{
                    St(flushUpdateQueue(mt, _t))
                }
                ),
                ot()
            }
            )
        }
    }), [])
      , lt = react.exports.useRef([...st.ctrls])
      , ut = []
      , ct = usePrev(et) || 0;
    react.exports.useMemo(()=>{
        each(lt.current.slice(et, ct), mt=>{
            detachRefs(mt, rt),
            mt.stop(!0)
        }
        ),
        lt.current.length = et,
        ht(ct, et)
    }
    , [et]),
    react.exports.useMemo(()=>{
        ht(0, Math.min(ct, et))
    }
    , tt);
    function ht(mt, _t) {
        for (let bt = mt; bt < _t; bt++) {
            const Mt = lt.current[bt] || (lt.current[bt] = new Controller(null,st.flush))
              , St = nt ? nt(bt, Mt) : $[bt];
            St && (ut[bt] = declareUpdate(St))
        }
    }
    const ft = lt.current.map((mt,_t)=>getSprings(mt, ut[_t]))
      , gt = react.exports.useContext(SpringContext)
      , vt = usePrev(gt)
      , yt = gt !== vt && hasProps(gt);
    useLayoutEffect(()=>{
        it.current++,
        st.ctrls = lt.current;
        const {queue: mt} = st;
        mt.length && (st.queue = [],
        each(mt, _t=>_t())),
        each(lt.current, (_t,bt)=>{
            rt == null || rt.add(_t),
            yt && _t.start({
                default: gt
            });
            const Mt = ut[bt];
            Mt && (replaceRef(_t, Mt.ref),
            _t.ref ? _t.queue.push(Mt) : _t.start(Mt))
        }
        )
    }
    ),
    useOnce(()=>()=>{
        each(st.ctrls, mt=>mt.stop(!0))
    }
    );
    const wt = ft.map(mt=>_extends({}, mt));
    return rt ? [wt, rt] : wt
}
function useSpring(et, $) {
    const tt = is.fun(et)
      , [[nt],rt] = useSprings(1, tt ? et : [et], tt ? $ || [] : $);
    return tt || arguments.length == 2 ? [nt, rt] : nt
}
function useTrail(et, $, tt) {
    var nt;
    const rt = is.fun($) && $;
    rt && !tt && (tt = []);
    let it = !0, ot;
    const st = useSprings(et, (ut,ct)=>{
        const ht = rt ? rt(ut, ct) : $;
        return ot = ht.ref,
        it = it && ht.reverse,
        ht
    }
    , tt || [{}])
      , lt = (nt = ot) != null ? nt : st[1];
    return useLayoutEffect(()=>{
        each(lt.current, (ut,ct)=>{
            const ht = lt.current[ct + (it ? 1 : -1)];
            ht ? ut.start({
                to: ht.springs
            }) : ut.start()
        }
        )
    }
    , tt),
    rt || arguments.length == 3 ? (lt._getProps = (ut,ct,ht)=>{
        const ft = is.fun(ut) ? ut(ht, ct) : ut;
        if (ft) {
            const gt = lt.current[ht + (ft.reverse ? 1 : -1)];
            return gt && (ft.to = gt.springs),
            ft
        }
    }
    ,
    st) : (lt.start = ut=>{
        const ct = [];
        return each(lt.current, (ht,ft)=>{
            const gt = is.fun(ut) ? ut(ft, ht) : ut
              , vt = lt.current[ft + (it ? 1 : -1)];
            vt ? ct.push(ht.start(_extends({}, gt, {
                to: vt.springs
            }))) : ct.push(ht.start(_extends({}, gt)))
        }
        ),
        ct
    }
    ,
    st[0])
}
let TransitionPhase;
(function(et) {
    et.MOUNT = "mount",
    et.ENTER = "enter",
    et.UPDATE = "update",
    et.LEAVE = "leave"
}
)(TransitionPhase || (TransitionPhase = {}));
class Interpolation extends FrameValue {
    constructor($, tt) {
        super(),
        this.key = void 0,
        this.idle = !0,
        this.calc = void 0,
        this._active = new Set,
        this.source = $,
        this.calc = createInterpolator(...tt);
        const nt = this._get()
          , rt = getAnimatedType(nt);
        setAnimated(this, rt.create(nt))
    }
    advance($) {
        const tt = this._get()
          , nt = this.get();
        isEqual(tt, nt) || (getAnimated(this).setValue(tt),
        this._onChange(tt, this.idle)),
        !this.idle && checkIdle(this._active) && becomeIdle(this)
    }
    _get() {
        const $ = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
        return this.calc(...$)
    }
    _start() {
        this.idle && !checkIdle(this._active) && (this.idle = !1,
        each(getPayload(this), $=>{
            $.done = !1
        }
        ),
        globals.skipAnimation ? (raf.batchedUpdates(()=>this.advance()),
        becomeIdle(this)) : frameLoop.start(this))
    }
    _attach() {
        let $ = 1;
        each(toArray(this.source), tt=>{
            hasFluidValue(tt) && addFluidObserver(tt, this),
            isFrameValue(tt) && (tt.idle || this._active.add(tt),
            $ = Math.max($, tt.priority + 1))
        }
        ),
        this.priority = $,
        this._start()
    }
    _detach() {
        each(toArray(this.source), $=>{
            hasFluidValue($) && removeFluidObserver($, this)
        }
        ),
        this._active.clear(),
        becomeIdle(this)
    }
    eventObserved($) {
        $.type == "change" ? $.idle ? this.advance() : (this._active.add($.parent),
        this._start()) : $.type == "idle" ? this._active.delete($.parent) : $.type == "priority" && (this.priority = toArray(this.source).reduce((tt,nt)=>Math.max(tt, (isFrameValue(nt) ? nt.priority : 0) + 1), 0))
    }
}
function isIdle(et) {
    return et.idle !== !1
}
function checkIdle(et) {
    return !et.size || Array.from(et).every(isIdle)
}
function becomeIdle(et) {
    et.idle || (et.idle = !0,
    each(getPayload(et), $=>{
        $.done = !0
    }
    ),
    callFluidObservers(et, {
        type: "idle",
        parent: et
    }))
}
globals.assign({
    createStringInterpolator,
    to: (et,$)=>new Interpolation(et,$)
});
function _objectWithoutPropertiesLoose(et, $) {
    if (et == null)
        return {};
    var tt = {}, nt = Object.keys(et), rt, it;
    for (it = 0; it < nt.length; it++)
        rt = nt[it],
        !($.indexOf(rt) >= 0) && (tt[rt] = et[rt]);
    return tt
}
const _excluded$2 = ["style", "children", "scrollTop", "scrollLeft"]
  , isCustomPropRE = /^--/;
function dangerousStyleValue(et, $) {
    return $ == null || typeof $ == "boolean" || $ === "" ? "" : typeof $ == "number" && $ !== 0 && !isCustomPropRE.test(et) && !(isUnitlessNumber.hasOwnProperty(et) && isUnitlessNumber[et]) ? $ + "px" : ("" + $).trim()
}
const attributeCache = {};
function applyAnimatedValues(et, $) {
    if (!et.nodeType || !et.setAttribute)
        return !1;
    const tt = et.nodeName === "filter" || et.parentNode && et.parentNode.nodeName === "filter"
      , nt = $
      , {style: rt, children: it, scrollTop: ot, scrollLeft: st} = nt
      , lt = _objectWithoutPropertiesLoose(nt, _excluded$2)
      , ut = Object.values(lt)
      , ct = Object.keys(lt).map(ht=>tt || et.hasAttribute(ht) ? ht : attributeCache[ht] || (attributeCache[ht] = ht.replace(/([A-Z])/g, ft=>"-" + ft.toLowerCase())));
    it !== void 0 && (et.textContent = it);
    for (let ht in rt)
        if (rt.hasOwnProperty(ht)) {
            const ft = dangerousStyleValue(ht, rt[ht]);
            isCustomPropRE.test(ht) ? et.style.setProperty(ht, ft) : et.style[ht] = ft
        }
    ct.forEach((ht,ft)=>{
        et.setAttribute(ht, ut[ft])
    }
    ),
    ot !== void 0 && (et.scrollTop = ot),
    st !== void 0 && (et.scrollLeft = st)
}
let isUnitlessNumber = {
    animationIterationCount: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
};
const prefixKey = (et,$)=>et + $.charAt(0).toUpperCase() + $.substring(1)
  , prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((et,$)=>(prefixes.forEach(tt=>et[prefixKey(tt, $)] = et[$]),
et), isUnitlessNumber);
const _excluded$1 = ["x", "y", "z"]
  , domTransforms = /^(matrix|translate|scale|rotate|skew)/
  , pxTransforms = /^(translate)/
  , degTransforms = /^(rotate|skew)/
  , addUnit = (et,$)=>is.num(et) && et !== 0 ? et + $ : et
  , isValueIdentity = (et,$)=>is.arr(et) ? et.every(tt=>isValueIdentity(tt, $)) : is.num(et) ? et === $ : parseFloat(et) === $;
class AnimatedStyle extends AnimatedObject {
    constructor($) {
        let {x: tt, y: nt, z: rt} = $
          , it = _objectWithoutPropertiesLoose($, _excluded$1);
        const ot = []
          , st = [];
        (tt || nt || rt) && (ot.push([tt || 0, nt || 0, rt || 0]),
        st.push(lt=>[`translate3d(${lt.map(ut=>addUnit(ut, "px")).join(",")})`, isValueIdentity(lt, 0)])),
        eachProp(it, (lt,ut)=>{
            if (ut === "transform")
                ot.push([lt || ""]),
                st.push(ct=>[ct, ct === ""]);
            else if (domTransforms.test(ut)) {
                if (delete it[ut],
                is.und(lt))
                    return;
                const ct = pxTransforms.test(ut) ? "px" : degTransforms.test(ut) ? "deg" : "";
                ot.push(toArray(lt)),
                st.push(ut === "rotate3d" ? ([ht,ft,gt,vt])=>[`rotate3d(${ht},${ft},${gt},${addUnit(vt, ct)})`, isValueIdentity(vt, 0)] : ht=>[`${ut}(${ht.map(ft=>addUnit(ft, ct)).join(",")})`, isValueIdentity(ht, ut.startsWith("scale") ? 1 : 0)])
            }
        }
        ),
        ot.length && (it.transform = new FluidTransform(ot,st)),
        super(it)
    }
}
class FluidTransform extends FluidValue {
    constructor($, tt) {
        super(),
        this._value = null,
        this.inputs = $,
        this.transforms = tt
    }
    get() {
        return this._value || (this._value = this._get())
    }
    _get() {
        let $ = ""
          , tt = !0;
        return each(this.inputs, (nt,rt)=>{
            const it = getFluidValue(nt[0])
              , [ot,st] = this.transforms[rt](is.arr(it) ? it : nt.map(getFluidValue));
            $ += " " + ot,
            tt = tt && st
        }
        ),
        tt ? "none" : $
    }
    observerAdded($) {
        $ == 1 && each(this.inputs, tt=>each(tt, nt=>hasFluidValue(nt) && addFluidObserver(nt, this)))
    }
    observerRemoved($) {
        $ == 0 && each(this.inputs, tt=>each(tt, nt=>hasFluidValue(nt) && removeFluidObserver(nt, this)))
    }
    eventObserved($) {
        $.type == "change" && (this._value = null),
        callFluidObservers(this, $)
    }
}
const primitives = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]
  , _excluded = ["scrollTop", "scrollLeft"];
globals.assign({
    batchedUpdates: reactDom.exports.unstable_batchedUpdates,
    createStringInterpolator,
    colors
});
const host = createHost(primitives, {
    applyAnimatedValues,
    createAnimatedStyle: et=>new AnimatedStyle(et),
    getComponentProps: et=>_objectWithoutPropertiesLoose(et, _excluded)
})
  , animated = host.animated;
var jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = react.exports
  , k$3 = Symbol.for("react.element")
  , l$3 = Symbol.for("react.fragment")
  , m$3 = Object.prototype.hasOwnProperty
  , n$4 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , p$4 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function q$4(et, $, tt) {
    var nt, rt = {}, it = null, ot = null;
    tt !== void 0 && (it = "" + tt),
    $.key !== void 0 && (it = "" + $.key),
    $.ref !== void 0 && (ot = $.ref);
    for (nt in $)
        m$3.call($, nt) && !p$4.hasOwnProperty(nt) && (rt[nt] = $[nt]);
    if (et && et.defaultProps)
        for (nt in $ = et.defaultProps,
        $)
            rt[nt] === void 0 && (rt[nt] = $[nt]);
    return {
        $$typeof: k$3,
        type: et,
        key: it,
        ref: ot,
        props: rt,
        _owner: n$4.current
    }
}
reactJsxRuntime_production_min.Fragment = l$3;
reactJsxRuntime_production_min.jsx = q$4;
reactJsxRuntime_production_min.jsxs = q$4;
jsxRuntime.exports = reactJsxRuntime_production_min;
const jsx = jsxRuntime.exports.jsx
  , jsxs = jsxRuntime.exports.jsxs
  , Fragment = jsxRuntime.exports.Fragment
  , GridView = React.forwardRef(function(et, $) {
    const lt = et
      , {children: tt, full: nt, noPadding: rt, className: it, noGap: ot} = lt
      , st = nr(lt, ["children", "full", "noPadding", "className", "noGap"]);
    return jsx(animated.div, kn(wn({
        ref: $
    }, st), {
        className: clsx("grid-view", ot && "grid-view--no-gap", nt && "grid-view--full", rt && "grid-view&--no-padding", it),
        children: tt
    }))
});
var isSSR = typeof window == "undefined"
  , DetectUA = function() {
    function et($) {
        this.userAgent = $ || (!isSSR && window.navigator ? window.navigator.userAgent : ""),
        this.isAndroidDevice = !/like android/i.test(this.userAgent) && /android/i.test(this.userAgent),
        this.iOSDevice = this.match(1, /(iphone|ipod|ipad)/i).toLowerCase(),
        !isSSR && navigator.platform === "MacIntel" && navigator.maxTouchPoints > 2 && !window.MSStream && (this.iOSDevice = "ipad")
    }
    return et.prototype.match = function($, tt) {
        var nt = this.userAgent.match(tt);
        return nt && nt.length > 1 && nt[$] || ""
    }
    ,
    Object.defineProperty(et.prototype, "isMobile", {
        get: function() {
            return !this.isTablet && (/[^-]mobi/i.test(this.userAgent) || this.iOSDevice === "iphone" || this.iOSDevice === "ipod" || this.isAndroidDevice || /nexus\s*[0-6]\s*/i.test(this.userAgent))
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(et.prototype, "isTablet", {
        get: function() {
            return /tablet/i.test(this.userAgent) && !/tablet pc/i.test(this.userAgent) || this.iOSDevice === "ipad" || this.isAndroidDevice && !/[^-]mobi/i.test(this.userAgent) || !/nexus\s*[0-6]\s*/i.test(this.userAgent) && /nexus\s*[0-9]+/i.test(this.userAgent)
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(et.prototype, "isDesktop", {
        get: function() {
            return !this.isMobile && !this.isTablet
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(et.prototype, "isMacOS", {
        get: function() {
            return /macintosh/i.test(this.userAgent) && {
                version: this.match(1, /mac os x (\d+(\.?_?\d+)+)/i).replace(/[_\s]/g, ".").split(".").map(function($) {
                    return $
                })[1]
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(et.prototype, "isWindows", {
        get: function() {
            return /windows /i.test(this.userAgent) && {
                version: this.match(1, /Windows ((NT|XP)( \d\d?.\d)?)/i)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(et.prototype, "isiOS", {
        get: function() {
            return !!this.iOSDevice && {
                version: this.match(1, /os (\d+([_\s]\d+)*) like mac os x/i).replace(/[_\s]/g, ".") || this.match(1, /version\/(\d+(\.\d+)?)/i)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(et.prototype, "isAndroid", {
        get: function() {
            return this.isAndroidDevice && {
                version: this.match(1, /android[ \/-](\d+(\.\d+)*)/i)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(et.prototype, "browser", {
        get: function() {
            var $ = this.match(1, /version\/(\d+(\.\d+)?)/i);
            return /opera/i.test(this.userAgent) ? {
                name: "Opera",
                version: $ || this.match(1, /(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
            } : /opr\/|opios/i.test(this.userAgent) ? {
                name: "Opera",
                version: this.match(1, /(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || $
            } : /SamsungBrowser/i.test(this.userAgent) ? {
                name: "Samsung Internet for Android",
                version: $ || this.match(1, /(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
            } : /yabrowser/i.test(this.userAgent) ? {
                name: "Yandex Browser",
                version: $ || this.match(1, /(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
            } : /ucbrowser/i.test(this.userAgent) ? {
                name: "UC Browser",
                version: this.match(1, /(?:ucbrowser)[\s\/](\d+(\.\d+)?)/i)
            } : /msie|trident/i.test(this.userAgent) ? {
                name: "Internet Explorer",
                version: this.match(1, /(?:msie |rv:)(\d+(\.\d+)?)/i)
            } : /(edge|edgios|edga|edg)/i.test(this.userAgent) ? {
                name: "Microsoft Edge",
                version: this.match(2, /(edge|edgios|edga|edg)\/(\d+(\.\d+)?)/i)
            } : /firefox|iceweasel|fxios/i.test(this.userAgent) ? {
                name: "Firefox",
                version: this.match(1, /(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
            } : /chromium/i.test(this.userAgent) ? {
                name: "Chromium",
                version: this.match(1, /(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || $
            } : /chrome|crios|crmo/i.test(this.userAgent) ? {
                name: "Chrome",
                version: this.match(1, /(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
            } : /safari|applewebkit/i.test(this.userAgent) ? {
                name: "Safari",
                version: $
            } : {
                name: this.match(1, /^(.*)\/(.*) /),
                version: this.match(2, /^(.*)\/(.*) /)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    et
}();
const detectUA = new DetectUA
  , userAgent = (navigator.userAgent || navigator.vendor).toLowerCase()
  , browserName = detectUA.browser.name;
class Browser {
    constructor() {
        Et(this, "isMobile", detectUA.isMobile || detectUA.isTablet);
        Et(this, "isDesktop", detectUA.isDesktop);
        Et(this, "device", this.isMobile ? "mobile" : "desktop");
        Et(this, "isAndroid", Boolean(detectUA.isAndroid));
        Et(this, "isIOS", Boolean(detectUA.isiOS));
        Et(this, "isMacOS", Boolean(detectUA.isMacOS));
        Et(this, "isWindows", Boolean(detectUA.isWindows.version !== null));
        Et(this, "isLinux", Boolean(userAgent.indexOf("linux") != -1));
        Et(this, "ua", userAgent);
        Et(this, "isEdge", browserName === "Microsoft Edge");
        Et(this, "isIE", browserName === "Internet Explorer");
        Et(this, "isFirefox", browserName === "Firefox");
        Et(this, "isChrome", browserName === "Chrome");
        Et(this, "isOpera", browserName === "Opera");
        Et(this, "isSafari", browserName === "Safari");
        Et(this, "isRetina", window.devicePixelRatio && window.devicePixelRatio >= 1.5);
        Et(this, "devicePixelRatio", window.devicePixelRatio || 1);
        Et(this, "cpuCoreCount", navigator.hardwareConcurrency || 1);
        Et(this, "baseUrl", document.location.origin);
        Et(this, "isIFrame", window.self !== window.top)
    }
}
const browser$1 = new Browser;
class Settings {
    constructor() {
        Et(this, "GLOBAL_ID", "LUSION_APP");
        Et(this, "IS_API_MODE", !1);
        Et(this, "MODEL_PATH", "/assets/models/");
        Et(this, "IMAGE_PATH", "/assets/images/");
        Et(this, "TEXTURE_PATH", "/assets/textures/");
        Et(this, "AUDIO_PATH", "/assets/audios/");
        Et(this, "RENDER_TARGET_FLOAT_TYPE", null);
        Et(this, "DATA_FLOAT_TYPE", null);
        Et(this, "USE_FLOAT_PACKING", !1);
        Et(this, "USE_WEBGL2", !0);
        Et(this, "DPR", Math.min(1.5, browser$1.devicePixelRatio) || 1);
        Et(this, "USE_PIXEL_LIMIT", !0);
        Et(this, "MAX_PIXEL_COUNT", 2560 * 1440);
        Et(this, "WEBGL_DISABLED", !1);
        Et(this, "PHYSICS_DISABLED", !1);
        Et(this, "CROSS_ORIGINS", {
            "https://example.com/": "anonymous"
        });
        Et(this, "IS_DEV", !Boolean(!0));
        Et(this, "LOG", !1);
        Et(this, "SKIP_ANIMATION", !1);
        Et(this, "LOOK_DEV_MODE", !1);
        Et(this, "ENABLE_ORBIT", !1);
        Et(this, "RESET_ALL", !1);
        Et(this, "UP_SCALE", 1);
        Et(this, "NO_REACT", !1);
        Et(this, "NO_WEBGL", !1);
        Et(this, "ENABLE_GRID", !1);
        Et(this, "SVG_FILTER_COUNT", 0);
        if (window.URLSearchParams) {
            const tt = (nt=>[...nt].reduce((rt,[it,ot])=>(rt[it] = ot === "" ? !0 : ot,
            rt), {}))(new URLSearchParams(window.location.search));
            this.override(tt)
        }
    }
    override($) {
        for (const tt in $)
            if (this[tt] !== void 0) {
                const nt = $[tt].toString();
                typeof this[tt] == "boolean" ? this[tt] = !(nt === "0" || nt === !1) : typeof this[tt] == "number" ? this[tt] = parseFloat(nt) : typeof this[tt] == "string" && (this[tt] = nt)
            }
    }
}
const settings = new Settings;
settings.IS_DEV && (window.settings = settings);
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "138"
  , MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , TOUCH = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , CullFaceNone = 0
  , CullFaceBack = 1
  , CullFaceFront = 2
  , PCFShadowMap = 1
  , PCFSoftShadowMap = 2
  , VSMShadowMap = 3
  , FrontSide = 0
  , BackSide = 1
  , DoubleSide = 2
  , FlatShading = 1
  , NoBlending = 0
  , NormalBlending = 1
  , AdditiveBlending = 2
  , SubtractiveBlending = 3
  , MultiplyBlending = 4
  , CustomBlending = 5
  , AddEquation = 100
  , SubtractEquation = 101
  , ReverseSubtractEquation = 102
  , MinEquation = 103
  , MaxEquation = 104
  , ZeroFactor = 200
  , OneFactor = 201
  , SrcColorFactor = 202
  , OneMinusSrcColorFactor = 203
  , SrcAlphaFactor = 204
  , OneMinusSrcAlphaFactor = 205
  , DstAlphaFactor = 206
  , OneMinusDstAlphaFactor = 207
  , DstColorFactor = 208
  , OneMinusDstColorFactor = 209
  , SrcAlphaSaturateFactor = 210
  , NeverDepth = 0
  , AlwaysDepth = 1
  , LessDepth = 2
  , LessEqualDepth = 3
  , EqualDepth = 4
  , GreaterEqualDepth = 5
  , GreaterDepth = 6
  , NotEqualDepth = 7
  , MultiplyOperation = 0
  , MixOperation = 1
  , AddOperation = 2
  , NoToneMapping = 0
  , LinearToneMapping = 1
  , ReinhardToneMapping = 2
  , CineonToneMapping = 3
  , ACESFilmicToneMapping = 4
  , CustomToneMapping = 5
  , UVMapping = 300
  , CubeReflectionMapping = 301
  , CubeRefractionMapping = 302
  , EquirectangularReflectionMapping = 303
  , EquirectangularRefractionMapping = 304
  , CubeUVReflectionMapping = 306
  , CubeUVRefractionMapping = 307
  , RepeatWrapping = 1e3
  , ClampToEdgeWrapping = 1001
  , MirroredRepeatWrapping = 1002
  , NearestFilter = 1003
  , NearestMipmapNearestFilter = 1004
  , NearestMipMapNearestFilter = 1004
  , NearestMipmapLinearFilter = 1005
  , NearestMipMapLinearFilter = 1005
  , LinearFilter = 1006
  , LinearMipmapNearestFilter = 1007
  , LinearMipMapNearestFilter = 1007
  , LinearMipmapLinearFilter = 1008
  , LinearMipMapLinearFilter = 1008
  , UnsignedByteType = 1009
  , ByteType = 1010
  , ShortType = 1011
  , UnsignedShortType = 1012
  , IntType = 1013
  , UnsignedIntType = 1014
  , FloatType = 1015
  , HalfFloatType = 1016
  , UnsignedShort4444Type = 1017
  , UnsignedShort5551Type = 1018
  , UnsignedInt248Type = 1020
  , AlphaFormat = 1021
  , RGBFormat = 1022
  , RGBAFormat = 1023
  , LuminanceFormat = 1024
  , LuminanceAlphaFormat = 1025
  , DepthFormat = 1026
  , DepthStencilFormat = 1027
  , RedFormat = 1028
  , RedIntegerFormat = 1029
  , RGFormat = 1030
  , RGIntegerFormat = 1031
  , RGBAIntegerFormat = 1033
  , RGB_S3TC_DXT1_Format = 33776
  , RGBA_S3TC_DXT1_Format = 33777
  , RGBA_S3TC_DXT3_Format = 33778
  , RGBA_S3TC_DXT5_Format = 33779
  , RGB_PVRTC_4BPPV1_Format = 35840
  , RGB_PVRTC_2BPPV1_Format = 35841
  , RGBA_PVRTC_4BPPV1_Format = 35842
  , RGBA_PVRTC_2BPPV1_Format = 35843
  , RGB_ETC1_Format = 36196
  , RGB_ETC2_Format = 37492
  , RGBA_ETC2_EAC_Format = 37496
  , RGBA_ASTC_4x4_Format = 37808
  , RGBA_ASTC_5x4_Format = 37809
  , RGBA_ASTC_5x5_Format = 37810
  , RGBA_ASTC_6x5_Format = 37811
  , RGBA_ASTC_6x6_Format = 37812
  , RGBA_ASTC_8x5_Format = 37813
  , RGBA_ASTC_8x6_Format = 37814
  , RGBA_ASTC_8x8_Format = 37815
  , RGBA_ASTC_10x5_Format = 37816
  , RGBA_ASTC_10x6_Format = 37817
  , RGBA_ASTC_10x8_Format = 37818
  , RGBA_ASTC_10x10_Format = 37819
  , RGBA_ASTC_12x10_Format = 37820
  , RGBA_ASTC_12x12_Format = 37821
  , RGBA_BPTC_Format = 36492
  , LoopOnce = 2200
  , LoopRepeat = 2201
  , LoopPingPong = 2202
  , InterpolateDiscrete = 2300
  , InterpolateLinear = 2301
  , InterpolateSmooth = 2302
  , ZeroCurvatureEnding = 2400
  , ZeroSlopeEnding = 2401
  , WrapAroundEnding = 2402
  , NormalAnimationBlendMode = 2500
  , AdditiveAnimationBlendMode = 2501
  , TrianglesDrawMode = 0
  , LinearEncoding = 3e3
  , sRGBEncoding = 3001
  , BasicDepthPacking = 3200
  , RGBADepthPacking = 3201
  , TangentSpaceNormalMap = 0
  , ObjectSpaceNormalMap = 1
  , KeepStencilOp = 7680
  , AlwaysStencilFunc = 519
  , StaticDrawUsage = 35044
  , DynamicDrawUsage = 35048
  , GLSL3 = "300 es"
  , _SRGBAFormat = 1035;
class EventDispatcher {
    addEventListener($, tt) {
        this._listeners === void 0 && (this._listeners = {});
        const nt = this._listeners;
        nt[$] === void 0 && (nt[$] = []),
        nt[$].indexOf(tt) === -1 && nt[$].push(tt)
    }
    hasEventListener($, tt) {
        if (this._listeners === void 0)
            return !1;
        const nt = this._listeners;
        return nt[$] !== void 0 && nt[$].indexOf(tt) !== -1
    }
    removeEventListener($, tt) {
        if (this._listeners === void 0)
            return;
        const rt = this._listeners[$];
        if (rt !== void 0) {
            const it = rt.indexOf(tt);
            it !== -1 && rt.splice(it, 1)
        }
    }
    dispatchEvent($) {
        if (this._listeners === void 0)
            return;
        const nt = this._listeners[$.type];
        if (nt !== void 0) {
            $.target = this;
            const rt = nt.slice(0);
            for (let it = 0, ot = rt.length; it < ot; it++)
                rt[it].call(this, $);
            $.target = null
        }
    }
}
const _lut = [];
for (let et = 0; et < 256; et++)
    _lut[et] = (et < 16 ? "0" : "") + et.toString(16);
let _seed = 1234567;
const DEG2RAD = Math.PI / 180
  , RAD2DEG = 180 / Math.PI;
function generateUUID() {
    const et = Math.random() * 4294967295 | 0
      , $ = Math.random() * 4294967295 | 0
      , tt = Math.random() * 4294967295 | 0
      , nt = Math.random() * 4294967295 | 0;
    return (_lut[et & 255] + _lut[et >> 8 & 255] + _lut[et >> 16 & 255] + _lut[et >> 24 & 255] + "-" + _lut[$ & 255] + _lut[$ >> 8 & 255] + "-" + _lut[$ >> 16 & 15 | 64] + _lut[$ >> 24 & 255] + "-" + _lut[tt & 63 | 128] + _lut[tt >> 8 & 255] + "-" + _lut[tt >> 16 & 255] + _lut[tt >> 24 & 255] + _lut[nt & 255] + _lut[nt >> 8 & 255] + _lut[nt >> 16 & 255] + _lut[nt >> 24 & 255]).toUpperCase()
}
function clamp$1(et, $, tt) {
    return Math.max($, Math.min(tt, et))
}
function euclideanModulo(et, $) {
    return (et % $ + $) % $
}
function mapLinear(et, $, tt, nt, rt) {
    return nt + (et - $) * (rt - nt) / (tt - $)
}
function inverseLerp(et, $, tt) {
    return et !== $ ? (tt - et) / ($ - et) : 0
}
function lerp(et, $, tt) {
    return (1 - tt) * et + tt * $
}
function damp(et, $, tt, nt) {
    return lerp(et, $, 1 - Math.exp(-tt * nt))
}
function pingpong(et, $=1) {
    return $ - Math.abs(euclideanModulo(et, $ * 2) - $)
}
function smoothstep(et, $, tt) {
    return et <= $ ? 0 : et >= tt ? 1 : (et = (et - $) / (tt - $),
    et * et * (3 - 2 * et))
}
function smootherstep(et, $, tt) {
    return et <= $ ? 0 : et >= tt ? 1 : (et = (et - $) / (tt - $),
    et * et * et * (et * (et * 6 - 15) + 10))
}
function randInt(et, $) {
    return et + Math.floor(Math.random() * ($ - et + 1))
}
function randFloat(et, $) {
    return et + Math.random() * ($ - et)
}
function randFloatSpread(et) {
    return et * (.5 - Math.random())
}
function seededRandom(et) {
    return et !== void 0 && (_seed = et % 2147483647),
    _seed = _seed * 16807 % 2147483647,
    (_seed - 1) / 2147483646
}
function degToRad(et) {
    return et * DEG2RAD
}
function radToDeg(et) {
    return et * RAD2DEG
}
function isPowerOfTwo(et) {
    return (et & et - 1) === 0 && et !== 0
}
function ceilPowerOfTwo(et) {
    return Math.pow(2, Math.ceil(Math.log(et) / Math.LN2))
}
function floorPowerOfTwo(et) {
    return Math.pow(2, Math.floor(Math.log(et) / Math.LN2))
}
function setQuaternionFromProperEuler(et, $, tt, nt, rt) {
    const it = Math.cos
      , ot = Math.sin
      , st = it(tt / 2)
      , lt = ot(tt / 2)
      , ut = it(($ + nt) / 2)
      , ct = ot(($ + nt) / 2)
      , ht = it(($ - nt) / 2)
      , ft = ot(($ - nt) / 2)
      , gt = it((nt - $) / 2)
      , vt = ot((nt - $) / 2);
    switch (rt) {
    case "XYX":
        et.set(st * ct, lt * ht, lt * ft, st * ut);
        break;
    case "YZY":
        et.set(lt * ft, st * ct, lt * ht, st * ut);
        break;
    case "ZXZ":
        et.set(lt * ht, lt * ft, st * ct, st * ut);
        break;
    case "XZX":
        et.set(st * ct, lt * vt, lt * gt, st * ut);
        break;
    case "YXY":
        et.set(lt * gt, st * ct, lt * vt, st * ut);
        break;
    case "ZYZ":
        et.set(lt * vt, lt * gt, st * ct, st * ut);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + rt)
    }
}
var MathUtils$1 = Object.freeze({
    __proto__: null,
    DEG2RAD,
    RAD2DEG,
    generateUUID,
    clamp: clamp$1,
    euclideanModulo,
    mapLinear,
    inverseLerp,
    lerp,
    damp,
    pingpong,
    smoothstep,
    smootherstep,
    randInt,
    randFloat,
    randFloatSpread,
    seededRandom,
    degToRad,
    radToDeg,
    isPowerOfTwo,
    ceilPowerOfTwo,
    floorPowerOfTwo,
    setQuaternionFromProperEuler
});
class Vector2 {
    constructor($=0, tt=0) {
        this.x = $,
        this.y = tt
    }
    get width() {
        return this.x
    }
    set width($) {
        this.x = $
    }
    get height() {
        return this.y
    }
    set height($) {
        this.y = $
    }
    set($, tt) {
        return this.x = $,
        this.y = tt,
        this
    }
    setScalar($) {
        return this.x = $,
        this.y = $,
        this
    }
    setX($) {
        return this.x = $,
        this
    }
    setY($) {
        return this.y = $,
        this
    }
    setComponent($, tt) {
        switch ($) {
        case 0:
            this.x = tt;
            break;
        case 1:
            this.y = tt;
            break;
        default:
            throw new Error("index is out of range: " + $)
        }
        return this
    }
    getComponent($) {
        switch ($) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + $)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy($) {
        return this.x = $.x,
        this.y = $.y,
        this
    }
    add($, tt) {
        return tt !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors($, tt)) : (this.x += $.x,
        this.y += $.y,
        this)
    }
    addScalar($) {
        return this.x += $,
        this.y += $,
        this
    }
    addVectors($, tt) {
        return this.x = $.x + tt.x,
        this.y = $.y + tt.y,
        this
    }
    addScaledVector($, tt) {
        return this.x += $.x * tt,
        this.y += $.y * tt,
        this
    }
    sub($, tt) {
        return tt !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors($, tt)) : (this.x -= $.x,
        this.y -= $.y,
        this)
    }
    subScalar($) {
        return this.x -= $,
        this.y -= $,
        this
    }
    subVectors($, tt) {
        return this.x = $.x - tt.x,
        this.y = $.y - tt.y,
        this
    }
    multiply($) {
        return this.x *= $.x,
        this.y *= $.y,
        this
    }
    multiplyScalar($) {
        return this.x *= $,
        this.y *= $,
        this
    }
    divide($) {
        return this.x /= $.x,
        this.y /= $.y,
        this
    }
    divideScalar($) {
        return this.multiplyScalar(1 / $)
    }
    applyMatrix3($) {
        const tt = this.x
          , nt = this.y
          , rt = $.elements;
        return this.x = rt[0] * tt + rt[3] * nt + rt[6],
        this.y = rt[1] * tt + rt[4] * nt + rt[7],
        this
    }
    min($) {
        return this.x = Math.min(this.x, $.x),
        this.y = Math.min(this.y, $.y),
        this
    }
    max($) {
        return this.x = Math.max(this.x, $.x),
        this.y = Math.max(this.y, $.y),
        this
    }
    clamp($, tt) {
        return this.x = Math.max($.x, Math.min(tt.x, this.x)),
        this.y = Math.max($.y, Math.min(tt.y, this.y)),
        this
    }
    clampScalar($, tt) {
        return this.x = Math.max($, Math.min(tt, this.x)),
        this.y = Math.max($, Math.min(tt, this.y)),
        this
    }
    clampLength($, tt) {
        const nt = this.length();
        return this.divideScalar(nt || 1).multiplyScalar(Math.max($, Math.min(tt, nt)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot($) {
        return this.x * $.x + this.y * $.y
    }
    cross($) {
        return this.x * $.y - this.y * $.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo($) {
        return Math.sqrt(this.distanceToSquared($))
    }
    distanceToSquared($) {
        const tt = this.x - $.x
          , nt = this.y - $.y;
        return tt * tt + nt * nt
    }
    manhattanDistanceTo($) {
        return Math.abs(this.x - $.x) + Math.abs(this.y - $.y)
    }
    setLength($) {
        return this.normalize().multiplyScalar($)
    }
    lerp($, tt) {
        return this.x += ($.x - this.x) * tt,
        this.y += ($.y - this.y) * tt,
        this
    }
    lerpVectors($, tt, nt) {
        return this.x = $.x + (tt.x - $.x) * nt,
        this.y = $.y + (tt.y - $.y) * nt,
        this
    }
    equals($) {
        return $.x === this.x && $.y === this.y
    }
    fromArray($, tt=0) {
        return this.x = $[tt],
        this.y = $[tt + 1],
        this
    }
    toArray($=[], tt=0) {
        return $[tt] = this.x,
        $[tt + 1] = this.y,
        $
    }
    fromBufferAttribute($, tt, nt) {
        return nt !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
        this.x = $.getX(tt),
        this.y = $.getY(tt),
        this
    }
    rotateAround($, tt) {
        const nt = Math.cos(tt)
          , rt = Math.sin(tt)
          , it = this.x - $.x
          , ot = this.y - $.y;
        return this.x = it * nt - ot * rt + $.x,
        this.y = it * rt + ot * nt + $.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
Vector2.prototype.isVector2 = !0;
class Matrix3 {
    constructor() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    set($, tt, nt, rt, it, ot, st, lt, ut) {
        const ct = this.elements;
        return ct[0] = $,
        ct[1] = rt,
        ct[2] = st,
        ct[3] = tt,
        ct[4] = it,
        ct[5] = lt,
        ct[6] = nt,
        ct[7] = ot,
        ct[8] = ut,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy($) {
        const tt = this.elements
          , nt = $.elements;
        return tt[0] = nt[0],
        tt[1] = nt[1],
        tt[2] = nt[2],
        tt[3] = nt[3],
        tt[4] = nt[4],
        tt[5] = nt[5],
        tt[6] = nt[6],
        tt[7] = nt[7],
        tt[8] = nt[8],
        this
    }
    extractBasis($, tt, nt) {
        return $.setFromMatrix3Column(this, 0),
        tt.setFromMatrix3Column(this, 1),
        nt.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4($) {
        const tt = $.elements;
        return this.set(tt[0], tt[4], tt[8], tt[1], tt[5], tt[9], tt[2], tt[6], tt[10]),
        this
    }
    multiply($) {
        return this.multiplyMatrices(this, $)
    }
    premultiply($) {
        return this.multiplyMatrices($, this)
    }
    multiplyMatrices($, tt) {
        const nt = $.elements
          , rt = tt.elements
          , it = this.elements
          , ot = nt[0]
          , st = nt[3]
          , lt = nt[6]
          , ut = nt[1]
          , ct = nt[4]
          , ht = nt[7]
          , ft = nt[2]
          , gt = nt[5]
          , vt = nt[8]
          , yt = rt[0]
          , wt = rt[3]
          , mt = rt[6]
          , _t = rt[1]
          , bt = rt[4]
          , Mt = rt[7]
          , St = rt[2]
          , At = rt[5]
          , Pt = rt[8];
        return it[0] = ot * yt + st * _t + lt * St,
        it[3] = ot * wt + st * bt + lt * At,
        it[6] = ot * mt + st * Mt + lt * Pt,
        it[1] = ut * yt + ct * _t + ht * St,
        it[4] = ut * wt + ct * bt + ht * At,
        it[7] = ut * mt + ct * Mt + ht * Pt,
        it[2] = ft * yt + gt * _t + vt * St,
        it[5] = ft * wt + gt * bt + vt * At,
        it[8] = ft * mt + gt * Mt + vt * Pt,
        this
    }
    multiplyScalar($) {
        const tt = this.elements;
        return tt[0] *= $,
        tt[3] *= $,
        tt[6] *= $,
        tt[1] *= $,
        tt[4] *= $,
        tt[7] *= $,
        tt[2] *= $,
        tt[5] *= $,
        tt[8] *= $,
        this
    }
    determinant() {
        const $ = this.elements
          , tt = $[0]
          , nt = $[1]
          , rt = $[2]
          , it = $[3]
          , ot = $[4]
          , st = $[5]
          , lt = $[6]
          , ut = $[7]
          , ct = $[8];
        return tt * ot * ct - tt * st * ut - nt * it * ct + nt * st * lt + rt * it * ut - rt * ot * lt
    }
    invert() {
        const $ = this.elements
          , tt = $[0]
          , nt = $[1]
          , rt = $[2]
          , it = $[3]
          , ot = $[4]
          , st = $[5]
          , lt = $[6]
          , ut = $[7]
          , ct = $[8]
          , ht = ct * ot - st * ut
          , ft = st * lt - ct * it
          , gt = ut * it - ot * lt
          , vt = tt * ht + nt * ft + rt * gt;
        if (vt === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const yt = 1 / vt;
        return $[0] = ht * yt,
        $[1] = (rt * ut - ct * nt) * yt,
        $[2] = (st * nt - rt * ot) * yt,
        $[3] = ft * yt,
        $[4] = (ct * tt - rt * lt) * yt,
        $[5] = (rt * it - st * tt) * yt,
        $[6] = gt * yt,
        $[7] = (nt * lt - ut * tt) * yt,
        $[8] = (ot * tt - nt * it) * yt,
        this
    }
    transpose() {
        let $;
        const tt = this.elements;
        return $ = tt[1],
        tt[1] = tt[3],
        tt[3] = $,
        $ = tt[2],
        tt[2] = tt[6],
        tt[6] = $,
        $ = tt[5],
        tt[5] = tt[7],
        tt[7] = $,
        this
    }
    getNormalMatrix($) {
        return this.setFromMatrix4($).invert().transpose()
    }
    transposeIntoArray($) {
        const tt = this.elements;
        return $[0] = tt[0],
        $[1] = tt[3],
        $[2] = tt[6],
        $[3] = tt[1],
        $[4] = tt[4],
        $[5] = tt[7],
        $[6] = tt[2],
        $[7] = tt[5],
        $[8] = tt[8],
        this
    }
    setUvTransform($, tt, nt, rt, it, ot, st) {
        const lt = Math.cos(it)
          , ut = Math.sin(it);
        return this.set(nt * lt, nt * ut, -nt * (lt * ot + ut * st) + ot + $, -rt * ut, rt * lt, -rt * (-ut * ot + lt * st) + st + tt, 0, 0, 1),
        this
    }
    scale($, tt) {
        const nt = this.elements;
        return nt[0] *= $,
        nt[3] *= $,
        nt[6] *= $,
        nt[1] *= tt,
        nt[4] *= tt,
        nt[7] *= tt,
        this
    }
    rotate($) {
        const tt = Math.cos($)
          , nt = Math.sin($)
          , rt = this.elements
          , it = rt[0]
          , ot = rt[3]
          , st = rt[6]
          , lt = rt[1]
          , ut = rt[4]
          , ct = rt[7];
        return rt[0] = tt * it + nt * lt,
        rt[3] = tt * ot + nt * ut,
        rt[6] = tt * st + nt * ct,
        rt[1] = -nt * it + tt * lt,
        rt[4] = -nt * ot + tt * ut,
        rt[7] = -nt * st + tt * ct,
        this
    }
    translate($, tt) {
        const nt = this.elements;
        return nt[0] += $ * nt[2],
        nt[3] += $ * nt[5],
        nt[6] += $ * nt[8],
        nt[1] += tt * nt[2],
        nt[4] += tt * nt[5],
        nt[7] += tt * nt[8],
        this
    }
    equals($) {
        const tt = this.elements
          , nt = $.elements;
        for (let rt = 0; rt < 9; rt++)
            if (tt[rt] !== nt[rt])
                return !1;
        return !0
    }
    fromArray($, tt=0) {
        for (let nt = 0; nt < 9; nt++)
            this.elements[nt] = $[nt + tt];
        return this
    }
    toArray($=[], tt=0) {
        const nt = this.elements;
        return $[tt] = nt[0],
        $[tt + 1] = nt[1],
        $[tt + 2] = nt[2],
        $[tt + 3] = nt[3],
        $[tt + 4] = nt[4],
        $[tt + 5] = nt[5],
        $[tt + 6] = nt[6],
        $[tt + 7] = nt[7],
        $[tt + 8] = nt[8],
        $
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
Matrix3.prototype.isMatrix3 = !0;
function arrayNeedsUint32(et) {
    for (let $ = et.length - 1; $ >= 0; --$)
        if (et[$] > 65535)
            return !0;
    return !1
}
function createElementNS(et) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", et)
}
const _colorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , _hslA = {
    h: 0,
    s: 0,
    l: 0
}
  , _hslB = {
    h: 0,
    s: 0,
    l: 0
};
function hue2rgb(et, $, tt) {
    return tt < 0 && (tt += 1),
    tt > 1 && (tt -= 1),
    tt < 1 / 6 ? et + ($ - et) * 6 * tt : tt < 1 / 2 ? $ : tt < 2 / 3 ? et + ($ - et) * 6 * (2 / 3 - tt) : et
}
function SRGBToLinear(et) {
    return et < .04045 ? et * .0773993808 : Math.pow(et * .9478672986 + .0521327014, 2.4)
}
function LinearToSRGB(et) {
    return et < .0031308 ? et * 12.92 : 1.055 * Math.pow(et, .41666) - .055
}
class Color {
    constructor($, tt, nt) {
        return tt === void 0 && nt === void 0 ? this.set($) : this.setRGB($, tt, nt)
    }
    set($) {
        return $ && $.isColor ? this.copy($) : typeof $ == "number" ? this.setHex($) : typeof $ == "string" && this.setStyle($),
        this
    }
    setScalar($) {
        return this.r = $,
        this.g = $,
        this.b = $,
        this
    }
    setHex($) {
        return $ = Math.floor($),
        this.r = ($ >> 16 & 255) / 255,
        this.g = ($ >> 8 & 255) / 255,
        this.b = ($ & 255) / 255,
        this
    }
    setRGB($, tt, nt) {
        return this.r = $,
        this.g = tt,
        this.b = nt,
        this
    }
    setHSL($, tt, nt) {
        if ($ = euclideanModulo($, 1),
        tt = clamp$1(tt, 0, 1),
        nt = clamp$1(nt, 0, 1),
        tt === 0)
            this.r = this.g = this.b = nt;
        else {
            const rt = nt <= .5 ? nt * (1 + tt) : nt + tt - nt * tt
              , it = 2 * nt - rt;
            this.r = hue2rgb(it, rt, $ + 1 / 3),
            this.g = hue2rgb(it, rt, $),
            this.b = hue2rgb(it, rt, $ - 1 / 3)
        }
        return this
    }
    setStyle($) {
        function tt(rt) {
            rt !== void 0 && parseFloat(rt) < 1 && console.warn("THREE.Color: Alpha component of " + $ + " will be ignored.")
        }
        let nt;
        if (nt = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec($)) {
            let rt;
            const it = nt[1]
              , ot = nt[2];
            switch (it) {
            case "rgb":
            case "rgba":
                if (rt = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(ot))
                    return this.r = Math.min(255, parseInt(rt[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(rt[2], 10)) / 255,
                    this.b = Math.min(255, parseInt(rt[3], 10)) / 255,
                    tt(rt[4]),
                    this;
                if (rt = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(ot))
                    return this.r = Math.min(100, parseInt(rt[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(rt[2], 10)) / 100,
                    this.b = Math.min(100, parseInt(rt[3], 10)) / 100,
                    tt(rt[4]),
                    this;
                break;
            case "hsl":
            case "hsla":
                if (rt = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(ot)) {
                    const st = parseFloat(rt[1]) / 360
                      , lt = parseInt(rt[2], 10) / 100
                      , ut = parseInt(rt[3], 10) / 100;
                    return tt(rt[4]),
                    this.setHSL(st, lt, ut)
                }
                break
            }
        } else if (nt = /^\#([A-Fa-f\d]+)$/.exec($)) {
            const rt = nt[1]
              , it = rt.length;
            if (it === 3)
                return this.r = parseInt(rt.charAt(0) + rt.charAt(0), 16) / 255,
                this.g = parseInt(rt.charAt(1) + rt.charAt(1), 16) / 255,
                this.b = parseInt(rt.charAt(2) + rt.charAt(2), 16) / 255,
                this;
            if (it === 6)
                return this.r = parseInt(rt.charAt(0) + rt.charAt(1), 16) / 255,
                this.g = parseInt(rt.charAt(2) + rt.charAt(3), 16) / 255,
                this.b = parseInt(rt.charAt(4) + rt.charAt(5), 16) / 255,
                this
        }
        return $ && $.length > 0 ? this.setColorName($) : this
    }
    setColorName($) {
        const tt = _colorKeywords[$.toLowerCase()];
        return tt !== void 0 ? this.setHex(tt) : console.warn("THREE.Color: Unknown color " + $),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy($) {
        return this.r = $.r,
        this.g = $.g,
        this.b = $.b,
        this
    }
    copySRGBToLinear($) {
        return this.r = SRGBToLinear($.r),
        this.g = SRGBToLinear($.g),
        this.b = SRGBToLinear($.b),
        this
    }
    copyLinearToSRGB($) {
        return this.r = LinearToSRGB($.r),
        this.g = LinearToSRGB($.g),
        this.b = LinearToSRGB($.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0
    }
    getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6)
    }
    getHSL($) {
        const tt = this.r
          , nt = this.g
          , rt = this.b
          , it = Math.max(tt, nt, rt)
          , ot = Math.min(tt, nt, rt);
        let st, lt;
        const ut = (ot + it) / 2;
        if (ot === it)
            st = 0,
            lt = 0;
        else {
            const ct = it - ot;
            switch (lt = ut <= .5 ? ct / (it + ot) : ct / (2 - it - ot),
            it) {
            case tt:
                st = (nt - rt) / ct + (nt < rt ? 6 : 0);
                break;
            case nt:
                st = (rt - tt) / ct + 2;
                break;
            case rt:
                st = (tt - nt) / ct + 4;
                break
            }
            st /= 6
        }
        return $.h = st,
        $.s = lt,
        $.l = ut,
        $
    }
    getStyle() {
        return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")"
    }
    offsetHSL($, tt, nt) {
        return this.getHSL(_hslA),
        _hslA.h += $,
        _hslA.s += tt,
        _hslA.l += nt,
        this.setHSL(_hslA.h, _hslA.s, _hslA.l),
        this
    }
    add($) {
        return this.r += $.r,
        this.g += $.g,
        this.b += $.b,
        this
    }
    addColors($, tt) {
        return this.r = $.r + tt.r,
        this.g = $.g + tt.g,
        this.b = $.b + tt.b,
        this
    }
    addScalar($) {
        return this.r += $,
        this.g += $,
        this.b += $,
        this
    }
    sub($) {
        return this.r = Math.max(0, this.r - $.r),
        this.g = Math.max(0, this.g - $.g),
        this.b = Math.max(0, this.b - $.b),
        this
    }
    multiply($) {
        return this.r *= $.r,
        this.g *= $.g,
        this.b *= $.b,
        this
    }
    multiplyScalar($) {
        return this.r *= $,
        this.g *= $,
        this.b *= $,
        this
    }
    lerp($, tt) {
        return this.r += ($.r - this.r) * tt,
        this.g += ($.g - this.g) * tt,
        this.b += ($.b - this.b) * tt,
        this
    }
    lerpColors($, tt, nt) {
        return this.r = $.r + (tt.r - $.r) * nt,
        this.g = $.g + (tt.g - $.g) * nt,
        this.b = $.b + (tt.b - $.b) * nt,
        this
    }
    lerpHSL($, tt) {
        this.getHSL(_hslA),
        $.getHSL(_hslB);
        const nt = lerp(_hslA.h, _hslB.h, tt)
          , rt = lerp(_hslA.s, _hslB.s, tt)
          , it = lerp(_hslA.l, _hslB.l, tt);
        return this.setHSL(nt, rt, it),
        this
    }
    equals($) {
        return $.r === this.r && $.g === this.g && $.b === this.b
    }
    fromArray($, tt=0) {
        return this.r = $[tt],
        this.g = $[tt + 1],
        this.b = $[tt + 2],
        this
    }
    toArray($=[], tt=0) {
        return $[tt] = this.r,
        $[tt + 1] = this.g,
        $[tt + 2] = this.b,
        $
    }
    fromBufferAttribute($, tt) {
        return this.r = $.getX(tt),
        this.g = $.getY(tt),
        this.b = $.getZ(tt),
        $.normalized === !0 && (this.r /= 255,
        this.g /= 255,
        this.b /= 255),
        this
    }
    toJSON() {
        return this.getHex()
    }
}
Color.NAMES = _colorKeywords;
Color.prototype.isColor = !0;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
let _canvas;
class ImageUtils {
    static getDataURL($) {
        if (/^data:/i.test($.src) || typeof HTMLCanvasElement == "undefined")
            return $.src;
        let tt;
        if ($ instanceof HTMLCanvasElement)
            tt = $;
        else {
            _canvas === void 0 && (_canvas = createElementNS("canvas")),
            _canvas.width = $.width,
            _canvas.height = $.height;
            const nt = _canvas.getContext("2d");
            $ instanceof ImageData ? nt.putImageData($, 0, 0) : nt.drawImage($, 0, 0, $.width, $.height),
            tt = _canvas
        }
        return tt.width > 2048 || tt.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", $),
        tt.toDataURL("image/jpeg", .6)) : tt.toDataURL("image/png")
    }
    static sRGBToLinear($) {
        if (typeof HTMLImageElement != "undefined" && $ instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && $ instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && $ instanceof ImageBitmap) {
            const tt = createElementNS("canvas");
            tt.width = $.width,
            tt.height = $.height;
            const nt = tt.getContext("2d");
            nt.drawImage($, 0, 0, $.width, $.height);
            const rt = nt.getImageData(0, 0, $.width, $.height)
              , it = rt.data;
            for (let ot = 0; ot < it.length; ot++)
                it[ot] = SRGBToLinear(it[ot] / 255) * 255;
            return nt.putImageData(rt, 0, 0),
            tt
        } else if ($.data) {
            const tt = $.data.slice(0);
            for (let nt = 0; nt < tt.length; nt++)
                tt instanceof Uint8Array || tt instanceof Uint8ClampedArray ? tt[nt] = Math.floor(SRGBToLinear(tt[nt] / 255) * 255) : tt[nt] = SRGBToLinear(tt[nt]);
            return {
                data: tt,
                width: $.width,
                height: $.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            $
    }
}
class Source {
    constructor($=null) {
        this.uuid = generateUUID(),
        this.data = $,
        this.version = 0
    }
    set needsUpdate($) {
        $ === !0 && this.version++
    }
    toJSON($) {
        const tt = $ === void 0 || typeof $ == "string";
        if (!tt && $.images[this.uuid] !== void 0)
            return $.images[this.uuid];
        const nt = {
            uuid: this.uuid,
            url: ""
        }
          , rt = this.data;
        if (rt !== null) {
            let it;
            if (Array.isArray(rt)) {
                it = [];
                for (let ot = 0, st = rt.length; ot < st; ot++)
                    rt[ot].isDataTexture ? it.push(serializeImage(rt[ot].image)) : it.push(serializeImage(rt[ot]))
            } else
                it = serializeImage(rt);
            nt.url = it
        }
        return tt || ($.images[this.uuid] = nt),
        nt
    }
}
function serializeImage(et) {
    return typeof HTMLImageElement != "undefined" && et instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && et instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && et instanceof ImageBitmap ? ImageUtils.getDataURL(et) : et.data ? {
        data: Array.prototype.slice.call(et.data),
        width: et.width,
        height: et.height,
        type: et.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
Source.prototype.isSource = !0;
let textureId = 0;
class Texture extends EventDispatcher {
    constructor($=Texture.DEFAULT_IMAGE, tt=Texture.DEFAULT_MAPPING, nt=ClampToEdgeWrapping, rt=ClampToEdgeWrapping, it=LinearFilter, ot=LinearMipmapLinearFilter, st=RGBAFormat, lt=UnsignedByteType, ut=1, ct=LinearEncoding) {
        super(),
        Object.defineProperty(this, "id", {
            value: textureId++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.source = new Source($),
        this.mipmaps = [],
        this.mapping = tt,
        this.wrapS = nt,
        this.wrapT = rt,
        this.magFilter = it,
        this.minFilter = ot,
        this.anisotropy = ut,
        this.format = st,
        this.internalFormat = null,
        this.type = lt,
        this.offset = new Vector2(0,0),
        this.repeat = new Vector2(1,1),
        this.center = new Vector2(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Matrix3,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = ct,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image($) {
        this.source.data = $
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy($) {
        return this.name = $.name,
        this.source = $.source,
        this.mipmaps = $.mipmaps.slice(0),
        this.mapping = $.mapping,
        this.wrapS = $.wrapS,
        this.wrapT = $.wrapT,
        this.magFilter = $.magFilter,
        this.minFilter = $.minFilter,
        this.anisotropy = $.anisotropy,
        this.format = $.format,
        this.internalFormat = $.internalFormat,
        this.type = $.type,
        this.offset.copy($.offset),
        this.repeat.copy($.repeat),
        this.center.copy($.center),
        this.rotation = $.rotation,
        this.matrixAutoUpdate = $.matrixAutoUpdate,
        this.matrix.copy($.matrix),
        this.generateMipmaps = $.generateMipmaps,
        this.premultiplyAlpha = $.premultiplyAlpha,
        this.flipY = $.flipY,
        this.unpackAlignment = $.unpackAlignment,
        this.encoding = $.encoding,
        this.userData = JSON.parse(JSON.stringify($.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON($) {
        const tt = $ === void 0 || typeof $ == "string";
        if (!tt && $.textures[this.uuid] !== void 0)
            return $.textures[this.uuid];
        const nt = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON($).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return JSON.stringify(this.userData) !== "{}" && (nt.userData = this.userData),
        tt || ($.textures[this.uuid] = nt),
        nt
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv($) {
        if (this.mapping !== UVMapping)
            return $;
        if ($.applyMatrix3(this.matrix),
        $.x < 0 || $.x > 1)
            switch (this.wrapS) {
            case RepeatWrapping:
                $.x = $.x - Math.floor($.x);
                break;
            case ClampToEdgeWrapping:
                $.x = $.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                Math.abs(Math.floor($.x) % 2) === 1 ? $.x = Math.ceil($.x) - $.x : $.x = $.x - Math.floor($.x);
                break
            }
        if ($.y < 0 || $.y > 1)
            switch (this.wrapT) {
            case RepeatWrapping:
                $.y = $.y - Math.floor($.y);
                break;
            case ClampToEdgeWrapping:
                $.y = $.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                Math.abs(Math.floor($.y) % 2) === 1 ? $.y = Math.ceil($.y) - $.y : $.y = $.y - Math.floor($.y);
                break
            }
        return this.flipY && ($.y = 1 - $.y),
        $
    }
    set needsUpdate($) {
        $ === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = !0;
class Vector4 {
    constructor($=0, tt=0, nt=0, rt=1) {
        this.x = $,
        this.y = tt,
        this.z = nt,
        this.w = rt
    }
    get width() {
        return this.z
    }
    set width($) {
        this.z = $
    }
    get height() {
        return this.w
    }
    set height($) {
        this.w = $
    }
    set($, tt, nt, rt) {
        return this.x = $,
        this.y = tt,
        this.z = nt,
        this.w = rt,
        this
    }
    setScalar($) {
        return this.x = $,
        this.y = $,
        this.z = $,
        this.w = $,
        this
    }
    setX($) {
        return this.x = $,
        this
    }
    setY($) {
        return this.y = $,
        this
    }
    setZ($) {
        return this.z = $,
        this
    }
    setW($) {
        return this.w = $,
        this
    }
    setComponent($, tt) {
        switch ($) {
        case 0:
            this.x = tt;
            break;
        case 1:
            this.y = tt;
            break;
        case 2:
            this.z = tt;
            break;
        case 3:
            this.w = tt;
            break;
        default:
            throw new Error("index is out of range: " + $)
        }
        return this
    }
    getComponent($) {
        switch ($) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + $)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy($) {
        return this.x = $.x,
        this.y = $.y,
        this.z = $.z,
        this.w = $.w !== void 0 ? $.w : 1,
        this
    }
    add($, tt) {
        return tt !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors($, tt)) : (this.x += $.x,
        this.y += $.y,
        this.z += $.z,
        this.w += $.w,
        this)
    }
    addScalar($) {
        return this.x += $,
        this.y += $,
        this.z += $,
        this.w += $,
        this
    }
    addVectors($, tt) {
        return this.x = $.x + tt.x,
        this.y = $.y + tt.y,
        this.z = $.z + tt.z,
        this.w = $.w + tt.w,
        this
    }
    addScaledVector($, tt) {
        return this.x += $.x * tt,
        this.y += $.y * tt,
        this.z += $.z * tt,
        this.w += $.w * tt,
        this
    }
    sub($, tt) {
        return tt !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors($, tt)) : (this.x -= $.x,
        this.y -= $.y,
        this.z -= $.z,
        this.w -= $.w,
        this)
    }
    subScalar($) {
        return this.x -= $,
        this.y -= $,
        this.z -= $,
        this.w -= $,
        this
    }
    subVectors($, tt) {
        return this.x = $.x - tt.x,
        this.y = $.y - tt.y,
        this.z = $.z - tt.z,
        this.w = $.w - tt.w,
        this
    }
    multiply($) {
        return this.x *= $.x,
        this.y *= $.y,
        this.z *= $.z,
        this.w *= $.w,
        this
    }
    multiplyScalar($) {
        return this.x *= $,
        this.y *= $,
        this.z *= $,
        this.w *= $,
        this
    }
    applyMatrix4($) {
        const tt = this.x
          , nt = this.y
          , rt = this.z
          , it = this.w
          , ot = $.elements;
        return this.x = ot[0] * tt + ot[4] * nt + ot[8] * rt + ot[12] * it,
        this.y = ot[1] * tt + ot[5] * nt + ot[9] * rt + ot[13] * it,
        this.z = ot[2] * tt + ot[6] * nt + ot[10] * rt + ot[14] * it,
        this.w = ot[3] * tt + ot[7] * nt + ot[11] * rt + ot[15] * it,
        this
    }
    divideScalar($) {
        return this.multiplyScalar(1 / $)
    }
    setAxisAngleFromQuaternion($) {
        this.w = 2 * Math.acos($.w);
        const tt = Math.sqrt(1 - $.w * $.w);
        return tt < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = $.x / tt,
        this.y = $.y / tt,
        this.z = $.z / tt),
        this
    }
    setAxisAngleFromRotationMatrix($) {
        let tt, nt, rt, it;
        const lt = $.elements
          , ut = lt[0]
          , ct = lt[4]
          , ht = lt[8]
          , ft = lt[1]
          , gt = lt[5]
          , vt = lt[9]
          , yt = lt[2]
          , wt = lt[6]
          , mt = lt[10];
        if (Math.abs(ct - ft) < .01 && Math.abs(ht - yt) < .01 && Math.abs(vt - wt) < .01) {
            if (Math.abs(ct + ft) < .1 && Math.abs(ht + yt) < .1 && Math.abs(vt + wt) < .1 && Math.abs(ut + gt + mt - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            tt = Math.PI;
            const bt = (ut + 1) / 2
              , Mt = (gt + 1) / 2
              , St = (mt + 1) / 2
              , At = (ct + ft) / 4
              , Pt = (ht + yt) / 4
              , Ot = (vt + wt) / 4;
            return bt > Mt && bt > St ? bt < .01 ? (nt = 0,
            rt = .707106781,
            it = .707106781) : (nt = Math.sqrt(bt),
            rt = At / nt,
            it = Pt / nt) : Mt > St ? Mt < .01 ? (nt = .707106781,
            rt = 0,
            it = .707106781) : (rt = Math.sqrt(Mt),
            nt = At / rt,
            it = Ot / rt) : St < .01 ? (nt = .707106781,
            rt = .707106781,
            it = 0) : (it = Math.sqrt(St),
            nt = Pt / it,
            rt = Ot / it),
            this.set(nt, rt, it, tt),
            this
        }
        let _t = Math.sqrt((wt - vt) * (wt - vt) + (ht - yt) * (ht - yt) + (ft - ct) * (ft - ct));
        return Math.abs(_t) < .001 && (_t = 1),
        this.x = (wt - vt) / _t,
        this.y = (ht - yt) / _t,
        this.z = (ft - ct) / _t,
        this.w = Math.acos((ut + gt + mt - 1) / 2),
        this
    }
    min($) {
        return this.x = Math.min(this.x, $.x),
        this.y = Math.min(this.y, $.y),
        this.z = Math.min(this.z, $.z),
        this.w = Math.min(this.w, $.w),
        this
    }
    max($) {
        return this.x = Math.max(this.x, $.x),
        this.y = Math.max(this.y, $.y),
        this.z = Math.max(this.z, $.z),
        this.w = Math.max(this.w, $.w),
        this
    }
    clamp($, tt) {
        return this.x = Math.max($.x, Math.min(tt.x, this.x)),
        this.y = Math.max($.y, Math.min(tt.y, this.y)),
        this.z = Math.max($.z, Math.min(tt.z, this.z)),
        this.w = Math.max($.w, Math.min(tt.w, this.w)),
        this
    }
    clampScalar($, tt) {
        return this.x = Math.max($, Math.min(tt, this.x)),
        this.y = Math.max($, Math.min(tt, this.y)),
        this.z = Math.max($, Math.min(tt, this.z)),
        this.w = Math.max($, Math.min(tt, this.w)),
        this
    }
    clampLength($, tt) {
        const nt = this.length();
        return this.divideScalar(nt || 1).multiplyScalar(Math.max($, Math.min(tt, nt)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot($) {
        return this.x * $.x + this.y * $.y + this.z * $.z + this.w * $.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength($) {
        return this.normalize().multiplyScalar($)
    }
    lerp($, tt) {
        return this.x += ($.x - this.x) * tt,
        this.y += ($.y - this.y) * tt,
        this.z += ($.z - this.z) * tt,
        this.w += ($.w - this.w) * tt,
        this
    }
    lerpVectors($, tt, nt) {
        return this.x = $.x + (tt.x - $.x) * nt,
        this.y = $.y + (tt.y - $.y) * nt,
        this.z = $.z + (tt.z - $.z) * nt,
        this.w = $.w + (tt.w - $.w) * nt,
        this
    }
    equals($) {
        return $.x === this.x && $.y === this.y && $.z === this.z && $.w === this.w
    }
    fromArray($, tt=0) {
        return this.x = $[tt],
        this.y = $[tt + 1],
        this.z = $[tt + 2],
        this.w = $[tt + 3],
        this
    }
    toArray($=[], tt=0) {
        return $[tt] = this.x,
        $[tt + 1] = this.y,
        $[tt + 2] = this.z,
        $[tt + 3] = this.w,
        $
    }
    fromBufferAttribute($, tt, nt) {
        return nt !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
        this.x = $.getX(tt),
        this.y = $.getY(tt),
        this.z = $.getZ(tt),
        this.w = $.getW(tt),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
Vector4.prototype.isVector4 = !0;
class WebGLRenderTarget extends EventDispatcher {
    constructor($, tt, nt={}) {
        super(),
        this.width = $,
        this.height = tt,
        this.depth = 1,
        this.scissor = new Vector4(0,0,$,tt),
        this.scissorTest = !1,
        this.viewport = new Vector4(0,0,$,tt);
        const rt = {
            width: $,
            height: tt,
            depth: 1
        };
        this.texture = new Texture(rt,nt.mapping,nt.wrapS,nt.wrapT,nt.magFilter,nt.minFilter,nt.format,nt.type,nt.anisotropy,nt.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = nt.generateMipmaps !== void 0 ? nt.generateMipmaps : !1,
        this.texture.internalFormat = nt.internalFormat !== void 0 ? nt.internalFormat : null,
        this.texture.minFilter = nt.minFilter !== void 0 ? nt.minFilter : LinearFilter,
        this.depthBuffer = nt.depthBuffer !== void 0 ? nt.depthBuffer : !0,
        this.stencilBuffer = nt.stencilBuffer !== void 0 ? nt.stencilBuffer : !1,
        this.depthTexture = nt.depthTexture !== void 0 ? nt.depthTexture : null,
        this.samples = nt.samples !== void 0 ? nt.samples : 0
    }
    setSize($, tt, nt=1) {
        (this.width !== $ || this.height !== tt || this.depth !== nt) && (this.width = $,
        this.height = tt,
        this.depth = nt,
        this.texture.image.width = $,
        this.texture.image.height = tt,
        this.texture.image.depth = nt,
        this.dispose()),
        this.viewport.set(0, 0, $, tt),
        this.scissor.set(0, 0, $, tt)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy($) {
        return this.width = $.width,
        this.height = $.height,
        this.depth = $.depth,
        this.viewport.copy($.viewport),
        this.texture = $.texture.clone(),
        this.texture.image = Object.assign({}, $.texture.image),
        this.depthBuffer = $.depthBuffer,
        this.stencilBuffer = $.stencilBuffer,
        $.depthTexture !== null && (this.depthTexture = $.depthTexture.clone()),
        this.samples = $.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
WebGLRenderTarget.prototype.isWebGLRenderTarget = !0;
class DataArrayTexture extends Texture {
    constructor($=null, tt=1, nt=1, rt=1) {
        super(null),
        this.image = {
            data: $,
            width: tt,
            height: nt,
            depth: rt
        },
        this.magFilter = NearestFilter,
        this.minFilter = NearestFilter,
        this.wrapR = ClampToEdgeWrapping,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
DataArrayTexture.prototype.isDataArrayTexture = !0;
class WebGLArrayRenderTarget extends WebGLRenderTarget {
    constructor($, tt, nt) {
        super($, tt),
        this.depth = nt,
        this.texture = new DataArrayTexture(null,$,tt,nt),
        this.texture.isRenderTargetTexture = !0
    }
}
WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = !0;
class Data3DTexture extends Texture {
    constructor($=null, tt=1, nt=1, rt=1) {
        super(null),
        this.image = {
            data: $,
            width: tt,
            height: nt,
            depth: rt
        },
        this.magFilter = NearestFilter,
        this.minFilter = NearestFilter,
        this.wrapR = ClampToEdgeWrapping,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
Data3DTexture.prototype.isData3DTexture = !0;
class WebGL3DRenderTarget extends WebGLRenderTarget {
    constructor($, tt, nt) {
        super($, tt),
        this.depth = nt,
        this.texture = new Data3DTexture(null,$,tt,nt),
        this.texture.isRenderTargetTexture = !0
    }
}
WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = !0;
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
    constructor($, tt, nt, rt={}) {
        super($, tt, rt);
        const it = this.texture;
        this.texture = [];
        for (let ot = 0; ot < nt; ot++)
            this.texture[ot] = it.clone(),
            this.texture[ot].isRenderTargetTexture = !0
    }
    setSize($, tt, nt=1) {
        if (this.width !== $ || this.height !== tt || this.depth !== nt) {
            this.width = $,
            this.height = tt,
            this.depth = nt;
            for (let rt = 0, it = this.texture.length; rt < it; rt++)
                this.texture[rt].image.width = $,
                this.texture[rt].image.height = tt,
                this.texture[rt].image.depth = nt;
            this.dispose()
        }
        return this.viewport.set(0, 0, $, tt),
        this.scissor.set(0, 0, $, tt),
        this
    }
    copy($) {
        this.dispose(),
        this.width = $.width,
        this.height = $.height,
        this.depth = $.depth,
        this.viewport.set(0, 0, this.width, this.height),
        this.scissor.set(0, 0, this.width, this.height),
        this.depthBuffer = $.depthBuffer,
        this.stencilBuffer = $.stencilBuffer,
        this.depthTexture = $.depthTexture,
        this.texture.length = 0;
        for (let tt = 0, nt = $.texture.length; tt < nt; tt++)
            this.texture[tt] = $.texture[tt].clone();
        return this
    }
}
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = !0;
class Quaternion {
    constructor($=0, tt=0, nt=0, rt=1) {
        this._x = $,
        this._y = tt,
        this._z = nt,
        this._w = rt
    }
    static slerp($, tt, nt, rt) {
        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
        nt.slerpQuaternions($, tt, rt)
    }
    static slerpFlat($, tt, nt, rt, it, ot, st) {
        let lt = nt[rt + 0]
          , ut = nt[rt + 1]
          , ct = nt[rt + 2]
          , ht = nt[rt + 3];
        const ft = it[ot + 0]
          , gt = it[ot + 1]
          , vt = it[ot + 2]
          , yt = it[ot + 3];
        if (st === 0) {
            $[tt + 0] = lt,
            $[tt + 1] = ut,
            $[tt + 2] = ct,
            $[tt + 3] = ht;
            return
        }
        if (st === 1) {
            $[tt + 0] = ft,
            $[tt + 1] = gt,
            $[tt + 2] = vt,
            $[tt + 3] = yt;
            return
        }
        if (ht !== yt || lt !== ft || ut !== gt || ct !== vt) {
            let wt = 1 - st;
            const mt = lt * ft + ut * gt + ct * vt + ht * yt
              , _t = mt >= 0 ? 1 : -1
              , bt = 1 - mt * mt;
            if (bt > Number.EPSILON) {
                const St = Math.sqrt(bt)
                  , At = Math.atan2(St, mt * _t);
                wt = Math.sin(wt * At) / St,
                st = Math.sin(st * At) / St
            }
            const Mt = st * _t;
            if (lt = lt * wt + ft * Mt,
            ut = ut * wt + gt * Mt,
            ct = ct * wt + vt * Mt,
            ht = ht * wt + yt * Mt,
            wt === 1 - st) {
                const St = 1 / Math.sqrt(lt * lt + ut * ut + ct * ct + ht * ht);
                lt *= St,
                ut *= St,
                ct *= St,
                ht *= St
            }
        }
        $[tt] = lt,
        $[tt + 1] = ut,
        $[tt + 2] = ct,
        $[tt + 3] = ht
    }
    static multiplyQuaternionsFlat($, tt, nt, rt, it, ot) {
        const st = nt[rt]
          , lt = nt[rt + 1]
          , ut = nt[rt + 2]
          , ct = nt[rt + 3]
          , ht = it[ot]
          , ft = it[ot + 1]
          , gt = it[ot + 2]
          , vt = it[ot + 3];
        return $[tt] = st * vt + ct * ht + lt * gt - ut * ft,
        $[tt + 1] = lt * vt + ct * ft + ut * ht - st * gt,
        $[tt + 2] = ut * vt + ct * gt + st * ft - lt * ht,
        $[tt + 3] = ct * vt - st * ht - lt * ft - ut * gt,
        $
    }
    get x() {
        return this._x
    }
    set x($) {
        this._x = $,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y($) {
        this._y = $,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z($) {
        this._z = $,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w($) {
        this._w = $,
        this._onChangeCallback()
    }
    set($, tt, nt, rt) {
        return this._x = $,
        this._y = tt,
        this._z = nt,
        this._w = rt,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy($) {
        return this._x = $.x,
        this._y = $.y,
        this._z = $.z,
        this._w = $.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler($, tt) {
        if (!($ && $.isEuler))
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        const nt = $._x
          , rt = $._y
          , it = $._z
          , ot = $._order
          , st = Math.cos
          , lt = Math.sin
          , ut = st(nt / 2)
          , ct = st(rt / 2)
          , ht = st(it / 2)
          , ft = lt(nt / 2)
          , gt = lt(rt / 2)
          , vt = lt(it / 2);
        switch (ot) {
        case "XYZ":
            this._x = ft * ct * ht + ut * gt * vt,
            this._y = ut * gt * ht - ft * ct * vt,
            this._z = ut * ct * vt + ft * gt * ht,
            this._w = ut * ct * ht - ft * gt * vt;
            break;
        case "YXZ":
            this._x = ft * ct * ht + ut * gt * vt,
            this._y = ut * gt * ht - ft * ct * vt,
            this._z = ut * ct * vt - ft * gt * ht,
            this._w = ut * ct * ht + ft * gt * vt;
            break;
        case "ZXY":
            this._x = ft * ct * ht - ut * gt * vt,
            this._y = ut * gt * ht + ft * ct * vt,
            this._z = ut * ct * vt + ft * gt * ht,
            this._w = ut * ct * ht - ft * gt * vt;
            break;
        case "ZYX":
            this._x = ft * ct * ht - ut * gt * vt,
            this._y = ut * gt * ht + ft * ct * vt,
            this._z = ut * ct * vt - ft * gt * ht,
            this._w = ut * ct * ht + ft * gt * vt;
            break;
        case "YZX":
            this._x = ft * ct * ht + ut * gt * vt,
            this._y = ut * gt * ht + ft * ct * vt,
            this._z = ut * ct * vt - ft * gt * ht,
            this._w = ut * ct * ht - ft * gt * vt;
            break;
        case "XZY":
            this._x = ft * ct * ht - ut * gt * vt,
            this._y = ut * gt * ht - ft * ct * vt,
            this._z = ut * ct * vt + ft * gt * ht,
            this._w = ut * ct * ht + ft * gt * vt;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + ot)
        }
        return tt !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle($, tt) {
        const nt = tt / 2
          , rt = Math.sin(nt);
        return this._x = $.x * rt,
        this._y = $.y * rt,
        this._z = $.z * rt,
        this._w = Math.cos(nt),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix($) {
        const tt = $.elements
          , nt = tt[0]
          , rt = tt[4]
          , it = tt[8]
          , ot = tt[1]
          , st = tt[5]
          , lt = tt[9]
          , ut = tt[2]
          , ct = tt[6]
          , ht = tt[10]
          , ft = nt + st + ht;
        if (ft > 0) {
            const gt = .5 / Math.sqrt(ft + 1);
            this._w = .25 / gt,
            this._x = (ct - lt) * gt,
            this._y = (it - ut) * gt,
            this._z = (ot - rt) * gt
        } else if (nt > st && nt > ht) {
            const gt = 2 * Math.sqrt(1 + nt - st - ht);
            this._w = (ct - lt) / gt,
            this._x = .25 * gt,
            this._y = (rt + ot) / gt,
            this._z = (it + ut) / gt
        } else if (st > ht) {
            const gt = 2 * Math.sqrt(1 + st - nt - ht);
            this._w = (it - ut) / gt,
            this._x = (rt + ot) / gt,
            this._y = .25 * gt,
            this._z = (lt + ct) / gt
        } else {
            const gt = 2 * Math.sqrt(1 + ht - nt - st);
            this._w = (ot - rt) / gt,
            this._x = (it + ut) / gt,
            this._y = (lt + ct) / gt,
            this._z = .25 * gt
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors($, tt) {
        let nt = $.dot(tt) + 1;
        return nt < Number.EPSILON ? (nt = 0,
        Math.abs($.x) > Math.abs($.z) ? (this._x = -$.y,
        this._y = $.x,
        this._z = 0,
        this._w = nt) : (this._x = 0,
        this._y = -$.z,
        this._z = $.y,
        this._w = nt)) : (this._x = $.y * tt.z - $.z * tt.y,
        this._y = $.z * tt.x - $.x * tt.z,
        this._z = $.x * tt.y - $.y * tt.x,
        this._w = nt),
        this.normalize()
    }
    angleTo($) {
        return 2 * Math.acos(Math.abs(clamp$1(this.dot($), -1, 1)))
    }
    rotateTowards($, tt) {
        const nt = this.angleTo($);
        if (nt === 0)
            return this;
        const rt = Math.min(1, tt / nt);
        return this.slerp($, rt),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot($) {
        return this._x * $._x + this._y * $._y + this._z * $._z + this._w * $._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let $ = this.length();
        return $ === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : ($ = 1 / $,
        this._x = this._x * $,
        this._y = this._y * $,
        this._z = this._z * $,
        this._w = this._w * $),
        this._onChangeCallback(),
        this
    }
    multiply($, tt) {
        return tt !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
        this.multiplyQuaternions($, tt)) : this.multiplyQuaternions(this, $)
    }
    premultiply($) {
        return this.multiplyQuaternions($, this)
    }
    multiplyQuaternions($, tt) {
        const nt = $._x
          , rt = $._y
          , it = $._z
          , ot = $._w
          , st = tt._x
          , lt = tt._y
          , ut = tt._z
          , ct = tt._w;
        return this._x = nt * ct + ot * st + rt * ut - it * lt,
        this._y = rt * ct + ot * lt + it * st - nt * ut,
        this._z = it * ct + ot * ut + nt * lt - rt * st,
        this._w = ot * ct - nt * st - rt * lt - it * ut,
        this._onChangeCallback(),
        this
    }
    slerp($, tt) {
        if (tt === 0)
            return this;
        if (tt === 1)
            return this.copy($);
        const nt = this._x
          , rt = this._y
          , it = this._z
          , ot = this._w;
        let st = ot * $._w + nt * $._x + rt * $._y + it * $._z;
        if (st < 0 ? (this._w = -$._w,
        this._x = -$._x,
        this._y = -$._y,
        this._z = -$._z,
        st = -st) : this.copy($),
        st >= 1)
            return this._w = ot,
            this._x = nt,
            this._y = rt,
            this._z = it,
            this;
        const lt = 1 - st * st;
        if (lt <= Number.EPSILON) {
            const gt = 1 - tt;
            return this._w = gt * ot + tt * this._w,
            this._x = gt * nt + tt * this._x,
            this._y = gt * rt + tt * this._y,
            this._z = gt * it + tt * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const ut = Math.sqrt(lt)
          , ct = Math.atan2(ut, st)
          , ht = Math.sin((1 - tt) * ct) / ut
          , ft = Math.sin(tt * ct) / ut;
        return this._w = ot * ht + this._w * ft,
        this._x = nt * ht + this._x * ft,
        this._y = rt * ht + this._y * ft,
        this._z = it * ht + this._z * ft,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions($, tt, nt) {
        return this.copy($).slerp(tt, nt)
    }
    random() {
        const $ = Math.random()
          , tt = Math.sqrt(1 - $)
          , nt = Math.sqrt($)
          , rt = 2 * Math.PI * Math.random()
          , it = 2 * Math.PI * Math.random();
        return this.set(tt * Math.cos(rt), nt * Math.sin(it), nt * Math.cos(it), tt * Math.sin(rt))
    }
    equals($) {
        return $._x === this._x && $._y === this._y && $._z === this._z && $._w === this._w
    }
    fromArray($, tt=0) {
        return this._x = $[tt],
        this._y = $[tt + 1],
        this._z = $[tt + 2],
        this._w = $[tt + 3],
        this._onChangeCallback(),
        this
    }
    toArray($=[], tt=0) {
        return $[tt] = this._x,
        $[tt + 1] = this._y,
        $[tt + 2] = this._z,
        $[tt + 3] = this._w,
        $
    }
    fromBufferAttribute($, tt) {
        return this._x = $.getX(tt),
        this._y = $.getY(tt),
        this._z = $.getZ(tt),
        this._w = $.getW(tt),
        this
    }
    _onChange($) {
        return this._onChangeCallback = $,
        this
    }
    _onChangeCallback() {}
}
Quaternion.prototype.isQuaternion = !0;
class Vector3 {
    constructor($=0, tt=0, nt=0) {
        this.x = $,
        this.y = tt,
        this.z = nt
    }
    set($, tt, nt) {
        return nt === void 0 && (nt = this.z),
        this.x = $,
        this.y = tt,
        this.z = nt,
        this
    }
    setScalar($) {
        return this.x = $,
        this.y = $,
        this.z = $,
        this
    }
    setX($) {
        return this.x = $,
        this
    }
    setY($) {
        return this.y = $,
        this
    }
    setZ($) {
        return this.z = $,
        this
    }
    setComponent($, tt) {
        switch ($) {
        case 0:
            this.x = tt;
            break;
        case 1:
            this.y = tt;
            break;
        case 2:
            this.z = tt;
            break;
        default:
            throw new Error("index is out of range: " + $)
        }
        return this
    }
    getComponent($) {
        switch ($) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + $)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy($) {
        return this.x = $.x,
        this.y = $.y,
        this.z = $.z,
        this
    }
    add($, tt) {
        return tt !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors($, tt)) : (this.x += $.x,
        this.y += $.y,
        this.z += $.z,
        this)
    }
    addScalar($) {
        return this.x += $,
        this.y += $,
        this.z += $,
        this
    }
    addVectors($, tt) {
        return this.x = $.x + tt.x,
        this.y = $.y + tt.y,
        this.z = $.z + tt.z,
        this
    }
    addScaledVector($, tt) {
        return this.x += $.x * tt,
        this.y += $.y * tt,
        this.z += $.z * tt,
        this
    }
    sub($, tt) {
        return tt !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors($, tt)) : (this.x -= $.x,
        this.y -= $.y,
        this.z -= $.z,
        this)
    }
    subScalar($) {
        return this.x -= $,
        this.y -= $,
        this.z -= $,
        this
    }
    subVectors($, tt) {
        return this.x = $.x - tt.x,
        this.y = $.y - tt.y,
        this.z = $.z - tt.z,
        this
    }
    multiply($, tt) {
        return tt !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
        this.multiplyVectors($, tt)) : (this.x *= $.x,
        this.y *= $.y,
        this.z *= $.z,
        this)
    }
    multiplyScalar($) {
        return this.x *= $,
        this.y *= $,
        this.z *= $,
        this
    }
    multiplyVectors($, tt) {
        return this.x = $.x * tt.x,
        this.y = $.y * tt.y,
        this.z = $.z * tt.z,
        this
    }
    applyEuler($) {
        return $ && $.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
        this.applyQuaternion(_quaternion$4.setFromEuler($))
    }
    applyAxisAngle($, tt) {
        return this.applyQuaternion(_quaternion$4.setFromAxisAngle($, tt))
    }
    applyMatrix3($) {
        const tt = this.x
          , nt = this.y
          , rt = this.z
          , it = $.elements;
        return this.x = it[0] * tt + it[3] * nt + it[6] * rt,
        this.y = it[1] * tt + it[4] * nt + it[7] * rt,
        this.z = it[2] * tt + it[5] * nt + it[8] * rt,
        this
    }
    applyNormalMatrix($) {
        return this.applyMatrix3($).normalize()
    }
    applyMatrix4($) {
        const tt = this.x
          , nt = this.y
          , rt = this.z
          , it = $.elements
          , ot = 1 / (it[3] * tt + it[7] * nt + it[11] * rt + it[15]);
        return this.x = (it[0] * tt + it[4] * nt + it[8] * rt + it[12]) * ot,
        this.y = (it[1] * tt + it[5] * nt + it[9] * rt + it[13]) * ot,
        this.z = (it[2] * tt + it[6] * nt + it[10] * rt + it[14]) * ot,
        this
    }
    applyQuaternion($) {
        const tt = this.x
          , nt = this.y
          , rt = this.z
          , it = $.x
          , ot = $.y
          , st = $.z
          , lt = $.w
          , ut = lt * tt + ot * rt - st * nt
          , ct = lt * nt + st * tt - it * rt
          , ht = lt * rt + it * nt - ot * tt
          , ft = -it * tt - ot * nt - st * rt;
        return this.x = ut * lt + ft * -it + ct * -st - ht * -ot,
        this.y = ct * lt + ft * -ot + ht * -it - ut * -st,
        this.z = ht * lt + ft * -st + ut * -ot - ct * -it,
        this
    }
    project($) {
        return this.applyMatrix4($.matrixWorldInverse).applyMatrix4($.projectionMatrix)
    }
    unproject($) {
        return this.applyMatrix4($.projectionMatrixInverse).applyMatrix4($.matrixWorld)
    }
    transformDirection($) {
        const tt = this.x
          , nt = this.y
          , rt = this.z
          , it = $.elements;
        return this.x = it[0] * tt + it[4] * nt + it[8] * rt,
        this.y = it[1] * tt + it[5] * nt + it[9] * rt,
        this.z = it[2] * tt + it[6] * nt + it[10] * rt,
        this.normalize()
    }
    divide($) {
        return this.x /= $.x,
        this.y /= $.y,
        this.z /= $.z,
        this
    }
    divideScalar($) {
        return this.multiplyScalar(1 / $)
    }
    min($) {
        return this.x = Math.min(this.x, $.x),
        this.y = Math.min(this.y, $.y),
        this.z = Math.min(this.z, $.z),
        this
    }
    max($) {
        return this.x = Math.max(this.x, $.x),
        this.y = Math.max(this.y, $.y),
        this.z = Math.max(this.z, $.z),
        this
    }
    clamp($, tt) {
        return this.x = Math.max($.x, Math.min(tt.x, this.x)),
        this.y = Math.max($.y, Math.min(tt.y, this.y)),
        this.z = Math.max($.z, Math.min(tt.z, this.z)),
        this
    }
    clampScalar($, tt) {
        return this.x = Math.max($, Math.min(tt, this.x)),
        this.y = Math.max($, Math.min(tt, this.y)),
        this.z = Math.max($, Math.min(tt, this.z)),
        this
    }
    clampLength($, tt) {
        const nt = this.length();
        return this.divideScalar(nt || 1).multiplyScalar(Math.max($, Math.min(tt, nt)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot($) {
        return this.x * $.x + this.y * $.y + this.z * $.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength($) {
        return this.normalize().multiplyScalar($)
    }
    lerp($, tt) {
        return this.x += ($.x - this.x) * tt,
        this.y += ($.y - this.y) * tt,
        this.z += ($.z - this.z) * tt,
        this
    }
    lerpVectors($, tt, nt) {
        return this.x = $.x + (tt.x - $.x) * nt,
        this.y = $.y + (tt.y - $.y) * nt,
        this.z = $.z + (tt.z - $.z) * nt,
        this
    }
    cross($, tt) {
        return tt !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
        this.crossVectors($, tt)) : this.crossVectors(this, $)
    }
    crossVectors($, tt) {
        const nt = $.x
          , rt = $.y
          , it = $.z
          , ot = tt.x
          , st = tt.y
          , lt = tt.z;
        return this.x = rt * lt - it * st,
        this.y = it * ot - nt * lt,
        this.z = nt * st - rt * ot,
        this
    }
    projectOnVector($) {
        const tt = $.lengthSq();
        if (tt === 0)
            return this.set(0, 0, 0);
        const nt = $.dot(this) / tt;
        return this.copy($).multiplyScalar(nt)
    }
    projectOnPlane($) {
        return _vector$c.copy(this).projectOnVector($),
        this.sub(_vector$c)
    }
    reflect($) {
        return this.sub(_vector$c.copy($).multiplyScalar(2 * this.dot($)))
    }
    angleTo($) {
        const tt = Math.sqrt(this.lengthSq() * $.lengthSq());
        if (tt === 0)
            return Math.PI / 2;
        const nt = this.dot($) / tt;
        return Math.acos(clamp$1(nt, -1, 1))
    }
    distanceTo($) {
        return Math.sqrt(this.distanceToSquared($))
    }
    distanceToSquared($) {
        const tt = this.x - $.x
          , nt = this.y - $.y
          , rt = this.z - $.z;
        return tt * tt + nt * nt + rt * rt
    }
    manhattanDistanceTo($) {
        return Math.abs(this.x - $.x) + Math.abs(this.y - $.y) + Math.abs(this.z - $.z)
    }
    setFromSpherical($) {
        return this.setFromSphericalCoords($.radius, $.phi, $.theta)
    }
    setFromSphericalCoords($, tt, nt) {
        const rt = Math.sin(tt) * $;
        return this.x = rt * Math.sin(nt),
        this.y = Math.cos(tt) * $,
        this.z = rt * Math.cos(nt),
        this
    }
    setFromCylindrical($) {
        return this.setFromCylindricalCoords($.radius, $.theta, $.y)
    }
    setFromCylindricalCoords($, tt, nt) {
        return this.x = $ * Math.sin(tt),
        this.y = nt,
        this.z = $ * Math.cos(tt),
        this
    }
    setFromMatrixPosition($) {
        const tt = $.elements;
        return this.x = tt[12],
        this.y = tt[13],
        this.z = tt[14],
        this
    }
    setFromMatrixScale($) {
        const tt = this.setFromMatrixColumn($, 0).length()
          , nt = this.setFromMatrixColumn($, 1).length()
          , rt = this.setFromMatrixColumn($, 2).length();
        return this.x = tt,
        this.y = nt,
        this.z = rt,
        this
    }
    setFromMatrixColumn($, tt) {
        return this.fromArray($.elements, tt * 4)
    }
    setFromMatrix3Column($, tt) {
        return this.fromArray($.elements, tt * 3)
    }
    setFromEuler($) {
        return this.x = $._x,
        this.y = $._y,
        this.z = $._z,
        this
    }
    equals($) {
        return $.x === this.x && $.y === this.y && $.z === this.z
    }
    fromArray($, tt=0) {
        return this.x = $[tt],
        this.y = $[tt + 1],
        this.z = $[tt + 2],
        this
    }
    toArray($=[], tt=0) {
        return $[tt] = this.x,
        $[tt + 1] = this.y,
        $[tt + 2] = this.z,
        $
    }
    fromBufferAttribute($, tt, nt) {
        return nt !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
        this.x = $.getX(tt),
        this.y = $.getY(tt),
        this.z = $.getZ(tt),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const $ = (Math.random() - .5) * 2
          , tt = Math.random() * Math.PI * 2
          , nt = Math.sqrt(1 - $ ** 2);
        return this.x = nt * Math.cos(tt),
        this.y = nt * Math.sin(tt),
        this.z = $,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
Vector3.prototype.isVector3 = !0;
const _vector$c = new Vector3
  , _quaternion$4 = new Quaternion;
class Box3 {
    constructor($=new Vector3(1 / 0,1 / 0,1 / 0), tt=new Vector3(-1 / 0,-1 / 0,-1 / 0)) {
        this.min = $,
        this.max = tt
    }
    set($, tt) {
        return this.min.copy($),
        this.max.copy(tt),
        this
    }
    setFromArray($) {
        let tt = 1 / 0
          , nt = 1 / 0
          , rt = 1 / 0
          , it = -1 / 0
          , ot = -1 / 0
          , st = -1 / 0;
        for (let lt = 0, ut = $.length; lt < ut; lt += 3) {
            const ct = $[lt]
              , ht = $[lt + 1]
              , ft = $[lt + 2];
            ct < tt && (tt = ct),
            ht < nt && (nt = ht),
            ft < rt && (rt = ft),
            ct > it && (it = ct),
            ht > ot && (ot = ht),
            ft > st && (st = ft)
        }
        return this.min.set(tt, nt, rt),
        this.max.set(it, ot, st),
        this
    }
    setFromBufferAttribute($) {
        let tt = 1 / 0
          , nt = 1 / 0
          , rt = 1 / 0
          , it = -1 / 0
          , ot = -1 / 0
          , st = -1 / 0;
        for (let lt = 0, ut = $.count; lt < ut; lt++) {
            const ct = $.getX(lt)
              , ht = $.getY(lt)
              , ft = $.getZ(lt);
            ct < tt && (tt = ct),
            ht < nt && (nt = ht),
            ft < rt && (rt = ft),
            ct > it && (it = ct),
            ht > ot && (ot = ht),
            ft > st && (st = ft)
        }
        return this.min.set(tt, nt, rt),
        this.max.set(it, ot, st),
        this
    }
    setFromPoints($) {
        this.makeEmpty();
        for (let tt = 0, nt = $.length; tt < nt; tt++)
            this.expandByPoint($[tt]);
        return this
    }
    setFromCenterAndSize($, tt) {
        const nt = _vector$b.copy(tt).multiplyScalar(.5);
        return this.min.copy($).sub(nt),
        this.max.copy($).add(nt),
        this
    }
    setFromObject($, tt=!1) {
        return this.makeEmpty(),
        this.expandByObject($, tt)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy($) {
        return this.min.copy($.min),
        this.max.copy($.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter($) {
        return this.isEmpty() ? $.set(0, 0, 0) : $.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize($) {
        return this.isEmpty() ? $.set(0, 0, 0) : $.subVectors(this.max, this.min)
    }
    expandByPoint($) {
        return this.min.min($),
        this.max.max($),
        this
    }
    expandByVector($) {
        return this.min.sub($),
        this.max.add($),
        this
    }
    expandByScalar($) {
        return this.min.addScalar(-$),
        this.max.addScalar($),
        this
    }
    expandByObject($, tt=!1) {
        $.updateWorldMatrix(!1, !1);
        const nt = $.geometry;
        if (nt !== void 0)
            if (tt && nt.attributes != null && nt.attributes.position !== void 0) {
                const it = nt.attributes.position;
                for (let ot = 0, st = it.count; ot < st; ot++)
                    _vector$b.fromBufferAttribute(it, ot).applyMatrix4($.matrixWorld),
                    this.expandByPoint(_vector$b)
            } else
                nt.boundingBox === null && nt.computeBoundingBox(),
                _box$3.copy(nt.boundingBox),
                _box$3.applyMatrix4($.matrixWorld),
                this.union(_box$3);
        const rt = $.children;
        for (let it = 0, ot = rt.length; it < ot; it++)
            this.expandByObject(rt[it], tt);
        return this
    }
    containsPoint($) {
        return !($.x < this.min.x || $.x > this.max.x || $.y < this.min.y || $.y > this.max.y || $.z < this.min.z || $.z > this.max.z)
    }
    containsBox($) {
        return this.min.x <= $.min.x && $.max.x <= this.max.x && this.min.y <= $.min.y && $.max.y <= this.max.y && this.min.z <= $.min.z && $.max.z <= this.max.z
    }
    getParameter($, tt) {
        return tt.set(($.x - this.min.x) / (this.max.x - this.min.x), ($.y - this.min.y) / (this.max.y - this.min.y), ($.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox($) {
        return !($.max.x < this.min.x || $.min.x > this.max.x || $.max.y < this.min.y || $.min.y > this.max.y || $.max.z < this.min.z || $.min.z > this.max.z)
    }
    intersectsSphere($) {
        return this.clampPoint($.center, _vector$b),
        _vector$b.distanceToSquared($.center) <= $.radius * $.radius
    }
    intersectsPlane($) {
        let tt, nt;
        return $.normal.x > 0 ? (tt = $.normal.x * this.min.x,
        nt = $.normal.x * this.max.x) : (tt = $.normal.x * this.max.x,
        nt = $.normal.x * this.min.x),
        $.normal.y > 0 ? (tt += $.normal.y * this.min.y,
        nt += $.normal.y * this.max.y) : (tt += $.normal.y * this.max.y,
        nt += $.normal.y * this.min.y),
        $.normal.z > 0 ? (tt += $.normal.z * this.min.z,
        nt += $.normal.z * this.max.z) : (tt += $.normal.z * this.max.z,
        nt += $.normal.z * this.min.z),
        tt <= -$.constant && nt >= -$.constant
    }
    intersectsTriangle($) {
        if (this.isEmpty())
            return !1;
        this.getCenter(_center),
        _extents.subVectors(this.max, _center),
        _v0$2.subVectors($.a, _center),
        _v1$7.subVectors($.b, _center),
        _v2$3.subVectors($.c, _center),
        _f0.subVectors(_v1$7, _v0$2),
        _f1.subVectors(_v2$3, _v1$7),
        _f2.subVectors(_v0$2, _v2$3);
        let tt = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
        return !satForAxes(tt, _v0$2, _v1$7, _v2$3, _extents) || (tt = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !satForAxes(tt, _v0$2, _v1$7, _v2$3, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1),
        tt = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z],
        satForAxes(tt, _v0$2, _v1$7, _v2$3, _extents))
    }
    clampPoint($, tt) {
        return tt.copy($).clamp(this.min, this.max)
    }
    distanceToPoint($) {
        return _vector$b.copy($).clamp(this.min, this.max).sub($).length()
    }
    getBoundingSphere($) {
        return this.getCenter($.center),
        $.radius = this.getSize(_vector$b).length() * .5,
        $
    }
    intersect($) {
        return this.min.max($.min),
        this.max.min($.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union($) {
        return this.min.min($.min),
        this.max.max($.max),
        this
    }
    applyMatrix4($) {
        return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4($),
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4($),
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4($),
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4($),
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4($),
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4($),
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4($),
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4($),
        this.setFromPoints(_points),
        this)
    }
    translate($) {
        return this.min.add($),
        this.max.add($),
        this
    }
    equals($) {
        return $.min.equals(this.min) && $.max.equals(this.max)
    }
}
Box3.prototype.isBox3 = !0;
const _points = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3]
  , _vector$b = new Vector3
  , _box$3 = new Box3
  , _v0$2 = new Vector3
  , _v1$7 = new Vector3
  , _v2$3 = new Vector3
  , _f0 = new Vector3
  , _f1 = new Vector3
  , _f2 = new Vector3
  , _center = new Vector3
  , _extents = new Vector3
  , _triangleNormal = new Vector3
  , _testAxis = new Vector3;
function satForAxes(et, $, tt, nt, rt) {
    for (let it = 0, ot = et.length - 3; it <= ot; it += 3) {
        _testAxis.fromArray(et, it);
        const st = rt.x * Math.abs(_testAxis.x) + rt.y * Math.abs(_testAxis.y) + rt.z * Math.abs(_testAxis.z)
          , lt = $.dot(_testAxis)
          , ut = tt.dot(_testAxis)
          , ct = nt.dot(_testAxis);
        if (Math.max(-Math.max(lt, ut, ct), Math.min(lt, ut, ct)) > st)
            return !1
    }
    return !0
}
const _box$2 = new Box3
  , _v1$6 = new Vector3
  , _toFarthestPoint = new Vector3
  , _toPoint = new Vector3;
class Sphere {
    constructor($=new Vector3, tt=-1) {
        this.center = $,
        this.radius = tt
    }
    set($, tt) {
        return this.center.copy($),
        this.radius = tt,
        this
    }
    setFromPoints($, tt) {
        const nt = this.center;
        tt !== void 0 ? nt.copy(tt) : _box$2.setFromPoints($).getCenter(nt);
        let rt = 0;
        for (let it = 0, ot = $.length; it < ot; it++)
            rt = Math.max(rt, nt.distanceToSquared($[it]));
        return this.radius = Math.sqrt(rt),
        this
    }
    copy($) {
        return this.center.copy($.center),
        this.radius = $.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint($) {
        return $.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint($) {
        return $.distanceTo(this.center) - this.radius
    }
    intersectsSphere($) {
        const tt = this.radius + $.radius;
        return $.center.distanceToSquared(this.center) <= tt * tt
    }
    intersectsBox($) {
        return $.intersectsSphere(this)
    }
    intersectsPlane($) {
        return Math.abs($.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint($, tt) {
        const nt = this.center.distanceToSquared($);
        return tt.copy($),
        nt > this.radius * this.radius && (tt.sub(this.center).normalize(),
        tt.multiplyScalar(this.radius).add(this.center)),
        tt
    }
    getBoundingBox($) {
        return this.isEmpty() ? ($.makeEmpty(),
        $) : ($.set(this.center, this.center),
        $.expandByScalar(this.radius),
        $)
    }
    applyMatrix4($) {
        return this.center.applyMatrix4($),
        this.radius = this.radius * $.getMaxScaleOnAxis(),
        this
    }
    translate($) {
        return this.center.add($),
        this
    }
    expandByPoint($) {
        _toPoint.subVectors($, this.center);
        const tt = _toPoint.lengthSq();
        if (tt > this.radius * this.radius) {
            const nt = Math.sqrt(tt)
              , rt = (nt - this.radius) * .5;
            this.center.add(_toPoint.multiplyScalar(rt / nt)),
            this.radius += rt
        }
        return this
    }
    union($) {
        return this.center.equals($.center) === !0 ? _toFarthestPoint.set(0, 0, 1).multiplyScalar($.radius) : _toFarthestPoint.subVectors($.center, this.center).normalize().multiplyScalar($.radius),
        this.expandByPoint(_v1$6.copy($.center).add(_toFarthestPoint)),
        this.expandByPoint(_v1$6.copy($.center).sub(_toFarthestPoint)),
        this
    }
    equals($) {
        return $.center.equals(this.center) && $.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _vector$a = new Vector3
  , _segCenter = new Vector3
  , _segDir = new Vector3
  , _diff = new Vector3
  , _edge1 = new Vector3
  , _edge2 = new Vector3
  , _normal$1 = new Vector3;
class Ray {
    constructor($=new Vector3, tt=new Vector3(0,0,-1)) {
        this.origin = $,
        this.direction = tt
    }
    set($, tt) {
        return this.origin.copy($),
        this.direction.copy(tt),
        this
    }
    copy($) {
        return this.origin.copy($.origin),
        this.direction.copy($.direction),
        this
    }
    at($, tt) {
        return tt.copy(this.direction).multiplyScalar($).add(this.origin)
    }
    lookAt($) {
        return this.direction.copy($).sub(this.origin).normalize(),
        this
    }
    recast($) {
        return this.origin.copy(this.at($, _vector$a)),
        this
    }
    closestPointToPoint($, tt) {
        tt.subVectors($, this.origin);
        const nt = tt.dot(this.direction);
        return nt < 0 ? tt.copy(this.origin) : tt.copy(this.direction).multiplyScalar(nt).add(this.origin)
    }
    distanceToPoint($) {
        return Math.sqrt(this.distanceSqToPoint($))
    }
    distanceSqToPoint($) {
        const tt = _vector$a.subVectors($, this.origin).dot(this.direction);
        return tt < 0 ? this.origin.distanceToSquared($) : (_vector$a.copy(this.direction).multiplyScalar(tt).add(this.origin),
        _vector$a.distanceToSquared($))
    }
    distanceSqToSegment($, tt, nt, rt) {
        _segCenter.copy($).add(tt).multiplyScalar(.5),
        _segDir.copy(tt).sub($).normalize(),
        _diff.copy(this.origin).sub(_segCenter);
        const it = $.distanceTo(tt) * .5
          , ot = -this.direction.dot(_segDir)
          , st = _diff.dot(this.direction)
          , lt = -_diff.dot(_segDir)
          , ut = _diff.lengthSq()
          , ct = Math.abs(1 - ot * ot);
        let ht, ft, gt, vt;
        if (ct > 0)
            if (ht = ot * lt - st,
            ft = ot * st - lt,
            vt = it * ct,
            ht >= 0)
                if (ft >= -vt)
                    if (ft <= vt) {
                        const yt = 1 / ct;
                        ht *= yt,
                        ft *= yt,
                        gt = ht * (ht + ot * ft + 2 * st) + ft * (ot * ht + ft + 2 * lt) + ut
                    } else
                        ft = it,
                        ht = Math.max(0, -(ot * ft + st)),
                        gt = -ht * ht + ft * (ft + 2 * lt) + ut;
                else
                    ft = -it,
                    ht = Math.max(0, -(ot * ft + st)),
                    gt = -ht * ht + ft * (ft + 2 * lt) + ut;
            else
                ft <= -vt ? (ht = Math.max(0, -(-ot * it + st)),
                ft = ht > 0 ? -it : Math.min(Math.max(-it, -lt), it),
                gt = -ht * ht + ft * (ft + 2 * lt) + ut) : ft <= vt ? (ht = 0,
                ft = Math.min(Math.max(-it, -lt), it),
                gt = ft * (ft + 2 * lt) + ut) : (ht = Math.max(0, -(ot * it + st)),
                ft = ht > 0 ? it : Math.min(Math.max(-it, -lt), it),
                gt = -ht * ht + ft * (ft + 2 * lt) + ut);
        else
            ft = ot > 0 ? -it : it,
            ht = Math.max(0, -(ot * ft + st)),
            gt = -ht * ht + ft * (ft + 2 * lt) + ut;
        return nt && nt.copy(this.direction).multiplyScalar(ht).add(this.origin),
        rt && rt.copy(_segDir).multiplyScalar(ft).add(_segCenter),
        gt
    }
    intersectSphere($, tt) {
        _vector$a.subVectors($.center, this.origin);
        const nt = _vector$a.dot(this.direction)
          , rt = _vector$a.dot(_vector$a) - nt * nt
          , it = $.radius * $.radius;
        if (rt > it)
            return null;
        const ot = Math.sqrt(it - rt)
          , st = nt - ot
          , lt = nt + ot;
        return st < 0 && lt < 0 ? null : st < 0 ? this.at(lt, tt) : this.at(st, tt)
    }
    intersectsSphere($) {
        return this.distanceSqToPoint($.center) <= $.radius * $.radius
    }
    distanceToPlane($) {
        const tt = $.normal.dot(this.direction);
        if (tt === 0)
            return $.distanceToPoint(this.origin) === 0 ? 0 : null;
        const nt = -(this.origin.dot($.normal) + $.constant) / tt;
        return nt >= 0 ? nt : null
    }
    intersectPlane($, tt) {
        const nt = this.distanceToPlane($);
        return nt === null ? null : this.at(nt, tt)
    }
    intersectsPlane($) {
        const tt = $.distanceToPoint(this.origin);
        return tt === 0 || $.normal.dot(this.direction) * tt < 0
    }
    intersectBox($, tt) {
        let nt, rt, it, ot, st, lt;
        const ut = 1 / this.direction.x
          , ct = 1 / this.direction.y
          , ht = 1 / this.direction.z
          , ft = this.origin;
        return ut >= 0 ? (nt = ($.min.x - ft.x) * ut,
        rt = ($.max.x - ft.x) * ut) : (nt = ($.max.x - ft.x) * ut,
        rt = ($.min.x - ft.x) * ut),
        ct >= 0 ? (it = ($.min.y - ft.y) * ct,
        ot = ($.max.y - ft.y) * ct) : (it = ($.max.y - ft.y) * ct,
        ot = ($.min.y - ft.y) * ct),
        nt > ot || it > rt || ((it > nt || nt !== nt) && (nt = it),
        (ot < rt || rt !== rt) && (rt = ot),
        ht >= 0 ? (st = ($.min.z - ft.z) * ht,
        lt = ($.max.z - ft.z) * ht) : (st = ($.max.z - ft.z) * ht,
        lt = ($.min.z - ft.z) * ht),
        nt > lt || st > rt) || ((st > nt || nt !== nt) && (nt = st),
        (lt < rt || rt !== rt) && (rt = lt),
        rt < 0) ? null : this.at(nt >= 0 ? nt : rt, tt)
    }
    intersectsBox($) {
        return this.intersectBox($, _vector$a) !== null
    }
    intersectTriangle($, tt, nt, rt, it) {
        _edge1.subVectors(tt, $),
        _edge2.subVectors(nt, $),
        _normal$1.crossVectors(_edge1, _edge2);
        let ot = this.direction.dot(_normal$1), st;
        if (ot > 0) {
            if (rt)
                return null;
            st = 1
        } else if (ot < 0)
            st = -1,
            ot = -ot;
        else
            return null;
        _diff.subVectors(this.origin, $);
        const lt = st * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (lt < 0)
            return null;
        const ut = st * this.direction.dot(_edge1.cross(_diff));
        if (ut < 0 || lt + ut > ot)
            return null;
        const ct = -st * _diff.dot(_normal$1);
        return ct < 0 ? null : this.at(ct / ot, it)
    }
    applyMatrix4($) {
        return this.origin.applyMatrix4($),
        this.direction.transformDirection($),
        this
    }
    equals($) {
        return $.origin.equals(this.origin) && $.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Matrix4 {
    constructor() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    set($, tt, nt, rt, it, ot, st, lt, ut, ct, ht, ft, gt, vt, yt, wt) {
        const mt = this.elements;
        return mt[0] = $,
        mt[4] = tt,
        mt[8] = nt,
        mt[12] = rt,
        mt[1] = it,
        mt[5] = ot,
        mt[9] = st,
        mt[13] = lt,
        mt[2] = ut,
        mt[6] = ct,
        mt[10] = ht,
        mt[14] = ft,
        mt[3] = gt,
        mt[7] = vt,
        mt[11] = yt,
        mt[15] = wt,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Matrix4().fromArray(this.elements)
    }
    copy($) {
        const tt = this.elements
          , nt = $.elements;
        return tt[0] = nt[0],
        tt[1] = nt[1],
        tt[2] = nt[2],
        tt[3] = nt[3],
        tt[4] = nt[4],
        tt[5] = nt[5],
        tt[6] = nt[6],
        tt[7] = nt[7],
        tt[8] = nt[8],
        tt[9] = nt[9],
        tt[10] = nt[10],
        tt[11] = nt[11],
        tt[12] = nt[12],
        tt[13] = nt[13],
        tt[14] = nt[14],
        tt[15] = nt[15],
        this
    }
    copyPosition($) {
        const tt = this.elements
          , nt = $.elements;
        return tt[12] = nt[12],
        tt[13] = nt[13],
        tt[14] = nt[14],
        this
    }
    setFromMatrix3($) {
        const tt = $.elements;
        return this.set(tt[0], tt[3], tt[6], 0, tt[1], tt[4], tt[7], 0, tt[2], tt[5], tt[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis($, tt, nt) {
        return $.setFromMatrixColumn(this, 0),
        tt.setFromMatrixColumn(this, 1),
        nt.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis($, tt, nt) {
        return this.set($.x, tt.x, nt.x, 0, $.y, tt.y, nt.y, 0, $.z, tt.z, nt.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation($) {
        const tt = this.elements
          , nt = $.elements
          , rt = 1 / _v1$5.setFromMatrixColumn($, 0).length()
          , it = 1 / _v1$5.setFromMatrixColumn($, 1).length()
          , ot = 1 / _v1$5.setFromMatrixColumn($, 2).length();
        return tt[0] = nt[0] * rt,
        tt[1] = nt[1] * rt,
        tt[2] = nt[2] * rt,
        tt[3] = 0,
        tt[4] = nt[4] * it,
        tt[5] = nt[5] * it,
        tt[6] = nt[6] * it,
        tt[7] = 0,
        tt[8] = nt[8] * ot,
        tt[9] = nt[9] * ot,
        tt[10] = nt[10] * ot,
        tt[11] = 0,
        tt[12] = 0,
        tt[13] = 0,
        tt[14] = 0,
        tt[15] = 1,
        this
    }
    makeRotationFromEuler($) {
        $ && $.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        const tt = this.elements
          , nt = $.x
          , rt = $.y
          , it = $.z
          , ot = Math.cos(nt)
          , st = Math.sin(nt)
          , lt = Math.cos(rt)
          , ut = Math.sin(rt)
          , ct = Math.cos(it)
          , ht = Math.sin(it);
        if ($.order === "XYZ") {
            const ft = ot * ct
              , gt = ot * ht
              , vt = st * ct
              , yt = st * ht;
            tt[0] = lt * ct,
            tt[4] = -lt * ht,
            tt[8] = ut,
            tt[1] = gt + vt * ut,
            tt[5] = ft - yt * ut,
            tt[9] = -st * lt,
            tt[2] = yt - ft * ut,
            tt[6] = vt + gt * ut,
            tt[10] = ot * lt
        } else if ($.order === "YXZ") {
            const ft = lt * ct
              , gt = lt * ht
              , vt = ut * ct
              , yt = ut * ht;
            tt[0] = ft + yt * st,
            tt[4] = vt * st - gt,
            tt[8] = ot * ut,
            tt[1] = ot * ht,
            tt[5] = ot * ct,
            tt[9] = -st,
            tt[2] = gt * st - vt,
            tt[6] = yt + ft * st,
            tt[10] = ot * lt
        } else if ($.order === "ZXY") {
            const ft = lt * ct
              , gt = lt * ht
              , vt = ut * ct
              , yt = ut * ht;
            tt[0] = ft - yt * st,
            tt[4] = -ot * ht,
            tt[8] = vt + gt * st,
            tt[1] = gt + vt * st,
            tt[5] = ot * ct,
            tt[9] = yt - ft * st,
            tt[2] = -ot * ut,
            tt[6] = st,
            tt[10] = ot * lt
        } else if ($.order === "ZYX") {
            const ft = ot * ct
              , gt = ot * ht
              , vt = st * ct
              , yt = st * ht;
            tt[0] = lt * ct,
            tt[4] = vt * ut - gt,
            tt[8] = ft * ut + yt,
            tt[1] = lt * ht,
            tt[5] = yt * ut + ft,
            tt[9] = gt * ut - vt,
            tt[2] = -ut,
            tt[6] = st * lt,
            tt[10] = ot * lt
        } else if ($.order === "YZX") {
            const ft = ot * lt
              , gt = ot * ut
              , vt = st * lt
              , yt = st * ut;
            tt[0] = lt * ct,
            tt[4] = yt - ft * ht,
            tt[8] = vt * ht + gt,
            tt[1] = ht,
            tt[5] = ot * ct,
            tt[9] = -st * ct,
            tt[2] = -ut * ct,
            tt[6] = gt * ht + vt,
            tt[10] = ft - yt * ht
        } else if ($.order === "XZY") {
            const ft = ot * lt
              , gt = ot * ut
              , vt = st * lt
              , yt = st * ut;
            tt[0] = lt * ct,
            tt[4] = -ht,
            tt[8] = ut * ct,
            tt[1] = ft * ht + yt,
            tt[5] = ot * ct,
            tt[9] = gt * ht - vt,
            tt[2] = vt * ht - gt,
            tt[6] = st * ct,
            tt[10] = yt * ht + ft
        }
        return tt[3] = 0,
        tt[7] = 0,
        tt[11] = 0,
        tt[12] = 0,
        tt[13] = 0,
        tt[14] = 0,
        tt[15] = 1,
        this
    }
    makeRotationFromQuaternion($) {
        return this.compose(_zero, $, _one)
    }
    lookAt($, tt, nt) {
        const rt = this.elements;
        return _z.subVectors($, tt),
        _z.lengthSq() === 0 && (_z.z = 1),
        _z.normalize(),
        _x.crossVectors(nt, _z),
        _x.lengthSq() === 0 && (Math.abs(nt.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4,
        _z.normalize(),
        _x.crossVectors(nt, _z)),
        _x.normalize(),
        _y.crossVectors(_z, _x),
        rt[0] = _x.x,
        rt[4] = _y.x,
        rt[8] = _z.x,
        rt[1] = _x.y,
        rt[5] = _y.y,
        rt[9] = _z.y,
        rt[2] = _x.z,
        rt[6] = _y.z,
        rt[10] = _z.z,
        this
    }
    multiply($, tt) {
        return tt !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
        this.multiplyMatrices($, tt)) : this.multiplyMatrices(this, $)
    }
    premultiply($) {
        return this.multiplyMatrices($, this)
    }
    multiplyMatrices($, tt) {
        const nt = $.elements
          , rt = tt.elements
          , it = this.elements
          , ot = nt[0]
          , st = nt[4]
          , lt = nt[8]
          , ut = nt[12]
          , ct = nt[1]
          , ht = nt[5]
          , ft = nt[9]
          , gt = nt[13]
          , vt = nt[2]
          , yt = nt[6]
          , wt = nt[10]
          , mt = nt[14]
          , _t = nt[3]
          , bt = nt[7]
          , Mt = nt[11]
          , St = nt[15]
          , At = rt[0]
          , Pt = rt[4]
          , Ot = rt[8]
          , Zt = rt[12]
          , Nt = rt[1]
          , Tt = rt[5]
          , Ft = rt[9]
          , $t = rt[13]
          , Wt = rt[2]
          , Kt = rt[6]
          , qt = rt[10]
          , jt = rt[14]
          , Bt = rt[3]
          , Xt = rt[7]
          , Jt = rt[11]
          , Lt = rt[15];
        return it[0] = ot * At + st * Nt + lt * Wt + ut * Bt,
        it[4] = ot * Pt + st * Tt + lt * Kt + ut * Xt,
        it[8] = ot * Ot + st * Ft + lt * qt + ut * Jt,
        it[12] = ot * Zt + st * $t + lt * jt + ut * Lt,
        it[1] = ct * At + ht * Nt + ft * Wt + gt * Bt,
        it[5] = ct * Pt + ht * Tt + ft * Kt + gt * Xt,
        it[9] = ct * Ot + ht * Ft + ft * qt + gt * Jt,
        it[13] = ct * Zt + ht * $t + ft * jt + gt * Lt,
        it[2] = vt * At + yt * Nt + wt * Wt + mt * Bt,
        it[6] = vt * Pt + yt * Tt + wt * Kt + mt * Xt,
        it[10] = vt * Ot + yt * Ft + wt * qt + mt * Jt,
        it[14] = vt * Zt + yt * $t + wt * jt + mt * Lt,
        it[3] = _t * At + bt * Nt + Mt * Wt + St * Bt,
        it[7] = _t * Pt + bt * Tt + Mt * Kt + St * Xt,
        it[11] = _t * Ot + bt * Ft + Mt * qt + St * Jt,
        it[15] = _t * Zt + bt * $t + Mt * jt + St * Lt,
        this
    }
    multiplyScalar($) {
        const tt = this.elements;
        return tt[0] *= $,
        tt[4] *= $,
        tt[8] *= $,
        tt[12] *= $,
        tt[1] *= $,
        tt[5] *= $,
        tt[9] *= $,
        tt[13] *= $,
        tt[2] *= $,
        tt[6] *= $,
        tt[10] *= $,
        tt[14] *= $,
        tt[3] *= $,
        tt[7] *= $,
        tt[11] *= $,
        tt[15] *= $,
        this
    }
    determinant() {
        const $ = this.elements
          , tt = $[0]
          , nt = $[4]
          , rt = $[8]
          , it = $[12]
          , ot = $[1]
          , st = $[5]
          , lt = $[9]
          , ut = $[13]
          , ct = $[2]
          , ht = $[6]
          , ft = $[10]
          , gt = $[14]
          , vt = $[3]
          , yt = $[7]
          , wt = $[11]
          , mt = $[15];
        return vt * (+it * lt * ht - rt * ut * ht - it * st * ft + nt * ut * ft + rt * st * gt - nt * lt * gt) + yt * (+tt * lt * gt - tt * ut * ft + it * ot * ft - rt * ot * gt + rt * ut * ct - it * lt * ct) + wt * (+tt * ut * ht - tt * st * gt - it * ot * ht + nt * ot * gt + it * st * ct - nt * ut * ct) + mt * (-rt * st * ct - tt * lt * ht + tt * st * ft + rt * ot * ht - nt * ot * ft + nt * lt * ct)
    }
    transpose() {
        const $ = this.elements;
        let tt;
        return tt = $[1],
        $[1] = $[4],
        $[4] = tt,
        tt = $[2],
        $[2] = $[8],
        $[8] = tt,
        tt = $[6],
        $[6] = $[9],
        $[9] = tt,
        tt = $[3],
        $[3] = $[12],
        $[12] = tt,
        tt = $[7],
        $[7] = $[13],
        $[13] = tt,
        tt = $[11],
        $[11] = $[14],
        $[14] = tt,
        this
    }
    setPosition($, tt, nt) {
        const rt = this.elements;
        return $.isVector3 ? (rt[12] = $.x,
        rt[13] = $.y,
        rt[14] = $.z) : (rt[12] = $,
        rt[13] = tt,
        rt[14] = nt),
        this
    }
    invert() {
        const $ = this.elements
          , tt = $[0]
          , nt = $[1]
          , rt = $[2]
          , it = $[3]
          , ot = $[4]
          , st = $[5]
          , lt = $[6]
          , ut = $[7]
          , ct = $[8]
          , ht = $[9]
          , ft = $[10]
          , gt = $[11]
          , vt = $[12]
          , yt = $[13]
          , wt = $[14]
          , mt = $[15]
          , _t = ht * wt * ut - yt * ft * ut + yt * lt * gt - st * wt * gt - ht * lt * mt + st * ft * mt
          , bt = vt * ft * ut - ct * wt * ut - vt * lt * gt + ot * wt * gt + ct * lt * mt - ot * ft * mt
          , Mt = ct * yt * ut - vt * ht * ut + vt * st * gt - ot * yt * gt - ct * st * mt + ot * ht * mt
          , St = vt * ht * lt - ct * yt * lt - vt * st * ft + ot * yt * ft + ct * st * wt - ot * ht * wt
          , At = tt * _t + nt * bt + rt * Mt + it * St;
        if (At === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const Pt = 1 / At;
        return $[0] = _t * Pt,
        $[1] = (yt * ft * it - ht * wt * it - yt * rt * gt + nt * wt * gt + ht * rt * mt - nt * ft * mt) * Pt,
        $[2] = (st * wt * it - yt * lt * it + yt * rt * ut - nt * wt * ut - st * rt * mt + nt * lt * mt) * Pt,
        $[3] = (ht * lt * it - st * ft * it - ht * rt * ut + nt * ft * ut + st * rt * gt - nt * lt * gt) * Pt,
        $[4] = bt * Pt,
        $[5] = (ct * wt * it - vt * ft * it + vt * rt * gt - tt * wt * gt - ct * rt * mt + tt * ft * mt) * Pt,
        $[6] = (vt * lt * it - ot * wt * it - vt * rt * ut + tt * wt * ut + ot * rt * mt - tt * lt * mt) * Pt,
        $[7] = (ot * ft * it - ct * lt * it + ct * rt * ut - tt * ft * ut - ot * rt * gt + tt * lt * gt) * Pt,
        $[8] = Mt * Pt,
        $[9] = (vt * ht * it - ct * yt * it - vt * nt * gt + tt * yt * gt + ct * nt * mt - tt * ht * mt) * Pt,
        $[10] = (ot * yt * it - vt * st * it + vt * nt * ut - tt * yt * ut - ot * nt * mt + tt * st * mt) * Pt,
        $[11] = (ct * st * it - ot * ht * it - ct * nt * ut + tt * ht * ut + ot * nt * gt - tt * st * gt) * Pt,
        $[12] = St * Pt,
        $[13] = (ct * yt * rt - vt * ht * rt + vt * nt * ft - tt * yt * ft - ct * nt * wt + tt * ht * wt) * Pt,
        $[14] = (vt * st * rt - ot * yt * rt - vt * nt * lt + tt * yt * lt + ot * nt * wt - tt * st * wt) * Pt,
        $[15] = (ot * ht * rt - ct * st * rt + ct * nt * lt - tt * ht * lt - ot * nt * ft + tt * st * ft) * Pt,
        this
    }
    scale($) {
        const tt = this.elements
          , nt = $.x
          , rt = $.y
          , it = $.z;
        return tt[0] *= nt,
        tt[4] *= rt,
        tt[8] *= it,
        tt[1] *= nt,
        tt[5] *= rt,
        tt[9] *= it,
        tt[2] *= nt,
        tt[6] *= rt,
        tt[10] *= it,
        tt[3] *= nt,
        tt[7] *= rt,
        tt[11] *= it,
        this
    }
    getMaxScaleOnAxis() {
        const $ = this.elements
          , tt = $[0] * $[0] + $[1] * $[1] + $[2] * $[2]
          , nt = $[4] * $[4] + $[5] * $[5] + $[6] * $[6]
          , rt = $[8] * $[8] + $[9] * $[9] + $[10] * $[10];
        return Math.sqrt(Math.max(tt, nt, rt))
    }
    makeTranslation($, tt, nt) {
        return this.set(1, 0, 0, $, 0, 1, 0, tt, 0, 0, 1, nt, 0, 0, 0, 1),
        this
    }
    makeRotationX($) {
        const tt = Math.cos($)
          , nt = Math.sin($);
        return this.set(1, 0, 0, 0, 0, tt, -nt, 0, 0, nt, tt, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY($) {
        const tt = Math.cos($)
          , nt = Math.sin($);
        return this.set(tt, 0, nt, 0, 0, 1, 0, 0, -nt, 0, tt, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ($) {
        const tt = Math.cos($)
          , nt = Math.sin($);
        return this.set(tt, -nt, 0, 0, nt, tt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis($, tt) {
        const nt = Math.cos(tt)
          , rt = Math.sin(tt)
          , it = 1 - nt
          , ot = $.x
          , st = $.y
          , lt = $.z
          , ut = it * ot
          , ct = it * st;
        return this.set(ut * ot + nt, ut * st - rt * lt, ut * lt + rt * st, 0, ut * st + rt * lt, ct * st + nt, ct * lt - rt * ot, 0, ut * lt - rt * st, ct * lt + rt * ot, it * lt * lt + nt, 0, 0, 0, 0, 1),
        this
    }
    makeScale($, tt, nt) {
        return this.set($, 0, 0, 0, 0, tt, 0, 0, 0, 0, nt, 0, 0, 0, 0, 1),
        this
    }
    makeShear($, tt, nt, rt, it, ot) {
        return this.set(1, nt, it, 0, $, 1, ot, 0, tt, rt, 1, 0, 0, 0, 0, 1),
        this
    }
    compose($, tt, nt) {
        const rt = this.elements
          , it = tt._x
          , ot = tt._y
          , st = tt._z
          , lt = tt._w
          , ut = it + it
          , ct = ot + ot
          , ht = st + st
          , ft = it * ut
          , gt = it * ct
          , vt = it * ht
          , yt = ot * ct
          , wt = ot * ht
          , mt = st * ht
          , _t = lt * ut
          , bt = lt * ct
          , Mt = lt * ht
          , St = nt.x
          , At = nt.y
          , Pt = nt.z;
        return rt[0] = (1 - (yt + mt)) * St,
        rt[1] = (gt + Mt) * St,
        rt[2] = (vt - bt) * St,
        rt[3] = 0,
        rt[4] = (gt - Mt) * At,
        rt[5] = (1 - (ft + mt)) * At,
        rt[6] = (wt + _t) * At,
        rt[7] = 0,
        rt[8] = (vt + bt) * Pt,
        rt[9] = (wt - _t) * Pt,
        rt[10] = (1 - (ft + yt)) * Pt,
        rt[11] = 0,
        rt[12] = $.x,
        rt[13] = $.y,
        rt[14] = $.z,
        rt[15] = 1,
        this
    }
    decompose($, tt, nt) {
        const rt = this.elements;
        let it = _v1$5.set(rt[0], rt[1], rt[2]).length();
        const ot = _v1$5.set(rt[4], rt[5], rt[6]).length()
          , st = _v1$5.set(rt[8], rt[9], rt[10]).length();
        this.determinant() < 0 && (it = -it),
        $.x = rt[12],
        $.y = rt[13],
        $.z = rt[14],
        _m1$2.copy(this);
        const ut = 1 / it
          , ct = 1 / ot
          , ht = 1 / st;
        return _m1$2.elements[0] *= ut,
        _m1$2.elements[1] *= ut,
        _m1$2.elements[2] *= ut,
        _m1$2.elements[4] *= ct,
        _m1$2.elements[5] *= ct,
        _m1$2.elements[6] *= ct,
        _m1$2.elements[8] *= ht,
        _m1$2.elements[9] *= ht,
        _m1$2.elements[10] *= ht,
        tt.setFromRotationMatrix(_m1$2),
        nt.x = it,
        nt.y = ot,
        nt.z = st,
        this
    }
    makePerspective($, tt, nt, rt, it, ot) {
        ot === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        const st = this.elements
          , lt = 2 * it / (tt - $)
          , ut = 2 * it / (nt - rt)
          , ct = (tt + $) / (tt - $)
          , ht = (nt + rt) / (nt - rt)
          , ft = -(ot + it) / (ot - it)
          , gt = -2 * ot * it / (ot - it);
        return st[0] = lt,
        st[4] = 0,
        st[8] = ct,
        st[12] = 0,
        st[1] = 0,
        st[5] = ut,
        st[9] = ht,
        st[13] = 0,
        st[2] = 0,
        st[6] = 0,
        st[10] = ft,
        st[14] = gt,
        st[3] = 0,
        st[7] = 0,
        st[11] = -1,
        st[15] = 0,
        this
    }
    makeOrthographic($, tt, nt, rt, it, ot) {
        const st = this.elements
          , lt = 1 / (tt - $)
          , ut = 1 / (nt - rt)
          , ct = 1 / (ot - it)
          , ht = (tt + $) * lt
          , ft = (nt + rt) * ut
          , gt = (ot + it) * ct;
        return st[0] = 2 * lt,
        st[4] = 0,
        st[8] = 0,
        st[12] = -ht,
        st[1] = 0,
        st[5] = 2 * ut,
        st[9] = 0,
        st[13] = -ft,
        st[2] = 0,
        st[6] = 0,
        st[10] = -2 * ct,
        st[14] = -gt,
        st[3] = 0,
        st[7] = 0,
        st[11] = 0,
        st[15] = 1,
        this
    }
    equals($) {
        const tt = this.elements
          , nt = $.elements;
        for (let rt = 0; rt < 16; rt++)
            if (tt[rt] !== nt[rt])
                return !1;
        return !0
    }
    fromArray($, tt=0) {
        for (let nt = 0; nt < 16; nt++)
            this.elements[nt] = $[nt + tt];
        return this
    }
    toArray($=[], tt=0) {
        const nt = this.elements;
        return $[tt] = nt[0],
        $[tt + 1] = nt[1],
        $[tt + 2] = nt[2],
        $[tt + 3] = nt[3],
        $[tt + 4] = nt[4],
        $[tt + 5] = nt[5],
        $[tt + 6] = nt[6],
        $[tt + 7] = nt[7],
        $[tt + 8] = nt[8],
        $[tt + 9] = nt[9],
        $[tt + 10] = nt[10],
        $[tt + 11] = nt[11],
        $[tt + 12] = nt[12],
        $[tt + 13] = nt[13],
        $[tt + 14] = nt[14],
        $[tt + 15] = nt[15],
        $
    }
}
Matrix4.prototype.isMatrix4 = !0;
const _v1$5 = new Vector3
  , _m1$2 = new Matrix4
  , _zero = new Vector3(0,0,0)
  , _one = new Vector3(1,1,1)
  , _x = new Vector3
  , _y = new Vector3
  , _z = new Vector3
  , _matrix$1 = new Matrix4
  , _quaternion$3 = new Quaternion;
class Euler {
    constructor($=0, tt=0, nt=0, rt=Euler.DefaultOrder) {
        this._x = $,
        this._y = tt,
        this._z = nt,
        this._order = rt
    }
    get x() {
        return this._x
    }
    set x($) {
        this._x = $,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y($) {
        this._y = $,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z($) {
        this._z = $,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order($) {
        this._order = $,
        this._onChangeCallback()
    }
    set($, tt, nt, rt=this._order) {
        return this._x = $,
        this._y = tt,
        this._z = nt,
        this._order = rt,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy($) {
        return this._x = $._x,
        this._y = $._y,
        this._z = $._z,
        this._order = $._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix($, tt=this._order, nt=!0) {
        const rt = $.elements
          , it = rt[0]
          , ot = rt[4]
          , st = rt[8]
          , lt = rt[1]
          , ut = rt[5]
          , ct = rt[9]
          , ht = rt[2]
          , ft = rt[6]
          , gt = rt[10];
        switch (tt) {
        case "XYZ":
            this._y = Math.asin(clamp$1(st, -1, 1)),
            Math.abs(st) < .9999999 ? (this._x = Math.atan2(-ct, gt),
            this._z = Math.atan2(-ot, it)) : (this._x = Math.atan2(ft, ut),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-clamp$1(ct, -1, 1)),
            Math.abs(ct) < .9999999 ? (this._y = Math.atan2(st, gt),
            this._z = Math.atan2(lt, ut)) : (this._y = Math.atan2(-ht, it),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(clamp$1(ft, -1, 1)),
            Math.abs(ft) < .9999999 ? (this._y = Math.atan2(-ht, gt),
            this._z = Math.atan2(-ot, ut)) : (this._y = 0,
            this._z = Math.atan2(lt, it));
            break;
        case "ZYX":
            this._y = Math.asin(-clamp$1(ht, -1, 1)),
            Math.abs(ht) < .9999999 ? (this._x = Math.atan2(ft, gt),
            this._z = Math.atan2(lt, it)) : (this._x = 0,
            this._z = Math.atan2(-ot, ut));
            break;
        case "YZX":
            this._z = Math.asin(clamp$1(lt, -1, 1)),
            Math.abs(lt) < .9999999 ? (this._x = Math.atan2(-ct, ut),
            this._y = Math.atan2(-ht, it)) : (this._x = 0,
            this._y = Math.atan2(st, gt));
            break;
        case "XZY":
            this._z = Math.asin(-clamp$1(ot, -1, 1)),
            Math.abs(ot) < .9999999 ? (this._x = Math.atan2(ft, ut),
            this._y = Math.atan2(st, it)) : (this._x = Math.atan2(-ct, gt),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + tt)
        }
        return this._order = tt,
        nt === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion($, tt, nt) {
        return _matrix$1.makeRotationFromQuaternion($),
        this.setFromRotationMatrix(_matrix$1, tt, nt)
    }
    setFromVector3($, tt=this._order) {
        return this.set($.x, $.y, $.z, tt)
    }
    reorder($) {
        return _quaternion$3.setFromEuler(this),
        this.setFromQuaternion(_quaternion$3, $)
    }
    equals($) {
        return $._x === this._x && $._y === this._y && $._z === this._z && $._order === this._order
    }
    fromArray($) {
        return this._x = $[0],
        this._y = $[1],
        this._z = $[2],
        $[3] !== void 0 && (this._order = $[3]),
        this._onChangeCallback(),
        this
    }
    toArray($=[], tt=0) {
        return $[tt] = this._x,
        $[tt + 1] = this._y,
        $[tt + 2] = this._z,
        $[tt + 3] = this._order,
        $
    }
    _onChange($) {
        return this._onChangeCallback = $,
        this
    }
    _onChangeCallback() {}
}
Euler.prototype.isEuler = !0;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Layers {
    constructor() {
        this.mask = 1
    }
    set($) {
        this.mask = (1 << $ | 0) >>> 0
    }
    enable($) {
        this.mask |= 1 << $ | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle($) {
        this.mask ^= 1 << $ | 0
    }
    disable($) {
        this.mask &= ~(1 << $ | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test($) {
        return (this.mask & $.mask) !== 0
    }
    isEnabled($) {
        return (this.mask & (1 << $ | 0)) !== 0
    }
}
let _object3DId = 0;
const _v1$4 = new Vector3
  , _q1 = new Quaternion
  , _m1$1 = new Matrix4
  , _target = new Vector3
  , _position$3 = new Vector3
  , _scale$2 = new Vector3
  , _quaternion$2 = new Quaternion
  , _xAxis = new Vector3(1,0,0)
  , _yAxis = new Vector3(0,1,0)
  , _zAxis = new Vector3(0,0,1)
  , _addedEvent = {
    type: "added"
}
  , _removedEvent = {
    type: "removed"
};
class Object3D extends EventDispatcher {
    constructor() {
        super(),
        Object.defineProperty(this, "id", {
            value: _object3DId++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Object3D.DefaultUp.clone();
        const $ = new Vector3
          , tt = new Euler
          , nt = new Quaternion
          , rt = new Vector3(1,1,1);
        function it() {
            nt.setFromEuler(tt, !1)
        }
        function ot() {
            tt.setFromQuaternion(nt, void 0, !1)
        }
        tt._onChange(it),
        nt._onChange(ot),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: $
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: tt
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: nt
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: rt
            },
            modelViewMatrix: {
                value: new Matrix4
            },
            normalMatrix: {
                value: new Matrix3
            }
        }),
        this.matrix = new Matrix4,
        this.matrixWorld = new Matrix4,
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new Layers,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4($) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply($),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion($) {
        return this.quaternion.premultiply($),
        this
    }
    setRotationFromAxisAngle($, tt) {
        this.quaternion.setFromAxisAngle($, tt)
    }
    setRotationFromEuler($) {
        this.quaternion.setFromEuler($, !0)
    }
    setRotationFromMatrix($) {
        this.quaternion.setFromRotationMatrix($)
    }
    setRotationFromQuaternion($) {
        this.quaternion.copy($)
    }
    rotateOnAxis($, tt) {
        return _q1.setFromAxisAngle($, tt),
        this.quaternion.multiply(_q1),
        this
    }
    rotateOnWorldAxis($, tt) {
        return _q1.setFromAxisAngle($, tt),
        this.quaternion.premultiply(_q1),
        this
    }
    rotateX($) {
        return this.rotateOnAxis(_xAxis, $)
    }
    rotateY($) {
        return this.rotateOnAxis(_yAxis, $)
    }
    rotateZ($) {
        return this.rotateOnAxis(_zAxis, $)
    }
    translateOnAxis($, tt) {
        return _v1$4.copy($).applyQuaternion(this.quaternion),
        this.position.add(_v1$4.multiplyScalar(tt)),
        this
    }
    translateX($) {
        return this.translateOnAxis(_xAxis, $)
    }
    translateY($) {
        return this.translateOnAxis(_yAxis, $)
    }
    translateZ($) {
        return this.translateOnAxis(_zAxis, $)
    }
    localToWorld($) {
        return $.applyMatrix4(this.matrixWorld)
    }
    worldToLocal($) {
        return $.applyMatrix4(_m1$1.copy(this.matrixWorld).invert())
    }
    lookAt($, tt, nt) {
        $.isVector3 ? _target.copy($) : _target.set($, tt, nt);
        const rt = this.parent;
        this.updateWorldMatrix(!0, !1),
        _position$3.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? _m1$1.lookAt(_position$3, _target, this.up) : _m1$1.lookAt(_target, _position$3, this.up),
        this.quaternion.setFromRotationMatrix(_m1$1),
        rt && (_m1$1.extractRotation(rt.matrixWorld),
        _q1.setFromRotationMatrix(_m1$1),
        this.quaternion.premultiply(_q1.invert()))
    }
    add($) {
        if (arguments.length > 1) {
            for (let tt = 0; tt < arguments.length; tt++)
                this.add(arguments[tt]);
            return this
        }
        return $ === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", $),
        this) : ($ && $.isObject3D ? ($.parent !== null && $.parent.remove($),
        $.parent = this,
        this.children.push($),
        $.dispatchEvent(_addedEvent)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", $),
        this)
    }
    remove($) {
        if (arguments.length > 1) {
            for (let nt = 0; nt < arguments.length; nt++)
                this.remove(arguments[nt]);
            return this
        }
        const tt = this.children.indexOf($);
        return tt !== -1 && ($.parent = null,
        this.children.splice(tt, 1),
        $.dispatchEvent(_removedEvent)),
        this
    }
    removeFromParent() {
        const $ = this.parent;
        return $ !== null && $.remove(this),
        this
    }
    clear() {
        for (let $ = 0; $ < this.children.length; $++) {
            const tt = this.children[$];
            tt.parent = null,
            tt.dispatchEvent(_removedEvent)
        }
        return this.children.length = 0,
        this
    }
    attach($) {
        return this.updateWorldMatrix(!0, !1),
        _m1$1.copy(this.matrixWorld).invert(),
        $.parent !== null && ($.parent.updateWorldMatrix(!0, !1),
        _m1$1.multiply($.parent.matrixWorld)),
        $.applyMatrix4(_m1$1),
        this.add($),
        $.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById($) {
        return this.getObjectByProperty("id", $)
    }
    getObjectByName($) {
        return this.getObjectByProperty("name", $)
    }
    getObjectByProperty($, tt) {
        if (this[$] === tt)
            return this;
        for (let nt = 0, rt = this.children.length; nt < rt; nt++) {
            const ot = this.children[nt].getObjectByProperty($, tt);
            if (ot !== void 0)
                return ot
        }
    }
    getWorldPosition($) {
        return this.updateWorldMatrix(!0, !1),
        $.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion($) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(_position$3, $, _scale$2),
        $
    }
    getWorldScale($) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(_position$3, _quaternion$2, $),
        $
    }
    getWorldDirection($) {
        this.updateWorldMatrix(!0, !1);
        const tt = this.matrixWorld.elements;
        return $.set(tt[8], tt[9], tt[10]).normalize()
    }
    raycast() {}
    traverse($) {
        $(this);
        const tt = this.children;
        for (let nt = 0, rt = tt.length; nt < rt; nt++)
            tt[nt].traverse($)
    }
    traverseVisible($) {
        if (this.visible === !1)
            return;
        $(this);
        const tt = this.children;
        for (let nt = 0, rt = tt.length; nt < rt; nt++)
            tt[nt].traverseVisible($)
    }
    traverseAncestors($) {
        const tt = this.parent;
        tt !== null && ($(tt),
        tt.traverseAncestors($))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld($) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || $) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        $ = !0);
        const tt = this.children;
        for (let nt = 0, rt = tt.length; nt < rt; nt++)
            tt[nt].updateMatrixWorld($)
    }
    updateWorldMatrix($, tt) {
        const nt = this.parent;
        if ($ === !0 && nt !== null && nt.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        tt === !0) {
            const rt = this.children;
            for (let it = 0, ot = rt.length; it < ot; it++)
                rt[it].updateWorldMatrix(!1, !0)
        }
    }
    toJSON($) {
        const tt = $ === void 0 || typeof $ == "string"
          , nt = {};
        tt && ($ = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        nt.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const rt = {};
        rt.uuid = this.uuid,
        rt.type = this.type,
        this.name !== "" && (rt.name = this.name),
        this.castShadow === !0 && (rt.castShadow = !0),
        this.receiveShadow === !0 && (rt.receiveShadow = !0),
        this.visible === !1 && (rt.visible = !1),
        this.frustumCulled === !1 && (rt.frustumCulled = !1),
        this.renderOrder !== 0 && (rt.renderOrder = this.renderOrder),
        JSON.stringify(this.userData) !== "{}" && (rt.userData = this.userData),
        rt.layers = this.layers.mask,
        rt.matrix = this.matrix.toArray(),
        this.matrixAutoUpdate === !1 && (rt.matrixAutoUpdate = !1),
        this.isInstancedMesh && (rt.type = "InstancedMesh",
        rt.count = this.count,
        rt.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (rt.instanceColor = this.instanceColor.toJSON()));
        function it(st, lt) {
            return st[lt.uuid] === void 0 && (st[lt.uuid] = lt.toJSON($)),
            lt.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? rt.background = this.background.toJSON() : this.background.isTexture && (rt.background = this.background.toJSON($).uuid)),
            this.environment && this.environment.isTexture && (rt.environment = this.environment.toJSON($).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            rt.geometry = it($.geometries, this.geometry);
            const st = this.geometry.parameters;
            if (st !== void 0 && st.shapes !== void 0) {
                const lt = st.shapes;
                if (Array.isArray(lt))
                    for (let ut = 0, ct = lt.length; ut < ct; ut++) {
                        const ht = lt[ut];
                        it($.shapes, ht)
                    }
                else
                    it($.shapes, lt)
            }
        }
        if (this.isSkinnedMesh && (rt.bindMode = this.bindMode,
        rt.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (it($.skeletons, this.skeleton),
        rt.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const st = [];
                for (let lt = 0, ut = this.material.length; lt < ut; lt++)
                    st.push(it($.materials, this.material[lt]));
                rt.material = st
            } else
                rt.material = it($.materials, this.material);
        if (this.children.length > 0) {
            rt.children = [];
            for (let st = 0; st < this.children.length; st++)
                rt.children.push(this.children[st].toJSON($).object)
        }
        if (this.animations.length > 0) {
            rt.animations = [];
            for (let st = 0; st < this.animations.length; st++) {
                const lt = this.animations[st];
                rt.animations.push(it($.animations, lt))
            }
        }
        if (tt) {
            const st = ot($.geometries)
              , lt = ot($.materials)
              , ut = ot($.textures)
              , ct = ot($.images)
              , ht = ot($.shapes)
              , ft = ot($.skeletons)
              , gt = ot($.animations)
              , vt = ot($.nodes);
            st.length > 0 && (nt.geometries = st),
            lt.length > 0 && (nt.materials = lt),
            ut.length > 0 && (nt.textures = ut),
            ct.length > 0 && (nt.images = ct),
            ht.length > 0 && (nt.shapes = ht),
            ft.length > 0 && (nt.skeletons = ft),
            gt.length > 0 && (nt.animations = gt),
            vt.length > 0 && (nt.nodes = vt)
        }
        return nt.object = rt,
        nt;
        function ot(st) {
            const lt = [];
            for (const ut in st) {
                const ct = st[ut];
                delete ct.metadata,
                lt.push(ct)
            }
            return lt
        }
    }
    clone($) {
        return new this.constructor().copy(this, $)
    }
    copy($, tt=!0) {
        if (this.name = $.name,
        this.up.copy($.up),
        this.position.copy($.position),
        this.rotation.order = $.rotation.order,
        this.quaternion.copy($.quaternion),
        this.scale.copy($.scale),
        this.matrix.copy($.matrix),
        this.matrixWorld.copy($.matrixWorld),
        this.matrixAutoUpdate = $.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = $.matrixWorldNeedsUpdate,
        this.layers.mask = $.layers.mask,
        this.visible = $.visible,
        this.castShadow = $.castShadow,
        this.receiveShadow = $.receiveShadow,
        this.frustumCulled = $.frustumCulled,
        this.renderOrder = $.renderOrder,
        this.userData = JSON.parse(JSON.stringify($.userData)),
        tt === !0)
            for (let nt = 0; nt < $.children.length; nt++) {
                const rt = $.children[nt];
                this.add(rt.clone())
            }
        return this
    }
}
Object3D.DefaultUp = new Vector3(0,1,0);
Object3D.DefaultMatrixAutoUpdate = !0;
Object3D.prototype.isObject3D = !0;
const _v0$1 = new Vector3
  , _v1$3 = new Vector3
  , _v2$2 = new Vector3
  , _v3$1 = new Vector3
  , _vab = new Vector3
  , _vac = new Vector3
  , _vbc = new Vector3
  , _vap = new Vector3
  , _vbp = new Vector3
  , _vcp = new Vector3;
class Triangle {
    constructor($=new Vector3, tt=new Vector3, nt=new Vector3) {
        this.a = $,
        this.b = tt,
        this.c = nt
    }
    static getNormal($, tt, nt, rt) {
        rt.subVectors(nt, tt),
        _v0$1.subVectors($, tt),
        rt.cross(_v0$1);
        const it = rt.lengthSq();
        return it > 0 ? rt.multiplyScalar(1 / Math.sqrt(it)) : rt.set(0, 0, 0)
    }
    static getBarycoord($, tt, nt, rt, it) {
        _v0$1.subVectors(rt, tt),
        _v1$3.subVectors(nt, tt),
        _v2$2.subVectors($, tt);
        const ot = _v0$1.dot(_v0$1)
          , st = _v0$1.dot(_v1$3)
          , lt = _v0$1.dot(_v2$2)
          , ut = _v1$3.dot(_v1$3)
          , ct = _v1$3.dot(_v2$2)
          , ht = ot * ut - st * st;
        if (ht === 0)
            return it.set(-2, -1, -1);
        const ft = 1 / ht
          , gt = (ut * lt - st * ct) * ft
          , vt = (ot * ct - st * lt) * ft;
        return it.set(1 - gt - vt, vt, gt)
    }
    static containsPoint($, tt, nt, rt) {
        return this.getBarycoord($, tt, nt, rt, _v3$1),
        _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1
    }
    static getUV($, tt, nt, rt, it, ot, st, lt) {
        return this.getBarycoord($, tt, nt, rt, _v3$1),
        lt.set(0, 0),
        lt.addScaledVector(it, _v3$1.x),
        lt.addScaledVector(ot, _v3$1.y),
        lt.addScaledVector(st, _v3$1.z),
        lt
    }
    static isFrontFacing($, tt, nt, rt) {
        return _v0$1.subVectors(nt, tt),
        _v1$3.subVectors($, tt),
        _v0$1.cross(_v1$3).dot(rt) < 0
    }
    set($, tt, nt) {
        return this.a.copy($),
        this.b.copy(tt),
        this.c.copy(nt),
        this
    }
    setFromPointsAndIndices($, tt, nt, rt) {
        return this.a.copy($[tt]),
        this.b.copy($[nt]),
        this.c.copy($[rt]),
        this
    }
    setFromAttributeAndIndices($, tt, nt, rt) {
        return this.a.fromBufferAttribute($, tt),
        this.b.fromBufferAttribute($, nt),
        this.c.fromBufferAttribute($, rt),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy($) {
        return this.a.copy($.a),
        this.b.copy($.b),
        this.c.copy($.c),
        this
    }
    getArea() {
        return _v0$1.subVectors(this.c, this.b),
        _v1$3.subVectors(this.a, this.b),
        _v0$1.cross(_v1$3).length() * .5
    }
    getMidpoint($) {
        return $.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal($) {
        return Triangle.getNormal(this.a, this.b, this.c, $)
    }
    getPlane($) {
        return $.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord($, tt) {
        return Triangle.getBarycoord($, this.a, this.b, this.c, tt)
    }
    getUV($, tt, nt, rt, it) {
        return Triangle.getUV($, this.a, this.b, this.c, tt, nt, rt, it)
    }
    containsPoint($) {
        return Triangle.containsPoint($, this.a, this.b, this.c)
    }
    isFrontFacing($) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, $)
    }
    intersectsBox($) {
        return $.intersectsTriangle(this)
    }
    closestPointToPoint($, tt) {
        const nt = this.a
          , rt = this.b
          , it = this.c;
        let ot, st;
        _vab.subVectors(rt, nt),
        _vac.subVectors(it, nt),
        _vap.subVectors($, nt);
        const lt = _vab.dot(_vap)
          , ut = _vac.dot(_vap);
        if (lt <= 0 && ut <= 0)
            return tt.copy(nt);
        _vbp.subVectors($, rt);
        const ct = _vab.dot(_vbp)
          , ht = _vac.dot(_vbp);
        if (ct >= 0 && ht <= ct)
            return tt.copy(rt);
        const ft = lt * ht - ct * ut;
        if (ft <= 0 && lt >= 0 && ct <= 0)
            return ot = lt / (lt - ct),
            tt.copy(nt).addScaledVector(_vab, ot);
        _vcp.subVectors($, it);
        const gt = _vab.dot(_vcp)
          , vt = _vac.dot(_vcp);
        if (vt >= 0 && gt <= vt)
            return tt.copy(it);
        const yt = gt * ut - lt * vt;
        if (yt <= 0 && ut >= 0 && vt <= 0)
            return st = ut / (ut - vt),
            tt.copy(nt).addScaledVector(_vac, st);
        const wt = ct * vt - gt * ht;
        if (wt <= 0 && ht - ct >= 0 && gt - vt >= 0)
            return _vbc.subVectors(it, rt),
            st = (ht - ct) / (ht - ct + (gt - vt)),
            tt.copy(rt).addScaledVector(_vbc, st);
        const mt = 1 / (wt + yt + ft);
        return ot = yt * mt,
        st = ft * mt,
        tt.copy(nt).addScaledVector(_vab, ot).addScaledVector(_vac, st)
    }
    equals($) {
        return $.a.equals(this.a) && $.b.equals(this.b) && $.c.equals(this.c)
    }
}
let materialId = 0;
class Material extends EventDispatcher {
    constructor() {
        super(),
        Object.defineProperty(this, "id", {
            value: materialId++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.blending = NormalBlending,
        this.side = FrontSide,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = SrcAlphaFactor,
        this.blendDst = OneMinusSrcAlphaFactor,
        this.blendEquation = AddEquation,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = LessEqualDepth,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = AlwaysStencilFunc,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = KeepStencilOp,
        this.stencilZFail = KeepStencilOp,
        this.stencilZPass = KeepStencilOp,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest($) {
        this._alphaTest > 0 != $ > 0 && this.version++,
        this._alphaTest = $
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues($) {
        if ($ !== void 0)
            for (const tt in $) {
                const nt = $[tt];
                if (nt === void 0) {
                    console.warn("THREE.Material: '" + tt + "' parameter is undefined.");
                    continue
                }
                if (tt === "shading") {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                    this.flatShading = nt === FlatShading;
                    continue
                }
                const rt = this[tt];
                if (rt === void 0) {
                    console.warn("THREE." + this.type + ": '" + tt + "' is not a property of this material.");
                    continue
                }
                rt && rt.isColor ? rt.set(nt) : rt && rt.isVector3 && nt && nt.isVector3 ? rt.copy(nt) : this[tt] = nt
            }
    }
    toJSON($) {
        const tt = $ === void 0 || typeof $ == "string";
        tt && ($ = {
            textures: {},
            images: {}
        });
        const nt = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        nt.uuid = this.uuid,
        nt.type = this.type,
        this.name !== "" && (nt.name = this.name),
        this.color && this.color.isColor && (nt.color = this.color.getHex()),
        this.roughness !== void 0 && (nt.roughness = this.roughness),
        this.metalness !== void 0 && (nt.metalness = this.metalness),
        this.sheen !== void 0 && (nt.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (nt.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (nt.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (nt.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (nt.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (nt.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (nt.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (nt.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (nt.shininess = this.shininess),
        this.clearcoat !== void 0 && (nt.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (nt.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (nt.clearcoatMap = this.clearcoatMap.toJSON($).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (nt.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON($).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (nt.clearcoatNormalMap = this.clearcoatNormalMap.toJSON($).uuid,
        nt.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.map && this.map.isTexture && (nt.map = this.map.toJSON($).uuid),
        this.matcap && this.matcap.isTexture && (nt.matcap = this.matcap.toJSON($).uuid),
        this.alphaMap && this.alphaMap.isTexture && (nt.alphaMap = this.alphaMap.toJSON($).uuid),
        this.lightMap && this.lightMap.isTexture && (nt.lightMap = this.lightMap.toJSON($).uuid,
        nt.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (nt.aoMap = this.aoMap.toJSON($).uuid,
        nt.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (nt.bumpMap = this.bumpMap.toJSON($).uuid,
        nt.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (nt.normalMap = this.normalMap.toJSON($).uuid,
        nt.normalMapType = this.normalMapType,
        nt.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (nt.displacementMap = this.displacementMap.toJSON($).uuid,
        nt.displacementScale = this.displacementScale,
        nt.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (nt.roughnessMap = this.roughnessMap.toJSON($).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (nt.metalnessMap = this.metalnessMap.toJSON($).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (nt.emissiveMap = this.emissiveMap.toJSON($).uuid),
        this.specularMap && this.specularMap.isTexture && (nt.specularMap = this.specularMap.toJSON($).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (nt.specularIntensityMap = this.specularIntensityMap.toJSON($).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (nt.specularColorMap = this.specularColorMap.toJSON($).uuid),
        this.envMap && this.envMap.isTexture && (nt.envMap = this.envMap.toJSON($).uuid,
        this.combine !== void 0 && (nt.combine = this.combine)),
        this.envMapIntensity !== void 0 && (nt.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (nt.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (nt.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (nt.gradientMap = this.gradientMap.toJSON($).uuid),
        this.transmission !== void 0 && (nt.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (nt.transmissionMap = this.transmissionMap.toJSON($).uuid),
        this.thickness !== void 0 && (nt.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (nt.thicknessMap = this.thicknessMap.toJSON($).uuid),
        this.attenuationDistance !== void 0 && (nt.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (nt.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (nt.size = this.size),
        this.shadowSide !== null && (nt.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (nt.sizeAttenuation = this.sizeAttenuation),
        this.blending !== NormalBlending && (nt.blending = this.blending),
        this.side !== FrontSide && (nt.side = this.side),
        this.vertexColors && (nt.vertexColors = !0),
        this.opacity < 1 && (nt.opacity = this.opacity),
        this.transparent === !0 && (nt.transparent = this.transparent),
        nt.depthFunc = this.depthFunc,
        nt.depthTest = this.depthTest,
        nt.depthWrite = this.depthWrite,
        nt.colorWrite = this.colorWrite,
        nt.stencilWrite = this.stencilWrite,
        nt.stencilWriteMask = this.stencilWriteMask,
        nt.stencilFunc = this.stencilFunc,
        nt.stencilRef = this.stencilRef,
        nt.stencilFuncMask = this.stencilFuncMask,
        nt.stencilFail = this.stencilFail,
        nt.stencilZFail = this.stencilZFail,
        nt.stencilZPass = this.stencilZPass,
        this.rotation !== void 0 && this.rotation !== 0 && (nt.rotation = this.rotation),
        this.polygonOffset === !0 && (nt.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (nt.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (nt.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (nt.linewidth = this.linewidth),
        this.dashSize !== void 0 && (nt.dashSize = this.dashSize),
        this.gapSize !== void 0 && (nt.gapSize = this.gapSize),
        this.scale !== void 0 && (nt.scale = this.scale),
        this.dithering === !0 && (nt.dithering = !0),
        this.alphaTest > 0 && (nt.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 && (nt.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 && (nt.premultipliedAlpha = this.premultipliedAlpha),
        this.wireframe === !0 && (nt.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (nt.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (nt.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (nt.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (nt.flatShading = this.flatShading),
        this.visible === !1 && (nt.visible = !1),
        this.toneMapped === !1 && (nt.toneMapped = !1),
        JSON.stringify(this.userData) !== "{}" && (nt.userData = this.userData);
        function rt(it) {
            const ot = [];
            for (const st in it) {
                const lt = it[st];
                delete lt.metadata,
                ot.push(lt)
            }
            return ot
        }
        if (tt) {
            const it = rt($.textures)
              , ot = rt($.images);
            it.length > 0 && (nt.textures = it),
            ot.length > 0 && (nt.images = ot)
        }
        return nt
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy($) {
        this.name = $.name,
        this.fog = $.fog,
        this.blending = $.blending,
        this.side = $.side,
        this.vertexColors = $.vertexColors,
        this.opacity = $.opacity,
        this.transparent = $.transparent,
        this.blendSrc = $.blendSrc,
        this.blendDst = $.blendDst,
        this.blendEquation = $.blendEquation,
        this.blendSrcAlpha = $.blendSrcAlpha,
        this.blendDstAlpha = $.blendDstAlpha,
        this.blendEquationAlpha = $.blendEquationAlpha,
        this.depthFunc = $.depthFunc,
        this.depthTest = $.depthTest,
        this.depthWrite = $.depthWrite,
        this.stencilWriteMask = $.stencilWriteMask,
        this.stencilFunc = $.stencilFunc,
        this.stencilRef = $.stencilRef,
        this.stencilFuncMask = $.stencilFuncMask,
        this.stencilFail = $.stencilFail,
        this.stencilZFail = $.stencilZFail,
        this.stencilZPass = $.stencilZPass,
        this.stencilWrite = $.stencilWrite;
        const tt = $.clippingPlanes;
        let nt = null;
        if (tt !== null) {
            const rt = tt.length;
            nt = new Array(rt);
            for (let it = 0; it !== rt; ++it)
                nt[it] = tt[it].clone()
        }
        return this.clippingPlanes = nt,
        this.clipIntersection = $.clipIntersection,
        this.clipShadows = $.clipShadows,
        this.shadowSide = $.shadowSide,
        this.colorWrite = $.colorWrite,
        this.precision = $.precision,
        this.polygonOffset = $.polygonOffset,
        this.polygonOffsetFactor = $.polygonOffsetFactor,
        this.polygonOffsetUnits = $.polygonOffsetUnits,
        this.dithering = $.dithering,
        this.alphaTest = $.alphaTest,
        this.alphaToCoverage = $.alphaToCoverage,
        this.premultipliedAlpha = $.premultipliedAlpha,
        this.visible = $.visible,
        this.toneMapped = $.toneMapped,
        this.userData = JSON.parse(JSON.stringify($.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate($) {
        $ === !0 && this.version++
    }
}
Material.prototype.isMaterial = !0;
Material.fromType = function() {
    return null
}
;
class MeshBasicMaterial extends Material {
    constructor($) {
        super(),
        this.type = "MeshBasicMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = MultiplyOperation,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.color.copy($.color),
        this.map = $.map,
        this.lightMap = $.lightMap,
        this.lightMapIntensity = $.lightMapIntensity,
        this.aoMap = $.aoMap,
        this.aoMapIntensity = $.aoMapIntensity,
        this.specularMap = $.specularMap,
        this.alphaMap = $.alphaMap,
        this.envMap = $.envMap,
        this.combine = $.combine,
        this.reflectivity = $.reflectivity,
        this.refractionRatio = $.refractionRatio,
        this.wireframe = $.wireframe,
        this.wireframeLinewidth = $.wireframeLinewidth,
        this.wireframeLinecap = $.wireframeLinecap,
        this.wireframeLinejoin = $.wireframeLinejoin,
        this
    }
}
MeshBasicMaterial.prototype.isMeshBasicMaterial = !0;
const _vector$9 = new Vector3
  , _vector2$1 = new Vector2;
class BufferAttribute {
    constructor($, tt, nt) {
        if (Array.isArray($))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = $,
        this.itemSize = tt,
        this.count = $ !== void 0 ? $.length / tt : 0,
        this.normalized = nt === !0,
        this.usage = StaticDrawUsage,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate($) {
        $ === !0 && this.version++
    }
    setUsage($) {
        return this.usage = $,
        this
    }
    copy($) {
        return this.name = $.name,
        this.array = new $.array.constructor($.array),
        this.itemSize = $.itemSize,
        this.count = $.count,
        this.normalized = $.normalized,
        this.usage = $.usage,
        this
    }
    copyAt($, tt, nt) {
        $ *= this.itemSize,
        nt *= tt.itemSize;
        for (let rt = 0, it = this.itemSize; rt < it; rt++)
            this.array[$ + rt] = tt.array[nt + rt];
        return this
    }
    copyArray($) {
        return this.array.set($),
        this
    }
    copyColorsArray($) {
        const tt = this.array;
        let nt = 0;
        for (let rt = 0, it = $.length; rt < it; rt++) {
            let ot = $[rt];
            ot === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", rt),
            ot = new Color),
            tt[nt++] = ot.r,
            tt[nt++] = ot.g,
            tt[nt++] = ot.b
        }
        return this
    }
    copyVector2sArray($) {
        const tt = this.array;
        let nt = 0;
        for (let rt = 0, it = $.length; rt < it; rt++) {
            let ot = $[rt];
            ot === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", rt),
            ot = new Vector2),
            tt[nt++] = ot.x,
            tt[nt++] = ot.y
        }
        return this
    }
    copyVector3sArray($) {
        const tt = this.array;
        let nt = 0;
        for (let rt = 0, it = $.length; rt < it; rt++) {
            let ot = $[rt];
            ot === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", rt),
            ot = new Vector3),
            tt[nt++] = ot.x,
            tt[nt++] = ot.y,
            tt[nt++] = ot.z
        }
        return this
    }
    copyVector4sArray($) {
        const tt = this.array;
        let nt = 0;
        for (let rt = 0, it = $.length; rt < it; rt++) {
            let ot = $[rt];
            ot === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", rt),
            ot = new Vector4),
            tt[nt++] = ot.x,
            tt[nt++] = ot.y,
            tt[nt++] = ot.z,
            tt[nt++] = ot.w
        }
        return this
    }
    applyMatrix3($) {
        if (this.itemSize === 2)
            for (let tt = 0, nt = this.count; tt < nt; tt++)
                _vector2$1.fromBufferAttribute(this, tt),
                _vector2$1.applyMatrix3($),
                this.setXY(tt, _vector2$1.x, _vector2$1.y);
        else if (this.itemSize === 3)
            for (let tt = 0, nt = this.count; tt < nt; tt++)
                _vector$9.fromBufferAttribute(this, tt),
                _vector$9.applyMatrix3($),
                this.setXYZ(tt, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    applyMatrix4($) {
        for (let tt = 0, nt = this.count; tt < nt; tt++)
            _vector$9.x = this.getX(tt),
            _vector$9.y = this.getY(tt),
            _vector$9.z = this.getZ(tt),
            _vector$9.applyMatrix4($),
            this.setXYZ(tt, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    applyNormalMatrix($) {
        for (let tt = 0, nt = this.count; tt < nt; tt++)
            _vector$9.x = this.getX(tt),
            _vector$9.y = this.getY(tt),
            _vector$9.z = this.getZ(tt),
            _vector$9.applyNormalMatrix($),
            this.setXYZ(tt, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    transformDirection($) {
        for (let tt = 0, nt = this.count; tt < nt; tt++)
            _vector$9.x = this.getX(tt),
            _vector$9.y = this.getY(tt),
            _vector$9.z = this.getZ(tt),
            _vector$9.transformDirection($),
            this.setXYZ(tt, _vector$9.x, _vector$9.y, _vector$9.z);
        return this
    }
    set($, tt=0) {
        return this.array.set($, tt),
        this
    }
    getX($) {
        return this.array[$ * this.itemSize]
    }
    setX($, tt) {
        return this.array[$ * this.itemSize] = tt,
        this
    }
    getY($) {
        return this.array[$ * this.itemSize + 1]
    }
    setY($, tt) {
        return this.array[$ * this.itemSize + 1] = tt,
        this
    }
    getZ($) {
        return this.array[$ * this.itemSize + 2]
    }
    setZ($, tt) {
        return this.array[$ * this.itemSize + 2] = tt,
        this
    }
    getW($) {
        return this.array[$ * this.itemSize + 3]
    }
    setW($, tt) {
        return this.array[$ * this.itemSize + 3] = tt,
        this
    }
    setXY($, tt, nt) {
        return $ *= this.itemSize,
        this.array[$ + 0] = tt,
        this.array[$ + 1] = nt,
        this
    }
    setXYZ($, tt, nt, rt) {
        return $ *= this.itemSize,
        this.array[$ + 0] = tt,
        this.array[$ + 1] = nt,
        this.array[$ + 2] = rt,
        this
    }
    setXYZW($, tt, nt, rt, it) {
        return $ *= this.itemSize,
        this.array[$ + 0] = tt,
        this.array[$ + 1] = nt,
        this.array[$ + 2] = rt,
        this.array[$ + 3] = it,
        this
    }
    onUpload($) {
        return this.onUploadCallback = $,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const $ = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && ($.name = this.name),
        this.usage !== StaticDrawUsage && ($.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && ($.updateRange = this.updateRange),
        $
    }
}
BufferAttribute.prototype.isBufferAttribute = !0;
class Uint16BufferAttribute extends BufferAttribute {
    constructor($, tt, nt) {
        super(new Uint16Array($), tt, nt)
    }
}
class Uint32BufferAttribute extends BufferAttribute {
    constructor($, tt, nt) {
        super(new Uint32Array($), tt, nt)
    }
}
class Float16BufferAttribute extends BufferAttribute {
    constructor($, tt, nt) {
        super(new Uint16Array($), tt, nt)
    }
}
Float16BufferAttribute.prototype.isFloat16BufferAttribute = !0;
class Float32BufferAttribute extends BufferAttribute {
    constructor($, tt, nt) {
        super(new Float32Array($), tt, nt)
    }
}
let _id$1 = 0;
const _m1 = new Matrix4
  , _obj = new Object3D
  , _offset = new Vector3
  , _box$1 = new Box3
  , _boxMorphTargets = new Box3
  , _vector$8 = new Vector3;
class BufferGeometry extends EventDispatcher {
    constructor() {
        super(),
        Object.defineProperty(this, "id", {
            value: _id$1++
        }),
        this.uuid = generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex($) {
        return Array.isArray($) ? this.index = new (arrayNeedsUint32($) ? Uint32BufferAttribute : Uint16BufferAttribute)($,1) : this.index = $,
        this
    }
    getAttribute($) {
        return this.attributes[$]
    }
    setAttribute($, tt) {
        return this.attributes[$] = tt,
        this
    }
    deleteAttribute($) {
        return delete this.attributes[$],
        this
    }
    hasAttribute($) {
        return this.attributes[$] !== void 0
    }
    addGroup($, tt, nt=0) {
        this.groups.push({
            start: $,
            count: tt,
            materialIndex: nt
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange($, tt) {
        this.drawRange.start = $,
        this.drawRange.count = tt
    }
    applyMatrix4($) {
        const tt = this.attributes.position;
        tt !== void 0 && (tt.applyMatrix4($),
        tt.needsUpdate = !0);
        const nt = this.attributes.normal;
        if (nt !== void 0) {
            const it = new Matrix3().getNormalMatrix($);
            nt.applyNormalMatrix(it),
            nt.needsUpdate = !0
        }
        const rt = this.attributes.tangent;
        return rt !== void 0 && (rt.transformDirection($),
        rt.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion($) {
        return _m1.makeRotationFromQuaternion($),
        this.applyMatrix4(_m1),
        this
    }
    rotateX($) {
        return _m1.makeRotationX($),
        this.applyMatrix4(_m1),
        this
    }
    rotateY($) {
        return _m1.makeRotationY($),
        this.applyMatrix4(_m1),
        this
    }
    rotateZ($) {
        return _m1.makeRotationZ($),
        this.applyMatrix4(_m1),
        this
    }
    translate($, tt, nt) {
        return _m1.makeTranslation($, tt, nt),
        this.applyMatrix4(_m1),
        this
    }
    scale($, tt, nt) {
        return _m1.makeScale($, tt, nt),
        this.applyMatrix4(_m1),
        this
    }
    lookAt($) {
        return _obj.lookAt($),
        _obj.updateMatrix(),
        this.applyMatrix4(_obj.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(_offset).negate(),
        this.translate(_offset.x, _offset.y, _offset.z),
        this
    }
    setFromPoints($) {
        const tt = [];
        for (let nt = 0, rt = $.length; nt < rt; nt++) {
            const it = $[nt];
            tt.push(it.x, it.y, it.z || 0)
        }
        return this.setAttribute("position", new Float32BufferAttribute(tt,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Box3);
        const $ = this.attributes.position
          , tt = this.morphAttributes.position;
        if ($ && $.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new Vector3(-1 / 0,-1 / 0,-1 / 0), new Vector3(1 / 0,1 / 0,1 / 0));
            return
        }
        if ($ !== void 0) {
            if (this.boundingBox.setFromBufferAttribute($),
            tt)
                for (let nt = 0, rt = tt.length; nt < rt; nt++) {
                    const it = tt[nt];
                    _box$1.setFromBufferAttribute(it),
                    this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$1.min),
                    this.boundingBox.expandByPoint(_vector$8),
                    _vector$8.addVectors(this.boundingBox.max, _box$1.max),
                    this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$1.min),
                    this.boundingBox.expandByPoint(_box$1.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Sphere);
        const $ = this.attributes.position
          , tt = this.morphAttributes.position;
        if ($ && $.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new Vector3, 1 / 0);
            return
        }
        if ($) {
            const nt = this.boundingSphere.center;
            if (_box$1.setFromBufferAttribute($),
            tt)
                for (let it = 0, ot = tt.length; it < ot; it++) {
                    const st = tt[it];
                    _boxMorphTargets.setFromBufferAttribute(st),
                    this.morphTargetsRelative ? (_vector$8.addVectors(_box$1.min, _boxMorphTargets.min),
                    _box$1.expandByPoint(_vector$8),
                    _vector$8.addVectors(_box$1.max, _boxMorphTargets.max),
                    _box$1.expandByPoint(_vector$8)) : (_box$1.expandByPoint(_boxMorphTargets.min),
                    _box$1.expandByPoint(_boxMorphTargets.max))
                }
            _box$1.getCenter(nt);
            let rt = 0;
            for (let it = 0, ot = $.count; it < ot; it++)
                _vector$8.fromBufferAttribute($, it),
                rt = Math.max(rt, nt.distanceToSquared(_vector$8));
            if (tt)
                for (let it = 0, ot = tt.length; it < ot; it++) {
                    const st = tt[it]
                      , lt = this.morphTargetsRelative;
                    for (let ut = 0, ct = st.count; ut < ct; ut++)
                        _vector$8.fromBufferAttribute(st, ut),
                        lt && (_offset.fromBufferAttribute($, ut),
                        _vector$8.add(_offset)),
                        rt = Math.max(rt, nt.distanceToSquared(_vector$8))
                }
            this.boundingSphere.radius = Math.sqrt(rt),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const $ = this.index
          , tt = this.attributes;
        if ($ === null || tt.position === void 0 || tt.normal === void 0 || tt.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const nt = $.array
          , rt = tt.position.array
          , it = tt.normal.array
          , ot = tt.uv.array
          , st = rt.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * st),4));
        const lt = this.getAttribute("tangent").array
          , ut = []
          , ct = [];
        for (let Nt = 0; Nt < st; Nt++)
            ut[Nt] = new Vector3,
            ct[Nt] = new Vector3;
        const ht = new Vector3
          , ft = new Vector3
          , gt = new Vector3
          , vt = new Vector2
          , yt = new Vector2
          , wt = new Vector2
          , mt = new Vector3
          , _t = new Vector3;
        function bt(Nt, Tt, Ft) {
            ht.fromArray(rt, Nt * 3),
            ft.fromArray(rt, Tt * 3),
            gt.fromArray(rt, Ft * 3),
            vt.fromArray(ot, Nt * 2),
            yt.fromArray(ot, Tt * 2),
            wt.fromArray(ot, Ft * 2),
            ft.sub(ht),
            gt.sub(ht),
            yt.sub(vt),
            wt.sub(vt);
            const $t = 1 / (yt.x * wt.y - wt.x * yt.y);
            !isFinite($t) || (mt.copy(ft).multiplyScalar(wt.y).addScaledVector(gt, -yt.y).multiplyScalar($t),
            _t.copy(gt).multiplyScalar(yt.x).addScaledVector(ft, -wt.x).multiplyScalar($t),
            ut[Nt].add(mt),
            ut[Tt].add(mt),
            ut[Ft].add(mt),
            ct[Nt].add(_t),
            ct[Tt].add(_t),
            ct[Ft].add(_t))
        }
        let Mt = this.groups;
        Mt.length === 0 && (Mt = [{
            start: 0,
            count: nt.length
        }]);
        for (let Nt = 0, Tt = Mt.length; Nt < Tt; ++Nt) {
            const Ft = Mt[Nt]
              , $t = Ft.start
              , Wt = Ft.count;
            for (let Kt = $t, qt = $t + Wt; Kt < qt; Kt += 3)
                bt(nt[Kt + 0], nt[Kt + 1], nt[Kt + 2])
        }
        const St = new Vector3
          , At = new Vector3
          , Pt = new Vector3
          , Ot = new Vector3;
        function Zt(Nt) {
            Pt.fromArray(it, Nt * 3),
            Ot.copy(Pt);
            const Tt = ut[Nt];
            St.copy(Tt),
            St.sub(Pt.multiplyScalar(Pt.dot(Tt))).normalize(),
            At.crossVectors(Ot, Tt);
            const $t = At.dot(ct[Nt]) < 0 ? -1 : 1;
            lt[Nt * 4] = St.x,
            lt[Nt * 4 + 1] = St.y,
            lt[Nt * 4 + 2] = St.z,
            lt[Nt * 4 + 3] = $t
        }
        for (let Nt = 0, Tt = Mt.length; Nt < Tt; ++Nt) {
            const Ft = Mt[Nt]
              , $t = Ft.start
              , Wt = Ft.count;
            for (let Kt = $t, qt = $t + Wt; Kt < qt; Kt += 3)
                Zt(nt[Kt + 0]),
                Zt(nt[Kt + 1]),
                Zt(nt[Kt + 2])
        }
    }
    computeVertexNormals() {
        const $ = this.index
          , tt = this.getAttribute("position");
        if (tt !== void 0) {
            let nt = this.getAttribute("normal");
            if (nt === void 0)
                nt = new BufferAttribute(new Float32Array(tt.count * 3),3),
                this.setAttribute("normal", nt);
            else
                for (let ft = 0, gt = nt.count; ft < gt; ft++)
                    nt.setXYZ(ft, 0, 0, 0);
            const rt = new Vector3
              , it = new Vector3
              , ot = new Vector3
              , st = new Vector3
              , lt = new Vector3
              , ut = new Vector3
              , ct = new Vector3
              , ht = new Vector3;
            if ($)
                for (let ft = 0, gt = $.count; ft < gt; ft += 3) {
                    const vt = $.getX(ft + 0)
                      , yt = $.getX(ft + 1)
                      , wt = $.getX(ft + 2);
                    rt.fromBufferAttribute(tt, vt),
                    it.fromBufferAttribute(tt, yt),
                    ot.fromBufferAttribute(tt, wt),
                    ct.subVectors(ot, it),
                    ht.subVectors(rt, it),
                    ct.cross(ht),
                    st.fromBufferAttribute(nt, vt),
                    lt.fromBufferAttribute(nt, yt),
                    ut.fromBufferAttribute(nt, wt),
                    st.add(ct),
                    lt.add(ct),
                    ut.add(ct),
                    nt.setXYZ(vt, st.x, st.y, st.z),
                    nt.setXYZ(yt, lt.x, lt.y, lt.z),
                    nt.setXYZ(wt, ut.x, ut.y, ut.z)
                }
            else
                for (let ft = 0, gt = tt.count; ft < gt; ft += 3)
                    rt.fromBufferAttribute(tt, ft + 0),
                    it.fromBufferAttribute(tt, ft + 1),
                    ot.fromBufferAttribute(tt, ft + 2),
                    ct.subVectors(ot, it),
                    ht.subVectors(rt, it),
                    ct.cross(ht),
                    nt.setXYZ(ft + 0, ct.x, ct.y, ct.z),
                    nt.setXYZ(ft + 1, ct.x, ct.y, ct.z),
                    nt.setXYZ(ft + 2, ct.x, ct.y, ct.z);
            this.normalizeNormals(),
            nt.needsUpdate = !0
        }
    }
    merge($, tt) {
        if (!($ && $.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", $);
            return
        }
        tt === void 0 && (tt = 0,
        console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        const nt = this.attributes;
        for (const rt in nt) {
            if ($.attributes[rt] === void 0)
                continue;
            const ot = nt[rt].array
              , st = $.attributes[rt]
              , lt = st.array
              , ut = st.itemSize * tt
              , ct = Math.min(lt.length, ot.length - ut);
            for (let ht = 0, ft = ut; ht < ct; ht++,
            ft++)
                ot[ft] = lt[ht]
        }
        return this
    }
    normalizeNormals() {
        const $ = this.attributes.normal;
        for (let tt = 0, nt = $.count; tt < nt; tt++)
            _vector$8.fromBufferAttribute($, tt),
            _vector$8.normalize(),
            $.setXYZ(tt, _vector$8.x, _vector$8.y, _vector$8.z)
    }
    toNonIndexed() {
        function $(st, lt) {
            const ut = st.array
              , ct = st.itemSize
              , ht = st.normalized
              , ft = new ut.constructor(lt.length * ct);
            let gt = 0
              , vt = 0;
            for (let yt = 0, wt = lt.length; yt < wt; yt++) {
                st.isInterleavedBufferAttribute ? gt = lt[yt] * st.data.stride + st.offset : gt = lt[yt] * ct;
                for (let mt = 0; mt < ct; mt++)
                    ft[vt++] = ut[gt++]
            }
            return new BufferAttribute(ft,ct,ht)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const tt = new BufferGeometry
          , nt = this.index.array
          , rt = this.attributes;
        for (const st in rt) {
            const lt = rt[st]
              , ut = $(lt, nt);
            tt.setAttribute(st, ut)
        }
        const it = this.morphAttributes;
        for (const st in it) {
            const lt = []
              , ut = it[st];
            for (let ct = 0, ht = ut.length; ct < ht; ct++) {
                const ft = ut[ct]
                  , gt = $(ft, nt);
                lt.push(gt)
            }
            tt.morphAttributes[st] = lt
        }
        tt.morphTargetsRelative = this.morphTargetsRelative;
        const ot = this.groups;
        for (let st = 0, lt = ot.length; st < lt; st++) {
            const ut = ot[st];
            tt.addGroup(ut.start, ut.count, ut.materialIndex)
        }
        return tt
    }
    toJSON() {
        const $ = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if ($.uuid = this.uuid,
        $.type = this.type,
        this.name !== "" && ($.name = this.name),
        Object.keys(this.userData).length > 0 && ($.userData = this.userData),
        this.parameters !== void 0) {
            const lt = this.parameters;
            for (const ut in lt)
                lt[ut] !== void 0 && ($[ut] = lt[ut]);
            return $
        }
        $.data = {
            attributes: {}
        };
        const tt = this.index;
        tt !== null && ($.data.index = {
            type: tt.array.constructor.name,
            array: Array.prototype.slice.call(tt.array)
        });
        const nt = this.attributes;
        for (const lt in nt) {
            const ut = nt[lt];
            $.data.attributes[lt] = ut.toJSON($.data)
        }
        const rt = {};
        let it = !1;
        for (const lt in this.morphAttributes) {
            const ut = this.morphAttributes[lt]
              , ct = [];
            for (let ht = 0, ft = ut.length; ht < ft; ht++) {
                const gt = ut[ht];
                ct.push(gt.toJSON($.data))
            }
            ct.length > 0 && (rt[lt] = ct,
            it = !0)
        }
        it && ($.data.morphAttributes = rt,
        $.data.morphTargetsRelative = this.morphTargetsRelative);
        const ot = this.groups;
        ot.length > 0 && ($.data.groups = JSON.parse(JSON.stringify(ot)));
        const st = this.boundingSphere;
        return st !== null && ($.data.boundingSphere = {
            center: st.center.toArray(),
            radius: st.radius
        }),
        $
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy($) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const tt = {};
        this.name = $.name;
        const nt = $.index;
        nt !== null && this.setIndex(nt.clone(tt));
        const rt = $.attributes;
        for (const ut in rt) {
            const ct = rt[ut];
            this.setAttribute(ut, ct.clone(tt))
        }
        const it = $.morphAttributes;
        for (const ut in it) {
            const ct = []
              , ht = it[ut];
            for (let ft = 0, gt = ht.length; ft < gt; ft++)
                ct.push(ht[ft].clone(tt));
            this.morphAttributes[ut] = ct
        }
        this.morphTargetsRelative = $.morphTargetsRelative;
        const ot = $.groups;
        for (let ut = 0, ct = ot.length; ut < ct; ut++) {
            const ht = ot[ut];
            this.addGroup(ht.start, ht.count, ht.materialIndex)
        }
        const st = $.boundingBox;
        st !== null && (this.boundingBox = st.clone());
        const lt = $.boundingSphere;
        return lt !== null && (this.boundingSphere = lt.clone()),
        this.drawRange.start = $.drawRange.start,
        this.drawRange.count = $.drawRange.count,
        this.userData = $.userData,
        $.parameters !== void 0 && (this.parameters = Object.assign({}, $.parameters)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
BufferGeometry.prototype.isBufferGeometry = !0;
const _inverseMatrix$2 = new Matrix4
  , _ray$2 = new Ray
  , _sphere$3 = new Sphere
  , _vA$1 = new Vector3
  , _vB$1 = new Vector3
  , _vC$1 = new Vector3
  , _tempA = new Vector3
  , _tempB = new Vector3
  , _tempC = new Vector3
  , _morphA = new Vector3
  , _morphB = new Vector3
  , _morphC = new Vector3
  , _uvA$1 = new Vector2
  , _uvB$1 = new Vector2
  , _uvC$1 = new Vector2
  , _intersectionPoint = new Vector3
  , _intersectionPointWorld = new Vector3;
class Mesh extends Object3D {
    constructor($=new BufferGeometry, tt=new MeshBasicMaterial) {
        super(),
        this.type = "Mesh",
        this.geometry = $,
        this.material = tt,
        this.updateMorphTargets()
    }
    copy($) {
        return super.copy($),
        $.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = $.morphTargetInfluences.slice()),
        $.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, $.morphTargetDictionary)),
        this.material = $.material,
        this.geometry = $.geometry,
        this
    }
    updateMorphTargets() {
        const $ = this.geometry;
        if ($.isBufferGeometry) {
            const tt = $.morphAttributes
              , nt = Object.keys(tt);
            if (nt.length > 0) {
                const rt = tt[nt[0]];
                if (rt !== void 0) {
                    this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {};
                    for (let it = 0, ot = rt.length; it < ot; it++) {
                        const st = rt[it].name || String(it);
                        this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[st] = it
                    }
                }
            }
        } else {
            const tt = $.morphTargets;
            tt !== void 0 && tt.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
    raycast($, tt) {
        const nt = this.geometry
          , rt = this.material
          , it = this.matrixWorld;
        if (rt === void 0 || (nt.boundingSphere === null && nt.computeBoundingSphere(),
        _sphere$3.copy(nt.boundingSphere),
        _sphere$3.applyMatrix4(it),
        $.ray.intersectsSphere(_sphere$3) === !1) || (_inverseMatrix$2.copy(it).invert(),
        _ray$2.copy($.ray).applyMatrix4(_inverseMatrix$2),
        nt.boundingBox !== null && _ray$2.intersectsBox(nt.boundingBox) === !1))
            return;
        let ot;
        if (nt.isBufferGeometry) {
            const st = nt.index
              , lt = nt.attributes.position
              , ut = nt.morphAttributes.position
              , ct = nt.morphTargetsRelative
              , ht = nt.attributes.uv
              , ft = nt.attributes.uv2
              , gt = nt.groups
              , vt = nt.drawRange;
            if (st !== null)
                if (Array.isArray(rt))
                    for (let yt = 0, wt = gt.length; yt < wt; yt++) {
                        const mt = gt[yt]
                          , _t = rt[mt.materialIndex]
                          , bt = Math.max(mt.start, vt.start)
                          , Mt = Math.min(st.count, Math.min(mt.start + mt.count, vt.start + vt.count));
                        for (let St = bt, At = Mt; St < At; St += 3) {
                            const Pt = st.getX(St)
                              , Ot = st.getX(St + 1)
                              , Zt = st.getX(St + 2);
                            ot = checkBufferGeometryIntersection(this, _t, $, _ray$2, lt, ut, ct, ht, ft, Pt, Ot, Zt),
                            ot && (ot.faceIndex = Math.floor(St / 3),
                            ot.face.materialIndex = mt.materialIndex,
                            tt.push(ot))
                        }
                    }
                else {
                    const yt = Math.max(0, vt.start)
                      , wt = Math.min(st.count, vt.start + vt.count);
                    for (let mt = yt, _t = wt; mt < _t; mt += 3) {
                        const bt = st.getX(mt)
                          , Mt = st.getX(mt + 1)
                          , St = st.getX(mt + 2);
                        ot = checkBufferGeometryIntersection(this, rt, $, _ray$2, lt, ut, ct, ht, ft, bt, Mt, St),
                        ot && (ot.faceIndex = Math.floor(mt / 3),
                        tt.push(ot))
                    }
                }
            else if (lt !== void 0)
                if (Array.isArray(rt))
                    for (let yt = 0, wt = gt.length; yt < wt; yt++) {
                        const mt = gt[yt]
                          , _t = rt[mt.materialIndex]
                          , bt = Math.max(mt.start, vt.start)
                          , Mt = Math.min(lt.count, Math.min(mt.start + mt.count, vt.start + vt.count));
                        for (let St = bt, At = Mt; St < At; St += 3) {
                            const Pt = St
                              , Ot = St + 1
                              , Zt = St + 2;
                            ot = checkBufferGeometryIntersection(this, _t, $, _ray$2, lt, ut, ct, ht, ft, Pt, Ot, Zt),
                            ot && (ot.faceIndex = Math.floor(St / 3),
                            ot.face.materialIndex = mt.materialIndex,
                            tt.push(ot))
                        }
                    }
                else {
                    const yt = Math.max(0, vt.start)
                      , wt = Math.min(lt.count, vt.start + vt.count);
                    for (let mt = yt, _t = wt; mt < _t; mt += 3) {
                        const bt = mt
                          , Mt = mt + 1
                          , St = mt + 2;
                        ot = checkBufferGeometryIntersection(this, rt, $, _ray$2, lt, ut, ct, ht, ft, bt, Mt, St),
                        ot && (ot.faceIndex = Math.floor(mt / 3),
                        tt.push(ot))
                    }
                }
        } else
            nt.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }
}
Mesh.prototype.isMesh = !0;
function checkIntersection(et, $, tt, nt, rt, it, ot, st) {
    let lt;
    if ($.side === BackSide ? lt = nt.intersectTriangle(ot, it, rt, !0, st) : lt = nt.intersectTriangle(rt, it, ot, $.side !== DoubleSide, st),
    lt === null)
        return null;
    _intersectionPointWorld.copy(st),
    _intersectionPointWorld.applyMatrix4(et.matrixWorld);
    const ut = tt.ray.origin.distanceTo(_intersectionPointWorld);
    return ut < tt.near || ut > tt.far ? null : {
        distance: ut,
        point: _intersectionPointWorld.clone(),
        object: et
    }
}
function checkBufferGeometryIntersection(et, $, tt, nt, rt, it, ot, st, lt, ut, ct, ht) {
    _vA$1.fromBufferAttribute(rt, ut),
    _vB$1.fromBufferAttribute(rt, ct),
    _vC$1.fromBufferAttribute(rt, ht);
    const ft = et.morphTargetInfluences;
    if (it && ft) {
        _morphA.set(0, 0, 0),
        _morphB.set(0, 0, 0),
        _morphC.set(0, 0, 0);
        for (let vt = 0, yt = it.length; vt < yt; vt++) {
            const wt = ft[vt]
              , mt = it[vt];
            wt !== 0 && (_tempA.fromBufferAttribute(mt, ut),
            _tempB.fromBufferAttribute(mt, ct),
            _tempC.fromBufferAttribute(mt, ht),
            ot ? (_morphA.addScaledVector(_tempA, wt),
            _morphB.addScaledVector(_tempB, wt),
            _morphC.addScaledVector(_tempC, wt)) : (_morphA.addScaledVector(_tempA.sub(_vA$1), wt),
            _morphB.addScaledVector(_tempB.sub(_vB$1), wt),
            _morphC.addScaledVector(_tempC.sub(_vC$1), wt)))
        }
        _vA$1.add(_morphA),
        _vB$1.add(_morphB),
        _vC$1.add(_morphC)
    }
    et.isSkinnedMesh && (et.boneTransform(ut, _vA$1),
    et.boneTransform(ct, _vB$1),
    et.boneTransform(ht, _vC$1));
    const gt = checkIntersection(et, $, tt, nt, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (gt) {
        st && (_uvA$1.fromBufferAttribute(st, ut),
        _uvB$1.fromBufferAttribute(st, ct),
        _uvC$1.fromBufferAttribute(st, ht),
        gt.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2)),
        lt && (_uvA$1.fromBufferAttribute(lt, ut),
        _uvB$1.fromBufferAttribute(lt, ct),
        _uvC$1.fromBufferAttribute(lt, ht),
        gt.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2));
        const vt = {
            a: ut,
            b: ct,
            c: ht,
            normal: new Vector3,
            materialIndex: 0
        };
        Triangle.getNormal(_vA$1, _vB$1, _vC$1, vt.normal),
        gt.face = vt
    }
    return gt
}
class BoxGeometry extends BufferGeometry {
    constructor($=1, tt=1, nt=1, rt=1, it=1, ot=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: $,
            height: tt,
            depth: nt,
            widthSegments: rt,
            heightSegments: it,
            depthSegments: ot
        };
        const st = this;
        rt = Math.floor(rt),
        it = Math.floor(it),
        ot = Math.floor(ot);
        const lt = []
          , ut = []
          , ct = []
          , ht = [];
        let ft = 0
          , gt = 0;
        vt("z", "y", "x", -1, -1, nt, tt, $, ot, it, 0),
        vt("z", "y", "x", 1, -1, nt, tt, -$, ot, it, 1),
        vt("x", "z", "y", 1, 1, $, nt, tt, rt, ot, 2),
        vt("x", "z", "y", 1, -1, $, nt, -tt, rt, ot, 3),
        vt("x", "y", "z", 1, -1, $, tt, nt, rt, it, 4),
        vt("x", "y", "z", -1, -1, $, tt, -nt, rt, it, 5),
        this.setIndex(lt),
        this.setAttribute("position", new Float32BufferAttribute(ut,3)),
        this.setAttribute("normal", new Float32BufferAttribute(ct,3)),
        this.setAttribute("uv", new Float32BufferAttribute(ht,2));
        function vt(yt, wt, mt, _t, bt, Mt, St, At, Pt, Ot, Zt) {
            const Nt = Mt / Pt
              , Tt = St / Ot
              , Ft = Mt / 2
              , $t = St / 2
              , Wt = At / 2
              , Kt = Pt + 1
              , qt = Ot + 1;
            let jt = 0
              , Bt = 0;
            const Xt = new Vector3;
            for (let Jt = 0; Jt < qt; Jt++) {
                const Lt = Jt * Tt - $t;
                for (let Rt = 0; Rt < Kt; Rt++) {
                    const _n = Rt * Nt - Ft;
                    Xt[yt] = _n * _t,
                    Xt[wt] = Lt * bt,
                    Xt[mt] = Wt,
                    ut.push(Xt.x, Xt.y, Xt.z),
                    Xt[yt] = 0,
                    Xt[wt] = 0,
                    Xt[mt] = At > 0 ? 1 : -1,
                    ct.push(Xt.x, Xt.y, Xt.z),
                    ht.push(Rt / Pt),
                    ht.push(1 - Jt / Ot),
                    jt += 1
                }
            }
            for (let Jt = 0; Jt < Ot; Jt++)
                for (let Lt = 0; Lt < Pt; Lt++) {
                    const Rt = ft + Lt + Kt * Jt
                      , _n = ft + Lt + Kt * (Jt + 1)
                      , Fn = ft + (Lt + 1) + Kt * (Jt + 1)
                      , Vn = ft + (Lt + 1) + Kt * Jt;
                    lt.push(Rt, _n, Vn),
                    lt.push(_n, Fn, Vn),
                    Bt += 6
                }
            st.addGroup(gt, Bt, Zt),
            gt += Bt,
            ft += jt
        }
    }
    static fromJSON($) {
        return new BoxGeometry($.width,$.height,$.depth,$.widthSegments,$.heightSegments,$.depthSegments)
    }
}
function cloneUniforms(et) {
    const $ = {};
    for (const tt in et) {
        $[tt] = {};
        for (const nt in et[tt]) {
            const rt = et[tt][nt];
            rt && (rt.isColor || rt.isMatrix3 || rt.isMatrix4 || rt.isVector2 || rt.isVector3 || rt.isVector4 || rt.isTexture || rt.isQuaternion) ? $[tt][nt] = rt.clone() : Array.isArray(rt) ? $[tt][nt] = rt.slice() : $[tt][nt] = rt
        }
    }
    return $
}
function mergeUniforms(et) {
    const $ = {};
    for (let tt = 0; tt < et.length; tt++) {
        const nt = cloneUniforms(et[tt]);
        for (const rt in nt)
            $[rt] = nt[rt]
    }
    return $
}
const UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
    constructor($) {
        super(),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = default_vertex,
        this.fragmentShader = default_fragment,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        $ !== void 0 && ($.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues($))
    }
    copy($) {
        return super.copy($),
        this.fragmentShader = $.fragmentShader,
        this.vertexShader = $.vertexShader,
        this.uniforms = cloneUniforms($.uniforms),
        this.defines = Object.assign({}, $.defines),
        this.wireframe = $.wireframe,
        this.wireframeLinewidth = $.wireframeLinewidth,
        this.lights = $.lights,
        this.clipping = $.clipping,
        this.extensions = Object.assign({}, $.extensions),
        this.glslVersion = $.glslVersion,
        this
    }
    toJSON($) {
        const tt = super.toJSON($);
        tt.glslVersion = this.glslVersion,
        tt.uniforms = {};
        for (const rt in this.uniforms) {
            const ot = this.uniforms[rt].value;
            ot && ot.isTexture ? tt.uniforms[rt] = {
                type: "t",
                value: ot.toJSON($).uuid
            } : ot && ot.isColor ? tt.uniforms[rt] = {
                type: "c",
                value: ot.getHex()
            } : ot && ot.isVector2 ? tt.uniforms[rt] = {
                type: "v2",
                value: ot.toArray()
            } : ot && ot.isVector3 ? tt.uniforms[rt] = {
                type: "v3",
                value: ot.toArray()
            } : ot && ot.isVector4 ? tt.uniforms[rt] = {
                type: "v4",
                value: ot.toArray()
            } : ot && ot.isMatrix3 ? tt.uniforms[rt] = {
                type: "m3",
                value: ot.toArray()
            } : ot && ot.isMatrix4 ? tt.uniforms[rt] = {
                type: "m4",
                value: ot.toArray()
            } : tt.uniforms[rt] = {
                value: ot
            }
        }
        Object.keys(this.defines).length > 0 && (tt.defines = this.defines),
        tt.vertexShader = this.vertexShader,
        tt.fragmentShader = this.fragmentShader;
        const nt = {};
        for (const rt in this.extensions)
            this.extensions[rt] === !0 && (nt[rt] = !0);
        return Object.keys(nt).length > 0 && (tt.extensions = nt),
        tt
    }
}
ShaderMaterial.prototype.isShaderMaterial = !0;
class Camera extends Object3D {
    constructor() {
        super(),
        this.type = "Camera",
        this.matrixWorldInverse = new Matrix4,
        this.projectionMatrix = new Matrix4,
        this.projectionMatrixInverse = new Matrix4
    }
    copy($, tt) {
        return super.copy($, tt),
        this.matrixWorldInverse.copy($.matrixWorldInverse),
        this.projectionMatrix.copy($.projectionMatrix),
        this.projectionMatrixInverse.copy($.projectionMatrixInverse),
        this
    }
    getWorldDirection($) {
        this.updateWorldMatrix(!0, !1);
        const tt = this.matrixWorld.elements;
        return $.set(-tt[8], -tt[9], -tt[10]).normalize()
    }
    updateMatrixWorld($) {
        super.updateMatrixWorld($),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix($, tt) {
        super.updateWorldMatrix($, tt),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
Camera.prototype.isCamera = !0;
class PerspectiveCamera extends Camera {
    constructor($=50, tt=1, nt=.1, rt=2e3) {
        super(),
        this.type = "PerspectiveCamera",
        this.fov = $,
        this.zoom = 1,
        this.near = nt,
        this.far = rt,
        this.focus = 10,
        this.aspect = tt,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy($, tt) {
        return super.copy($, tt),
        this.fov = $.fov,
        this.zoom = $.zoom,
        this.near = $.near,
        this.far = $.far,
        this.focus = $.focus,
        this.aspect = $.aspect,
        this.view = $.view === null ? null : Object.assign({}, $.view),
        this.filmGauge = $.filmGauge,
        this.filmOffset = $.filmOffset,
        this
    }
    setFocalLength($) {
        const tt = .5 * this.getFilmHeight() / $;
        this.fov = RAD2DEG * 2 * Math.atan(tt),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const $ = Math.tan(DEG2RAD * .5 * this.fov);
        return .5 * this.getFilmHeight() / $
    }
    getEffectiveFOV() {
        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset($, tt, nt, rt, it, ot) {
        this.aspect = $ / tt,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = $,
        this.view.fullHeight = tt,
        this.view.offsetX = nt,
        this.view.offsetY = rt,
        this.view.width = it,
        this.view.height = ot,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const $ = this.near;
        let tt = $ * Math.tan(DEG2RAD * .5 * this.fov) / this.zoom
          , nt = 2 * tt
          , rt = this.aspect * nt
          , it = -.5 * rt;
        const ot = this.view;
        if (this.view !== null && this.view.enabled) {
            const lt = ot.fullWidth
              , ut = ot.fullHeight;
            it += ot.offsetX * rt / lt,
            tt -= ot.offsetY * nt / ut,
            rt *= ot.width / lt,
            nt *= ot.height / ut
        }
        const st = this.filmOffset;
        st !== 0 && (it += $ * st / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(it, it + rt, tt, tt - nt, $, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON($) {
        const tt = super.toJSON($);
        return tt.object.fov = this.fov,
        tt.object.zoom = this.zoom,
        tt.object.near = this.near,
        tt.object.far = this.far,
        tt.object.focus = this.focus,
        tt.object.aspect = this.aspect,
        this.view !== null && (tt.object.view = Object.assign({}, this.view)),
        tt.object.filmGauge = this.filmGauge,
        tt.object.filmOffset = this.filmOffset,
        tt
    }
}
PerspectiveCamera.prototype.isPerspectiveCamera = !0;
const fov = 90
  , aspect = 1;
class CubeCamera extends Object3D {
    constructor($, tt, nt) {
        if (super(),
        this.type = "CubeCamera",
        nt.isWebGLCubeRenderTarget !== !0) {
            console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            return
        }
        this.renderTarget = nt;
        const rt = new PerspectiveCamera(fov,aspect,$,tt);
        rt.layers = this.layers,
        rt.up.set(0, -1, 0),
        rt.lookAt(new Vector3(1,0,0)),
        this.add(rt);
        const it = new PerspectiveCamera(fov,aspect,$,tt);
        it.layers = this.layers,
        it.up.set(0, -1, 0),
        it.lookAt(new Vector3(-1,0,0)),
        this.add(it);
        const ot = new PerspectiveCamera(fov,aspect,$,tt);
        ot.layers = this.layers,
        ot.up.set(0, 0, 1),
        ot.lookAt(new Vector3(0,1,0)),
        this.add(ot);
        const st = new PerspectiveCamera(fov,aspect,$,tt);
        st.layers = this.layers,
        st.up.set(0, 0, -1),
        st.lookAt(new Vector3(0,-1,0)),
        this.add(st);
        const lt = new PerspectiveCamera(fov,aspect,$,tt);
        lt.layers = this.layers,
        lt.up.set(0, -1, 0),
        lt.lookAt(new Vector3(0,0,1)),
        this.add(lt);
        const ut = new PerspectiveCamera(fov,aspect,$,tt);
        ut.layers = this.layers,
        ut.up.set(0, -1, 0),
        ut.lookAt(new Vector3(0,0,-1)),
        this.add(ut)
    }
    update($, tt) {
        this.parent === null && this.updateMatrixWorld();
        const nt = this.renderTarget
          , [rt,it,ot,st,lt,ut] = this.children
          , ct = $.xr.enabled
          , ht = $.getRenderTarget();
        $.xr.enabled = !1;
        const ft = nt.texture.generateMipmaps;
        nt.texture.generateMipmaps = !1,
        $.setRenderTarget(nt, 0),
        $.render(tt, rt),
        $.setRenderTarget(nt, 1),
        $.render(tt, it),
        $.setRenderTarget(nt, 2),
        $.render(tt, ot),
        $.setRenderTarget(nt, 3),
        $.render(tt, st),
        $.setRenderTarget(nt, 4),
        $.render(tt, lt),
        nt.texture.generateMipmaps = ft,
        $.setRenderTarget(nt, 5),
        $.render(tt, ut),
        $.setRenderTarget(ht),
        $.xr.enabled = ct,
        nt.texture.needsPMREMUpdate = !0
    }
}
class CubeTexture extends Texture {
    constructor($, tt, nt, rt, it, ot, st, lt, ut, ct) {
        $ = $ !== void 0 ? $ : [],
        tt = tt !== void 0 ? tt : CubeReflectionMapping,
        super($, tt, nt, rt, it, ot, st, lt, ut, ct),
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images($) {
        this.image = $
    }
}
CubeTexture.prototype.isCubeTexture = !0;
class WebGLCubeRenderTarget extends WebGLRenderTarget {
    constructor($, tt={}) {
        super($, $, tt);
        const nt = {
            width: $,
            height: $,
            depth: 1
        }
          , rt = [nt, nt, nt, nt, nt, nt];
        this.texture = new CubeTexture(rt,tt.mapping,tt.wrapS,tt.wrapT,tt.magFilter,tt.minFilter,tt.format,tt.type,tt.anisotropy,tt.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = tt.generateMipmaps !== void 0 ? tt.generateMipmaps : !1,
        this.texture.minFilter = tt.minFilter !== void 0 ? tt.minFilter : LinearFilter
    }
    fromEquirectangularTexture($, tt) {
        this.texture.type = tt.type,
        this.texture.format = RGBAFormat,
        this.texture.encoding = tt.encoding,
        this.texture.generateMipmaps = tt.generateMipmaps,
        this.texture.minFilter = tt.minFilter,
        this.texture.magFilter = tt.magFilter;
        const nt = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , rt = new BoxGeometry(5,5,5)
          , it = new ShaderMaterial({
            name: "CubemapFromEquirect",
            uniforms: cloneUniforms(nt.uniforms),
            vertexShader: nt.vertexShader,
            fragmentShader: nt.fragmentShader,
            side: BackSide,
            blending: NoBlending
        });
        it.uniforms.tEquirect.value = tt;
        const ot = new Mesh(rt,it)
          , st = tt.minFilter;
        return tt.minFilter === LinearMipmapLinearFilter && (tt.minFilter = LinearFilter),
        new CubeCamera(1,10,this).update($, ot),
        tt.minFilter = st,
        ot.geometry.dispose(),
        ot.material.dispose(),
        this
    }
    clear($, tt, nt, rt) {
        const it = $.getRenderTarget();
        for (let ot = 0; ot < 6; ot++)
            $.setRenderTarget(this, ot),
            $.clear(tt, nt, rt);
        $.setRenderTarget(it)
    }
}
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = !0;
const _vector1 = new Vector3
  , _vector2 = new Vector3
  , _normalMatrix = new Matrix3;
class Plane {
    constructor($=new Vector3(1,0,0), tt=0) {
        this.normal = $,
        this.constant = tt
    }
    set($, tt) {
        return this.normal.copy($),
        this.constant = tt,
        this
    }
    setComponents($, tt, nt, rt) {
        return this.normal.set($, tt, nt),
        this.constant = rt,
        this
    }
    setFromNormalAndCoplanarPoint($, tt) {
        return this.normal.copy($),
        this.constant = -tt.dot(this.normal),
        this
    }
    setFromCoplanarPoints($, tt, nt) {
        const rt = _vector1.subVectors(nt, tt).cross(_vector2.subVectors($, tt)).normalize();
        return this.setFromNormalAndCoplanarPoint(rt, $),
        this
    }
    copy($) {
        return this.normal.copy($.normal),
        this.constant = $.constant,
        this
    }
    normalize() {
        const $ = 1 / this.normal.length();
        return this.normal.multiplyScalar($),
        this.constant *= $,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint($) {
        return this.normal.dot($) + this.constant
    }
    distanceToSphere($) {
        return this.distanceToPoint($.center) - $.radius
    }
    projectPoint($, tt) {
        return tt.copy(this.normal).multiplyScalar(-this.distanceToPoint($)).add($)
    }
    intersectLine($, tt) {
        const nt = $.delta(_vector1)
          , rt = this.normal.dot(nt);
        if (rt === 0)
            return this.distanceToPoint($.start) === 0 ? tt.copy($.start) : null;
        const it = -($.start.dot(this.normal) + this.constant) / rt;
        return it < 0 || it > 1 ? null : tt.copy(nt).multiplyScalar(it).add($.start)
    }
    intersectsLine($) {
        const tt = this.distanceToPoint($.start)
          , nt = this.distanceToPoint($.end);
        return tt < 0 && nt > 0 || nt < 0 && tt > 0
    }
    intersectsBox($) {
        return $.intersectsPlane(this)
    }
    intersectsSphere($) {
        return $.intersectsPlane(this)
    }
    coplanarPoint($) {
        return $.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4($, tt) {
        const nt = tt || _normalMatrix.getNormalMatrix($)
          , rt = this.coplanarPoint(_vector1).applyMatrix4($)
          , it = this.normal.applyMatrix3(nt).normalize();
        return this.constant = -rt.dot(it),
        this
    }
    translate($) {
        return this.constant -= $.dot(this.normal),
        this
    }
    equals($) {
        return $.normal.equals(this.normal) && $.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
Plane.prototype.isPlane = !0;
const _sphere$2 = new Sphere
  , _vector$7 = new Vector3;
class Frustum {
    constructor($=new Plane, tt=new Plane, nt=new Plane, rt=new Plane, it=new Plane, ot=new Plane) {
        this.planes = [$, tt, nt, rt, it, ot]
    }
    set($, tt, nt, rt, it, ot) {
        const st = this.planes;
        return st[0].copy($),
        st[1].copy(tt),
        st[2].copy(nt),
        st[3].copy(rt),
        st[4].copy(it),
        st[5].copy(ot),
        this
    }
    copy($) {
        const tt = this.planes;
        for (let nt = 0; nt < 6; nt++)
            tt[nt].copy($.planes[nt]);
        return this
    }
    setFromProjectionMatrix($) {
        const tt = this.planes
          , nt = $.elements
          , rt = nt[0]
          , it = nt[1]
          , ot = nt[2]
          , st = nt[3]
          , lt = nt[4]
          , ut = nt[5]
          , ct = nt[6]
          , ht = nt[7]
          , ft = nt[8]
          , gt = nt[9]
          , vt = nt[10]
          , yt = nt[11]
          , wt = nt[12]
          , mt = nt[13]
          , _t = nt[14]
          , bt = nt[15];
        return tt[0].setComponents(st - rt, ht - lt, yt - ft, bt - wt).normalize(),
        tt[1].setComponents(st + rt, ht + lt, yt + ft, bt + wt).normalize(),
        tt[2].setComponents(st + it, ht + ut, yt + gt, bt + mt).normalize(),
        tt[3].setComponents(st - it, ht - ut, yt - gt, bt - mt).normalize(),
        tt[4].setComponents(st - ot, ht - ct, yt - vt, bt - _t).normalize(),
        tt[5].setComponents(st + ot, ht + ct, yt + vt, bt + _t).normalize(),
        this
    }
    intersectsObject($) {
        const tt = $.geometry;
        return tt.boundingSphere === null && tt.computeBoundingSphere(),
        _sphere$2.copy(tt.boundingSphere).applyMatrix4($.matrixWorld),
        this.intersectsSphere(_sphere$2)
    }
    intersectsSprite($) {
        return _sphere$2.center.set(0, 0, 0),
        _sphere$2.radius = .7071067811865476,
        _sphere$2.applyMatrix4($.matrixWorld),
        this.intersectsSphere(_sphere$2)
    }
    intersectsSphere($) {
        const tt = this.planes
          , nt = $.center
          , rt = -$.radius;
        for (let it = 0; it < 6; it++)
            if (tt[it].distanceToPoint(nt) < rt)
                return !1;
        return !0
    }
    intersectsBox($) {
        const tt = this.planes;
        for (let nt = 0; nt < 6; nt++) {
            const rt = tt[nt];
            if (_vector$7.x = rt.normal.x > 0 ? $.max.x : $.min.x,
            _vector$7.y = rt.normal.y > 0 ? $.max.y : $.min.y,
            _vector$7.z = rt.normal.z > 0 ? $.max.z : $.min.z,
            rt.distanceToPoint(_vector$7) < 0)
                return !1
        }
        return !0
    }
    containsPoint($) {
        const tt = this.planes;
        for (let nt = 0; nt < 6; nt++)
            if (tt[nt].distanceToPoint($) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function WebGLAnimation() {
    let et = null
      , $ = !1
      , tt = null
      , nt = null;
    function rt(it, ot) {
        tt(it, ot),
        nt = et.requestAnimationFrame(rt)
    }
    return {
        start: function() {
            $ !== !0 && tt !== null && (nt = et.requestAnimationFrame(rt),
            $ = !0)
        },
        stop: function() {
            et.cancelAnimationFrame(nt),
            $ = !1
        },
        setAnimationLoop: function(it) {
            tt = it
        },
        setContext: function(it) {
            et = it
        }
    }
}
function WebGLAttributes(et, $) {
    const tt = $.isWebGL2
      , nt = new WeakMap;
    function rt(ut, ct) {
        const ht = ut.array
          , ft = ut.usage
          , gt = et.createBuffer();
        et.bindBuffer(ct, gt),
        et.bufferData(ct, ht, ft),
        ut.onUploadCallback();
        let vt;
        if (ht instanceof Float32Array)
            vt = 5126;
        else if (ht instanceof Uint16Array)
            if (ut.isFloat16BufferAttribute)
                if (tt)
                    vt = 5131;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                vt = 5123;
        else if (ht instanceof Int16Array)
            vt = 5122;
        else if (ht instanceof Uint32Array)
            vt = 5125;
        else if (ht instanceof Int32Array)
            vt = 5124;
        else if (ht instanceof Int8Array)
            vt = 5120;
        else if (ht instanceof Uint8Array)
            vt = 5121;
        else if (ht instanceof Uint8ClampedArray)
            vt = 5121;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + ht);
        return {
            buffer: gt,
            type: vt,
            bytesPerElement: ht.BYTES_PER_ELEMENT,
            version: ut.version
        }
    }
    function it(ut, ct, ht) {
        const ft = ct.array
          , gt = ct.updateRange;
        et.bindBuffer(ht, ut),
        gt.count === -1 ? et.bufferSubData(ht, 0, ft) : (tt ? et.bufferSubData(ht, gt.offset * ft.BYTES_PER_ELEMENT, ft, gt.offset, gt.count) : et.bufferSubData(ht, gt.offset * ft.BYTES_PER_ELEMENT, ft.subarray(gt.offset, gt.offset + gt.count)),
        gt.count = -1)
    }
    function ot(ut) {
        return ut.isInterleavedBufferAttribute && (ut = ut.data),
        nt.get(ut)
    }
    function st(ut) {
        ut.isInterleavedBufferAttribute && (ut = ut.data);
        const ct = nt.get(ut);
        ct && (et.deleteBuffer(ct.buffer),
        nt.delete(ut))
    }
    function lt(ut, ct) {
        if (ut.isGLBufferAttribute) {
            const ft = nt.get(ut);
            (!ft || ft.version < ut.version) && nt.set(ut, {
                buffer: ut.buffer,
                type: ut.type,
                bytesPerElement: ut.elementSize,
                version: ut.version
            });
            return
        }
        ut.isInterleavedBufferAttribute && (ut = ut.data);
        const ht = nt.get(ut);
        ht === void 0 ? nt.set(ut, rt(ut, ct)) : ht.version < ut.version && (it(ht.buffer, ut, ct),
        ht.version = ut.version)
    }
    return {
        get: ot,
        remove: st,
        update: lt
    }
}
class PlaneGeometry extends BufferGeometry {
    constructor($=1, tt=1, nt=1, rt=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: $,
            height: tt,
            widthSegments: nt,
            heightSegments: rt
        };
        const it = $ / 2
          , ot = tt / 2
          , st = Math.floor(nt)
          , lt = Math.floor(rt)
          , ut = st + 1
          , ct = lt + 1
          , ht = $ / st
          , ft = tt / lt
          , gt = []
          , vt = []
          , yt = []
          , wt = [];
        for (let mt = 0; mt < ct; mt++) {
            const _t = mt * ft - ot;
            for (let bt = 0; bt < ut; bt++) {
                const Mt = bt * ht - it;
                vt.push(Mt, -_t, 0),
                yt.push(0, 0, 1),
                wt.push(bt / st),
                wt.push(1 - mt / lt)
            }
        }
        for (let mt = 0; mt < lt; mt++)
            for (let _t = 0; _t < st; _t++) {
                const bt = _t + ut * mt
                  , Mt = _t + ut * (mt + 1)
                  , St = _t + 1 + ut * (mt + 1)
                  , At = _t + 1 + ut * mt;
                gt.push(bt, Mt, At),
                gt.push(Mt, St, At)
            }
        this.setIndex(gt),
        this.setAttribute("position", new Float32BufferAttribute(vt,3)),
        this.setAttribute("normal", new Float32BufferAttribute(yt,3)),
        this.setAttribute("uv", new Float32BufferAttribute(wt,2))
    }
    static fromJSON($) {
        return new PlaneGeometry($.width,$.height,$.widthSegments,$.heightSegments)
    }
}
var alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`
  , alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , alphatest_fragment = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , begin_vertex = "vec3 transformed = vec3( position );"
  , beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , bsdfs = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`
  , bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`
  , cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`
  , emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , encodings_pars_fragment = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`
  , lightmap_fragment = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , lights_lambert_vertex = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`
  , lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , envmap_physical_pars_fragment = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`
  , lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`
  , lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`
  , lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`
  , lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , lights_fragment_begin = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`
  , logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , map_particle_pars_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , morphcolor_vertex = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ]
		#endif
	}
#endif`
  , morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			float texelIndex = float( vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`
  , normal_fragment_maps = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`
  , clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`
  , clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`
  , clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`
  , output_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`
  , premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , shadowmap_pars_fragment = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , shadowmap_pars_vertex = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , shadowmap_vertex = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`
  , shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`
  , skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , transmission_fragment = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`
  , transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`
  , uv_pars_fragment = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`
  , uv_pars_vertex = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`
  , uv_vertex = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`
  , uv2_pars_fragment = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`
  , uv2_pars_vertex = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`
  , uv2_vertex = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`
  , worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vertex$g = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , fragment$g = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , fragment$f = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , vertex$e = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , vertex$a = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$9 = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$9 = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , vertex$2 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , ShaderChunk = {
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    encodings_fragment,
    encodings_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_vertex,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    output_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    uv2_pars_fragment,
    uv2_pars_vertex,
    uv2_vertex,
    worldpos_vertex,
    background_vert: vertex$g,
    background_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1
}
  , UniformsLib = {
    common: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix3
        },
        uv2Transform: {
            value: new Matrix3
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector2(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Matrix3
        }
    },
    sprite: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Vector2(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Matrix3
        }
    }
}
  , ShaderLib = {
    basic: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            }
        }]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            },
            specular: {
                value: new Color(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            }
        }]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.meshnormal_vert,
        fragmentShader: ShaderChunk.meshnormal_frag
    },
    sprite: {
        uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix3
            },
            t2D: {
                value: null
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    cube: {
        uniforms: mergeUniforms([UniformsLib.envmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
            referencePosition: {
                value: new Vector3
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
            color: {
                value: new Color(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
ShaderLib.physical = {
    uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new Vector2(1,1)
        },
        clearcoatNormalMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Color(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new Vector2
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Color(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new Color(1,1,1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(et, $, tt, nt, rt, it) {
    const ot = new Color(0);
    let st = rt === !0 ? 0 : 1, lt, ut, ct = null, ht = 0, ft = null;
    function gt(yt, wt) {
        let mt = !1
          , _t = wt.isScene === !0 ? wt.background : null;
        _t && _t.isTexture && (_t = $.get(_t));
        const bt = et.xr
          , Mt = bt.getSession && bt.getSession();
        Mt && Mt.environmentBlendMode === "additive" && (_t = null),
        _t === null ? vt(ot, st) : _t && _t.isColor && (vt(_t, 1),
        mt = !0),
        (et.autoClear || mt) && et.clear(et.autoClearColor, et.autoClearDepth, et.autoClearStencil),
        _t && (_t.isCubeTexture || _t.mapping === CubeUVReflectionMapping) ? (ut === void 0 && (ut = new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        ut.geometry.deleteAttribute("normal"),
        ut.geometry.deleteAttribute("uv"),
        ut.onBeforeRender = function(St, At, Pt) {
            this.matrixWorld.copyPosition(Pt.matrixWorld)
        }
        ,
        Object.defineProperty(ut.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        nt.update(ut)),
        ut.material.uniforms.envMap.value = _t,
        ut.material.uniforms.flipEnvMap.value = _t.isCubeTexture && _t.isRenderTargetTexture === !1 ? -1 : 1,
        (ct !== _t || ht !== _t.version || ft !== et.toneMapping) && (ut.material.needsUpdate = !0,
        ct = _t,
        ht = _t.version,
        ft = et.toneMapping),
        yt.unshift(ut, ut.geometry, ut.material, 0, 0, null)) : _t && _t.isTexture && (lt === void 0 && (lt = new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        lt.geometry.deleteAttribute("normal"),
        Object.defineProperty(lt.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        nt.update(lt)),
        lt.material.uniforms.t2D.value = _t,
        _t.matrixAutoUpdate === !0 && _t.updateMatrix(),
        lt.material.uniforms.uvTransform.value.copy(_t.matrix),
        (ct !== _t || ht !== _t.version || ft !== et.toneMapping) && (lt.material.needsUpdate = !0,
        ct = _t,
        ht = _t.version,
        ft = et.toneMapping),
        yt.unshift(lt, lt.geometry, lt.material, 0, 0, null))
    }
    function vt(yt, wt) {
        tt.buffers.color.setClear(yt.r, yt.g, yt.b, wt, it)
    }
    return {
        getClearColor: function() {
            return ot
        },
        setClearColor: function(yt, wt=1) {
            ot.set(yt),
            st = wt,
            vt(ot, st)
        },
        getClearAlpha: function() {
            return st
        },
        setClearAlpha: function(yt) {
            st = yt,
            vt(ot, st)
        },
        render: gt
    }
}
function WebGLBindingStates(et, $, tt, nt) {
    const rt = et.getParameter(34921)
      , it = nt.isWebGL2 ? null : $.get("OES_vertex_array_object")
      , ot = nt.isWebGL2 || it !== null
      , st = {}
      , lt = yt(null);
    let ut = lt;
    function ct($t, Wt, Kt, qt, jt) {
        let Bt = !1;
        if (ot) {
            const Xt = vt(qt, Kt, Wt);
            ut !== Xt && (ut = Xt,
            ft(ut.object)),
            Bt = wt(qt, jt),
            Bt && mt(qt, jt)
        } else {
            const Xt = Wt.wireframe === !0;
            (ut.geometry !== qt.id || ut.program !== Kt.id || ut.wireframe !== Xt) && (ut.geometry = qt.id,
            ut.program = Kt.id,
            ut.wireframe = Xt,
            Bt = !0)
        }
        $t.isInstancedMesh === !0 && (Bt = !0),
        jt !== null && tt.update(jt, 34963),
        Bt && (Pt($t, Wt, Kt, qt),
        jt !== null && et.bindBuffer(34963, tt.get(jt).buffer))
    }
    function ht() {
        return nt.isWebGL2 ? et.createVertexArray() : it.createVertexArrayOES()
    }
    function ft($t) {
        return nt.isWebGL2 ? et.bindVertexArray($t) : it.bindVertexArrayOES($t)
    }
    function gt($t) {
        return nt.isWebGL2 ? et.deleteVertexArray($t) : it.deleteVertexArrayOES($t)
    }
    function vt($t, Wt, Kt) {
        const qt = Kt.wireframe === !0;
        let jt = st[$t.id];
        jt === void 0 && (jt = {},
        st[$t.id] = jt);
        let Bt = jt[Wt.id];
        Bt === void 0 && (Bt = {},
        jt[Wt.id] = Bt);
        let Xt = Bt[qt];
        return Xt === void 0 && (Xt = yt(ht()),
        Bt[qt] = Xt),
        Xt
    }
    function yt($t) {
        const Wt = []
          , Kt = []
          , qt = [];
        for (let jt = 0; jt < rt; jt++)
            Wt[jt] = 0,
            Kt[jt] = 0,
            qt[jt] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: Wt,
            enabledAttributes: Kt,
            attributeDivisors: qt,
            object: $t,
            attributes: {},
            index: null
        }
    }
    function wt($t, Wt) {
        const Kt = ut.attributes
          , qt = $t.attributes;
        let jt = 0;
        for (const Bt in qt) {
            const Xt = Kt[Bt]
              , Jt = qt[Bt];
            if (Xt === void 0 || Xt.attribute !== Jt || Xt.data !== Jt.data)
                return !0;
            jt++
        }
        return ut.attributesNum !== jt || ut.index !== Wt
    }
    function mt($t, Wt) {
        const Kt = {}
          , qt = $t.attributes;
        let jt = 0;
        for (const Bt in qt) {
            const Xt = qt[Bt]
              , Jt = {};
            Jt.attribute = Xt,
            Xt.data && (Jt.data = Xt.data),
            Kt[Bt] = Jt,
            jt++
        }
        ut.attributes = Kt,
        ut.attributesNum = jt,
        ut.index = Wt
    }
    function _t() {
        const $t = ut.newAttributes;
        for (let Wt = 0, Kt = $t.length; Wt < Kt; Wt++)
            $t[Wt] = 0
    }
    function bt($t) {
        Mt($t, 0)
    }
    function Mt($t, Wt) {
        const Kt = ut.newAttributes
          , qt = ut.enabledAttributes
          , jt = ut.attributeDivisors;
        Kt[$t] = 1,
        qt[$t] === 0 && (et.enableVertexAttribArray($t),
        qt[$t] = 1),
        jt[$t] !== Wt && ((nt.isWebGL2 ? et : $.get("ANGLE_instanced_arrays"))[nt.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"]($t, Wt),
        jt[$t] = Wt)
    }
    function St() {
        const $t = ut.newAttributes
          , Wt = ut.enabledAttributes;
        for (let Kt = 0, qt = Wt.length; Kt < qt; Kt++)
            Wt[Kt] !== $t[Kt] && (et.disableVertexAttribArray(Kt),
            Wt[Kt] = 0)
    }
    function At($t, Wt, Kt, qt, jt, Bt) {
        nt.isWebGL2 === !0 && (Kt === 5124 || Kt === 5125) ? et.vertexAttribIPointer($t, Wt, Kt, jt, Bt) : et.vertexAttribPointer($t, Wt, Kt, qt, jt, Bt)
    }
    function Pt($t, Wt, Kt, qt) {
        if (nt.isWebGL2 === !1 && ($t.isInstancedMesh || qt.isInstancedBufferGeometry) && $.get("ANGLE_instanced_arrays") === null)
            return;
        _t();
        const jt = qt.attributes
          , Bt = Kt.getAttributes()
          , Xt = Wt.defaultAttributeValues;
        for (const Jt in Bt) {
            const Lt = Bt[Jt];
            if (Lt.location >= 0) {
                let Rt = jt[Jt];
                if (Rt === void 0 && (Jt === "instanceMatrix" && $t.instanceMatrix && (Rt = $t.instanceMatrix),
                Jt === "instanceColor" && $t.instanceColor && (Rt = $t.instanceColor)),
                Rt !== void 0) {
                    const _n = Rt.normalized
                      , Fn = Rt.itemSize
                      , Vn = tt.get(Rt);
                    if (Vn === void 0)
                        continue;
                    const sn = Vn.buffer
                      , Un = Vn.type
                      , zn = Vn.bytesPerElement;
                    if (Rt.isInterleavedBufferAttribute) {
                        const Rn = Rt.data
                          , Ln = Rn.stride
                          , Gn = Rt.offset;
                        if (Rn.isInstancedInterleavedBuffer) {
                            for (let cn = 0; cn < Lt.locationSize; cn++)
                                Mt(Lt.location + cn, Rn.meshPerAttribute);
                            $t.isInstancedMesh !== !0 && qt._maxInstanceCount === void 0 && (qt._maxInstanceCount = Rn.meshPerAttribute * Rn.count)
                        } else
                            for (let cn = 0; cn < Lt.locationSize; cn++)
                                bt(Lt.location + cn);
                        et.bindBuffer(34962, sn);
                        for (let cn = 0; cn < Lt.locationSize; cn++)
                            At(Lt.location + cn, Fn / Lt.locationSize, Un, _n, Ln * zn, (Gn + Fn / Lt.locationSize * cn) * zn)
                    } else {
                        if (Rt.isInstancedBufferAttribute) {
                            for (let Rn = 0; Rn < Lt.locationSize; Rn++)
                                Mt(Lt.location + Rn, Rt.meshPerAttribute);
                            $t.isInstancedMesh !== !0 && qt._maxInstanceCount === void 0 && (qt._maxInstanceCount = Rt.meshPerAttribute * Rt.count)
                        } else
                            for (let Rn = 0; Rn < Lt.locationSize; Rn++)
                                bt(Lt.location + Rn);
                        et.bindBuffer(34962, sn);
                        for (let Rn = 0; Rn < Lt.locationSize; Rn++)
                            At(Lt.location + Rn, Fn / Lt.locationSize, Un, _n, Fn * zn, Fn / Lt.locationSize * Rn * zn)
                    }
                } else if (Xt !== void 0) {
                    const _n = Xt[Jt];
                    if (_n !== void 0)
                        switch (_n.length) {
                        case 2:
                            et.vertexAttrib2fv(Lt.location, _n);
                            break;
                        case 3:
                            et.vertexAttrib3fv(Lt.location, _n);
                            break;
                        case 4:
                            et.vertexAttrib4fv(Lt.location, _n);
                            break;
                        default:
                            et.vertexAttrib1fv(Lt.location, _n)
                        }
                }
            }
        }
        St()
    }
    function Ot() {
        Tt();
        for (const $t in st) {
            const Wt = st[$t];
            for (const Kt in Wt) {
                const qt = Wt[Kt];
                for (const jt in qt)
                    gt(qt[jt].object),
                    delete qt[jt];
                delete Wt[Kt]
            }
            delete st[$t]
        }
    }
    function Zt($t) {
        if (st[$t.id] === void 0)
            return;
        const Wt = st[$t.id];
        for (const Kt in Wt) {
            const qt = Wt[Kt];
            for (const jt in qt)
                gt(qt[jt].object),
                delete qt[jt];
            delete Wt[Kt]
        }
        delete st[$t.id]
    }
    function Nt($t) {
        for (const Wt in st) {
            const Kt = st[Wt];
            if (Kt[$t.id] === void 0)
                continue;
            const qt = Kt[$t.id];
            for (const jt in qt)
                gt(qt[jt].object),
                delete qt[jt];
            delete Kt[$t.id]
        }
    }
    function Tt() {
        Ft(),
        ut !== lt && (ut = lt,
        ft(ut.object))
    }
    function Ft() {
        lt.geometry = null,
        lt.program = null,
        lt.wireframe = !1
    }
    return {
        setup: ct,
        reset: Tt,
        resetDefaultState: Ft,
        dispose: Ot,
        releaseStatesOfGeometry: Zt,
        releaseStatesOfProgram: Nt,
        initAttributes: _t,
        enableAttribute: bt,
        disableUnusedAttributes: St
    }
}
function WebGLBufferRenderer(et, $, tt, nt) {
    const rt = nt.isWebGL2;
    let it;
    function ot(ut) {
        it = ut
    }
    function st(ut, ct) {
        et.drawArrays(it, ut, ct),
        tt.update(ct, it, 1)
    }
    function lt(ut, ct, ht) {
        if (ht === 0)
            return;
        let ft, gt;
        if (rt)
            ft = et,
            gt = "drawArraysInstanced";
        else if (ft = $.get("ANGLE_instanced_arrays"),
        gt = "drawArraysInstancedANGLE",
        ft === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        ft[gt](it, ut, ct, ht),
        tt.update(ct, it, ht)
    }
    this.setMode = ot,
    this.render = st,
    this.renderInstances = lt
}
function WebGLCapabilities(et, $, tt) {
    let nt;
    function rt() {
        if (nt !== void 0)
            return nt;
        if ($.has("EXT_texture_filter_anisotropic") === !0) {
            const Pt = $.get("EXT_texture_filter_anisotropic");
            nt = et.getParameter(Pt.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            nt = 0;
        return nt
    }
    function it(Pt) {
        if (Pt === "highp") {
            if (et.getShaderPrecisionFormat(35633, 36338).precision > 0 && et.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
            Pt = "mediump"
        }
        return Pt === "mediump" && et.getShaderPrecisionFormat(35633, 36337).precision > 0 && et.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const ot = typeof WebGL2RenderingContext != "undefined" && et instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext != "undefined" && et instanceof WebGL2ComputeRenderingContext;
    let st = tt.precision !== void 0 ? tt.precision : "highp";
    const lt = it(st);
    lt !== st && (console.warn("THREE.WebGLRenderer:", st, "not supported, using", lt, "instead."),
    st = lt);
    const ut = ot || $.has("WEBGL_draw_buffers")
      , ct = tt.logarithmicDepthBuffer === !0
      , ht = et.getParameter(34930)
      , ft = et.getParameter(35660)
      , gt = et.getParameter(3379)
      , vt = et.getParameter(34076)
      , yt = et.getParameter(34921)
      , wt = et.getParameter(36347)
      , mt = et.getParameter(36348)
      , _t = et.getParameter(36349)
      , bt = ft > 0
      , Mt = ot || $.has("OES_texture_float")
      , St = bt && Mt
      , At = ot ? et.getParameter(36183) : 0;
    return {
        isWebGL2: ot,
        drawBuffers: ut,
        getMaxAnisotropy: rt,
        getMaxPrecision: it,
        precision: st,
        logarithmicDepthBuffer: ct,
        maxTextures: ht,
        maxVertexTextures: ft,
        maxTextureSize: gt,
        maxCubemapSize: vt,
        maxAttributes: yt,
        maxVertexUniforms: wt,
        maxVaryings: mt,
        maxFragmentUniforms: _t,
        vertexTextures: bt,
        floatFragmentTextures: Mt,
        floatVertexTextures: St,
        maxSamples: At
    }
}
function WebGLClipping(et) {
    const $ = this;
    let tt = null
      , nt = 0
      , rt = !1
      , it = !1;
    const ot = new Plane
      , st = new Matrix3
      , lt = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = lt,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(ht, ft, gt) {
        const vt = ht.length !== 0 || ft || nt !== 0 || rt;
        return rt = ft,
        tt = ct(ht, gt, 0),
        nt = ht.length,
        vt
    }
    ,
    this.beginShadows = function() {
        it = !0,
        ct(null)
    }
    ,
    this.endShadows = function() {
        it = !1,
        ut()
    }
    ,
    this.setState = function(ht, ft, gt) {
        const vt = ht.clippingPlanes
          , yt = ht.clipIntersection
          , wt = ht.clipShadows
          , mt = et.get(ht);
        if (!rt || vt === null || vt.length === 0 || it && !wt)
            it ? ct(null) : ut();
        else {
            const _t = it ? 0 : nt
              , bt = _t * 4;
            let Mt = mt.clippingState || null;
            lt.value = Mt,
            Mt = ct(vt, ft, bt, gt);
            for (let St = 0; St !== bt; ++St)
                Mt[St] = tt[St];
            mt.clippingState = Mt,
            this.numIntersection = yt ? this.numPlanes : 0,
            this.numPlanes += _t
        }
    }
    ;
    function ut() {
        lt.value !== tt && (lt.value = tt,
        lt.needsUpdate = nt > 0),
        $.numPlanes = nt,
        $.numIntersection = 0
    }
    function ct(ht, ft, gt, vt) {
        const yt = ht !== null ? ht.length : 0;
        let wt = null;
        if (yt !== 0) {
            if (wt = lt.value,
            vt !== !0 || wt === null) {
                const mt = gt + yt * 4
                  , _t = ft.matrixWorldInverse;
                st.getNormalMatrix(_t),
                (wt === null || wt.length < mt) && (wt = new Float32Array(mt));
                for (let bt = 0, Mt = gt; bt !== yt; ++bt,
                Mt += 4)
                    ot.copy(ht[bt]).applyMatrix4(_t, st),
                    ot.normal.toArray(wt, Mt),
                    wt[Mt + 3] = ot.constant
            }
            lt.value = wt,
            lt.needsUpdate = !0
        }
        return $.numPlanes = yt,
        $.numIntersection = 0,
        wt
    }
}
function WebGLCubeMaps(et) {
    let $ = new WeakMap;
    function tt(ot, st) {
        return st === EquirectangularReflectionMapping ? ot.mapping = CubeReflectionMapping : st === EquirectangularRefractionMapping && (ot.mapping = CubeRefractionMapping),
        ot
    }
    function nt(ot) {
        if (ot && ot.isTexture && ot.isRenderTargetTexture === !1) {
            const st = ot.mapping;
            if (st === EquirectangularReflectionMapping || st === EquirectangularRefractionMapping)
                if ($.has(ot)) {
                    const lt = $.get(ot).texture;
                    return tt(lt, ot.mapping)
                } else {
                    const lt = ot.image;
                    if (lt && lt.height > 0) {
                        const ut = new WebGLCubeRenderTarget(lt.height / 2);
                        return ut.fromEquirectangularTexture(et, ot),
                        $.set(ot, ut),
                        ot.addEventListener("dispose", rt),
                        tt(ut.texture, ot.mapping)
                    } else
                        return null
                }
        }
        return ot
    }
    function rt(ot) {
        const st = ot.target;
        st.removeEventListener("dispose", rt);
        const lt = $.get(st);
        lt !== void 0 && ($.delete(st),
        lt.dispose())
    }
    function it() {
        $ = new WeakMap
    }
    return {
        get: nt,
        dispose: it
    }
}
class OrthographicCamera extends Camera {
    constructor($=-1, tt=1, nt=1, rt=-1, it=.1, ot=2e3) {
        super(),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = $,
        this.right = tt,
        this.top = nt,
        this.bottom = rt,
        this.near = it,
        this.far = ot,
        this.updateProjectionMatrix()
    }
    copy($, tt) {
        return super.copy($, tt),
        this.left = $.left,
        this.right = $.right,
        this.top = $.top,
        this.bottom = $.bottom,
        this.near = $.near,
        this.far = $.far,
        this.zoom = $.zoom,
        this.view = $.view === null ? null : Object.assign({}, $.view),
        this
    }
    setViewOffset($, tt, nt, rt, it, ot) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = $,
        this.view.fullHeight = tt,
        this.view.offsetX = nt,
        this.view.offsetY = rt,
        this.view.width = it,
        this.view.height = ot,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const $ = (this.right - this.left) / (2 * this.zoom)
          , tt = (this.top - this.bottom) / (2 * this.zoom)
          , nt = (this.right + this.left) / 2
          , rt = (this.top + this.bottom) / 2;
        let it = nt - $
          , ot = nt + $
          , st = rt + tt
          , lt = rt - tt;
        if (this.view !== null && this.view.enabled) {
            const ut = (this.right - this.left) / this.view.fullWidth / this.zoom
              , ct = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            it += ut * this.view.offsetX,
            ot = it + ut * this.view.width,
            st -= ct * this.view.offsetY,
            lt = st - ct * this.view.height
        }
        this.projectionMatrix.makeOrthographic(it, ot, st, lt, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON($) {
        const tt = super.toJSON($);
        return tt.object.zoom = this.zoom,
        tt.object.left = this.left,
        tt.object.right = this.right,
        tt.object.top = this.top,
        tt.object.bottom = this.bottom,
        tt.object.near = this.near,
        tt.object.far = this.far,
        this.view !== null && (tt.object.view = Object.assign({}, this.view)),
        tt
    }
}
OrthographicCamera.prototype.isOrthographicCamera = !0;
const LOD_MIN = 4
  , EXTRA_LOD_SIGMA = [.125, .215, .35, .446, .526, .582]
  , MAX_SAMPLES = 20
  , _flatCamera = new OrthographicCamera
  , _clearColor = new Color;
let _oldTarget = null;
const PHI = (1 + Math.sqrt(5)) / 2
  , INV_PHI = 1 / PHI
  , _axisDirections = [new Vector3(1,1,1), new Vector3(-1,1,1), new Vector3(1,1,-1), new Vector3(-1,1,-1), new Vector3(0,PHI,INV_PHI), new Vector3(0,PHI,-INV_PHI), new Vector3(INV_PHI,0,PHI), new Vector3(-INV_PHI,0,PHI), new Vector3(PHI,INV_PHI,0), new Vector3(-PHI,INV_PHI,0)];
class PMREMGenerator {
    constructor($) {
        this._renderer = $,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene($, tt=0, nt=.1, rt=100) {
        _oldTarget = this._renderer.getRenderTarget(),
        this._setSize(256);
        const it = this._allocateTargets();
        return it.depthBuffer = !0,
        this._sceneToCubeUV($, nt, rt, it),
        tt > 0 && this._blur(it, 0, 0, tt),
        this._applyPMREM(it),
        this._cleanup(it),
        it
    }
    fromEquirectangular($, tt=null) {
        return this._fromTexture($, tt)
    }
    fromCubemap($, tt=null) {
        return this._fromTexture($, tt)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize($) {
        this._lodMax = Math.floor(Math.log2($)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let $ = 0; $ < this._lodPlanes.length; $++)
            this._lodPlanes[$].dispose()
    }
    _cleanup($) {
        this._renderer.setRenderTarget(_oldTarget),
        $.scissorTest = !1,
        _setViewport($, 0, 0, $.width, $.height)
    }
    _fromTexture($, tt) {
        $.mapping === CubeReflectionMapping || $.mapping === CubeRefractionMapping ? this._setSize($.image.length === 0 ? 16 : $.image[0].width || $.image[0].image.width) : this._setSize($.image.width / 4),
        _oldTarget = this._renderer.getRenderTarget();
        const nt = tt || this._allocateTargets();
        return this._textureToCubeUV($, nt),
        this._applyPMREM(nt),
        this._cleanup(nt),
        nt
    }
    _allocateTargets() {
        const $ = 3 * Math.max(this._cubeSize, 112)
          , tt = 4 * this._cubeSize - 32
          , nt = {
            magFilter: LinearFilter,
            minFilter: LinearFilter,
            generateMipmaps: !1,
            type: HalfFloatType,
            format: RGBAFormat,
            encoding: LinearEncoding,
            depthBuffer: !1
        }
          , rt = _createRenderTarget($, tt, nt);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== $) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = _createRenderTarget($, tt, nt);
            const {_lodMax: it} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = _createPlanes(it)),
            this._blurMaterial = _getBlurShader(it, $, tt)
        }
        return rt
    }
    _compileMaterial($) {
        const tt = new Mesh(this._lodPlanes[0],$);
        this._renderer.compile(tt, _flatCamera)
    }
    _sceneToCubeUV($, tt, nt, rt) {
        const st = new PerspectiveCamera(90,1,tt,nt)
          , lt = [1, -1, 1, 1, 1, 1]
          , ut = [1, 1, 1, -1, -1, -1]
          , ct = this._renderer
          , ht = ct.autoClear
          , ft = ct.toneMapping;
        ct.getClearColor(_clearColor),
        ct.toneMapping = NoToneMapping,
        ct.autoClear = !1;
        const gt = new MeshBasicMaterial({
            name: "PMREM.Background",
            side: BackSide,
            depthWrite: !1,
            depthTest: !1
        })
          , vt = new Mesh(new BoxGeometry,gt);
        let yt = !1;
        const wt = $.background;
        wt ? wt.isColor && (gt.color.copy(wt),
        $.background = null,
        yt = !0) : (gt.color.copy(_clearColor),
        yt = !0);
        for (let mt = 0; mt < 6; mt++) {
            const _t = mt % 3;
            _t === 0 ? (st.up.set(0, lt[mt], 0),
            st.lookAt(ut[mt], 0, 0)) : _t === 1 ? (st.up.set(0, 0, lt[mt]),
            st.lookAt(0, ut[mt], 0)) : (st.up.set(0, lt[mt], 0),
            st.lookAt(0, 0, ut[mt]));
            const bt = this._cubeSize;
            _setViewport(rt, _t * bt, mt > 2 ? bt : 0, bt, bt),
            ct.setRenderTarget(rt),
            yt && ct.render(vt, st),
            ct.render($, st)
        }
        vt.geometry.dispose(),
        vt.material.dispose(),
        ct.toneMapping = ft,
        ct.autoClear = ht,
        $.background = wt
    }
    _textureToCubeUV($, tt) {
        const nt = this._renderer
          , rt = $.mapping === CubeReflectionMapping || $.mapping === CubeRefractionMapping;
        rt ? (this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = $.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial());
        const it = rt ? this._cubemapMaterial : this._equirectMaterial
          , ot = new Mesh(this._lodPlanes[0],it)
          , st = it.uniforms;
        st.envMap.value = $;
        const lt = this._cubeSize;
        _setViewport(tt, 0, 0, 3 * lt, 2 * lt),
        nt.setRenderTarget(tt),
        nt.render(ot, _flatCamera)
    }
    _applyPMREM($) {
        const tt = this._renderer
          , nt = tt.autoClear;
        tt.autoClear = !1;
        for (let rt = 1; rt < this._lodPlanes.length; rt++) {
            const it = Math.sqrt(this._sigmas[rt] * this._sigmas[rt] - this._sigmas[rt - 1] * this._sigmas[rt - 1])
              , ot = _axisDirections[(rt - 1) % _axisDirections.length];
            this._blur($, rt - 1, rt, it, ot)
        }
        tt.autoClear = nt
    }
    _blur($, tt, nt, rt, it) {
        const ot = this._pingPongRenderTarget;
        this._halfBlur($, ot, tt, nt, rt, "latitudinal", it),
        this._halfBlur(ot, $, nt, nt, rt, "longitudinal", it)
    }
    _halfBlur($, tt, nt, rt, it, ot, st) {
        const lt = this._renderer
          , ut = this._blurMaterial;
        ot !== "latitudinal" && ot !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const ct = 3
          , ht = new Mesh(this._lodPlanes[rt],ut)
          , ft = ut.uniforms
          , gt = this._sizeLods[nt] - 1
          , vt = isFinite(it) ? Math.PI / (2 * gt) : 2 * Math.PI / (2 * MAX_SAMPLES - 1)
          , yt = it / vt
          , wt = isFinite(it) ? 1 + Math.floor(ct * yt) : MAX_SAMPLES;
        wt > MAX_SAMPLES && console.warn(`sigmaRadians, ${it}, is too large and will clip, as it requested ${wt} samples when the maximum is set to ${MAX_SAMPLES}`);
        const mt = [];
        let _t = 0;
        for (let Pt = 0; Pt < MAX_SAMPLES; ++Pt) {
            const Ot = Pt / yt
              , Zt = Math.exp(-Ot * Ot / 2);
            mt.push(Zt),
            Pt === 0 ? _t += Zt : Pt < wt && (_t += 2 * Zt)
        }
        for (let Pt = 0; Pt < mt.length; Pt++)
            mt[Pt] = mt[Pt] / _t;
        ft.envMap.value = $.texture,
        ft.samples.value = wt,
        ft.weights.value = mt,
        ft.latitudinal.value = ot === "latitudinal",
        st && (ft.poleAxis.value = st);
        const {_lodMax: bt} = this;
        ft.dTheta.value = vt,
        ft.mipInt.value = bt - nt;
        const Mt = this._sizeLods[rt]
          , St = 3 * Mt * (rt > bt - LOD_MIN ? rt - bt + LOD_MIN : 0)
          , At = 4 * (this._cubeSize - Mt);
        _setViewport(tt, St, At, 3 * Mt, 2 * Mt),
        lt.setRenderTarget(tt),
        lt.render(ht, _flatCamera)
    }
}
function _createPlanes(et) {
    const $ = []
      , tt = []
      , nt = [];
    let rt = et;
    const it = et - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let ot = 0; ot < it; ot++) {
        const st = Math.pow(2, rt);
        tt.push(st);
        let lt = 1 / st;
        ot > et - LOD_MIN ? lt = EXTRA_LOD_SIGMA[ot - et + LOD_MIN - 1] : ot === 0 && (lt = 0),
        nt.push(lt);
        const ut = 1 / (st - 1)
          , ct = -ut / 2
          , ht = 1 + ut / 2
          , ft = [ct, ct, ht, ct, ht, ht, ct, ct, ht, ht, ct, ht]
          , gt = 6
          , vt = 6
          , yt = 3
          , wt = 2
          , mt = 1
          , _t = new Float32Array(yt * vt * gt)
          , bt = new Float32Array(wt * vt * gt)
          , Mt = new Float32Array(mt * vt * gt);
        for (let At = 0; At < gt; At++) {
            const Pt = At % 3 * 2 / 3 - 1
              , Ot = At > 2 ? 0 : -1
              , Zt = [Pt, Ot, 0, Pt + 2 / 3, Ot, 0, Pt + 2 / 3, Ot + 1, 0, Pt, Ot, 0, Pt + 2 / 3, Ot + 1, 0, Pt, Ot + 1, 0];
            _t.set(Zt, yt * vt * At),
            bt.set(ft, wt * vt * At);
            const Nt = [At, At, At, At, At, At];
            Mt.set(Nt, mt * vt * At)
        }
        const St = new BufferGeometry;
        St.setAttribute("position", new BufferAttribute(_t,yt)),
        St.setAttribute("uv", new BufferAttribute(bt,wt)),
        St.setAttribute("faceIndex", new BufferAttribute(Mt,mt)),
        $.push(St),
        rt > LOD_MIN && rt--
    }
    return {
        lodPlanes: $,
        sizeLods: tt,
        sigmas: nt
    }
}
function _createRenderTarget(et, $, tt) {
    const nt = new WebGLRenderTarget(et,$,tt);
    return nt.texture.mapping = CubeUVReflectionMapping,
    nt.texture.name = "PMREM.cubeUv",
    nt.scissorTest = !0,
    nt
}
function _setViewport(et, $, tt, nt, rt) {
    et.viewport.set($, tt, nt, rt),
    et.scissor.set($, tt, nt, rt)
}
function _getBlurShader(et, $, tt) {
    const nt = new Float32Array(MAX_SAMPLES)
      , rt = new Vector3(0,1,0);
    return new ShaderMaterial({
        name: "SphericalGaussianBlur",
        defines: {
            n: MAX_SAMPLES,
            CUBEUV_TEXEL_WIDTH: 1 / $,
            CUBEUV_TEXEL_HEIGHT: 1 / tt,
            CUBEUV_MAX_MIP: `${et}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: nt
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: rt
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getEquirectMaterial() {
    return new ShaderMaterial({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getCubemapMaterial() {
    return new ShaderMaterial({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getCommonVertexShader() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function WebGLCubeUVMaps(et) {
    let $ = new WeakMap
      , tt = null;
    function nt(st) {
        if (st && st.isTexture) {
            const lt = st.mapping
              , ut = lt === EquirectangularReflectionMapping || lt === EquirectangularRefractionMapping
              , ct = lt === CubeReflectionMapping || lt === CubeRefractionMapping;
            if (ut || ct)
                if (st.isRenderTargetTexture && st.needsPMREMUpdate === !0) {
                    st.needsPMREMUpdate = !1;
                    let ht = $.get(st);
                    return tt === null && (tt = new PMREMGenerator(et)),
                    ht = ut ? tt.fromEquirectangular(st, ht) : tt.fromCubemap(st, ht),
                    $.set(st, ht),
                    ht.texture
                } else {
                    if ($.has(st))
                        return $.get(st).texture;
                    {
                        const ht = st.image;
                        if (ut && ht && ht.height > 0 || ct && ht && rt(ht)) {
                            tt === null && (tt = new PMREMGenerator(et));
                            const ft = ut ? tt.fromEquirectangular(st) : tt.fromCubemap(st);
                            return $.set(st, ft),
                            st.addEventListener("dispose", it),
                            ft.texture
                        } else
                            return null
                    }
                }
        }
        return st
    }
    function rt(st) {
        let lt = 0;
        const ut = 6;
        for (let ct = 0; ct < ut; ct++)
            st[ct] !== void 0 && lt++;
        return lt === ut
    }
    function it(st) {
        const lt = st.target;
        lt.removeEventListener("dispose", it);
        const ut = $.get(lt);
        ut !== void 0 && ($.delete(lt),
        ut.dispose())
    }
    function ot() {
        $ = new WeakMap,
        tt !== null && (tt.dispose(),
        tt = null)
    }
    return {
        get: nt,
        dispose: ot
    }
}
function WebGLExtensions(et) {
    const $ = {};
    function tt(nt) {
        if ($[nt] !== void 0)
            return $[nt];
        let rt;
        switch (nt) {
        case "WEBGL_depth_texture":
            rt = et.getExtension("WEBGL_depth_texture") || et.getExtension("MOZ_WEBGL_depth_texture") || et.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            rt = et.getExtension("EXT_texture_filter_anisotropic") || et.getExtension("MOZ_EXT_texture_filter_anisotropic") || et.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            rt = et.getExtension("WEBGL_compressed_texture_s3tc") || et.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || et.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            rt = et.getExtension("WEBGL_compressed_texture_pvrtc") || et.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            rt = et.getExtension(nt)
        }
        return $[nt] = rt,
        rt
    }
    return {
        has: function(nt) {
            return tt(nt) !== null
        },
        init: function(nt) {
            nt.isWebGL2 ? tt("EXT_color_buffer_float") : (tt("WEBGL_depth_texture"),
            tt("OES_texture_float"),
            tt("OES_texture_half_float"),
            tt("OES_texture_half_float_linear"),
            tt("OES_standard_derivatives"),
            tt("OES_element_index_uint"),
            tt("OES_vertex_array_object"),
            tt("ANGLE_instanced_arrays")),
            tt("OES_texture_float_linear"),
            tt("EXT_color_buffer_half_float"),
            tt("WEBGL_multisampled_render_to_texture")
        },
        get: function(nt) {
            const rt = tt(nt);
            return rt === null && console.warn("THREE.WebGLRenderer: " + nt + " extension not supported."),
            rt
        }
    }
}
function WebGLGeometries(et, $, tt, nt) {
    const rt = {}
      , it = new WeakMap;
    function ot(ht) {
        const ft = ht.target;
        ft.index !== null && $.remove(ft.index);
        for (const vt in ft.attributes)
            $.remove(ft.attributes[vt]);
        ft.removeEventListener("dispose", ot),
        delete rt[ft.id];
        const gt = it.get(ft);
        gt && ($.remove(gt),
        it.delete(ft)),
        nt.releaseStatesOfGeometry(ft),
        ft.isInstancedBufferGeometry === !0 && delete ft._maxInstanceCount,
        tt.memory.geometries--
    }
    function st(ht, ft) {
        return rt[ft.id] === !0 || (ft.addEventListener("dispose", ot),
        rt[ft.id] = !0,
        tt.memory.geometries++),
        ft
    }
    function lt(ht) {
        const ft = ht.attributes;
        for (const vt in ft)
            $.update(ft[vt], 34962);
        const gt = ht.morphAttributes;
        for (const vt in gt) {
            const yt = gt[vt];
            for (let wt = 0, mt = yt.length; wt < mt; wt++)
                $.update(yt[wt], 34962)
        }
    }
    function ut(ht) {
        const ft = []
          , gt = ht.index
          , vt = ht.attributes.position;
        let yt = 0;
        if (gt !== null) {
            const _t = gt.array;
            yt = gt.version;
            for (let bt = 0, Mt = _t.length; bt < Mt; bt += 3) {
                const St = _t[bt + 0]
                  , At = _t[bt + 1]
                  , Pt = _t[bt + 2];
                ft.push(St, At, At, Pt, Pt, St)
            }
        } else {
            const _t = vt.array;
            yt = vt.version;
            for (let bt = 0, Mt = _t.length / 3 - 1; bt < Mt; bt += 3) {
                const St = bt + 0
                  , At = bt + 1
                  , Pt = bt + 2;
                ft.push(St, At, At, Pt, Pt, St)
            }
        }
        const wt = new (arrayNeedsUint32(ft) ? Uint32BufferAttribute : Uint16BufferAttribute)(ft,1);
        wt.version = yt;
        const mt = it.get(ht);
        mt && $.remove(mt),
        it.set(ht, wt)
    }
    function ct(ht) {
        const ft = it.get(ht);
        if (ft) {
            const gt = ht.index;
            gt !== null && ft.version < gt.version && ut(ht)
        } else
            ut(ht);
        return it.get(ht)
    }
    return {
        get: st,
        update: lt,
        getWireframeAttribute: ct
    }
}
function WebGLIndexedBufferRenderer(et, $, tt, nt) {
    const rt = nt.isWebGL2;
    let it;
    function ot(ft) {
        it = ft
    }
    let st, lt;
    function ut(ft) {
        st = ft.type,
        lt = ft.bytesPerElement
    }
    function ct(ft, gt) {
        et.drawElements(it, gt, st, ft * lt),
        tt.update(gt, it, 1)
    }
    function ht(ft, gt, vt) {
        if (vt === 0)
            return;
        let yt, wt;
        if (rt)
            yt = et,
            wt = "drawElementsInstanced";
        else if (yt = $.get("ANGLE_instanced_arrays"),
        wt = "drawElementsInstancedANGLE",
        yt === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        yt[wt](it, gt, st, ft * lt, vt),
        tt.update(gt, it, vt)
    }
    this.setMode = ot,
    this.setIndex = ut,
    this.render = ct,
    this.renderInstances = ht
}
function WebGLInfo(et) {
    const $ = {
        geometries: 0,
        textures: 0
    }
      , tt = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function nt(it, ot, st) {
        switch (tt.calls++,
        ot) {
        case 4:
            tt.triangles += st * (it / 3);
            break;
        case 1:
            tt.lines += st * (it / 2);
            break;
        case 3:
            tt.lines += st * (it - 1);
            break;
        case 2:
            tt.lines += st * it;
            break;
        case 0:
            tt.points += st * it;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", ot);
            break
        }
    }
    function rt() {
        tt.frame++,
        tt.calls = 0,
        tt.triangles = 0,
        tt.points = 0,
        tt.lines = 0
    }
    return {
        memory: $,
        render: tt,
        programs: null,
        autoReset: !0,
        reset: rt,
        update: nt
    }
}
function numericalSort(et, $) {
    return et[0] - $[0]
}
function absNumericalSort(et, $) {
    return Math.abs($[1]) - Math.abs(et[1])
}
function denormalize(et, $) {
    let tt = 1;
    const nt = $.isInterleavedBufferAttribute ? $.data.array : $.array;
    nt instanceof Int8Array ? tt = 127 : nt instanceof Int16Array ? tt = 32767 : nt instanceof Int32Array ? tt = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", nt),
    et.divideScalar(tt)
}
function WebGLMorphtargets(et, $, tt) {
    const nt = {}
      , rt = new Float32Array(8)
      , it = new WeakMap
      , ot = new Vector4
      , st = [];
    for (let ut = 0; ut < 8; ut++)
        st[ut] = [ut, 0];
    function lt(ut, ct, ht, ft) {
        const gt = ut.morphTargetInfluences;
        if ($.isWebGL2 === !0) {
            const yt = ct.morphAttributes.position || ct.morphAttributes.normal || ct.morphAttributes.color
              , wt = yt !== void 0 ? yt.length : 0;
            let mt = it.get(ct);
            if (mt === void 0 || mt.count !== wt) {
                let qt = function() {
                    Wt.dispose(),
                    it.delete(ct),
                    ct.removeEventListener("dispose", qt)
                };
                var vt = qt;
                mt !== void 0 && mt.texture.dispose();
                const Mt = ct.morphAttributes.position !== void 0
                  , St = ct.morphAttributes.normal !== void 0
                  , At = ct.morphAttributes.color !== void 0
                  , Pt = ct.morphAttributes.position || []
                  , Ot = ct.morphAttributes.normal || []
                  , Zt = ct.morphAttributes.color || [];
                let Nt = 0;
                Mt === !0 && (Nt = 1),
                St === !0 && (Nt = 2),
                At === !0 && (Nt = 3);
                let Tt = ct.attributes.position.count * Nt
                  , Ft = 1;
                Tt > $.maxTextureSize && (Ft = Math.ceil(Tt / $.maxTextureSize),
                Tt = $.maxTextureSize);
                const $t = new Float32Array(Tt * Ft * 4 * wt)
                  , Wt = new DataArrayTexture($t,Tt,Ft,wt);
                Wt.format = RGBAFormat,
                Wt.type = FloatType,
                Wt.needsUpdate = !0;
                const Kt = Nt * 4;
                for (let jt = 0; jt < wt; jt++) {
                    const Bt = Pt[jt]
                      , Xt = Ot[jt]
                      , Jt = Zt[jt]
                      , Lt = Tt * Ft * 4 * jt;
                    for (let Rt = 0; Rt < Bt.count; Rt++) {
                        const _n = Rt * Kt;
                        Mt === !0 && (ot.fromBufferAttribute(Bt, Rt),
                        Bt.normalized === !0 && denormalize(ot, Bt),
                        $t[Lt + _n + 0] = ot.x,
                        $t[Lt + _n + 1] = ot.y,
                        $t[Lt + _n + 2] = ot.z,
                        $t[Lt + _n + 3] = 0),
                        St === !0 && (ot.fromBufferAttribute(Xt, Rt),
                        Xt.normalized === !0 && denormalize(ot, Xt),
                        $t[Lt + _n + 4] = ot.x,
                        $t[Lt + _n + 5] = ot.y,
                        $t[Lt + _n + 6] = ot.z,
                        $t[Lt + _n + 7] = 0),
                        At === !0 && (ot.fromBufferAttribute(Jt, Rt),
                        Jt.normalized === !0 && denormalize(ot, Xt),
                        $t[Lt + _n + 8] = ot.x,
                        $t[Lt + _n + 9] = ot.y,
                        $t[Lt + _n + 10] = ot.z,
                        $t[Lt + _n + 11] = Jt.itemSize === 4 ? ot.w : 1)
                    }
                }
                mt = {
                    count: wt,
                    texture: Wt,
                    size: new Vector2(Tt,Ft)
                },
                it.set(ct, mt),
                ct.addEventListener("dispose", qt)
            }
            let _t = 0;
            for (let Mt = 0; Mt < gt.length; Mt++)
                _t += gt[Mt];
            const bt = ct.morphTargetsRelative ? 1 : 1 - _t;
            ft.getUniforms().setValue(et, "morphTargetBaseInfluence", bt),
            ft.getUniforms().setValue(et, "morphTargetInfluences", gt),
            ft.getUniforms().setValue(et, "morphTargetsTexture", mt.texture, tt),
            ft.getUniforms().setValue(et, "morphTargetsTextureSize", mt.size)
        } else {
            const yt = gt === void 0 ? 0 : gt.length;
            let wt = nt[ct.id];
            if (wt === void 0 || wt.length !== yt) {
                wt = [];
                for (let St = 0; St < yt; St++)
                    wt[St] = [St, 0];
                nt[ct.id] = wt
            }
            for (let St = 0; St < yt; St++) {
                const At = wt[St];
                At[0] = St,
                At[1] = gt[St]
            }
            wt.sort(absNumericalSort);
            for (let St = 0; St < 8; St++)
                St < yt && wt[St][1] ? (st[St][0] = wt[St][0],
                st[St][1] = wt[St][1]) : (st[St][0] = Number.MAX_SAFE_INTEGER,
                st[St][1] = 0);
            st.sort(numericalSort);
            const mt = ct.morphAttributes.position
              , _t = ct.morphAttributes.normal;
            let bt = 0;
            for (let St = 0; St < 8; St++) {
                const At = st[St]
                  , Pt = At[0]
                  , Ot = At[1];
                Pt !== Number.MAX_SAFE_INTEGER && Ot ? (mt && ct.getAttribute("morphTarget" + St) !== mt[Pt] && ct.setAttribute("morphTarget" + St, mt[Pt]),
                _t && ct.getAttribute("morphNormal" + St) !== _t[Pt] && ct.setAttribute("morphNormal" + St, _t[Pt]),
                rt[St] = Ot,
                bt += Ot) : (mt && ct.hasAttribute("morphTarget" + St) === !0 && ct.deleteAttribute("morphTarget" + St),
                _t && ct.hasAttribute("morphNormal" + St) === !0 && ct.deleteAttribute("morphNormal" + St),
                rt[St] = 0)
            }
            const Mt = ct.morphTargetsRelative ? 1 : 1 - bt;
            ft.getUniforms().setValue(et, "morphTargetBaseInfluence", Mt),
            ft.getUniforms().setValue(et, "morphTargetInfluences", rt)
        }
    }
    return {
        update: lt
    }
}
function WebGLObjects(et, $, tt, nt) {
    let rt = new WeakMap;
    function it(lt) {
        const ut = nt.render.frame
          , ct = lt.geometry
          , ht = $.get(lt, ct);
        return rt.get(ht) !== ut && ($.update(ht),
        rt.set(ht, ut)),
        lt.isInstancedMesh && (lt.hasEventListener("dispose", st) === !1 && lt.addEventListener("dispose", st),
        tt.update(lt.instanceMatrix, 34962),
        lt.instanceColor !== null && tt.update(lt.instanceColor, 34962)),
        ht
    }
    function ot() {
        rt = new WeakMap
    }
    function st(lt) {
        const ut = lt.target;
        ut.removeEventListener("dispose", st),
        tt.remove(ut.instanceMatrix),
        ut.instanceColor !== null && tt.remove(ut.instanceColor)
    }
    return {
        update: it,
        dispose: ot
    }
}
const emptyTexture = new Texture
  , emptyArrayTexture = new DataArrayTexture
  , empty3dTexture = new Data3DTexture
  , emptyCubeTexture = new CubeTexture
  , arrayCacheF32 = []
  , arrayCacheI32 = []
  , mat4array = new Float32Array(16)
  , mat3array = new Float32Array(9)
  , mat2array = new Float32Array(4);
function flatten(et, $, tt) {
    const nt = et[0];
    if (nt <= 0 || nt > 0)
        return et;
    const rt = $ * tt;
    let it = arrayCacheF32[rt];
    if (it === void 0 && (it = new Float32Array(rt),
    arrayCacheF32[rt] = it),
    $ !== 0) {
        nt.toArray(it, 0);
        for (let ot = 1, st = 0; ot !== $; ++ot)
            st += tt,
            et[ot].toArray(it, st)
    }
    return it
}
function arraysEqual(et, $) {
    if (et.length !== $.length)
        return !1;
    for (let tt = 0, nt = et.length; tt < nt; tt++)
        if (et[tt] !== $[tt])
            return !1;
    return !0
}
function copyArray(et, $) {
    for (let tt = 0, nt = $.length; tt < nt; tt++)
        et[tt] = $[tt]
}
function allocTexUnits(et, $) {
    let tt = arrayCacheI32[$];
    tt === void 0 && (tt = new Int32Array($),
    arrayCacheI32[$] = tt);
    for (let nt = 0; nt !== $; ++nt)
        tt[nt] = et.allocateTextureUnit();
    return tt
}
function setValueV1f(et, $) {
    const tt = this.cache;
    tt[0] !== $ && (et.uniform1f(this.addr, $),
    tt[0] = $)
}
function setValueV2f(et, $) {
    const tt = this.cache;
    if ($.x !== void 0)
        (tt[0] !== $.x || tt[1] !== $.y) && (et.uniform2f(this.addr, $.x, $.y),
        tt[0] = $.x,
        tt[1] = $.y);
    else {
        if (arraysEqual(tt, $))
            return;
        et.uniform2fv(this.addr, $),
        copyArray(tt, $)
    }
}
function setValueV3f(et, $) {
    const tt = this.cache;
    if ($.x !== void 0)
        (tt[0] !== $.x || tt[1] !== $.y || tt[2] !== $.z) && (et.uniform3f(this.addr, $.x, $.y, $.z),
        tt[0] = $.x,
        tt[1] = $.y,
        tt[2] = $.z);
    else if ($.r !== void 0)
        (tt[0] !== $.r || tt[1] !== $.g || tt[2] !== $.b) && (et.uniform3f(this.addr, $.r, $.g, $.b),
        tt[0] = $.r,
        tt[1] = $.g,
        tt[2] = $.b);
    else {
        if (arraysEqual(tt, $))
            return;
        et.uniform3fv(this.addr, $),
        copyArray(tt, $)
    }
}
function setValueV4f(et, $) {
    const tt = this.cache;
    if ($.x !== void 0)
        (tt[0] !== $.x || tt[1] !== $.y || tt[2] !== $.z || tt[3] !== $.w) && (et.uniform4f(this.addr, $.x, $.y, $.z, $.w),
        tt[0] = $.x,
        tt[1] = $.y,
        tt[2] = $.z,
        tt[3] = $.w);
    else {
        if (arraysEqual(tt, $))
            return;
        et.uniform4fv(this.addr, $),
        copyArray(tt, $)
    }
}
function setValueM2(et, $) {
    const tt = this.cache
      , nt = $.elements;
    if (nt === void 0) {
        if (arraysEqual(tt, $))
            return;
        et.uniformMatrix2fv(this.addr, !1, $),
        copyArray(tt, $)
    } else {
        if (arraysEqual(tt, nt))
            return;
        mat2array.set(nt),
        et.uniformMatrix2fv(this.addr, !1, mat2array),
        copyArray(tt, nt)
    }
}
function setValueM3(et, $) {
    const tt = this.cache
      , nt = $.elements;
    if (nt === void 0) {
        if (arraysEqual(tt, $))
            return;
        et.uniformMatrix3fv(this.addr, !1, $),
        copyArray(tt, $)
    } else {
        if (arraysEqual(tt, nt))
            return;
        mat3array.set(nt),
        et.uniformMatrix3fv(this.addr, !1, mat3array),
        copyArray(tt, nt)
    }
}
function setValueM4(et, $) {
    const tt = this.cache
      , nt = $.elements;
    if (nt === void 0) {
        if (arraysEqual(tt, $))
            return;
        et.uniformMatrix4fv(this.addr, !1, $),
        copyArray(tt, $)
    } else {
        if (arraysEqual(tt, nt))
            return;
        mat4array.set(nt),
        et.uniformMatrix4fv(this.addr, !1, mat4array),
        copyArray(tt, nt)
    }
}
function setValueV1i(et, $) {
    const tt = this.cache;
    tt[0] !== $ && (et.uniform1i(this.addr, $),
    tt[0] = $)
}
function setValueV2i(et, $) {
    const tt = this.cache;
    arraysEqual(tt, $) || (et.uniform2iv(this.addr, $),
    copyArray(tt, $))
}
function setValueV3i(et, $) {
    const tt = this.cache;
    arraysEqual(tt, $) || (et.uniform3iv(this.addr, $),
    copyArray(tt, $))
}
function setValueV4i(et, $) {
    const tt = this.cache;
    arraysEqual(tt, $) || (et.uniform4iv(this.addr, $),
    copyArray(tt, $))
}
function setValueV1ui(et, $) {
    const tt = this.cache;
    tt[0] !== $ && (et.uniform1ui(this.addr, $),
    tt[0] = $)
}
function setValueV2ui(et, $) {
    const tt = this.cache;
    arraysEqual(tt, $) || (et.uniform2uiv(this.addr, $),
    copyArray(tt, $))
}
function setValueV3ui(et, $) {
    const tt = this.cache;
    arraysEqual(tt, $) || (et.uniform3uiv(this.addr, $),
    copyArray(tt, $))
}
function setValueV4ui(et, $) {
    const tt = this.cache;
    arraysEqual(tt, $) || (et.uniform4uiv(this.addr, $),
    copyArray(tt, $))
}
function setValueT1(et, $, tt) {
    const nt = this.cache
      , rt = tt.allocateTextureUnit();
    nt[0] !== rt && (et.uniform1i(this.addr, rt),
    nt[0] = rt),
    tt.setTexture2D($ || emptyTexture, rt)
}
function setValueT3D1(et, $, tt) {
    const nt = this.cache
      , rt = tt.allocateTextureUnit();
    nt[0] !== rt && (et.uniform1i(this.addr, rt),
    nt[0] = rt),
    tt.setTexture3D($ || empty3dTexture, rt)
}
function setValueT6(et, $, tt) {
    const nt = this.cache
      , rt = tt.allocateTextureUnit();
    nt[0] !== rt && (et.uniform1i(this.addr, rt),
    nt[0] = rt),
    tt.setTextureCube($ || emptyCubeTexture, rt)
}
function setValueT2DArray1(et, $, tt) {
    const nt = this.cache
      , rt = tt.allocateTextureUnit();
    nt[0] !== rt && (et.uniform1i(this.addr, rt),
    nt[0] = rt),
    tt.setTexture2DArray($ || emptyArrayTexture, rt)
}
function getSingularSetter(et) {
    switch (et) {
    case 5126:
        return setValueV1f;
    case 35664:
        return setValueV2f;
    case 35665:
        return setValueV3f;
    case 35666:
        return setValueV4f;
    case 35674:
        return setValueM2;
    case 35675:
        return setValueM3;
    case 35676:
        return setValueM4;
    case 5124:
    case 35670:
        return setValueV1i;
    case 35667:
    case 35671:
        return setValueV2i;
    case 35668:
    case 35672:
        return setValueV3i;
    case 35669:
    case 35673:
        return setValueV4i;
    case 5125:
        return setValueV1ui;
    case 36294:
        return setValueV2ui;
    case 36295:
        return setValueV3ui;
    case 36296:
        return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return setValueT1;
    case 35679:
    case 36299:
    case 36307:
        return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return setValueT2DArray1
    }
}
function setValueV1fArray(et, $) {
    et.uniform1fv(this.addr, $)
}
function setValueV2fArray(et, $) {
    const tt = flatten($, this.size, 2);
    et.uniform2fv(this.addr, tt)
}
function setValueV3fArray(et, $) {
    const tt = flatten($, this.size, 3);
    et.uniform3fv(this.addr, tt)
}
function setValueV4fArray(et, $) {
    const tt = flatten($, this.size, 4);
    et.uniform4fv(this.addr, tt)
}
function setValueM2Array(et, $) {
    const tt = flatten($, this.size, 4);
    et.uniformMatrix2fv(this.addr, !1, tt)
}
function setValueM3Array(et, $) {
    const tt = flatten($, this.size, 9);
    et.uniformMatrix3fv(this.addr, !1, tt)
}
function setValueM4Array(et, $) {
    const tt = flatten($, this.size, 16);
    et.uniformMatrix4fv(this.addr, !1, tt)
}
function setValueV1iArray(et, $) {
    et.uniform1iv(this.addr, $)
}
function setValueV2iArray(et, $) {
    et.uniform2iv(this.addr, $)
}
function setValueV3iArray(et, $) {
    et.uniform3iv(this.addr, $)
}
function setValueV4iArray(et, $) {
    et.uniform4iv(this.addr, $)
}
function setValueV1uiArray(et, $) {
    et.uniform1uiv(this.addr, $)
}
function setValueV2uiArray(et, $) {
    et.uniform2uiv(this.addr, $)
}
function setValueV3uiArray(et, $) {
    et.uniform3uiv(this.addr, $)
}
function setValueV4uiArray(et, $) {
    et.uniform4uiv(this.addr, $)
}
function setValueT1Array(et, $, tt) {
    const nt = $.length
      , rt = allocTexUnits(tt, nt);
    et.uniform1iv(this.addr, rt);
    for (let it = 0; it !== nt; ++it)
        tt.setTexture2D($[it] || emptyTexture, rt[it])
}
function setValueT3DArray(et, $, tt) {
    const nt = $.length
      , rt = allocTexUnits(tt, nt);
    et.uniform1iv(this.addr, rt);
    for (let it = 0; it !== nt; ++it)
        tt.setTexture3D($[it] || empty3dTexture, rt[it])
}
function setValueT6Array(et, $, tt) {
    const nt = $.length
      , rt = allocTexUnits(tt, nt);
    et.uniform1iv(this.addr, rt);
    for (let it = 0; it !== nt; ++it)
        tt.setTextureCube($[it] || emptyCubeTexture, rt[it])
}
function setValueT2DArrayArray(et, $, tt) {
    const nt = $.length
      , rt = allocTexUnits(tt, nt);
    et.uniform1iv(this.addr, rt);
    for (let it = 0; it !== nt; ++it)
        tt.setTexture2DArray($[it] || emptyArrayTexture, rt[it])
}
function getPureArraySetter(et) {
    switch (et) {
    case 5126:
        return setValueV1fArray;
    case 35664:
        return setValueV2fArray;
    case 35665:
        return setValueV3fArray;
    case 35666:
        return setValueV4fArray;
    case 35674:
        return setValueM2Array;
    case 35675:
        return setValueM3Array;
    case 35676:
        return setValueM4Array;
    case 5124:
    case 35670:
        return setValueV1iArray;
    case 35667:
    case 35671:
        return setValueV2iArray;
    case 35668:
    case 35672:
        return setValueV3iArray;
    case 35669:
    case 35673:
        return setValueV4iArray;
    case 5125:
        return setValueV1uiArray;
    case 36294:
        return setValueV2uiArray;
    case 36295:
        return setValueV3uiArray;
    case 36296:
        return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
        return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return setValueT2DArrayArray
    }
}
function SingleUniform(et, $, tt) {
    this.id = et,
    this.addr = tt,
    this.cache = [],
    this.setValue = getSingularSetter($.type)
}
function PureArrayUniform(et, $, tt) {
    this.id = et,
    this.addr = tt,
    this.cache = [],
    this.size = $.size,
    this.setValue = getPureArraySetter($.type)
}
PureArrayUniform.prototype.updateCache = function(et) {
    const $ = this.cache;
    et instanceof Float32Array && $.length !== et.length && (this.cache = new Float32Array(et.length)),
    copyArray($, et)
}
;
function StructuredUniform(et) {
    this.id = et,
    this.seq = [],
    this.map = {}
}
StructuredUniform.prototype.setValue = function(et, $, tt) {
    const nt = this.seq;
    for (let rt = 0, it = nt.length; rt !== it; ++rt) {
        const ot = nt[rt];
        ot.setValue(et, $[ot.id], tt)
    }
}
;
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(et, $) {
    et.seq.push($),
    et.map[$.id] = $
}
function parseUniform(et, $, tt) {
    const nt = et.name
      , rt = nt.length;
    for (RePathPart.lastIndex = 0; ; ) {
        const it = RePathPart.exec(nt)
          , ot = RePathPart.lastIndex;
        let st = it[1];
        const lt = it[2] === "]"
          , ut = it[3];
        if (lt && (st = st | 0),
        ut === void 0 || ut === "[" && ot + 2 === rt) {
            addUniform(tt, ut === void 0 ? new SingleUniform(st,et,$) : new PureArrayUniform(st,et,$));
            break
        } else {
            let ht = tt.map[st];
            ht === void 0 && (ht = new StructuredUniform(st),
            addUniform(tt, ht)),
            tt = ht
        }
    }
}
function WebGLUniforms(et, $) {
    this.seq = [],
    this.map = {};
    const tt = et.getProgramParameter($, 35718);
    for (let nt = 0; nt < tt; ++nt) {
        const rt = et.getActiveUniform($, nt)
          , it = et.getUniformLocation($, rt.name);
        parseUniform(rt, it, this)
    }
}
WebGLUniforms.prototype.setValue = function(et, $, tt, nt) {
    const rt = this.map[$];
    rt !== void 0 && rt.setValue(et, tt, nt)
}
;
WebGLUniforms.prototype.setOptional = function(et, $, tt) {
    const nt = $[tt];
    nt !== void 0 && this.setValue(et, tt, nt)
}
;
WebGLUniforms.upload = function(et, $, tt, nt) {
    for (let rt = 0, it = $.length; rt !== it; ++rt) {
        const ot = $[rt]
          , st = tt[ot.id];
        st.needsUpdate !== !1 && ot.setValue(et, st.value, nt)
    }
}
;
WebGLUniforms.seqWithValue = function(et, $) {
    const tt = [];
    for (let nt = 0, rt = et.length; nt !== rt; ++nt) {
        const it = et[nt];
        it.id in $ && tt.push(it)
    }
    return tt
}
;
function WebGLShader(et, $, tt) {
    const nt = et.createShader($);
    return et.shaderSource(nt, tt),
    et.compileShader(nt),
    nt
}
let programIdCount = 0;
function addLineNumbers(et) {
    const $ = et.split(`
`);
    for (let tt = 0; tt < $.length; tt++)
        $[tt] = tt + 1 + ": " + $[tt];
    return $.join(`
`)
}
function getEncodingComponents(et) {
    switch (et) {
    case LinearEncoding:
        return ["Linear", "( value )"];
    case sRGBEncoding:
        return ["sRGB", "( value )"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", et),
        ["Linear", "( value )"]
    }
}
function getShaderErrors(et, $, tt) {
    const nt = et.getShaderParameter($, 35713)
      , rt = et.getShaderInfoLog($).trim();
    return nt && rt === "" ? "" : tt.toUpperCase() + `

` + rt + `

` + addLineNumbers(et.getShaderSource($))
}
function getTexelEncodingFunction(et, $) {
    const tt = getEncodingComponents($);
    return "vec4 " + et + "( vec4 value ) { return LinearTo" + tt[0] + tt[1] + "; }"
}
function getToneMappingFunction(et, $) {
    let tt;
    switch ($) {
    case LinearToneMapping:
        tt = "Linear";
        break;
    case ReinhardToneMapping:
        tt = "Reinhard";
        break;
    case CineonToneMapping:
        tt = "OptimizedCineon";
        break;
    case ACESFilmicToneMapping:
        tt = "ACESFilmic";
        break;
    case CustomToneMapping:
        tt = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", $),
        tt = "Linear"
    }
    return "vec3 " + et + "( vec3 color ) { return " + tt + "ToneMapping( color ); }"
}
function generateExtensions(et) {
    return [et.extensionDerivatives || !!et.envMapCubeUVHeight || et.bumpMap || et.tangentSpaceNormalMap || et.clearcoatNormalMap || et.flatShading || et.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (et.extensionFragDepth || et.logarithmicDepthBuffer) && et.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", et.extensionDrawBuffers && et.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (et.extensionShaderTextureLOD || et.envMap || et.transmission) && et.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(filterEmptyLine).join(`
`)
}
function generateDefines(et) {
    const $ = [];
    for (const tt in et) {
        const nt = et[tt];
        nt !== !1 && $.push("#define " + tt + " " + nt)
    }
    return $.join(`
`)
}
function fetchAttributeLocations(et, $) {
    const tt = {}
      , nt = et.getProgramParameter($, 35721);
    for (let rt = 0; rt < nt; rt++) {
        const it = et.getActiveAttrib($, rt)
          , ot = it.name;
        let st = 1;
        it.type === 35674 && (st = 2),
        it.type === 35675 && (st = 3),
        it.type === 35676 && (st = 4),
        tt[ot] = {
            type: it.type,
            location: et.getAttribLocation($, ot),
            locationSize: st
        }
    }
    return tt
}
function filterEmptyLine(et) {
    return et !== ""
}
function replaceLightNums(et, $) {
    return et.replace(/NUM_DIR_LIGHTS/g, $.numDirLights).replace(/NUM_SPOT_LIGHTS/g, $.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, $.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, $.numPointLights).replace(/NUM_HEMI_LIGHTS/g, $.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, $.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, $.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, $.numPointLightShadows)
}
function replaceClippingPlaneNums(et, $) {
    return et.replace(/NUM_CLIPPING_PLANES/g, $.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, $.numClippingPlanes - $.numClipIntersection)
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(et) {
    return et.replace(includePattern, includeReplacer)
}
function includeReplacer(et, $) {
    const tt = ShaderChunk[$];
    if (tt === void 0)
        throw new Error("Can not resolve #include <" + $ + ">");
    return resolveIncludes(tt)
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
  , unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(et) {
    return et.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer)
}
function deprecatedLoopReplacer(et, $, tt, nt) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
    loopReplacer(et, $, tt, nt)
}
function loopReplacer(et, $, tt, nt) {
    let rt = "";
    for (let it = parseInt($); it < parseInt(tt); it++)
        rt += nt.replace(/\[\s*i\s*\]/g, "[ " + it + " ]").replace(/UNROLLED_LOOP_INDEX/g, it);
    return rt
}
function generatePrecision(et) {
    let $ = "precision " + et.precision + ` float;
precision ` + et.precision + " int;";
    return et.precision === "highp" ? $ += `
#define HIGH_PRECISION` : et.precision === "mediump" ? $ += `
#define MEDIUM_PRECISION` : et.precision === "lowp" && ($ += `
#define LOW_PRECISION`),
    $
}
function generateShadowMapTypeDefine(et) {
    let $ = "SHADOWMAP_TYPE_BASIC";
    return et.shadowMapType === PCFShadowMap ? $ = "SHADOWMAP_TYPE_PCF" : et.shadowMapType === PCFSoftShadowMap ? $ = "SHADOWMAP_TYPE_PCF_SOFT" : et.shadowMapType === VSMShadowMap && ($ = "SHADOWMAP_TYPE_VSM"),
    $
}
function generateEnvMapTypeDefine(et) {
    let $ = "ENVMAP_TYPE_CUBE";
    if (et.envMap)
        switch (et.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
            $ = "ENVMAP_TYPE_CUBE";
            break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
            $ = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return $
}
function generateEnvMapModeDefine(et) {
    let $ = "ENVMAP_MODE_REFLECTION";
    if (et.envMap)
        switch (et.envMapMode) {
        case CubeRefractionMapping:
        case CubeUVRefractionMapping:
            $ = "ENVMAP_MODE_REFRACTION";
            break
        }
    return $
}
function generateEnvMapBlendingDefine(et) {
    let $ = "ENVMAP_BLENDING_NONE";
    if (et.envMap)
        switch (et.combine) {
        case MultiplyOperation:
            $ = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case MixOperation:
            $ = "ENVMAP_BLENDING_MIX";
            break;
        case AddOperation:
            $ = "ENVMAP_BLENDING_ADD";
            break
        }
    return $
}
function generateCubeUVSize(et) {
    const $ = et.envMapCubeUVHeight;
    if ($ === null)
        return null;
    const tt = Math.log2($ / 32 + 1) + 3
      , nt = 1 / $;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, tt), 7 * 16)),
        texelHeight: nt,
        maxMip: tt
    }
}
function WebGLProgram(et, $, tt, nt) {
    const rt = et.getContext()
      , it = tt.defines;
    let ot = tt.vertexShader
      , st = tt.fragmentShader;
    const lt = generateShadowMapTypeDefine(tt)
      , ut = generateEnvMapTypeDefine(tt)
      , ct = generateEnvMapModeDefine(tt)
      , ht = generateEnvMapBlendingDefine(tt)
      , ft = generateCubeUVSize(tt)
      , gt = tt.isWebGL2 ? "" : generateExtensions(tt)
      , vt = generateDefines(it)
      , yt = rt.createProgram();
    let wt, mt, _t = tt.glslVersion ? "#version " + tt.glslVersion + `
` : "";
    tt.isRawShaderMaterial ? (wt = [vt].filter(filterEmptyLine).join(`
`),
    wt.length > 0 && (wt += `
`),
    mt = [gt, vt].filter(filterEmptyLine).join(`
`),
    mt.length > 0 && (mt += `
`)) : (wt = [generatePrecision(tt), "#define SHADER_NAME " + tt.shaderName, vt, tt.instancing ? "#define USE_INSTANCING" : "", tt.instancingColor ? "#define USE_INSTANCING_COLOR" : "", tt.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + tt.maxBones, tt.useFog && tt.fog ? "#define USE_FOG" : "", tt.useFog && tt.fogExp2 ? "#define FOG_EXP2" : "", tt.map ? "#define USE_MAP" : "", tt.envMap ? "#define USE_ENVMAP" : "", tt.envMap ? "#define " + ct : "", tt.lightMap ? "#define USE_LIGHTMAP" : "", tt.aoMap ? "#define USE_AOMAP" : "", tt.emissiveMap ? "#define USE_EMISSIVEMAP" : "", tt.bumpMap ? "#define USE_BUMPMAP" : "", tt.normalMap ? "#define USE_NORMALMAP" : "", tt.normalMap && tt.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", tt.normalMap && tt.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", tt.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", tt.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", tt.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", tt.displacementMap && tt.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", tt.specularMap ? "#define USE_SPECULARMAP" : "", tt.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", tt.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", tt.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", tt.metalnessMap ? "#define USE_METALNESSMAP" : "", tt.alphaMap ? "#define USE_ALPHAMAP" : "", tt.transmission ? "#define USE_TRANSMISSION" : "", tt.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", tt.thicknessMap ? "#define USE_THICKNESSMAP" : "", tt.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", tt.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", tt.vertexTangents ? "#define USE_TANGENT" : "", tt.vertexColors ? "#define USE_COLOR" : "", tt.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", tt.vertexUvs ? "#define USE_UV" : "", tt.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", tt.flatShading ? "#define FLAT_SHADED" : "", tt.skinning ? "#define USE_SKINNING" : "", tt.useVertexTexture ? "#define BONE_TEXTURE" : "", tt.morphTargets ? "#define USE_MORPHTARGETS" : "", tt.morphNormals && tt.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", tt.morphColors && tt.isWebGL2 ? "#define USE_MORPHCOLORS" : "", tt.morphTargetsCount > 0 && tt.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", tt.morphTargetsCount > 0 && tt.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + tt.morphTextureStride : "", tt.morphTargetsCount > 0 && tt.isWebGL2 ? "#define MORPHTARGETS_COUNT " + tt.morphTargetsCount : "", tt.doubleSided ? "#define DOUBLE_SIDED" : "", tt.flipSided ? "#define FLIP_SIDED" : "", tt.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", tt.shadowMapEnabled ? "#define " + lt : "", tt.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", tt.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", tt.logarithmicDepthBuffer && tt.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(filterEmptyLine).join(`
`),
    mt = [gt, generatePrecision(tt), "#define SHADER_NAME " + tt.shaderName, vt, tt.useFog && tt.fog ? "#define USE_FOG" : "", tt.useFog && tt.fogExp2 ? "#define FOG_EXP2" : "", tt.map ? "#define USE_MAP" : "", tt.matcap ? "#define USE_MATCAP" : "", tt.envMap ? "#define USE_ENVMAP" : "", tt.envMap ? "#define " + ut : "", tt.envMap ? "#define " + ct : "", tt.envMap ? "#define " + ht : "", ft ? "#define CUBEUV_TEXEL_WIDTH " + ft.texelWidth : "", ft ? "#define CUBEUV_TEXEL_HEIGHT " + ft.texelHeight : "", ft ? "#define CUBEUV_MAX_MIP " + ft.maxMip + ".0" : "", tt.lightMap ? "#define USE_LIGHTMAP" : "", tt.aoMap ? "#define USE_AOMAP" : "", tt.emissiveMap ? "#define USE_EMISSIVEMAP" : "", tt.bumpMap ? "#define USE_BUMPMAP" : "", tt.normalMap ? "#define USE_NORMALMAP" : "", tt.normalMap && tt.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", tt.normalMap && tt.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", tt.clearcoat ? "#define USE_CLEARCOAT" : "", tt.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", tt.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", tt.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", tt.specularMap ? "#define USE_SPECULARMAP" : "", tt.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", tt.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", tt.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", tt.metalnessMap ? "#define USE_METALNESSMAP" : "", tt.alphaMap ? "#define USE_ALPHAMAP" : "", tt.alphaTest ? "#define USE_ALPHATEST" : "", tt.sheen ? "#define USE_SHEEN" : "", tt.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", tt.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", tt.transmission ? "#define USE_TRANSMISSION" : "", tt.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", tt.thicknessMap ? "#define USE_THICKNESSMAP" : "", tt.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", tt.vertexTangents ? "#define USE_TANGENT" : "", tt.vertexColors || tt.instancingColor ? "#define USE_COLOR" : "", tt.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", tt.vertexUvs ? "#define USE_UV" : "", tt.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", tt.gradientMap ? "#define USE_GRADIENTMAP" : "", tt.flatShading ? "#define FLAT_SHADED" : "", tt.doubleSided ? "#define DOUBLE_SIDED" : "", tt.flipSided ? "#define FLIP_SIDED" : "", tt.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", tt.shadowMapEnabled ? "#define " + lt : "", tt.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", tt.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", tt.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", tt.logarithmicDepthBuffer && tt.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", tt.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", tt.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", tt.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", tt.toneMapping) : "", tt.dithering ? "#define DITHERING" : "", tt.opaque ? "#define OPAQUE" : "", ShaderChunk.encodings_pars_fragment, getTexelEncodingFunction("linearToOutputTexel", tt.outputEncoding), tt.depthPacking ? "#define DEPTH_PACKING " + tt.depthPacking : "", `
`].filter(filterEmptyLine).join(`
`)),
    ot = resolveIncludes(ot),
    ot = replaceLightNums(ot, tt),
    ot = replaceClippingPlaneNums(ot, tt),
    st = resolveIncludes(st),
    st = replaceLightNums(st, tt),
    st = replaceClippingPlaneNums(st, tt),
    ot = unrollLoops(ot),
    st = unrollLoops(st),
    tt.isWebGL2 && tt.isRawShaderMaterial !== !0 && (_t = `#version 300 es
`,
    wt = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + wt,
    mt = ["#define varying in", tt.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", tt.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + mt);
    const bt = _t + wt + ot
      , Mt = _t + mt + st
      , St = WebGLShader(rt, 35633, bt)
      , At = WebGLShader(rt, 35632, Mt);
    if (rt.attachShader(yt, St),
    rt.attachShader(yt, At),
    tt.index0AttributeName !== void 0 ? rt.bindAttribLocation(yt, 0, tt.index0AttributeName) : tt.morphTargets === !0 && rt.bindAttribLocation(yt, 0, "position"),
    rt.linkProgram(yt),
    et.debug.checkShaderErrors) {
        const Zt = rt.getProgramInfoLog(yt).trim()
          , Nt = rt.getShaderInfoLog(St).trim()
          , Tt = rt.getShaderInfoLog(At).trim();
        let Ft = !0
          , $t = !0;
        if (rt.getProgramParameter(yt, 35714) === !1) {
            Ft = !1;
            const Wt = getShaderErrors(rt, St, "vertex")
              , Kt = getShaderErrors(rt, At, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + rt.getError() + " - VALIDATE_STATUS " + rt.getProgramParameter(yt, 35715) + `

Program Info Log: ` + Zt + `
` + Wt + `
` + Kt)
        } else
            Zt !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", Zt) : (Nt === "" || Tt === "") && ($t = !1);
        $t && (this.diagnostics = {
            runnable: Ft,
            programLog: Zt,
            vertexShader: {
                log: Nt,
                prefix: wt
            },
            fragmentShader: {
                log: Tt,
                prefix: mt
            }
        })
    }
    rt.deleteShader(St),
    rt.deleteShader(At);
    let Pt;
    this.getUniforms = function() {
        return Pt === void 0 && (Pt = new WebGLUniforms(rt,yt)),
        Pt
    }
    ;
    let Ot;
    return this.getAttributes = function() {
        return Ot === void 0 && (Ot = fetchAttributeLocations(rt, yt)),
        Ot
    }
    ,
    this.destroy = function() {
        nt.releaseStatesOfProgram(this),
        rt.deleteProgram(yt),
        this.program = void 0
    }
    ,
    this.name = tt.shaderName,
    this.id = programIdCount++,
    this.cacheKey = $,
    this.usedTimes = 1,
    this.program = yt,
    this.vertexShader = St,
    this.fragmentShader = At,
    this
}
let _id = 0;
class WebGLShaderCache {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update($) {
        const tt = $.vertexShader
          , nt = $.fragmentShader
          , rt = this._getShaderStage(tt)
          , it = this._getShaderStage(nt)
          , ot = this._getShaderCacheForMaterial($);
        return ot.has(rt) === !1 && (ot.add(rt),
        rt.usedTimes++),
        ot.has(it) === !1 && (ot.add(it),
        it.usedTimes++),
        this
    }
    remove($) {
        const tt = this.materialCache.get($);
        for (const nt of tt)
            nt.usedTimes--,
            nt.usedTimes === 0 && this.shaderCache.delete(nt);
        return this.materialCache.delete($),
        this
    }
    getVertexShaderID($) {
        return this._getShaderStage($.vertexShader).id
    }
    getFragmentShaderID($) {
        return this._getShaderStage($.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial($) {
        const tt = this.materialCache;
        return tt.has($) === !1 && tt.set($, new Set),
        tt.get($)
    }
    _getShaderStage($) {
        const tt = this.shaderCache;
        if (tt.has($) === !1) {
            const nt = new WebGLShaderStage;
            tt.set($, nt)
        }
        return tt.get($)
    }
}
class WebGLShaderStage {
    constructor() {
        this.id = _id++,
        this.usedTimes = 0
    }
}
function WebGLPrograms(et, $, tt, nt, rt, it, ot) {
    const st = new Layers
      , lt = new WebGLShaderCache
      , ut = []
      , ct = rt.isWebGL2
      , ht = rt.logarithmicDepthBuffer
      , ft = rt.floatVertexTextures
      , gt = rt.maxVertexUniforms
      , vt = rt.vertexTextures;
    let yt = rt.precision;
    const wt = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function mt(Tt) {
        const $t = Tt.skeleton.bones;
        if (ft)
            return 1024;
        {
            const Kt = Math.floor((gt - 20) / 4)
              , qt = Math.min(Kt, $t.length);
            return qt < $t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + $t.length + " bones. This GPU supports " + qt + "."),
            0) : qt
        }
    }
    function _t(Tt, Ft, $t, Wt, Kt) {
        const qt = Wt.fog
          , jt = Kt.geometry
          , Bt = Tt.isMeshStandardMaterial ? Wt.environment : null
          , Xt = (Tt.isMeshStandardMaterial ? tt : $).get(Tt.envMap || Bt)
          , Jt = !!Xt && (Xt.mapping === CubeUVReflectionMapping || Xt.mapping === CubeUVRefractionMapping) ? Xt.image.height : null
          , Lt = wt[Tt.type]
          , Rt = Kt.isSkinnedMesh ? mt(Kt) : 0;
        Tt.precision !== null && (yt = rt.getMaxPrecision(Tt.precision),
        yt !== Tt.precision && console.warn("THREE.WebGLProgram.getParameters:", Tt.precision, "not supported, using", yt, "instead."));
        const _n = jt.morphAttributes.position || jt.morphAttributes.normal || jt.morphAttributes.color
          , Fn = _n !== void 0 ? _n.length : 0;
        let Vn = 0;
        jt.morphAttributes.position !== void 0 && (Vn = 1),
        jt.morphAttributes.normal !== void 0 && (Vn = 2),
        jt.morphAttributes.color !== void 0 && (Vn = 3);
        let sn, Un, zn, Rn;
        if (Lt) {
            const Mn = ShaderLib[Lt];
            sn = Mn.vertexShader,
            Un = Mn.fragmentShader
        } else
            sn = Tt.vertexShader,
            Un = Tt.fragmentShader,
            lt.update(Tt),
            zn = lt.getVertexShaderID(Tt),
            Rn = lt.getFragmentShaderID(Tt);
        const Ln = et.getRenderTarget()
          , Gn = Tt.alphaTest > 0
          , cn = Tt.clearcoat > 0;
        return {
            isWebGL2: ct,
            shaderID: Lt,
            shaderName: Tt.type,
            vertexShader: sn,
            fragmentShader: Un,
            defines: Tt.defines,
            customVertexShaderID: zn,
            customFragmentShaderID: Rn,
            isRawShaderMaterial: Tt.isRawShaderMaterial === !0,
            glslVersion: Tt.glslVersion,
            precision: yt,
            instancing: Kt.isInstancedMesh === !0,
            instancingColor: Kt.isInstancedMesh === !0 && Kt.instanceColor !== null,
            supportsVertexTextures: vt,
            outputEncoding: Ln === null ? et.outputEncoding : Ln.isXRRenderTarget === !0 ? Ln.texture.encoding : LinearEncoding,
            map: !!Tt.map,
            matcap: !!Tt.matcap,
            envMap: !!Xt,
            envMapMode: Xt && Xt.mapping,
            envMapCubeUVHeight: Jt,
            lightMap: !!Tt.lightMap,
            aoMap: !!Tt.aoMap,
            emissiveMap: !!Tt.emissiveMap,
            bumpMap: !!Tt.bumpMap,
            normalMap: !!Tt.normalMap,
            objectSpaceNormalMap: Tt.normalMapType === ObjectSpaceNormalMap,
            tangentSpaceNormalMap: Tt.normalMapType === TangentSpaceNormalMap,
            decodeVideoTexture: !!Tt.map && Tt.map.isVideoTexture === !0 && Tt.map.encoding === sRGBEncoding,
            clearcoat: cn,
            clearcoatMap: cn && !!Tt.clearcoatMap,
            clearcoatRoughnessMap: cn && !!Tt.clearcoatRoughnessMap,
            clearcoatNormalMap: cn && !!Tt.clearcoatNormalMap,
            displacementMap: !!Tt.displacementMap,
            roughnessMap: !!Tt.roughnessMap,
            metalnessMap: !!Tt.metalnessMap,
            specularMap: !!Tt.specularMap,
            specularIntensityMap: !!Tt.specularIntensityMap,
            specularColorMap: !!Tt.specularColorMap,
            opaque: Tt.transparent === !1 && Tt.blending === NormalBlending,
            alphaMap: !!Tt.alphaMap,
            alphaTest: Gn,
            gradientMap: !!Tt.gradientMap,
            sheen: Tt.sheen > 0,
            sheenColorMap: !!Tt.sheenColorMap,
            sheenRoughnessMap: !!Tt.sheenRoughnessMap,
            transmission: Tt.transmission > 0,
            transmissionMap: !!Tt.transmissionMap,
            thicknessMap: !!Tt.thicknessMap,
            combine: Tt.combine,
            vertexTangents: !!Tt.normalMap && !!jt.attributes.tangent,
            vertexColors: Tt.vertexColors,
            vertexAlphas: Tt.vertexColors === !0 && !!jt.attributes.color && jt.attributes.color.itemSize === 4,
            vertexUvs: !!Tt.map || !!Tt.bumpMap || !!Tt.normalMap || !!Tt.specularMap || !!Tt.alphaMap || !!Tt.emissiveMap || !!Tt.roughnessMap || !!Tt.metalnessMap || !!Tt.clearcoatMap || !!Tt.clearcoatRoughnessMap || !!Tt.clearcoatNormalMap || !!Tt.displacementMap || !!Tt.transmissionMap || !!Tt.thicknessMap || !!Tt.specularIntensityMap || !!Tt.specularColorMap || !!Tt.sheenColorMap || !!Tt.sheenRoughnessMap,
            uvsVertexOnly: !(!!Tt.map || !!Tt.bumpMap || !!Tt.normalMap || !!Tt.specularMap || !!Tt.alphaMap || !!Tt.emissiveMap || !!Tt.roughnessMap || !!Tt.metalnessMap || !!Tt.clearcoatNormalMap || Tt.transmission > 0 || !!Tt.transmissionMap || !!Tt.thicknessMap || !!Tt.specularIntensityMap || !!Tt.specularColorMap || Tt.sheen > 0 || !!Tt.sheenColorMap || !!Tt.sheenRoughnessMap) && !!Tt.displacementMap,
            fog: !!qt,
            useFog: Tt.fog,
            fogExp2: qt && qt.isFogExp2,
            flatShading: !!Tt.flatShading,
            sizeAttenuation: Tt.sizeAttenuation,
            logarithmicDepthBuffer: ht,
            skinning: Kt.isSkinnedMesh === !0 && Rt > 0,
            maxBones: Rt,
            useVertexTexture: ft,
            morphTargets: jt.morphAttributes.position !== void 0,
            morphNormals: jt.morphAttributes.normal !== void 0,
            morphColors: jt.morphAttributes.color !== void 0,
            morphTargetsCount: Fn,
            morphTextureStride: Vn,
            numDirLights: Ft.directional.length,
            numPointLights: Ft.point.length,
            numSpotLights: Ft.spot.length,
            numRectAreaLights: Ft.rectArea.length,
            numHemiLights: Ft.hemi.length,
            numDirLightShadows: Ft.directionalShadowMap.length,
            numPointLightShadows: Ft.pointShadowMap.length,
            numSpotLightShadows: Ft.spotShadowMap.length,
            numClippingPlanes: ot.numPlanes,
            numClipIntersection: ot.numIntersection,
            dithering: Tt.dithering,
            shadowMapEnabled: et.shadowMap.enabled && $t.length > 0,
            shadowMapType: et.shadowMap.type,
            toneMapping: Tt.toneMapped ? et.toneMapping : NoToneMapping,
            physicallyCorrectLights: et.physicallyCorrectLights,
            premultipliedAlpha: Tt.premultipliedAlpha,
            doubleSided: Tt.side === DoubleSide,
            flipSided: Tt.side === BackSide,
            depthPacking: Tt.depthPacking !== void 0 ? Tt.depthPacking : !1,
            index0AttributeName: Tt.index0AttributeName,
            extensionDerivatives: Tt.extensions && Tt.extensions.derivatives,
            extensionFragDepth: Tt.extensions && Tt.extensions.fragDepth,
            extensionDrawBuffers: Tt.extensions && Tt.extensions.drawBuffers,
            extensionShaderTextureLOD: Tt.extensions && Tt.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: ct || nt.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: ct || nt.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: ct || nt.has("EXT_shader_texture_lod"),
            customProgramCacheKey: Tt.customProgramCacheKey()
        }
    }
    function bt(Tt) {
        const Ft = [];
        if (Tt.shaderID ? Ft.push(Tt.shaderID) : (Ft.push(Tt.customVertexShaderID),
        Ft.push(Tt.customFragmentShaderID)),
        Tt.defines !== void 0)
            for (const $t in Tt.defines)
                Ft.push($t),
                Ft.push(Tt.defines[$t]);
        return Tt.isRawShaderMaterial === !1 && (Mt(Ft, Tt),
        St(Ft, Tt),
        Ft.push(et.outputEncoding)),
        Ft.push(Tt.customProgramCacheKey),
        Ft.join()
    }
    function Mt(Tt, Ft) {
        Tt.push(Ft.precision),
        Tt.push(Ft.outputEncoding),
        Tt.push(Ft.envMapMode),
        Tt.push(Ft.envMapCubeUVHeight),
        Tt.push(Ft.combine),
        Tt.push(Ft.vertexUvs),
        Tt.push(Ft.fogExp2),
        Tt.push(Ft.sizeAttenuation),
        Tt.push(Ft.maxBones),
        Tt.push(Ft.morphTargetsCount),
        Tt.push(Ft.morphAttributeCount),
        Tt.push(Ft.numDirLights),
        Tt.push(Ft.numPointLights),
        Tt.push(Ft.numSpotLights),
        Tt.push(Ft.numHemiLights),
        Tt.push(Ft.numRectAreaLights),
        Tt.push(Ft.numDirLightShadows),
        Tt.push(Ft.numPointLightShadows),
        Tt.push(Ft.numSpotLightShadows),
        Tt.push(Ft.shadowMapType),
        Tt.push(Ft.toneMapping),
        Tt.push(Ft.numClippingPlanes),
        Tt.push(Ft.numClipIntersection)
    }
    function St(Tt, Ft) {
        st.disableAll(),
        Ft.isWebGL2 && st.enable(0),
        Ft.supportsVertexTextures && st.enable(1),
        Ft.instancing && st.enable(2),
        Ft.instancingColor && st.enable(3),
        Ft.map && st.enable(4),
        Ft.matcap && st.enable(5),
        Ft.envMap && st.enable(6),
        Ft.lightMap && st.enable(7),
        Ft.aoMap && st.enable(8),
        Ft.emissiveMap && st.enable(9),
        Ft.bumpMap && st.enable(10),
        Ft.normalMap && st.enable(11),
        Ft.objectSpaceNormalMap && st.enable(12),
        Ft.tangentSpaceNormalMap && st.enable(13),
        Ft.clearcoat && st.enable(14),
        Ft.clearcoatMap && st.enable(15),
        Ft.clearcoatRoughnessMap && st.enable(16),
        Ft.clearcoatNormalMap && st.enable(17),
        Ft.displacementMap && st.enable(18),
        Ft.specularMap && st.enable(19),
        Ft.roughnessMap && st.enable(20),
        Ft.metalnessMap && st.enable(21),
        Ft.gradientMap && st.enable(22),
        Ft.alphaMap && st.enable(23),
        Ft.alphaTest && st.enable(24),
        Ft.vertexColors && st.enable(25),
        Ft.vertexAlphas && st.enable(26),
        Ft.vertexUvs && st.enable(27),
        Ft.vertexTangents && st.enable(28),
        Ft.uvsVertexOnly && st.enable(29),
        Ft.fog && st.enable(30),
        Tt.push(st.mask),
        st.disableAll(),
        Ft.useFog && st.enable(0),
        Ft.flatShading && st.enable(1),
        Ft.logarithmicDepthBuffer && st.enable(2),
        Ft.skinning && st.enable(3),
        Ft.useVertexTexture && st.enable(4),
        Ft.morphTargets && st.enable(5),
        Ft.morphNormals && st.enable(6),
        Ft.morphColors && st.enable(7),
        Ft.premultipliedAlpha && st.enable(8),
        Ft.shadowMapEnabled && st.enable(9),
        Ft.physicallyCorrectLights && st.enable(10),
        Ft.doubleSided && st.enable(11),
        Ft.flipSided && st.enable(12),
        Ft.depthPacking && st.enable(13),
        Ft.dithering && st.enable(14),
        Ft.specularIntensityMap && st.enable(15),
        Ft.specularColorMap && st.enable(16),
        Ft.transmission && st.enable(17),
        Ft.transmissionMap && st.enable(18),
        Ft.thicknessMap && st.enable(19),
        Ft.sheen && st.enable(20),
        Ft.sheenColorMap && st.enable(21),
        Ft.sheenRoughnessMap && st.enable(22),
        Ft.decodeVideoTexture && st.enable(23),
        Ft.opaque && st.enable(24),
        Tt.push(st.mask)
    }
    function At(Tt) {
        const Ft = wt[Tt.type];
        let $t;
        if (Ft) {
            const Wt = ShaderLib[Ft];
            $t = UniformsUtils.clone(Wt.uniforms)
        } else
            $t = Tt.uniforms;
        return $t
    }
    function Pt(Tt, Ft) {
        let $t;
        for (let Wt = 0, Kt = ut.length; Wt < Kt; Wt++) {
            const qt = ut[Wt];
            if (qt.cacheKey === Ft) {
                $t = qt,
                ++$t.usedTimes;
                break
            }
        }
        return $t === void 0 && ($t = new WebGLProgram(et,Ft,Tt,it),
        ut.push($t)),
        $t
    }
    function Ot(Tt) {
        if (--Tt.usedTimes === 0) {
            const Ft = ut.indexOf(Tt);
            ut[Ft] = ut[ut.length - 1],
            ut.pop(),
            Tt.destroy()
        }
    }
    function Zt(Tt) {
        lt.remove(Tt)
    }
    function Nt() {
        lt.dispose()
    }
    return {
        getParameters: _t,
        getProgramCacheKey: bt,
        getUniforms: At,
        acquireProgram: Pt,
        releaseProgram: Ot,
        releaseShaderCache: Zt,
        programs: ut,
        dispose: Nt
    }
}
function WebGLProperties() {
    let et = new WeakMap;
    function $(it) {
        let ot = et.get(it);
        return ot === void 0 && (ot = {},
        et.set(it, ot)),
        ot
    }
    function tt(it) {
        et.delete(it)
    }
    function nt(it, ot, st) {
        et.get(it)[ot] = st
    }
    function rt() {
        et = new WeakMap
    }
    return {
        get: $,
        remove: tt,
        update: nt,
        dispose: rt
    }
}
function painterSortStable(et, $) {
    return et.groupOrder !== $.groupOrder ? et.groupOrder - $.groupOrder : et.renderOrder !== $.renderOrder ? et.renderOrder - $.renderOrder : et.material.id !== $.material.id ? et.material.id - $.material.id : et.z !== $.z ? et.z - $.z : et.id - $.id
}
function reversePainterSortStable(et, $) {
    return et.groupOrder !== $.groupOrder ? et.groupOrder - $.groupOrder : et.renderOrder !== $.renderOrder ? et.renderOrder - $.renderOrder : et.z !== $.z ? $.z - et.z : et.id - $.id
}
function WebGLRenderList() {
    const et = [];
    let $ = 0;
    const tt = []
      , nt = []
      , rt = [];
    function it() {
        $ = 0,
        tt.length = 0,
        nt.length = 0,
        rt.length = 0
    }
    function ot(ht, ft, gt, vt, yt, wt) {
        let mt = et[$];
        return mt === void 0 ? (mt = {
            id: ht.id,
            object: ht,
            geometry: ft,
            material: gt,
            groupOrder: vt,
            renderOrder: ht.renderOrder,
            z: yt,
            group: wt
        },
        et[$] = mt) : (mt.id = ht.id,
        mt.object = ht,
        mt.geometry = ft,
        mt.material = gt,
        mt.groupOrder = vt,
        mt.renderOrder = ht.renderOrder,
        mt.z = yt,
        mt.group = wt),
        $++,
        mt
    }
    function st(ht, ft, gt, vt, yt, wt) {
        const mt = ot(ht, ft, gt, vt, yt, wt);
        gt.transmission > 0 ? nt.push(mt) : gt.transparent === !0 ? rt.push(mt) : tt.push(mt)
    }
    function lt(ht, ft, gt, vt, yt, wt) {
        const mt = ot(ht, ft, gt, vt, yt, wt);
        gt.transmission > 0 ? nt.unshift(mt) : gt.transparent === !0 ? rt.unshift(mt) : tt.unshift(mt)
    }
    function ut(ht, ft) {
        tt.length > 1 && tt.sort(ht || painterSortStable),
        nt.length > 1 && nt.sort(ft || reversePainterSortStable),
        rt.length > 1 && rt.sort(ft || reversePainterSortStable)
    }
    function ct() {
        for (let ht = $, ft = et.length; ht < ft; ht++) {
            const gt = et[ht];
            if (gt.id === null)
                break;
            gt.id = null,
            gt.object = null,
            gt.geometry = null,
            gt.material = null,
            gt.group = null
        }
    }
    return {
        opaque: tt,
        transmissive: nt,
        transparent: rt,
        init: it,
        push: st,
        unshift: lt,
        finish: ct,
        sort: ut
    }
}
function WebGLRenderLists() {
    let et = new WeakMap;
    function $(nt, rt) {
        let it;
        return et.has(nt) === !1 ? (it = new WebGLRenderList,
        et.set(nt, [it])) : rt >= et.get(nt).length ? (it = new WebGLRenderList,
        et.get(nt).push(it)) : it = et.get(nt)[rt],
        it
    }
    function tt() {
        et = new WeakMap
    }
    return {
        get: $,
        dispose: tt
    }
}
function UniformsCache() {
    const et = {};
    return {
        get: function($) {
            if (et[$.id] !== void 0)
                return et[$.id];
            let tt;
            switch ($.type) {
            case "DirectionalLight":
                tt = {
                    direction: new Vector3,
                    color: new Color
                };
                break;
            case "SpotLight":
                tt = {
                    position: new Vector3,
                    direction: new Vector3,
                    color: new Color,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                tt = {
                    position: new Vector3,
                    color: new Color,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                tt = {
                    direction: new Vector3,
                    skyColor: new Color,
                    groundColor: new Color
                };
                break;
            case "RectAreaLight":
                tt = {
                    color: new Color,
                    position: new Vector3,
                    halfWidth: new Vector3,
                    halfHeight: new Vector3
                };
                break
            }
            return et[$.id] = tt,
            tt
        }
    }
}
function ShadowUniformsCache() {
    const et = {};
    return {
        get: function($) {
            if (et[$.id] !== void 0)
                return et[$.id];
            let tt;
            switch ($.type) {
            case "DirectionalLight":
                tt = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2
                };
                break;
            case "SpotLight":
                tt = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2
                };
                break;
            case "PointLight":
                tt = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return et[$.id] = tt,
            tt
        }
    }
}
let nextVersion = 0;
function shadowCastingLightsFirst(et, $) {
    return ($.castShadow ? 1 : 0) - (et.castShadow ? 1 : 0)
}
function WebGLLights(et, $) {
    const tt = new UniformsCache
      , nt = ShadowUniformsCache()
      , rt = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for (let ct = 0; ct < 9; ct++)
        rt.probe.push(new Vector3);
    const it = new Vector3
      , ot = new Matrix4
      , st = new Matrix4;
    function lt(ct, ht) {
        let ft = 0
          , gt = 0
          , vt = 0;
        for (let Zt = 0; Zt < 9; Zt++)
            rt.probe[Zt].set(0, 0, 0);
        let yt = 0
          , wt = 0
          , mt = 0
          , _t = 0
          , bt = 0
          , Mt = 0
          , St = 0
          , At = 0;
        ct.sort(shadowCastingLightsFirst);
        const Pt = ht !== !0 ? Math.PI : 1;
        for (let Zt = 0, Nt = ct.length; Zt < Nt; Zt++) {
            const Tt = ct[Zt]
              , Ft = Tt.color
              , $t = Tt.intensity
              , Wt = Tt.distance
              , Kt = Tt.shadow && Tt.shadow.map ? Tt.shadow.map.texture : null;
            if (Tt.isAmbientLight)
                ft += Ft.r * $t * Pt,
                gt += Ft.g * $t * Pt,
                vt += Ft.b * $t * Pt;
            else if (Tt.isLightProbe)
                for (let qt = 0; qt < 9; qt++)
                    rt.probe[qt].addScaledVector(Tt.sh.coefficients[qt], $t);
            else if (Tt.isDirectionalLight) {
                const qt = tt.get(Tt);
                if (qt.color.copy(Tt.color).multiplyScalar(Tt.intensity * Pt),
                Tt.castShadow) {
                    const jt = Tt.shadow
                      , Bt = nt.get(Tt);
                    Bt.shadowBias = jt.bias,
                    Bt.shadowNormalBias = jt.normalBias,
                    Bt.shadowRadius = jt.radius,
                    Bt.shadowMapSize = jt.mapSize,
                    rt.directionalShadow[yt] = Bt,
                    rt.directionalShadowMap[yt] = Kt,
                    rt.directionalShadowMatrix[yt] = Tt.shadow.matrix,
                    Mt++
                }
                rt.directional[yt] = qt,
                yt++
            } else if (Tt.isSpotLight) {
                const qt = tt.get(Tt);
                if (qt.position.setFromMatrixPosition(Tt.matrixWorld),
                qt.color.copy(Ft).multiplyScalar($t * Pt),
                qt.distance = Wt,
                qt.coneCos = Math.cos(Tt.angle),
                qt.penumbraCos = Math.cos(Tt.angle * (1 - Tt.penumbra)),
                qt.decay = Tt.decay,
                Tt.castShadow) {
                    const jt = Tt.shadow
                      , Bt = nt.get(Tt);
                    Bt.shadowBias = jt.bias,
                    Bt.shadowNormalBias = jt.normalBias,
                    Bt.shadowRadius = jt.radius,
                    Bt.shadowMapSize = jt.mapSize,
                    rt.spotShadow[mt] = Bt,
                    rt.spotShadowMap[mt] = Kt,
                    rt.spotShadowMatrix[mt] = Tt.shadow.matrix,
                    At++
                }
                rt.spot[mt] = qt,
                mt++
            } else if (Tt.isRectAreaLight) {
                const qt = tt.get(Tt);
                qt.color.copy(Ft).multiplyScalar($t),
                qt.halfWidth.set(Tt.width * .5, 0, 0),
                qt.halfHeight.set(0, Tt.height * .5, 0),
                rt.rectArea[_t] = qt,
                _t++
            } else if (Tt.isPointLight) {
                const qt = tt.get(Tt);
                if (qt.color.copy(Tt.color).multiplyScalar(Tt.intensity * Pt),
                qt.distance = Tt.distance,
                qt.decay = Tt.decay,
                Tt.castShadow) {
                    const jt = Tt.shadow
                      , Bt = nt.get(Tt);
                    Bt.shadowBias = jt.bias,
                    Bt.shadowNormalBias = jt.normalBias,
                    Bt.shadowRadius = jt.radius,
                    Bt.shadowMapSize = jt.mapSize,
                    Bt.shadowCameraNear = jt.camera.near,
                    Bt.shadowCameraFar = jt.camera.far,
                    rt.pointShadow[wt] = Bt,
                    rt.pointShadowMap[wt] = Kt,
                    rt.pointShadowMatrix[wt] = Tt.shadow.matrix,
                    St++
                }
                rt.point[wt] = qt,
                wt++
            } else if (Tt.isHemisphereLight) {
                const qt = tt.get(Tt);
                qt.skyColor.copy(Tt.color).multiplyScalar($t * Pt),
                qt.groundColor.copy(Tt.groundColor).multiplyScalar($t * Pt),
                rt.hemi[bt] = qt,
                bt++
            }
        }
        _t > 0 && ($.isWebGL2 || et.has("OES_texture_float_linear") === !0 ? (rt.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1,
        rt.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : et.has("OES_texture_half_float_linear") === !0 ? (rt.rectAreaLTC1 = UniformsLib.LTC_HALF_1,
        rt.rectAreaLTC2 = UniformsLib.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        rt.ambient[0] = ft,
        rt.ambient[1] = gt,
        rt.ambient[2] = vt;
        const Ot = rt.hash;
        (Ot.directionalLength !== yt || Ot.pointLength !== wt || Ot.spotLength !== mt || Ot.rectAreaLength !== _t || Ot.hemiLength !== bt || Ot.numDirectionalShadows !== Mt || Ot.numPointShadows !== St || Ot.numSpotShadows !== At) && (rt.directional.length = yt,
        rt.spot.length = mt,
        rt.rectArea.length = _t,
        rt.point.length = wt,
        rt.hemi.length = bt,
        rt.directionalShadow.length = Mt,
        rt.directionalShadowMap.length = Mt,
        rt.pointShadow.length = St,
        rt.pointShadowMap.length = St,
        rt.spotShadow.length = At,
        rt.spotShadowMap.length = At,
        rt.directionalShadowMatrix.length = Mt,
        rt.pointShadowMatrix.length = St,
        rt.spotShadowMatrix.length = At,
        Ot.directionalLength = yt,
        Ot.pointLength = wt,
        Ot.spotLength = mt,
        Ot.rectAreaLength = _t,
        Ot.hemiLength = bt,
        Ot.numDirectionalShadows = Mt,
        Ot.numPointShadows = St,
        Ot.numSpotShadows = At,
        rt.version = nextVersion++)
    }
    function ut(ct, ht) {
        let ft = 0
          , gt = 0
          , vt = 0
          , yt = 0
          , wt = 0;
        const mt = ht.matrixWorldInverse;
        for (let _t = 0, bt = ct.length; _t < bt; _t++) {
            const Mt = ct[_t];
            if (Mt.isDirectionalLight) {
                const St = rt.directional[ft];
                St.direction.setFromMatrixPosition(Mt.matrixWorld),
                it.setFromMatrixPosition(Mt.target.matrixWorld),
                St.direction.sub(it),
                St.direction.transformDirection(mt),
                ft++
            } else if (Mt.isSpotLight) {
                const St = rt.spot[vt];
                St.position.setFromMatrixPosition(Mt.matrixWorld),
                St.position.applyMatrix4(mt),
                St.direction.setFromMatrixPosition(Mt.matrixWorld),
                it.setFromMatrixPosition(Mt.target.matrixWorld),
                St.direction.sub(it),
                St.direction.transformDirection(mt),
                vt++
            } else if (Mt.isRectAreaLight) {
                const St = rt.rectArea[yt];
                St.position.setFromMatrixPosition(Mt.matrixWorld),
                St.position.applyMatrix4(mt),
                st.identity(),
                ot.copy(Mt.matrixWorld),
                ot.premultiply(mt),
                st.extractRotation(ot),
                St.halfWidth.set(Mt.width * .5, 0, 0),
                St.halfHeight.set(0, Mt.height * .5, 0),
                St.halfWidth.applyMatrix4(st),
                St.halfHeight.applyMatrix4(st),
                yt++
            } else if (Mt.isPointLight) {
                const St = rt.point[gt];
                St.position.setFromMatrixPosition(Mt.matrixWorld),
                St.position.applyMatrix4(mt),
                gt++
            } else if (Mt.isHemisphereLight) {
                const St = rt.hemi[wt];
                St.direction.setFromMatrixPosition(Mt.matrixWorld),
                St.direction.transformDirection(mt),
                St.direction.normalize(),
                wt++
            }
        }
    }
    return {
        setup: lt,
        setupView: ut,
        state: rt
    }
}
function WebGLRenderState(et, $) {
    const tt = new WebGLLights(et,$)
      , nt = []
      , rt = [];
    function it() {
        nt.length = 0,
        rt.length = 0
    }
    function ot(ht) {
        nt.push(ht)
    }
    function st(ht) {
        rt.push(ht)
    }
    function lt(ht) {
        tt.setup(nt, ht)
    }
    function ut(ht) {
        tt.setupView(nt, ht)
    }
    return {
        init: it,
        state: {
            lightsArray: nt,
            shadowsArray: rt,
            lights: tt
        },
        setupLights: lt,
        setupLightsView: ut,
        pushLight: ot,
        pushShadow: st
    }
}
function WebGLRenderStates(et, $) {
    let tt = new WeakMap;
    function nt(it, ot=0) {
        let st;
        return tt.has(it) === !1 ? (st = new WebGLRenderState(et,$),
        tt.set(it, [st])) : ot >= tt.get(it).length ? (st = new WebGLRenderState(et,$),
        tt.get(it).push(st)) : st = tt.get(it)[ot],
        st
    }
    function rt() {
        tt = new WeakMap
    }
    return {
        get: nt,
        dispose: rt
    }
}
class MeshDepthMaterial extends Material {
    constructor($) {
        super(),
        this.type = "MeshDepthMaterial",
        this.depthPacking = BasicDepthPacking,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.depthPacking = $.depthPacking,
        this.map = $.map,
        this.alphaMap = $.alphaMap,
        this.displacementMap = $.displacementMap,
        this.displacementScale = $.displacementScale,
        this.displacementBias = $.displacementBias,
        this.wireframe = $.wireframe,
        this.wireframeLinewidth = $.wireframeLinewidth,
        this
    }
}
MeshDepthMaterial.prototype.isMeshDepthMaterial = !0;
class MeshDistanceMaterial extends Material {
    constructor($) {
        super(),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new Vector3,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.fog = !1,
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.referencePosition.copy($.referencePosition),
        this.nearDistance = $.nearDistance,
        this.farDistance = $.farDistance,
        this.map = $.map,
        this.alphaMap = $.alphaMap,
        this.displacementMap = $.displacementMap,
        this.displacementScale = $.displacementScale,
        this.displacementBias = $.displacementBias,
        this
    }
}
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = !0;
const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function WebGLShadowMap(et, $, tt) {
    let nt = new Frustum;
    const rt = new Vector2
      , it = new Vector2
      , ot = new Vector4
      , st = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking
    })
      , lt = new MeshDistanceMaterial
      , ut = {}
      , ct = tt.maxTextureSize
      , ht = {
        0: BackSide,
        1: FrontSide,
        2: DoubleSide
    }
      , ft = new ShaderMaterial({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Vector2
            },
            radius: {
                value: 4
            }
        },
        vertexShader: vertex,
        fragmentShader: fragment
    })
      , gt = ft.clone();
    gt.defines.HORIZONTAL_PASS = 1;
    const vt = new BufferGeometry;
    vt.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const yt = new Mesh(vt,ft)
      , wt = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = PCFShadowMap,
    this.render = function(Mt, St, At) {
        if (wt.enabled === !1 || wt.autoUpdate === !1 && wt.needsUpdate === !1 || Mt.length === 0)
            return;
        const Pt = et.getRenderTarget()
          , Ot = et.getActiveCubeFace()
          , Zt = et.getActiveMipmapLevel()
          , Nt = et.state;
        Nt.setBlending(NoBlending),
        Nt.buffers.color.setClear(1, 1, 1, 1),
        Nt.buffers.depth.setTest(!0),
        Nt.setScissorTest(!1);
        for (let Tt = 0, Ft = Mt.length; Tt < Ft; Tt++) {
            const $t = Mt[Tt]
              , Wt = $t.shadow;
            if (Wt === void 0) {
                console.warn("THREE.WebGLShadowMap:", $t, "has no shadow.");
                continue
            }
            if (Wt.autoUpdate === !1 && Wt.needsUpdate === !1)
                continue;
            rt.copy(Wt.mapSize);
            const Kt = Wt.getFrameExtents();
            if (rt.multiply(Kt),
            it.copy(Wt.mapSize),
            (rt.x > ct || rt.y > ct) && (rt.x > ct && (it.x = Math.floor(ct / Kt.x),
            rt.x = it.x * Kt.x,
            Wt.mapSize.x = it.x),
            rt.y > ct && (it.y = Math.floor(ct / Kt.y),
            rt.y = it.y * Kt.y,
            Wt.mapSize.y = it.y)),
            Wt.map === null && !Wt.isPointLightShadow && this.type === VSMShadowMap) {
                const jt = {
                    minFilter: LinearFilter,
                    magFilter: LinearFilter,
                    format: RGBAFormat
                };
                Wt.map = new WebGLRenderTarget(rt.x,rt.y,jt),
                Wt.map.texture.name = $t.name + ".shadowMap",
                Wt.mapPass = new WebGLRenderTarget(rt.x,rt.y,jt),
                Wt.camera.updateProjectionMatrix()
            }
            if (Wt.map === null) {
                const jt = {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter,
                    format: RGBAFormat
                };
                Wt.map = new WebGLRenderTarget(rt.x,rt.y,jt),
                Wt.map.texture.name = $t.name + ".shadowMap",
                Wt.camera.updateProjectionMatrix()
            }
            et.setRenderTarget(Wt.map),
            et.clear();
            const qt = Wt.getViewportCount();
            for (let jt = 0; jt < qt; jt++) {
                const Bt = Wt.getViewport(jt);
                ot.set(it.x * Bt.x, it.y * Bt.y, it.x * Bt.z, it.y * Bt.w),
                Nt.viewport(ot),
                Wt.updateMatrices($t, jt),
                nt = Wt.getFrustum(),
                bt(St, At, Wt.camera, $t, this.type)
            }
            !Wt.isPointLightShadow && this.type === VSMShadowMap && mt(Wt, At),
            Wt.needsUpdate = !1
        }
        wt.needsUpdate = !1,
        et.setRenderTarget(Pt, Ot, Zt)
    }
    ;
    function mt(Mt, St) {
        const At = $.update(yt);
        ft.defines.VSM_SAMPLES !== Mt.blurSamples && (ft.defines.VSM_SAMPLES = Mt.blurSamples,
        gt.defines.VSM_SAMPLES = Mt.blurSamples,
        ft.needsUpdate = !0,
        gt.needsUpdate = !0),
        ft.uniforms.shadow_pass.value = Mt.map.texture,
        ft.uniforms.resolution.value = Mt.mapSize,
        ft.uniforms.radius.value = Mt.radius,
        et.setRenderTarget(Mt.mapPass),
        et.clear(),
        et.renderBufferDirect(St, null, At, ft, yt, null),
        gt.uniforms.shadow_pass.value = Mt.mapPass.texture,
        gt.uniforms.resolution.value = Mt.mapSize,
        gt.uniforms.radius.value = Mt.radius,
        et.setRenderTarget(Mt.map),
        et.clear(),
        et.renderBufferDirect(St, null, At, gt, yt, null)
    }
    function _t(Mt, St, At, Pt, Ot, Zt) {
        let Nt = null;
        const Tt = At.isPointLight === !0 ? Mt.customDistanceMaterial : Mt.customDepthMaterial;
        if (Tt !== void 0 ? Nt = Tt : Nt = At.isPointLight === !0 ? lt : st,
        et.localClippingEnabled && St.clipShadows === !0 && St.clippingPlanes.length !== 0 || St.displacementMap && St.displacementScale !== 0 || St.alphaMap && St.alphaTest > 0) {
            const Ft = Nt.uuid
              , $t = St.uuid;
            let Wt = ut[Ft];
            Wt === void 0 && (Wt = {},
            ut[Ft] = Wt);
            let Kt = Wt[$t];
            Kt === void 0 && (Kt = Nt.clone(),
            Wt[$t] = Kt),
            Nt = Kt
        }
        return Nt.visible = St.visible,
        Nt.wireframe = St.wireframe,
        Zt === VSMShadowMap ? Nt.side = St.shadowSide !== null ? St.shadowSide : St.side : Nt.side = St.shadowSide !== null ? St.shadowSide : ht[St.side],
        Nt.alphaMap = St.alphaMap,
        Nt.alphaTest = St.alphaTest,
        Nt.clipShadows = St.clipShadows,
        Nt.clippingPlanes = St.clippingPlanes,
        Nt.clipIntersection = St.clipIntersection,
        Nt.displacementMap = St.displacementMap,
        Nt.displacementScale = St.displacementScale,
        Nt.displacementBias = St.displacementBias,
        Nt.wireframeLinewidth = St.wireframeLinewidth,
        Nt.linewidth = St.linewidth,
        At.isPointLight === !0 && Nt.isMeshDistanceMaterial === !0 && (Nt.referencePosition.setFromMatrixPosition(At.matrixWorld),
        Nt.nearDistance = Pt,
        Nt.farDistance = Ot),
        Nt
    }
    function bt(Mt, St, At, Pt, Ot) {
        if (Mt.visible === !1)
            return;
        if (Mt.layers.test(St.layers) && (Mt.isMesh || Mt.isLine || Mt.isPoints) && (Mt.castShadow || Mt.receiveShadow && Ot === VSMShadowMap) && (!Mt.frustumCulled || nt.intersectsObject(Mt))) {
            Mt.modelViewMatrix.multiplyMatrices(At.matrixWorldInverse, Mt.matrixWorld);
            const Tt = $.update(Mt)
              , Ft = Mt.material;
            if (Array.isArray(Ft)) {
                const $t = Tt.groups;
                for (let Wt = 0, Kt = $t.length; Wt < Kt; Wt++) {
                    const qt = $t[Wt]
                      , jt = Ft[qt.materialIndex];
                    if (jt && jt.visible) {
                        const Bt = _t(Mt, jt, Pt, At.near, At.far, Ot);
                        et.renderBufferDirect(At, null, Tt, Bt, Mt, qt)
                    }
                }
            } else if (Ft.visible) {
                const $t = _t(Mt, Ft, Pt, At.near, At.far, Ot);
                et.renderBufferDirect(At, null, Tt, $t, Mt, null)
            }
        }
        const Nt = Mt.children;
        for (let Tt = 0, Ft = Nt.length; Tt < Ft; Tt++)
            bt(Nt[Tt], St, At, Pt, Ot)
    }
}
function WebGLState(et, $, tt) {
    const nt = tt.isWebGL2;
    function rt() {
        let Ut = !1;
        const Cn = new Vector4;
        let Tn = null;
        const Hn = new Vector4(0,0,0,0);
        return {
            setMask: function(yn) {
                Tn !== yn && !Ut && (et.colorMask(yn, yn, yn, yn),
                Tn = yn)
            },
            setLocked: function(yn) {
                Ut = yn
            },
            setClear: function(yn, xn, Nn, Jn, dr) {
                dr === !0 && (yn *= Jn,
                xn *= Jn,
                Nn *= Jn),
                Cn.set(yn, xn, Nn, Jn),
                Hn.equals(Cn) === !1 && (et.clearColor(yn, xn, Nn, Jn),
                Hn.copy(Cn))
            },
            reset: function() {
                Ut = !1,
                Tn = null,
                Hn.set(-1, 0, 0, 0)
            }
        }
    }
    function it() {
        let Ut = !1
          , Cn = null
          , Tn = null
          , Hn = null;
        return {
            setTest: function(yn) {
                yn ? Vn(2929) : sn(2929)
            },
            setMask: function(yn) {
                Cn !== yn && !Ut && (et.depthMask(yn),
                Cn = yn)
            },
            setFunc: function(yn) {
                if (Tn !== yn) {
                    if (yn)
                        switch (yn) {
                        case NeverDepth:
                            et.depthFunc(512);
                            break;
                        case AlwaysDepth:
                            et.depthFunc(519);
                            break;
                        case LessDepth:
                            et.depthFunc(513);
                            break;
                        case LessEqualDepth:
                            et.depthFunc(515);
                            break;
                        case EqualDepth:
                            et.depthFunc(514);
                            break;
                        case GreaterEqualDepth:
                            et.depthFunc(518);
                            break;
                        case GreaterDepth:
                            et.depthFunc(516);
                            break;
                        case NotEqualDepth:
                            et.depthFunc(517);
                            break;
                        default:
                            et.depthFunc(515)
                        }
                    else
                        et.depthFunc(515);
                    Tn = yn
                }
            },
            setLocked: function(yn) {
                Ut = yn
            },
            setClear: function(yn) {
                Hn !== yn && (et.clearDepth(yn),
                Hn = yn)
            },
            reset: function() {
                Ut = !1,
                Cn = null,
                Tn = null,
                Hn = null
            }
        }
    }
    function ot() {
        let Ut = !1
          , Cn = null
          , Tn = null
          , Hn = null
          , yn = null
          , xn = null
          , Nn = null
          , Jn = null
          , dr = null;
        return {
            setTest: function(Qn) {
                Ut || (Qn ? Vn(2960) : sn(2960))
            },
            setMask: function(Qn) {
                Cn !== Qn && !Ut && (et.stencilMask(Qn),
                Cn = Qn)
            },
            setFunc: function(Qn, _r, hr) {
                (Tn !== Qn || Hn !== _r || yn !== hr) && (et.stencilFunc(Qn, _r, hr),
                Tn = Qn,
                Hn = _r,
                yn = hr)
            },
            setOp: function(Qn, _r, hr) {
                (xn !== Qn || Nn !== _r || Jn !== hr) && (et.stencilOp(Qn, _r, hr),
                xn = Qn,
                Nn = _r,
                Jn = hr)
            },
            setLocked: function(Qn) {
                Ut = Qn
            },
            setClear: function(Qn) {
                dr !== Qn && (et.clearStencil(Qn),
                dr = Qn)
            },
            reset: function() {
                Ut = !1,
                Cn = null,
                Tn = null,
                Hn = null,
                yn = null,
                xn = null,
                Nn = null,
                Jn = null,
                dr = null
            }
        }
    }
    const st = new rt
      , lt = new it
      , ut = new ot;
    let ct = {}
      , ht = {}
      , ft = new WeakMap
      , gt = []
      , vt = null
      , yt = !1
      , wt = null
      , mt = null
      , _t = null
      , bt = null
      , Mt = null
      , St = null
      , At = null
      , Pt = !1
      , Ot = null
      , Zt = null
      , Nt = null
      , Tt = null
      , Ft = null;
    const $t = et.getParameter(35661);
    let Wt = !1
      , Kt = 0;
    const qt = et.getParameter(7938);
    qt.indexOf("WebGL") !== -1 ? (Kt = parseFloat(/^WebGL (\d)/.exec(qt)[1]),
    Wt = Kt >= 1) : qt.indexOf("OpenGL ES") !== -1 && (Kt = parseFloat(/^OpenGL ES (\d)/.exec(qt)[1]),
    Wt = Kt >= 2);
    let jt = null
      , Bt = {};
    const Xt = et.getParameter(3088)
      , Jt = et.getParameter(2978)
      , Lt = new Vector4().fromArray(Xt)
      , Rt = new Vector4().fromArray(Jt);
    function _n(Ut, Cn, Tn) {
        const Hn = new Uint8Array(4)
          , yn = et.createTexture();
        et.bindTexture(Ut, yn),
        et.texParameteri(Ut, 10241, 9728),
        et.texParameteri(Ut, 10240, 9728);
        for (let xn = 0; xn < Tn; xn++)
            et.texImage2D(Cn + xn, 0, 6408, 1, 1, 0, 6408, 5121, Hn);
        return yn
    }
    const Fn = {};
    Fn[3553] = _n(3553, 3553, 1),
    Fn[34067] = _n(34067, 34069, 6),
    st.setClear(0, 0, 0, 1),
    lt.setClear(1),
    ut.setClear(0),
    Vn(2929),
    lt.setFunc(LessEqualDepth),
    Mn(!1),
    Dn(CullFaceBack),
    Vn(2884),
    cn(NoBlending);
    function Vn(Ut) {
        ct[Ut] !== !0 && (et.enable(Ut),
        ct[Ut] = !0)
    }
    function sn(Ut) {
        ct[Ut] !== !1 && (et.disable(Ut),
        ct[Ut] = !1)
    }
    function Un(Ut, Cn) {
        return ht[Ut] !== Cn ? (et.bindFramebuffer(Ut, Cn),
        ht[Ut] = Cn,
        nt && (Ut === 36009 && (ht[36160] = Cn),
        Ut === 36160 && (ht[36009] = Cn)),
        !0) : !1
    }
    function zn(Ut, Cn) {
        let Tn = gt
          , Hn = !1;
        if (Ut)
            if (Tn = ft.get(Cn),
            Tn === void 0 && (Tn = [],
            ft.set(Cn, Tn)),
            Ut.isWebGLMultipleRenderTargets) {
                const yn = Ut.texture;
                if (Tn.length !== yn.length || Tn[0] !== 36064) {
                    for (let xn = 0, Nn = yn.length; xn < Nn; xn++)
                        Tn[xn] = 36064 + xn;
                    Tn.length = yn.length,
                    Hn = !0
                }
            } else
                Tn[0] !== 36064 && (Tn[0] = 36064,
                Hn = !0);
        else
            Tn[0] !== 1029 && (Tn[0] = 1029,
            Hn = !0);
        Hn && (tt.isWebGL2 ? et.drawBuffers(Tn) : $.get("WEBGL_draw_buffers").drawBuffersWEBGL(Tn))
    }
    function Rn(Ut) {
        return vt !== Ut ? (et.useProgram(Ut),
        vt = Ut,
        !0) : !1
    }
    const Ln = {
        [AddEquation]: 32774,
        [SubtractEquation]: 32778,
        [ReverseSubtractEquation]: 32779
    };
    if (nt)
        Ln[MinEquation] = 32775,
        Ln[MaxEquation] = 32776;
    else {
        const Ut = $.get("EXT_blend_minmax");
        Ut !== null && (Ln[MinEquation] = Ut.MIN_EXT,
        Ln[MaxEquation] = Ut.MAX_EXT)
    }
    const Gn = {
        [ZeroFactor]: 0,
        [OneFactor]: 1,
        [SrcColorFactor]: 768,
        [SrcAlphaFactor]: 770,
        [SrcAlphaSaturateFactor]: 776,
        [DstColorFactor]: 774,
        [DstAlphaFactor]: 772,
        [OneMinusSrcColorFactor]: 769,
        [OneMinusSrcAlphaFactor]: 771,
        [OneMinusDstColorFactor]: 775,
        [OneMinusDstAlphaFactor]: 773
    };
    function cn(Ut, Cn, Tn, Hn, yn, xn, Nn, Jn) {
        if (Ut === NoBlending) {
            yt === !0 && (sn(3042),
            yt = !1);
            return
        }
        if (yt === !1 && (Vn(3042),
        yt = !0),
        Ut !== CustomBlending) {
            if (Ut !== wt || Jn !== Pt) {
                if ((mt !== AddEquation || Mt !== AddEquation) && (et.blendEquation(32774),
                mt = AddEquation,
                Mt = AddEquation),
                Jn)
                    switch (Ut) {
                    case NormalBlending:
                        et.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        et.blendFunc(1, 1);
                        break;
                    case SubtractiveBlending:
                        et.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case MultiplyBlending:
                        et.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Ut);
                        break
                    }
                else
                    switch (Ut) {
                    case NormalBlending:
                        et.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        et.blendFunc(770, 1);
                        break;
                    case SubtractiveBlending:
                        et.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case MultiplyBlending:
                        et.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Ut);
                        break
                    }
                _t = null,
                bt = null,
                St = null,
                At = null,
                wt = Ut,
                Pt = Jn
            }
            return
        }
        yn = yn || Cn,
        xn = xn || Tn,
        Nn = Nn || Hn,
        (Cn !== mt || yn !== Mt) && (et.blendEquationSeparate(Ln[Cn], Ln[yn]),
        mt = Cn,
        Mt = yn),
        (Tn !== _t || Hn !== bt || xn !== St || Nn !== At) && (et.blendFuncSeparate(Gn[Tn], Gn[Hn], Gn[xn], Gn[Nn]),
        _t = Tn,
        bt = Hn,
        St = xn,
        At = Nn),
        wt = Ut,
        Pt = null
    }
    function bn(Ut, Cn) {
        Ut.side === DoubleSide ? sn(2884) : Vn(2884);
        let Tn = Ut.side === BackSide;
        Cn && (Tn = !Tn),
        Mn(Tn),
        Ut.blending === NormalBlending && Ut.transparent === !1 ? cn(NoBlending) : cn(Ut.blending, Ut.blendEquation, Ut.blendSrc, Ut.blendDst, Ut.blendEquationAlpha, Ut.blendSrcAlpha, Ut.blendDstAlpha, Ut.premultipliedAlpha),
        lt.setFunc(Ut.depthFunc),
        lt.setTest(Ut.depthTest),
        lt.setMask(Ut.depthWrite),
        st.setMask(Ut.colorWrite);
        const Hn = Ut.stencilWrite;
        ut.setTest(Hn),
        Hn && (ut.setMask(Ut.stencilWriteMask),
        ut.setFunc(Ut.stencilFunc, Ut.stencilRef, Ut.stencilFuncMask),
        ut.setOp(Ut.stencilFail, Ut.stencilZFail, Ut.stencilZPass)),
        $n(Ut.polygonOffset, Ut.polygonOffsetFactor, Ut.polygonOffsetUnits),
        Ut.alphaToCoverage === !0 ? Vn(32926) : sn(32926)
    }
    function Mn(Ut) {
        Ot !== Ut && (Ut ? et.frontFace(2304) : et.frontFace(2305),
        Ot = Ut)
    }
    function Dn(Ut) {
        Ut !== CullFaceNone ? (Vn(2884),
        Ut !== Zt && (Ut === CullFaceBack ? et.cullFace(1029) : Ut === CullFaceFront ? et.cullFace(1028) : et.cullFace(1032))) : sn(2884),
        Zt = Ut
    }
    function Pn(Ut) {
        Ut !== Nt && (Wt && et.lineWidth(Ut),
        Nt = Ut)
    }
    function $n(Ut, Cn, Tn) {
        Ut ? (Vn(32823),
        (Tt !== Cn || Ft !== Tn) && (et.polygonOffset(Cn, Tn),
        Tt = Cn,
        Ft = Tn)) : sn(32823)
    }
    function On(Ut) {
        Ut ? Vn(3089) : sn(3089)
    }
    function Wn(Ut) {
        Ut === void 0 && (Ut = 33984 + $t - 1),
        jt !== Ut && (et.activeTexture(Ut),
        jt = Ut)
    }
    function rr(Ut, Cn) {
        jt === null && Wn();
        let Tn = Bt[jt];
        Tn === void 0 && (Tn = {
            type: void 0,
            texture: void 0
        },
        Bt[jt] = Tn),
        (Tn.type !== Ut || Tn.texture !== Cn) && (et.bindTexture(Ut, Cn || Fn[Ut]),
        Tn.type = Ut,
        Tn.texture = Cn)
    }
    function Dt() {
        const Ut = Bt[jt];
        Ut !== void 0 && Ut.type !== void 0 && (et.bindTexture(Ut.type, null),
        Ut.type = void 0,
        Ut.texture = void 0)
    }
    function kt() {
        try {
            et.compressedTexImage2D.apply(et, arguments)
        } catch (Ut) {
            console.error("THREE.WebGLState:", Ut)
        }
    }
    function pn() {
        try {
            et.texSubImage2D.apply(et, arguments)
        } catch (Ut) {
            console.error("THREE.WebGLState:", Ut)
        }
    }
    function mn() {
        try {
            et.texSubImage3D.apply(et, arguments)
        } catch (Ut) {
            console.error("THREE.WebGLState:", Ut)
        }
    }
    function An() {
        try {
            et.compressedTexSubImage2D.apply(et, arguments)
        } catch (Ut) {
            console.error("THREE.WebGLState:", Ut)
        }
    }
    function In() {
        try {
            et.texStorage2D.apply(et, arguments)
        } catch (Ut) {
            console.error("THREE.WebGLState:", Ut)
        }
    }
    function Gt() {
        try {
            et.texStorage3D.apply(et, arguments)
        } catch (Ut) {
            console.error("THREE.WebGLState:", Ut)
        }
    }
    function Ht() {
        try {
            et.texImage2D.apply(et, arguments)
        } catch (Ut) {
            console.error("THREE.WebGLState:", Ut)
        }
    }
    function Vt() {
        try {
            et.texImage3D.apply(et, arguments)
        } catch (Ut) {
            console.error("THREE.WebGLState:", Ut)
        }
    }
    function hn(Ut) {
        Lt.equals(Ut) === !1 && (et.scissor(Ut.x, Ut.y, Ut.z, Ut.w),
        Lt.copy(Ut))
    }
    function vn(Ut) {
        Rt.equals(Ut) === !1 && (et.viewport(Ut.x, Ut.y, Ut.z, Ut.w),
        Rt.copy(Ut))
    }
    function En() {
        et.disable(3042),
        et.disable(2884),
        et.disable(2929),
        et.disable(32823),
        et.disable(3089),
        et.disable(2960),
        et.disable(32926),
        et.blendEquation(32774),
        et.blendFunc(1, 0),
        et.blendFuncSeparate(1, 0, 1, 0),
        et.colorMask(!0, !0, !0, !0),
        et.clearColor(0, 0, 0, 0),
        et.depthMask(!0),
        et.depthFunc(513),
        et.clearDepth(1),
        et.stencilMask(4294967295),
        et.stencilFunc(519, 0, 4294967295),
        et.stencilOp(7680, 7680, 7680),
        et.clearStencil(0),
        et.cullFace(1029),
        et.frontFace(2305),
        et.polygonOffset(0, 0),
        et.activeTexture(33984),
        et.bindFramebuffer(36160, null),
        nt === !0 && (et.bindFramebuffer(36009, null),
        et.bindFramebuffer(36008, null)),
        et.useProgram(null),
        et.lineWidth(1),
        et.scissor(0, 0, et.canvas.width, et.canvas.height),
        et.viewport(0, 0, et.canvas.width, et.canvas.height),
        ct = {},
        jt = null,
        Bt = {},
        ht = {},
        ft = new WeakMap,
        gt = [],
        vt = null,
        yt = !1,
        wt = null,
        mt = null,
        _t = null,
        bt = null,
        Mt = null,
        St = null,
        At = null,
        Pt = !1,
        Ot = null,
        Zt = null,
        Nt = null,
        Tt = null,
        Ft = null,
        Lt.set(0, 0, et.canvas.width, et.canvas.height),
        Rt.set(0, 0, et.canvas.width, et.canvas.height),
        st.reset(),
        lt.reset(),
        ut.reset()
    }
    return {
        buffers: {
            color: st,
            depth: lt,
            stencil: ut
        },
        enable: Vn,
        disable: sn,
        bindFramebuffer: Un,
        drawBuffers: zn,
        useProgram: Rn,
        setBlending: cn,
        setMaterial: bn,
        setFlipSided: Mn,
        setCullFace: Dn,
        setLineWidth: Pn,
        setPolygonOffset: $n,
        setScissorTest: On,
        activeTexture: Wn,
        bindTexture: rr,
        unbindTexture: Dt,
        compressedTexImage2D: kt,
        texImage2D: Ht,
        texImage3D: Vt,
        texStorage2D: In,
        texStorage3D: Gt,
        texSubImage2D: pn,
        texSubImage3D: mn,
        compressedTexSubImage2D: An,
        scissor: hn,
        viewport: vn,
        reset: En
    }
}
function WebGLTextures(et, $, tt, nt, rt, it, ot) {
    const st = rt.isWebGL2
      , lt = rt.maxTextures
      , ut = rt.maxCubemapSize
      , ct = rt.maxTextureSize
      , ht = rt.maxSamples
      , ft = $.has("WEBGL_multisampled_render_to_texture") ? $.get("WEBGL_multisampled_render_to_texture") : null
      , gt = new WeakMap;
    let vt;
    const yt = new WeakMap;
    let wt = !1;
    try {
        wt = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function mt(Dt, kt) {
        return wt ? new OffscreenCanvas(Dt,kt) : createElementNS("canvas")
    }
    function _t(Dt, kt, pn, mn) {
        let An = 1;
        if ((Dt.width > mn || Dt.height > mn) && (An = mn / Math.max(Dt.width, Dt.height)),
        An < 1 || kt === !0)
            if (typeof HTMLImageElement != "undefined" && Dt instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && Dt instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && Dt instanceof ImageBitmap) {
                const In = kt ? floorPowerOfTwo : Math.floor
                  , Gt = In(An * Dt.width)
                  , Ht = In(An * Dt.height);
                vt === void 0 && (vt = mt(Gt, Ht));
                const Vt = pn ? mt(Gt, Ht) : vt;
                return Vt.width = Gt,
                Vt.height = Ht,
                Vt.getContext("2d").drawImage(Dt, 0, 0, Gt, Ht),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Dt.width + "x" + Dt.height + ") to (" + Gt + "x" + Ht + ")."),
                Vt
            } else
                return "data"in Dt && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Dt.width + "x" + Dt.height + ")."),
                Dt;
        return Dt
    }
    function bt(Dt) {
        return isPowerOfTwo(Dt.width) && isPowerOfTwo(Dt.height)
    }
    function Mt(Dt) {
        return st ? !1 : Dt.wrapS !== ClampToEdgeWrapping || Dt.wrapT !== ClampToEdgeWrapping || Dt.minFilter !== NearestFilter && Dt.minFilter !== LinearFilter
    }
    function St(Dt, kt) {
        return Dt.generateMipmaps && kt && Dt.minFilter !== NearestFilter && Dt.minFilter !== LinearFilter
    }
    function At(Dt) {
        et.generateMipmap(Dt)
    }
    function Pt(Dt, kt, pn, mn, An=!1) {
        if (st === !1)
            return kt;
        if (Dt !== null) {
            if (et[Dt] !== void 0)
                return et[Dt];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Dt + "'")
        }
        let In = kt;
        return kt === 6403 && (pn === 5126 && (In = 33326),
        pn === 5131 && (In = 33325),
        pn === 5121 && (In = 33321)),
        kt === 33319 && (pn === 5126 && (In = 33328),
        pn === 5131 && (In = 33327),
        pn === 5121 && (In = 33323)),
        kt === 6408 && (pn === 5126 && (In = 34836),
        pn === 5131 && (In = 34842),
        pn === 5121 && (In = mn === sRGBEncoding && An === !1 ? 35907 : 32856),
        pn === 32819 && (In = 32854),
        pn === 32820 && (In = 32855)),
        (In === 33325 || In === 33326 || In === 33327 || In === 33328 || In === 34842 || In === 34836) && $.get("EXT_color_buffer_float"),
        In
    }
    function Ot(Dt, kt, pn) {
        return St(Dt, pn) === !0 || Dt.isFramebufferTexture && Dt.minFilter !== NearestFilter && Dt.minFilter !== LinearFilter ? Math.log2(Math.max(kt.width, kt.height)) + 1 : Dt.mipmaps !== void 0 && Dt.mipmaps.length > 0 ? Dt.mipmaps.length : Dt.isCompressedTexture && Array.isArray(Dt.image) ? kt.mipmaps.length : 1
    }
    function Zt(Dt) {
        return Dt === NearestFilter || Dt === NearestMipmapNearestFilter || Dt === NearestMipmapLinearFilter ? 9728 : 9729
    }
    function Nt(Dt) {
        const kt = Dt.target;
        kt.removeEventListener("dispose", Nt),
        Ft(kt),
        kt.isVideoTexture && gt.delete(kt)
    }
    function Tt(Dt) {
        const kt = Dt.target;
        kt.removeEventListener("dispose", Tt),
        Wt(kt)
    }
    function Ft(Dt) {
        const kt = nt.get(Dt);
        if (kt.__webglInit === void 0)
            return;
        const pn = Dt.source
          , mn = yt.get(pn);
        if (mn) {
            const An = mn[kt.__cacheKey];
            An.usedTimes--,
            An.usedTimes === 0 && $t(Dt),
            Object.keys(mn).length === 0 && yt.delete(pn)
        }
        nt.remove(Dt)
    }
    function $t(Dt) {
        const kt = nt.get(Dt);
        et.deleteTexture(kt.__webglTexture);
        const pn = Dt.source
          , mn = yt.get(pn);
        delete mn[kt.__cacheKey],
        ot.memory.textures--
    }
    function Wt(Dt) {
        const kt = Dt.texture
          , pn = nt.get(Dt)
          , mn = nt.get(kt);
        if (mn.__webglTexture !== void 0 && (et.deleteTexture(mn.__webglTexture),
        ot.memory.textures--),
        Dt.depthTexture && Dt.depthTexture.dispose(),
        Dt.isWebGLCubeRenderTarget)
            for (let An = 0; An < 6; An++)
                et.deleteFramebuffer(pn.__webglFramebuffer[An]),
                pn.__webglDepthbuffer && et.deleteRenderbuffer(pn.__webglDepthbuffer[An]);
        else
            et.deleteFramebuffer(pn.__webglFramebuffer),
            pn.__webglDepthbuffer && et.deleteRenderbuffer(pn.__webglDepthbuffer),
            pn.__webglMultisampledFramebuffer && et.deleteFramebuffer(pn.__webglMultisampledFramebuffer),
            pn.__webglColorRenderbuffer && et.deleteRenderbuffer(pn.__webglColorRenderbuffer),
            pn.__webglDepthRenderbuffer && et.deleteRenderbuffer(pn.__webglDepthRenderbuffer);
        if (Dt.isWebGLMultipleRenderTargets)
            for (let An = 0, In = kt.length; An < In; An++) {
                const Gt = nt.get(kt[An]);
                Gt.__webglTexture && (et.deleteTexture(Gt.__webglTexture),
                ot.memory.textures--),
                nt.remove(kt[An])
            }
        nt.remove(kt),
        nt.remove(Dt)
    }
    let Kt = 0;
    function qt() {
        Kt = 0
    }
    function jt() {
        const Dt = Kt;
        return Dt >= lt && console.warn("THREE.WebGLTextures: Trying to use " + Dt + " texture units while this GPU supports only " + lt),
        Kt += 1,
        Dt
    }
    function Bt(Dt) {
        const kt = [];
        return kt.push(Dt.wrapS),
        kt.push(Dt.wrapT),
        kt.push(Dt.magFilter),
        kt.push(Dt.minFilter),
        kt.push(Dt.anisotropy),
        kt.push(Dt.internalFormat),
        kt.push(Dt.format),
        kt.push(Dt.type),
        kt.push(Dt.generateMipmaps),
        kt.push(Dt.premultiplyAlpha),
        kt.push(Dt.flipY),
        kt.push(Dt.unpackAlignment),
        kt.push(Dt.encoding),
        kt.join()
    }
    function Xt(Dt, kt) {
        const pn = nt.get(Dt);
        if (Dt.isVideoTexture && Wn(Dt),
        Dt.isRenderTargetTexture === !1 && Dt.version > 0 && pn.__version !== Dt.version) {
            const mn = Dt.image;
            if (mn === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (mn.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Un(pn, Dt, kt);
                return
            }
        }
        tt.activeTexture(33984 + kt),
        tt.bindTexture(3553, pn.__webglTexture)
    }
    function Jt(Dt, kt) {
        const pn = nt.get(Dt);
        if (Dt.version > 0 && pn.__version !== Dt.version) {
            Un(pn, Dt, kt);
            return
        }
        tt.activeTexture(33984 + kt),
        tt.bindTexture(35866, pn.__webglTexture)
    }
    function Lt(Dt, kt) {
        const pn = nt.get(Dt);
        if (Dt.version > 0 && pn.__version !== Dt.version) {
            Un(pn, Dt, kt);
            return
        }
        tt.activeTexture(33984 + kt),
        tt.bindTexture(32879, pn.__webglTexture)
    }
    function Rt(Dt, kt) {
        const pn = nt.get(Dt);
        if (Dt.version > 0 && pn.__version !== Dt.version) {
            zn(pn, Dt, kt);
            return
        }
        tt.activeTexture(33984 + kt),
        tt.bindTexture(34067, pn.__webglTexture)
    }
    const _n = {
        [RepeatWrapping]: 10497,
        [ClampToEdgeWrapping]: 33071,
        [MirroredRepeatWrapping]: 33648
    }
      , Fn = {
        [NearestFilter]: 9728,
        [NearestMipmapNearestFilter]: 9984,
        [NearestMipmapLinearFilter]: 9986,
        [LinearFilter]: 9729,
        [LinearMipmapNearestFilter]: 9985,
        [LinearMipmapLinearFilter]: 9987
    };
    function Vn(Dt, kt, pn) {
        if (pn ? (et.texParameteri(Dt, 10242, _n[kt.wrapS]),
        et.texParameteri(Dt, 10243, _n[kt.wrapT]),
        (Dt === 32879 || Dt === 35866) && et.texParameteri(Dt, 32882, _n[kt.wrapR]),
        et.texParameteri(Dt, 10240, Fn[kt.magFilter]),
        et.texParameteri(Dt, 10241, Fn[kt.minFilter])) : (et.texParameteri(Dt, 10242, 33071),
        et.texParameteri(Dt, 10243, 33071),
        (Dt === 32879 || Dt === 35866) && et.texParameteri(Dt, 32882, 33071),
        (kt.wrapS !== ClampToEdgeWrapping || kt.wrapT !== ClampToEdgeWrapping) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        et.texParameteri(Dt, 10240, Zt(kt.magFilter)),
        et.texParameteri(Dt, 10241, Zt(kt.minFilter)),
        kt.minFilter !== NearestFilter && kt.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        $.has("EXT_texture_filter_anisotropic") === !0) {
            const mn = $.get("EXT_texture_filter_anisotropic");
            if (kt.type === FloatType && $.has("OES_texture_float_linear") === !1 || st === !1 && kt.type === HalfFloatType && $.has("OES_texture_half_float_linear") === !1)
                return;
            (kt.anisotropy > 1 || nt.get(kt).__currentAnisotropy) && (et.texParameterf(Dt, mn.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(kt.anisotropy, rt.getMaxAnisotropy())),
            nt.get(kt).__currentAnisotropy = kt.anisotropy)
        }
    }
    function sn(Dt, kt) {
        let pn = !1;
        Dt.__webglInit === void 0 && (Dt.__webglInit = !0,
        kt.addEventListener("dispose", Nt));
        const mn = kt.source;
        let An = yt.get(mn);
        An === void 0 && (An = {},
        yt.set(mn, An));
        const In = Bt(kt);
        if (In !== Dt.__cacheKey) {
            An[In] === void 0 && (An[In] = {
                texture: et.createTexture(),
                usedTimes: 0
            },
            ot.memory.textures++,
            pn = !0),
            An[In].usedTimes++;
            const Gt = An[Dt.__cacheKey];
            Gt !== void 0 && (An[Dt.__cacheKey].usedTimes--,
            Gt.usedTimes === 0 && $t(kt)),
            Dt.__cacheKey = In,
            Dt.__webglTexture = An[In].texture
        }
        return pn
    }
    function Un(Dt, kt, pn) {
        let mn = 3553;
        kt.isDataArrayTexture && (mn = 35866),
        kt.isData3DTexture && (mn = 32879);
        const An = sn(Dt, kt)
          , In = kt.source;
        if (tt.activeTexture(33984 + pn),
        tt.bindTexture(mn, Dt.__webglTexture),
        In.version !== In.__currentVersion || An === !0) {
            et.pixelStorei(37440, kt.flipY),
            et.pixelStorei(37441, kt.premultiplyAlpha),
            et.pixelStorei(3317, kt.unpackAlignment),
            et.pixelStorei(37443, 0);
            const Gt = Mt(kt) && bt(kt.image) === !1;
            let Ht = _t(kt.image, Gt, !1, ct);
            Ht = rr(kt, Ht);
            const Vt = bt(Ht) || st
              , hn = it.convert(kt.format, kt.encoding);
            let vn = it.convert(kt.type)
              , En = Pt(kt.internalFormat, hn, vn, kt.encoding, kt.isVideoTexture);
            Vn(mn, kt, Vt);
            let Ut;
            const Cn = kt.mipmaps
              , Tn = st && kt.isVideoTexture !== !0
              , Hn = Dt.__version === void 0
              , yn = Ot(kt, Ht, Vt);
            if (kt.isDepthTexture)
                En = 6402,
                st ? kt.type === FloatType ? En = 36012 : kt.type === UnsignedIntType ? En = 33190 : kt.type === UnsignedInt248Type ? En = 35056 : En = 33189 : kt.type === FloatType && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                kt.format === DepthFormat && En === 6402 && kt.type !== UnsignedShortType && kt.type !== UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                kt.type = UnsignedShortType,
                vn = it.convert(kt.type)),
                kt.format === DepthStencilFormat && En === 6402 && (En = 34041,
                kt.type !== UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                kt.type = UnsignedInt248Type,
                vn = it.convert(kt.type))),
                Tn && Hn ? tt.texStorage2D(3553, 1, En, Ht.width, Ht.height) : tt.texImage2D(3553, 0, En, Ht.width, Ht.height, 0, hn, vn, null);
            else if (kt.isDataTexture)
                if (Cn.length > 0 && Vt) {
                    Tn && Hn && tt.texStorage2D(3553, yn, En, Cn[0].width, Cn[0].height);
                    for (let xn = 0, Nn = Cn.length; xn < Nn; xn++)
                        Ut = Cn[xn],
                        Tn ? tt.texSubImage2D(3553, xn, 0, 0, Ut.width, Ut.height, hn, vn, Ut.data) : tt.texImage2D(3553, xn, En, Ut.width, Ut.height, 0, hn, vn, Ut.data);
                    kt.generateMipmaps = !1
                } else
                    Tn ? (Hn && tt.texStorage2D(3553, yn, En, Ht.width, Ht.height),
                    tt.texSubImage2D(3553, 0, 0, 0, Ht.width, Ht.height, hn, vn, Ht.data)) : tt.texImage2D(3553, 0, En, Ht.width, Ht.height, 0, hn, vn, Ht.data);
            else if (kt.isCompressedTexture) {
                Tn && Hn && tt.texStorage2D(3553, yn, En, Cn[0].width, Cn[0].height);
                for (let xn = 0, Nn = Cn.length; xn < Nn; xn++)
                    Ut = Cn[xn],
                    kt.format !== RGBAFormat ? hn !== null ? Tn ? tt.compressedTexSubImage2D(3553, xn, 0, 0, Ut.width, Ut.height, hn, Ut.data) : tt.compressedTexImage2D(3553, xn, En, Ut.width, Ut.height, 0, Ut.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Tn ? tt.texSubImage2D(3553, xn, 0, 0, Ut.width, Ut.height, hn, vn, Ut.data) : tt.texImage2D(3553, xn, En, Ut.width, Ut.height, 0, hn, vn, Ut.data)
            } else if (kt.isDataArrayTexture)
                Tn ? (Hn && tt.texStorage3D(35866, yn, En, Ht.width, Ht.height, Ht.depth),
                tt.texSubImage3D(35866, 0, 0, 0, 0, Ht.width, Ht.height, Ht.depth, hn, vn, Ht.data)) : tt.texImage3D(35866, 0, En, Ht.width, Ht.height, Ht.depth, 0, hn, vn, Ht.data);
            else if (kt.isData3DTexture)
                Tn ? (Hn && tt.texStorage3D(32879, yn, En, Ht.width, Ht.height, Ht.depth),
                tt.texSubImage3D(32879, 0, 0, 0, 0, Ht.width, Ht.height, Ht.depth, hn, vn, Ht.data)) : tt.texImage3D(32879, 0, En, Ht.width, Ht.height, Ht.depth, 0, hn, vn, Ht.data);
            else if (kt.isFramebufferTexture)
                Tn && Hn ? tt.texStorage2D(3553, yn, En, Ht.width, Ht.height) : tt.texImage2D(3553, 0, En, Ht.width, Ht.height, 0, hn, vn, null);
            else if (Cn.length > 0 && Vt) {
                Tn && Hn && tt.texStorage2D(3553, yn, En, Cn[0].width, Cn[0].height);
                for (let xn = 0, Nn = Cn.length; xn < Nn; xn++)
                    Ut = Cn[xn],
                    Tn ? tt.texSubImage2D(3553, xn, 0, 0, hn, vn, Ut) : tt.texImage2D(3553, xn, En, hn, vn, Ut);
                kt.generateMipmaps = !1
            } else
                Tn ? (Hn && tt.texStorage2D(3553, yn, En, Ht.width, Ht.height),
                tt.texSubImage2D(3553, 0, 0, 0, hn, vn, Ht)) : tt.texImage2D(3553, 0, En, hn, vn, Ht);
            St(kt, Vt) && At(mn),
            In.__currentVersion = In.version,
            kt.onUpdate && kt.onUpdate(kt)
        }
        Dt.__version = kt.version
    }
    function zn(Dt, kt, pn) {
        if (kt.image.length !== 6)
            return;
        const mn = sn(Dt, kt)
          , An = kt.source;
        if (tt.activeTexture(33984 + pn),
        tt.bindTexture(34067, Dt.__webglTexture),
        An.version !== An.__currentVersion || mn === !0) {
            et.pixelStorei(37440, kt.flipY),
            et.pixelStorei(37441, kt.premultiplyAlpha),
            et.pixelStorei(3317, kt.unpackAlignment),
            et.pixelStorei(37443, 0);
            const In = kt.isCompressedTexture || kt.image[0].isCompressedTexture
              , Gt = kt.image[0] && kt.image[0].isDataTexture
              , Ht = [];
            for (let xn = 0; xn < 6; xn++)
                !In && !Gt ? Ht[xn] = _t(kt.image[xn], !1, !0, ut) : Ht[xn] = Gt ? kt.image[xn].image : kt.image[xn],
                Ht[xn] = rr(kt, Ht[xn]);
            const Vt = Ht[0]
              , hn = bt(Vt) || st
              , vn = it.convert(kt.format, kt.encoding)
              , En = it.convert(kt.type)
              , Ut = Pt(kt.internalFormat, vn, En, kt.encoding)
              , Cn = st && kt.isVideoTexture !== !0
              , Tn = Dt.__version === void 0;
            let Hn = Ot(kt, Vt, hn);
            Vn(34067, kt, hn);
            let yn;
            if (In) {
                Cn && Tn && tt.texStorage2D(34067, Hn, Ut, Vt.width, Vt.height);
                for (let xn = 0; xn < 6; xn++) {
                    yn = Ht[xn].mipmaps;
                    for (let Nn = 0; Nn < yn.length; Nn++) {
                        const Jn = yn[Nn];
                        kt.format !== RGBAFormat ? vn !== null ? Cn ? tt.compressedTexSubImage2D(34069 + xn, Nn, 0, 0, Jn.width, Jn.height, vn, Jn.data) : tt.compressedTexImage2D(34069 + xn, Nn, Ut, Jn.width, Jn.height, 0, Jn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Cn ? tt.texSubImage2D(34069 + xn, Nn, 0, 0, Jn.width, Jn.height, vn, En, Jn.data) : tt.texImage2D(34069 + xn, Nn, Ut, Jn.width, Jn.height, 0, vn, En, Jn.data)
                    }
                }
            } else {
                yn = kt.mipmaps,
                Cn && Tn && (yn.length > 0 && Hn++,
                tt.texStorage2D(34067, Hn, Ut, Ht[0].width, Ht[0].height));
                for (let xn = 0; xn < 6; xn++)
                    if (Gt) {
                        Cn ? tt.texSubImage2D(34069 + xn, 0, 0, 0, Ht[xn].width, Ht[xn].height, vn, En, Ht[xn].data) : tt.texImage2D(34069 + xn, 0, Ut, Ht[xn].width, Ht[xn].height, 0, vn, En, Ht[xn].data);
                        for (let Nn = 0; Nn < yn.length; Nn++) {
                            const dr = yn[Nn].image[xn].image;
                            Cn ? tt.texSubImage2D(34069 + xn, Nn + 1, 0, 0, dr.width, dr.height, vn, En, dr.data) : tt.texImage2D(34069 + xn, Nn + 1, Ut, dr.width, dr.height, 0, vn, En, dr.data)
                        }
                    } else {
                        Cn ? tt.texSubImage2D(34069 + xn, 0, 0, 0, vn, En, Ht[xn]) : tt.texImage2D(34069 + xn, 0, Ut, vn, En, Ht[xn]);
                        for (let Nn = 0; Nn < yn.length; Nn++) {
                            const Jn = yn[Nn];
                            Cn ? tt.texSubImage2D(34069 + xn, Nn + 1, 0, 0, vn, En, Jn.image[xn]) : tt.texImage2D(34069 + xn, Nn + 1, Ut, vn, En, Jn.image[xn])
                        }
                    }
            }
            St(kt, hn) && At(34067),
            An.__currentVersion = An.version,
            kt.onUpdate && kt.onUpdate(kt)
        }
        Dt.__version = kt.version
    }
    function Rn(Dt, kt, pn, mn, An) {
        const In = it.convert(pn.format, pn.encoding)
          , Gt = it.convert(pn.type)
          , Ht = Pt(pn.internalFormat, In, Gt, pn.encoding);
        nt.get(kt).__hasExternalTextures || (An === 32879 || An === 35866 ? tt.texImage3D(An, 0, Ht, kt.width, kt.height, kt.depth, 0, In, Gt, null) : tt.texImage2D(An, 0, Ht, kt.width, kt.height, 0, In, Gt, null)),
        tt.bindFramebuffer(36160, Dt),
        On(kt) ? ft.framebufferTexture2DMultisampleEXT(36160, mn, An, nt.get(pn).__webglTexture, 0, $n(kt)) : et.framebufferTexture2D(36160, mn, An, nt.get(pn).__webglTexture, 0),
        tt.bindFramebuffer(36160, null)
    }
    function Ln(Dt, kt, pn) {
        if (et.bindRenderbuffer(36161, Dt),
        kt.depthBuffer && !kt.stencilBuffer) {
            let mn = 33189;
            if (pn || On(kt)) {
                const An = kt.depthTexture;
                An && An.isDepthTexture && (An.type === FloatType ? mn = 36012 : An.type === UnsignedIntType && (mn = 33190));
                const In = $n(kt);
                On(kt) ? ft.renderbufferStorageMultisampleEXT(36161, In, mn, kt.width, kt.height) : et.renderbufferStorageMultisample(36161, In, mn, kt.width, kt.height)
            } else
                et.renderbufferStorage(36161, mn, kt.width, kt.height);
            et.framebufferRenderbuffer(36160, 36096, 36161, Dt)
        } else if (kt.depthBuffer && kt.stencilBuffer) {
            const mn = $n(kt);
            pn && On(kt) === !1 ? et.renderbufferStorageMultisample(36161, mn, 35056, kt.width, kt.height) : On(kt) ? ft.renderbufferStorageMultisampleEXT(36161, mn, 35056, kt.width, kt.height) : et.renderbufferStorage(36161, 34041, kt.width, kt.height),
            et.framebufferRenderbuffer(36160, 33306, 36161, Dt)
        } else {
            const mn = kt.isWebGLMultipleRenderTargets === !0 ? kt.texture[0] : kt.texture
              , An = it.convert(mn.format, mn.encoding)
              , In = it.convert(mn.type)
              , Gt = Pt(mn.internalFormat, An, In, mn.encoding)
              , Ht = $n(kt);
            pn && On(kt) === !1 ? et.renderbufferStorageMultisample(36161, Ht, Gt, kt.width, kt.height) : On(kt) ? ft.renderbufferStorageMultisampleEXT(36161, Ht, Gt, kt.width, kt.height) : et.renderbufferStorage(36161, Gt, kt.width, kt.height)
        }
        et.bindRenderbuffer(36161, null)
    }
    function Gn(Dt, kt) {
        if (kt && kt.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (tt.bindFramebuffer(36160, Dt),
        !(kt.depthTexture && kt.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!nt.get(kt.depthTexture).__webglTexture || kt.depthTexture.image.width !== kt.width || kt.depthTexture.image.height !== kt.height) && (kt.depthTexture.image.width = kt.width,
        kt.depthTexture.image.height = kt.height,
        kt.depthTexture.needsUpdate = !0),
        Xt(kt.depthTexture, 0);
        const mn = nt.get(kt.depthTexture).__webglTexture
          , An = $n(kt);
        if (kt.depthTexture.format === DepthFormat)
            On(kt) ? ft.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, mn, 0, An) : et.framebufferTexture2D(36160, 36096, 3553, mn, 0);
        else if (kt.depthTexture.format === DepthStencilFormat)
            On(kt) ? ft.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, mn, 0, An) : et.framebufferTexture2D(36160, 33306, 3553, mn, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function cn(Dt) {
        const kt = nt.get(Dt)
          , pn = Dt.isWebGLCubeRenderTarget === !0;
        if (Dt.depthTexture && !kt.__autoAllocateDepthBuffer) {
            if (pn)
                throw new Error("target.depthTexture not supported in Cube render targets");
            Gn(kt.__webglFramebuffer, Dt)
        } else if (pn) {
            kt.__webglDepthbuffer = [];
            for (let mn = 0; mn < 6; mn++)
                tt.bindFramebuffer(36160, kt.__webglFramebuffer[mn]),
                kt.__webglDepthbuffer[mn] = et.createRenderbuffer(),
                Ln(kt.__webglDepthbuffer[mn], Dt, !1)
        } else
            tt.bindFramebuffer(36160, kt.__webglFramebuffer),
            kt.__webglDepthbuffer = et.createRenderbuffer(),
            Ln(kt.__webglDepthbuffer, Dt, !1);
        tt.bindFramebuffer(36160, null)
    }
    function bn(Dt, kt, pn) {
        const mn = nt.get(Dt);
        kt !== void 0 && Rn(mn.__webglFramebuffer, Dt, Dt.texture, 36064, 3553),
        pn !== void 0 && cn(Dt)
    }
    function Mn(Dt) {
        const kt = Dt.texture
          , pn = nt.get(Dt)
          , mn = nt.get(kt);
        Dt.addEventListener("dispose", Tt),
        Dt.isWebGLMultipleRenderTargets !== !0 && (mn.__webglTexture === void 0 && (mn.__webglTexture = et.createTexture()),
        mn.__version = kt.version,
        ot.memory.textures++);
        const An = Dt.isWebGLCubeRenderTarget === !0
          , In = Dt.isWebGLMultipleRenderTargets === !0
          , Gt = bt(Dt) || st;
        if (An) {
            pn.__webglFramebuffer = [];
            for (let Ht = 0; Ht < 6; Ht++)
                pn.__webglFramebuffer[Ht] = et.createFramebuffer()
        } else if (pn.__webglFramebuffer = et.createFramebuffer(),
        In)
            if (rt.drawBuffers) {
                const Ht = Dt.texture;
                for (let Vt = 0, hn = Ht.length; Vt < hn; Vt++) {
                    const vn = nt.get(Ht[Vt]);
                    vn.__webglTexture === void 0 && (vn.__webglTexture = et.createTexture(),
                    ot.memory.textures++)
                }
            } else
                console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        else if (st && Dt.samples > 0 && On(Dt) === !1) {
            pn.__webglMultisampledFramebuffer = et.createFramebuffer(),
            pn.__webglColorRenderbuffer = et.createRenderbuffer(),
            et.bindRenderbuffer(36161, pn.__webglColorRenderbuffer);
            const Ht = it.convert(kt.format, kt.encoding)
              , Vt = it.convert(kt.type)
              , hn = Pt(kt.internalFormat, Ht, Vt, kt.encoding)
              , vn = $n(Dt);
            et.renderbufferStorageMultisample(36161, vn, hn, Dt.width, Dt.height),
            tt.bindFramebuffer(36160, pn.__webglMultisampledFramebuffer),
            et.framebufferRenderbuffer(36160, 36064, 36161, pn.__webglColorRenderbuffer),
            et.bindRenderbuffer(36161, null),
            Dt.depthBuffer && (pn.__webglDepthRenderbuffer = et.createRenderbuffer(),
            Ln(pn.__webglDepthRenderbuffer, Dt, !0)),
            tt.bindFramebuffer(36160, null)
        }
        if (An) {
            tt.bindTexture(34067, mn.__webglTexture),
            Vn(34067, kt, Gt);
            for (let Ht = 0; Ht < 6; Ht++)
                Rn(pn.__webglFramebuffer[Ht], Dt, kt, 36064, 34069 + Ht);
            St(kt, Gt) && At(34067),
            tt.unbindTexture()
        } else if (In) {
            const Ht = Dt.texture;
            for (let Vt = 0, hn = Ht.length; Vt < hn; Vt++) {
                const vn = Ht[Vt]
                  , En = nt.get(vn);
                tt.bindTexture(3553, En.__webglTexture),
                Vn(3553, vn, Gt),
                Rn(pn.__webglFramebuffer, Dt, vn, 36064 + Vt, 3553),
                St(vn, Gt) && At(3553)
            }
            tt.unbindTexture()
        } else {
            let Ht = 3553;
            (Dt.isWebGL3DRenderTarget || Dt.isWebGLArrayRenderTarget) && (st ? Ht = Dt.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            tt.bindTexture(Ht, mn.__webglTexture),
            Vn(Ht, kt, Gt),
            Rn(pn.__webglFramebuffer, Dt, kt, 36064, Ht),
            St(kt, Gt) && At(Ht),
            tt.unbindTexture()
        }
        Dt.depthBuffer && cn(Dt)
    }
    function Dn(Dt) {
        const kt = bt(Dt) || st
          , pn = Dt.isWebGLMultipleRenderTargets === !0 ? Dt.texture : [Dt.texture];
        for (let mn = 0, An = pn.length; mn < An; mn++) {
            const In = pn[mn];
            if (St(In, kt)) {
                const Gt = Dt.isWebGLCubeRenderTarget ? 34067 : 3553
                  , Ht = nt.get(In).__webglTexture;
                tt.bindTexture(Gt, Ht),
                At(Gt),
                tt.unbindTexture()
            }
        }
    }
    function Pn(Dt) {
        if (st && Dt.samples > 0 && On(Dt) === !1) {
            const kt = Dt.width
              , pn = Dt.height;
            let mn = 16384;
            const An = [36064]
              , In = Dt.stencilBuffer ? 33306 : 36096;
            Dt.depthBuffer && An.push(In);
            const Gt = nt.get(Dt)
              , Ht = Gt.__ignoreDepthValues !== void 0 ? Gt.__ignoreDepthValues : !1;
            Ht === !1 && (Dt.depthBuffer && (mn |= 256),
            Dt.stencilBuffer && (mn |= 1024)),
            tt.bindFramebuffer(36008, Gt.__webglMultisampledFramebuffer),
            tt.bindFramebuffer(36009, Gt.__webglFramebuffer),
            Ht === !0 && (et.invalidateFramebuffer(36008, [In]),
            et.invalidateFramebuffer(36009, [In])),
            et.blitFramebuffer(0, 0, kt, pn, 0, 0, kt, pn, mn, 9728),
            et.invalidateFramebuffer(36008, An),
            tt.bindFramebuffer(36008, null),
            tt.bindFramebuffer(36009, Gt.__webglMultisampledFramebuffer)
        }
    }
    function $n(Dt) {
        return Math.min(ht, Dt.samples)
    }
    function On(Dt) {
        const kt = nt.get(Dt);
        return st && Dt.samples > 0 && $.has("WEBGL_multisampled_render_to_texture") === !0 && kt.__useRenderToTexture !== !1
    }
    function Wn(Dt) {
        const kt = ot.render.frame;
        gt.get(Dt) !== kt && (gt.set(Dt, kt),
        Dt.update())
    }
    function rr(Dt, kt) {
        const pn = Dt.encoding
          , mn = Dt.format
          , An = Dt.type;
        return Dt.isCompressedTexture === !0 || Dt.isVideoTexture === !0 || Dt.format === _SRGBAFormat || pn !== LinearEncoding && (pn === sRGBEncoding ? st === !1 ? $.has("EXT_sRGB") === !0 && mn === RGBAFormat ? (Dt.format = _SRGBAFormat,
        Dt.minFilter = LinearFilter,
        Dt.generateMipmaps = !1) : kt = ImageUtils.sRGBToLinear(kt) : (mn !== RGBAFormat || An !== UnsignedByteType) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", pn)),
        kt
    }
    this.allocateTextureUnit = jt,
    this.resetTextureUnits = qt,
    this.setTexture2D = Xt,
    this.setTexture2DArray = Jt,
    this.setTexture3D = Lt,
    this.setTextureCube = Rt,
    this.rebindTextures = bn,
    this.setupRenderTarget = Mn,
    this.updateRenderTargetMipmap = Dn,
    this.updateMultisampleRenderTarget = Pn,
    this.setupDepthRenderbuffer = cn,
    this.setupFrameBufferTexture = Rn,
    this.useMultisampledRTT = On
}
function WebGLUtils(et, $, tt) {
    const nt = tt.isWebGL2;
    function rt(it, ot=null) {
        let st;
        if (it === UnsignedByteType)
            return 5121;
        if (it === UnsignedShort4444Type)
            return 32819;
        if (it === UnsignedShort5551Type)
            return 32820;
        if (it === ByteType)
            return 5120;
        if (it === ShortType)
            return 5122;
        if (it === UnsignedShortType)
            return 5123;
        if (it === IntType)
            return 5124;
        if (it === UnsignedIntType)
            return 5125;
        if (it === FloatType)
            return 5126;
        if (it === HalfFloatType)
            return nt ? 5131 : (st = $.get("OES_texture_half_float"),
            st !== null ? st.HALF_FLOAT_OES : null);
        if (it === AlphaFormat)
            return 6406;
        if (it === RGBAFormat)
            return 6408;
        if (it === LuminanceFormat)
            return 6409;
        if (it === LuminanceAlphaFormat)
            return 6410;
        if (it === DepthFormat)
            return 6402;
        if (it === DepthStencilFormat)
            return 34041;
        if (it === RedFormat)
            return 6403;
        if (it === RGBFormat)
            return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),
            6408;
        if (it === _SRGBAFormat)
            return st = $.get("EXT_sRGB"),
            st !== null ? st.SRGB_ALPHA_EXT : null;
        if (it === RedIntegerFormat)
            return 36244;
        if (it === RGFormat)
            return 33319;
        if (it === RGIntegerFormat)
            return 33320;
        if (it === RGBAIntegerFormat)
            return 36249;
        if (it === RGB_S3TC_DXT1_Format || it === RGBA_S3TC_DXT1_Format || it === RGBA_S3TC_DXT3_Format || it === RGBA_S3TC_DXT5_Format)
            if (ot === sRGBEncoding)
                if (st = $.get("WEBGL_compressed_texture_s3tc_srgb"),
                st !== null) {
                    if (it === RGB_S3TC_DXT1_Format)
                        return st.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (it === RGBA_S3TC_DXT1_Format)
                        return st.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (it === RGBA_S3TC_DXT3_Format)
                        return st.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (it === RGBA_S3TC_DXT5_Format)
                        return st.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (st = $.get("WEBGL_compressed_texture_s3tc"),
            st !== null) {
                if (it === RGB_S3TC_DXT1_Format)
                    return st.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (it === RGBA_S3TC_DXT1_Format)
                    return st.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (it === RGBA_S3TC_DXT3_Format)
                    return st.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (it === RGBA_S3TC_DXT5_Format)
                    return st.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (it === RGB_PVRTC_4BPPV1_Format || it === RGB_PVRTC_2BPPV1_Format || it === RGBA_PVRTC_4BPPV1_Format || it === RGBA_PVRTC_2BPPV1_Format)
            if (st = $.get("WEBGL_compressed_texture_pvrtc"),
            st !== null) {
                if (it === RGB_PVRTC_4BPPV1_Format)
                    return st.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (it === RGB_PVRTC_2BPPV1_Format)
                    return st.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (it === RGBA_PVRTC_4BPPV1_Format)
                    return st.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (it === RGBA_PVRTC_2BPPV1_Format)
                    return st.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (it === RGB_ETC1_Format)
            return st = $.get("WEBGL_compressed_texture_etc1"),
            st !== null ? st.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (it === RGB_ETC2_Format || it === RGBA_ETC2_EAC_Format)
            if (st = $.get("WEBGL_compressed_texture_etc"),
            st !== null) {
                if (it === RGB_ETC2_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ETC2 : st.COMPRESSED_RGB8_ETC2;
                if (it === RGBA_ETC2_EAC_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : st.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (it === RGBA_ASTC_4x4_Format || it === RGBA_ASTC_5x4_Format || it === RGBA_ASTC_5x5_Format || it === RGBA_ASTC_6x5_Format || it === RGBA_ASTC_6x6_Format || it === RGBA_ASTC_8x5_Format || it === RGBA_ASTC_8x6_Format || it === RGBA_ASTC_8x8_Format || it === RGBA_ASTC_10x5_Format || it === RGBA_ASTC_10x6_Format || it === RGBA_ASTC_10x8_Format || it === RGBA_ASTC_10x10_Format || it === RGBA_ASTC_12x10_Format || it === RGBA_ASTC_12x12_Format)
            if (st = $.get("WEBGL_compressed_texture_astc"),
            st !== null) {
                if (it === RGBA_ASTC_4x4_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : st.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (it === RGBA_ASTC_5x4_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : st.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (it === RGBA_ASTC_5x5_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : st.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (it === RGBA_ASTC_6x5_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : st.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (it === RGBA_ASTC_6x6_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : st.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (it === RGBA_ASTC_8x5_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : st.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (it === RGBA_ASTC_8x6_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : st.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (it === RGBA_ASTC_8x8_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : st.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (it === RGBA_ASTC_10x5_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : st.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (it === RGBA_ASTC_10x6_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : st.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (it === RGBA_ASTC_10x8_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : st.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (it === RGBA_ASTC_10x10_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : st.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (it === RGBA_ASTC_12x10_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : st.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (it === RGBA_ASTC_12x12_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : st.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (it === RGBA_BPTC_Format)
            if (st = $.get("EXT_texture_compression_bptc"),
            st !== null) {
                if (it === RGBA_BPTC_Format)
                    return ot === sRGBEncoding ? st.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : st.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else
                return null;
        if (it === UnsignedInt248Type)
            return nt ? 34042 : (st = $.get("WEBGL_depth_texture"),
            st !== null ? st.UNSIGNED_INT_24_8_WEBGL : null)
    }
    return {
        convert: rt
    }
}
class ArrayCamera extends PerspectiveCamera {
    constructor($=[]) {
        super(),
        this.cameras = $
    }
}
ArrayCamera.prototype.isArrayCamera = !0;
class Group extends Object3D {
    constructor() {
        super(),
        this.type = "Group"
    }
}
Group.prototype.isGroup = !0;
const _moveEvent = {
    type: "move"
};
class WebXRController {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Group,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Group,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new Vector3,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new Vector3),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Group,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new Vector3,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new Vector3),
        this._grip
    }
    dispatchEvent($) {
        return this._targetRay !== null && this._targetRay.dispatchEvent($),
        this._grip !== null && this._grip.dispatchEvent($),
        this._hand !== null && this._hand.dispatchEvent($),
        this
    }
    disconnect($) {
        return this.dispatchEvent({
            type: "disconnected",
            data: $
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update($, tt, nt) {
        let rt = null
          , it = null
          , ot = null;
        const st = this._targetRay
          , lt = this._grip
          , ut = this._hand;
        if ($ && tt.session.visibilityState !== "visible-blurred")
            if (st !== null && (rt = tt.getPose($.targetRaySpace, nt),
            rt !== null && (st.matrix.fromArray(rt.transform.matrix),
            st.matrix.decompose(st.position, st.rotation, st.scale),
            rt.linearVelocity ? (st.hasLinearVelocity = !0,
            st.linearVelocity.copy(rt.linearVelocity)) : st.hasLinearVelocity = !1,
            rt.angularVelocity ? (st.hasAngularVelocity = !0,
            st.angularVelocity.copy(rt.angularVelocity)) : st.hasAngularVelocity = !1,
            this.dispatchEvent(_moveEvent))),
            ut && $.hand) {
                ot = !0;
                for (const yt of $.hand.values()) {
                    const wt = tt.getJointPose(yt, nt);
                    if (ut.joints[yt.jointName] === void 0) {
                        const _t = new Group;
                        _t.matrixAutoUpdate = !1,
                        _t.visible = !1,
                        ut.joints[yt.jointName] = _t,
                        ut.add(_t)
                    }
                    const mt = ut.joints[yt.jointName];
                    wt !== null && (mt.matrix.fromArray(wt.transform.matrix),
                    mt.matrix.decompose(mt.position, mt.rotation, mt.scale),
                    mt.jointRadius = wt.radius),
                    mt.visible = wt !== null
                }
                const ct = ut.joints["index-finger-tip"]
                  , ht = ut.joints["thumb-tip"]
                  , ft = ct.position.distanceTo(ht.position)
                  , gt = .02
                  , vt = .005;
                ut.inputState.pinching && ft > gt + vt ? (ut.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: $.handedness,
                    target: this
                })) : !ut.inputState.pinching && ft <= gt - vt && (ut.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: $.handedness,
                    target: this
                }))
            } else
                lt !== null && $.gripSpace && (it = tt.getPose($.gripSpace, nt),
                it !== null && (lt.matrix.fromArray(it.transform.matrix),
                lt.matrix.decompose(lt.position, lt.rotation, lt.scale),
                it.linearVelocity ? (lt.hasLinearVelocity = !0,
                lt.linearVelocity.copy(it.linearVelocity)) : lt.hasLinearVelocity = !1,
                it.angularVelocity ? (lt.hasAngularVelocity = !0,
                lt.angularVelocity.copy(it.angularVelocity)) : lt.hasAngularVelocity = !1));
        return st !== null && (st.visible = rt !== null),
        lt !== null && (lt.visible = it !== null),
        ut !== null && (ut.visible = ot !== null),
        this
    }
}
class DepthTexture extends Texture {
    constructor($, tt, nt, rt, it, ot, st, lt, ut, ct) {
        if (ct = ct !== void 0 ? ct : DepthFormat,
        ct !== DepthFormat && ct !== DepthStencilFormat)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        nt === void 0 && ct === DepthFormat && (nt = UnsignedShortType),
        nt === void 0 && ct === DepthStencilFormat && (nt = UnsignedInt248Type),
        super(null, rt, it, ot, st, lt, ct, nt, ut),
        this.image = {
            width: $,
            height: tt
        },
        this.magFilter = st !== void 0 ? st : NearestFilter,
        this.minFilter = lt !== void 0 ? lt : NearestFilter,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
DepthTexture.prototype.isDepthTexture = !0;
class WebXRManager extends EventDispatcher {
    constructor($, tt) {
        super();
        const nt = this;
        let rt = null
          , it = 1
          , ot = null
          , st = "local-floor"
          , lt = null
          , ut = null
          , ct = null
          , ht = null
          , ft = null;
        const gt = tt.getContextAttributes();
        let vt = null
          , yt = null;
        const wt = []
          , mt = new Map
          , _t = new PerspectiveCamera;
        _t.layers.enable(1),
        _t.viewport = new Vector4;
        const bt = new PerspectiveCamera;
        bt.layers.enable(2),
        bt.viewport = new Vector4;
        const Mt = [_t, bt]
          , St = new ArrayCamera;
        St.layers.enable(1),
        St.layers.enable(2);
        let At = null
          , Pt = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(Bt) {
            let Xt = wt[Bt];
            return Xt === void 0 && (Xt = new WebXRController,
            wt[Bt] = Xt),
            Xt.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(Bt) {
            let Xt = wt[Bt];
            return Xt === void 0 && (Xt = new WebXRController,
            wt[Bt] = Xt),
            Xt.getGripSpace()
        }
        ,
        this.getHand = function(Bt) {
            let Xt = wt[Bt];
            return Xt === void 0 && (Xt = new WebXRController,
            wt[Bt] = Xt),
            Xt.getHandSpace()
        }
        ;
        function Ot(Bt) {
            const Xt = mt.get(Bt.inputSource);
            Xt && Xt.dispatchEvent({
                type: Bt.type,
                data: Bt.inputSource
            })
        }
        function Zt() {
            mt.forEach(function(Bt, Xt) {
                Bt.disconnect(Xt)
            }),
            mt.clear(),
            At = null,
            Pt = null,
            $.setRenderTarget(vt),
            ht = null,
            ct = null,
            ut = null,
            rt = null,
            yt = null,
            jt.stop(),
            nt.isPresenting = !1,
            nt.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(Bt) {
            it = Bt,
            nt.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(Bt) {
            st = Bt,
            nt.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return ot
        }
        ,
        this.getBaseLayer = function() {
            return ct !== null ? ct : ht
        }
        ,
        this.getBinding = function() {
            return ut
        }
        ,
        this.getFrame = function() {
            return ft
        }
        ,
        this.getSession = function() {
            return rt
        }
        ,
        this.setSession = async function(Bt) {
            if (rt = Bt,
            rt !== null) {
                if (vt = $.getRenderTarget(),
                rt.addEventListener("select", Ot),
                rt.addEventListener("selectstart", Ot),
                rt.addEventListener("selectend", Ot),
                rt.addEventListener("squeeze", Ot),
                rt.addEventListener("squeezestart", Ot),
                rt.addEventListener("squeezeend", Ot),
                rt.addEventListener("end", Zt),
                rt.addEventListener("inputsourceschange", Nt),
                gt.xrCompatible !== !0 && await tt.makeXRCompatible(),
                rt.renderState.layers === void 0 || $.capabilities.isWebGL2 === !1) {
                    const Xt = {
                        antialias: rt.renderState.layers === void 0 ? gt.antialias : !0,
                        alpha: gt.alpha,
                        depth: gt.depth,
                        stencil: gt.stencil,
                        framebufferScaleFactor: it
                    };
                    ht = new XRWebGLLayer(rt,tt,Xt),
                    rt.updateRenderState({
                        baseLayer: ht
                    }),
                    yt = new WebGLRenderTarget(ht.framebufferWidth,ht.framebufferHeight,{
                        format: RGBAFormat,
                        type: UnsignedByteType,
                        encoding: $.outputEncoding
                    })
                } else {
                    let Xt = null
                      , Jt = null
                      , Lt = null;
                    gt.depth && (Lt = gt.stencil ? 35056 : 33190,
                    Xt = gt.stencil ? DepthStencilFormat : DepthFormat,
                    Jt = gt.stencil ? UnsignedInt248Type : UnsignedShortType);
                    const Rt = {
                        colorFormat: $.outputEncoding === sRGBEncoding ? 35907 : 32856,
                        depthFormat: Lt,
                        scaleFactor: it
                    };
                    ut = new XRWebGLBinding(rt,tt),
                    ct = ut.createProjectionLayer(Rt),
                    rt.updateRenderState({
                        layers: [ct]
                    }),
                    yt = new WebGLRenderTarget(ct.textureWidth,ct.textureHeight,{
                        format: RGBAFormat,
                        type: UnsignedByteType,
                        depthTexture: new DepthTexture(ct.textureWidth,ct.textureHeight,Jt,void 0,void 0,void 0,void 0,void 0,void 0,Xt),
                        stencilBuffer: gt.stencil,
                        encoding: $.outputEncoding,
                        samples: gt.antialias ? 4 : 0
                    });
                    const _n = $.properties.get(yt);
                    _n.__ignoreDepthValues = ct.ignoreDepthValues
                }
                yt.isXRRenderTarget = !0,
                this.setFoveation(1),
                ot = await rt.requestReferenceSpace(st),
                jt.setContext(rt),
                jt.start(),
                nt.isPresenting = !0,
                nt.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ;
        function Nt(Bt) {
            const Xt = rt.inputSources;
            for (let Jt = 0; Jt < wt.length; Jt++)
                mt.set(Xt[Jt], wt[Jt]);
            for (let Jt = 0; Jt < Bt.removed.length; Jt++) {
                const Lt = Bt.removed[Jt]
                  , Rt = mt.get(Lt);
                Rt && (Rt.dispatchEvent({
                    type: "disconnected",
                    data: Lt
                }),
                mt.delete(Lt))
            }
            for (let Jt = 0; Jt < Bt.added.length; Jt++) {
                const Lt = Bt.added[Jt]
                  , Rt = mt.get(Lt);
                Rt && Rt.dispatchEvent({
                    type: "connected",
                    data: Lt
                })
            }
        }
        const Tt = new Vector3
          , Ft = new Vector3;
        function $t(Bt, Xt, Jt) {
            Tt.setFromMatrixPosition(Xt.matrixWorld),
            Ft.setFromMatrixPosition(Jt.matrixWorld);
            const Lt = Tt.distanceTo(Ft)
              , Rt = Xt.projectionMatrix.elements
              , _n = Jt.projectionMatrix.elements
              , Fn = Rt[14] / (Rt[10] - 1)
              , Vn = Rt[14] / (Rt[10] + 1)
              , sn = (Rt[9] + 1) / Rt[5]
              , Un = (Rt[9] - 1) / Rt[5]
              , zn = (Rt[8] - 1) / Rt[0]
              , Rn = (_n[8] + 1) / _n[0]
              , Ln = Fn * zn
              , Gn = Fn * Rn
              , cn = Lt / (-zn + Rn)
              , bn = cn * -zn;
            Xt.matrixWorld.decompose(Bt.position, Bt.quaternion, Bt.scale),
            Bt.translateX(bn),
            Bt.translateZ(cn),
            Bt.matrixWorld.compose(Bt.position, Bt.quaternion, Bt.scale),
            Bt.matrixWorldInverse.copy(Bt.matrixWorld).invert();
            const Mn = Fn + cn
              , Dn = Vn + cn
              , Pn = Ln - bn
              , $n = Gn + (Lt - bn)
              , On = sn * Vn / Dn * Mn
              , Wn = Un * Vn / Dn * Mn;
            Bt.projectionMatrix.makePerspective(Pn, $n, On, Wn, Mn, Dn)
        }
        function Wt(Bt, Xt) {
            Xt === null ? Bt.matrixWorld.copy(Bt.matrix) : Bt.matrixWorld.multiplyMatrices(Xt.matrixWorld, Bt.matrix),
            Bt.matrixWorldInverse.copy(Bt.matrixWorld).invert()
        }
        this.updateCamera = function(Bt) {
            if (rt === null)
                return;
            St.near = bt.near = _t.near = Bt.near,
            St.far = bt.far = _t.far = Bt.far,
            (At !== St.near || Pt !== St.far) && (rt.updateRenderState({
                depthNear: St.near,
                depthFar: St.far
            }),
            At = St.near,
            Pt = St.far);
            const Xt = Bt.parent
              , Jt = St.cameras;
            Wt(St, Xt);
            for (let Rt = 0; Rt < Jt.length; Rt++)
                Wt(Jt[Rt], Xt);
            St.matrixWorld.decompose(St.position, St.quaternion, St.scale),
            Bt.position.copy(St.position),
            Bt.quaternion.copy(St.quaternion),
            Bt.scale.copy(St.scale),
            Bt.matrix.copy(St.matrix),
            Bt.matrixWorld.copy(St.matrixWorld);
            const Lt = Bt.children;
            for (let Rt = 0, _n = Lt.length; Rt < _n; Rt++)
                Lt[Rt].updateMatrixWorld(!0);
            Jt.length === 2 ? $t(St, _t, bt) : St.projectionMatrix.copy(_t.projectionMatrix)
        }
        ,
        this.getCamera = function() {
            return St
        }
        ,
        this.getFoveation = function() {
            if (ct !== null)
                return ct.fixedFoveation;
            if (ht !== null)
                return ht.fixedFoveation
        }
        ,
        this.setFoveation = function(Bt) {
            ct !== null && (ct.fixedFoveation = Bt),
            ht !== null && ht.fixedFoveation !== void 0 && (ht.fixedFoveation = Bt)
        }
        ;
        let Kt = null;
        function qt(Bt, Xt) {
            if (lt = Xt.getViewerPose(ot),
            ft = Xt,
            lt !== null) {
                const Lt = lt.views;
                ht !== null && ($.setRenderTargetFramebuffer(yt, ht.framebuffer),
                $.setRenderTarget(yt));
                let Rt = !1;
                Lt.length !== St.cameras.length && (St.cameras.length = 0,
                Rt = !0);
                for (let _n = 0; _n < Lt.length; _n++) {
                    const Fn = Lt[_n];
                    let Vn = null;
                    if (ht !== null)
                        Vn = ht.getViewport(Fn);
                    else {
                        const Un = ut.getViewSubImage(ct, Fn);
                        Vn = Un.viewport,
                        _n === 0 && ($.setRenderTargetTextures(yt, Un.colorTexture, ct.ignoreDepthValues ? void 0 : Un.depthStencilTexture),
                        $.setRenderTarget(yt))
                    }
                    const sn = Mt[_n];
                    sn.matrix.fromArray(Fn.transform.matrix),
                    sn.projectionMatrix.fromArray(Fn.projectionMatrix),
                    sn.viewport.set(Vn.x, Vn.y, Vn.width, Vn.height),
                    _n === 0 && St.matrix.copy(sn.matrix),
                    Rt === !0 && St.cameras.push(sn)
                }
            }
            const Jt = rt.inputSources;
            for (let Lt = 0; Lt < wt.length; Lt++) {
                const Rt = wt[Lt]
                  , _n = Jt[Lt];
                Rt.update(_n, Xt, ot)
            }
            Kt && Kt(Bt, Xt),
            ft = null
        }
        const jt = new WebGLAnimation;
        jt.setAnimationLoop(qt),
        this.setAnimationLoop = function(Bt) {
            Kt = Bt
        }
        ,
        this.dispose = function() {}
    }
}
function WebGLMaterials(et) {
    function $(mt, _t) {
        mt.fogColor.value.copy(_t.color),
        _t.isFog ? (mt.fogNear.value = _t.near,
        mt.fogFar.value = _t.far) : _t.isFogExp2 && (mt.fogDensity.value = _t.density)
    }
    function tt(mt, _t, bt, Mt, St) {
        _t.isMeshBasicMaterial ? nt(mt, _t) : _t.isMeshLambertMaterial ? (nt(mt, _t),
        lt(mt, _t)) : _t.isMeshToonMaterial ? (nt(mt, _t),
        ct(mt, _t)) : _t.isMeshPhongMaterial ? (nt(mt, _t),
        ut(mt, _t)) : _t.isMeshStandardMaterial ? (nt(mt, _t),
        _t.isMeshPhysicalMaterial ? ft(mt, _t, St) : ht(mt, _t)) : _t.isMeshMatcapMaterial ? (nt(mt, _t),
        gt(mt, _t)) : _t.isMeshDepthMaterial ? (nt(mt, _t),
        vt(mt, _t)) : _t.isMeshDistanceMaterial ? (nt(mt, _t),
        yt(mt, _t)) : _t.isMeshNormalMaterial ? (nt(mt, _t),
        wt(mt, _t)) : _t.isLineBasicMaterial ? (rt(mt, _t),
        _t.isLineDashedMaterial && it(mt, _t)) : _t.isPointsMaterial ? ot(mt, _t, bt, Mt) : _t.isSpriteMaterial ? st(mt, _t) : _t.isShadowMaterial ? (mt.color.value.copy(_t.color),
        mt.opacity.value = _t.opacity) : _t.isShaderMaterial && (_t.uniformsNeedUpdate = !1)
    }
    function nt(mt, _t) {
        mt.opacity.value = _t.opacity,
        _t.color && mt.diffuse.value.copy(_t.color),
        _t.emissive && mt.emissive.value.copy(_t.emissive).multiplyScalar(_t.emissiveIntensity),
        _t.map && (mt.map.value = _t.map),
        _t.alphaMap && (mt.alphaMap.value = _t.alphaMap),
        _t.specularMap && (mt.specularMap.value = _t.specularMap),
        _t.alphaTest > 0 && (mt.alphaTest.value = _t.alphaTest);
        const bt = et.get(_t).envMap;
        bt && (mt.envMap.value = bt,
        mt.flipEnvMap.value = bt.isCubeTexture && bt.isRenderTargetTexture === !1 ? -1 : 1,
        mt.reflectivity.value = _t.reflectivity,
        mt.ior.value = _t.ior,
        mt.refractionRatio.value = _t.refractionRatio),
        _t.lightMap && (mt.lightMap.value = _t.lightMap,
        mt.lightMapIntensity.value = _t.lightMapIntensity),
        _t.aoMap && (mt.aoMap.value = _t.aoMap,
        mt.aoMapIntensity.value = _t.aoMapIntensity);
        let Mt;
        _t.map ? Mt = _t.map : _t.specularMap ? Mt = _t.specularMap : _t.displacementMap ? Mt = _t.displacementMap : _t.normalMap ? Mt = _t.normalMap : _t.bumpMap ? Mt = _t.bumpMap : _t.roughnessMap ? Mt = _t.roughnessMap : _t.metalnessMap ? Mt = _t.metalnessMap : _t.alphaMap ? Mt = _t.alphaMap : _t.emissiveMap ? Mt = _t.emissiveMap : _t.clearcoatMap ? Mt = _t.clearcoatMap : _t.clearcoatNormalMap ? Mt = _t.clearcoatNormalMap : _t.clearcoatRoughnessMap ? Mt = _t.clearcoatRoughnessMap : _t.specularIntensityMap ? Mt = _t.specularIntensityMap : _t.specularColorMap ? Mt = _t.specularColorMap : _t.transmissionMap ? Mt = _t.transmissionMap : _t.thicknessMap ? Mt = _t.thicknessMap : _t.sheenColorMap ? Mt = _t.sheenColorMap : _t.sheenRoughnessMap && (Mt = _t.sheenRoughnessMap),
        Mt !== void 0 && (Mt.isWebGLRenderTarget && (Mt = Mt.texture),
        Mt.matrixAutoUpdate === !0 && Mt.updateMatrix(),
        mt.uvTransform.value.copy(Mt.matrix));
        let St;
        _t.aoMap ? St = _t.aoMap : _t.lightMap && (St = _t.lightMap),
        St !== void 0 && (St.isWebGLRenderTarget && (St = St.texture),
        St.matrixAutoUpdate === !0 && St.updateMatrix(),
        mt.uv2Transform.value.copy(St.matrix))
    }
    function rt(mt, _t) {
        mt.diffuse.value.copy(_t.color),
        mt.opacity.value = _t.opacity
    }
    function it(mt, _t) {
        mt.dashSize.value = _t.dashSize,
        mt.totalSize.value = _t.dashSize + _t.gapSize,
        mt.scale.value = _t.scale
    }
    function ot(mt, _t, bt, Mt) {
        mt.diffuse.value.copy(_t.color),
        mt.opacity.value = _t.opacity,
        mt.size.value = _t.size * bt,
        mt.scale.value = Mt * .5,
        _t.map && (mt.map.value = _t.map),
        _t.alphaMap && (mt.alphaMap.value = _t.alphaMap),
        _t.alphaTest > 0 && (mt.alphaTest.value = _t.alphaTest);
        let St;
        _t.map ? St = _t.map : _t.alphaMap && (St = _t.alphaMap),
        St !== void 0 && (St.matrixAutoUpdate === !0 && St.updateMatrix(),
        mt.uvTransform.value.copy(St.matrix))
    }
    function st(mt, _t) {
        mt.diffuse.value.copy(_t.color),
        mt.opacity.value = _t.opacity,
        mt.rotation.value = _t.rotation,
        _t.map && (mt.map.value = _t.map),
        _t.alphaMap && (mt.alphaMap.value = _t.alphaMap),
        _t.alphaTest > 0 && (mt.alphaTest.value = _t.alphaTest);
        let bt;
        _t.map ? bt = _t.map : _t.alphaMap && (bt = _t.alphaMap),
        bt !== void 0 && (bt.matrixAutoUpdate === !0 && bt.updateMatrix(),
        mt.uvTransform.value.copy(bt.matrix))
    }
    function lt(mt, _t) {
        _t.emissiveMap && (mt.emissiveMap.value = _t.emissiveMap)
    }
    function ut(mt, _t) {
        mt.specular.value.copy(_t.specular),
        mt.shininess.value = Math.max(_t.shininess, 1e-4),
        _t.emissiveMap && (mt.emissiveMap.value = _t.emissiveMap),
        _t.bumpMap && (mt.bumpMap.value = _t.bumpMap,
        mt.bumpScale.value = _t.bumpScale,
        _t.side === BackSide && (mt.bumpScale.value *= -1)),
        _t.normalMap && (mt.normalMap.value = _t.normalMap,
        mt.normalScale.value.copy(_t.normalScale),
        _t.side === BackSide && mt.normalScale.value.negate()),
        _t.displacementMap && (mt.displacementMap.value = _t.displacementMap,
        mt.displacementScale.value = _t.displacementScale,
        mt.displacementBias.value = _t.displacementBias)
    }
    function ct(mt, _t) {
        _t.gradientMap && (mt.gradientMap.value = _t.gradientMap),
        _t.emissiveMap && (mt.emissiveMap.value = _t.emissiveMap),
        _t.bumpMap && (mt.bumpMap.value = _t.bumpMap,
        mt.bumpScale.value = _t.bumpScale,
        _t.side === BackSide && (mt.bumpScale.value *= -1)),
        _t.normalMap && (mt.normalMap.value = _t.normalMap,
        mt.normalScale.value.copy(_t.normalScale),
        _t.side === BackSide && mt.normalScale.value.negate()),
        _t.displacementMap && (mt.displacementMap.value = _t.displacementMap,
        mt.displacementScale.value = _t.displacementScale,
        mt.displacementBias.value = _t.displacementBias)
    }
    function ht(mt, _t) {
        mt.roughness.value = _t.roughness,
        mt.metalness.value = _t.metalness,
        _t.roughnessMap && (mt.roughnessMap.value = _t.roughnessMap),
        _t.metalnessMap && (mt.metalnessMap.value = _t.metalnessMap),
        _t.emissiveMap && (mt.emissiveMap.value = _t.emissiveMap),
        _t.bumpMap && (mt.bumpMap.value = _t.bumpMap,
        mt.bumpScale.value = _t.bumpScale,
        _t.side === BackSide && (mt.bumpScale.value *= -1)),
        _t.normalMap && (mt.normalMap.value = _t.normalMap,
        mt.normalScale.value.copy(_t.normalScale),
        _t.side === BackSide && mt.normalScale.value.negate()),
        _t.displacementMap && (mt.displacementMap.value = _t.displacementMap,
        mt.displacementScale.value = _t.displacementScale,
        mt.displacementBias.value = _t.displacementBias),
        et.get(_t).envMap && (mt.envMapIntensity.value = _t.envMapIntensity)
    }
    function ft(mt, _t, bt) {
        ht(mt, _t),
        mt.ior.value = _t.ior,
        _t.sheen > 0 && (mt.sheenColor.value.copy(_t.sheenColor).multiplyScalar(_t.sheen),
        mt.sheenRoughness.value = _t.sheenRoughness,
        _t.sheenColorMap && (mt.sheenColorMap.value = _t.sheenColorMap),
        _t.sheenRoughnessMap && (mt.sheenRoughnessMap.value = _t.sheenRoughnessMap)),
        _t.clearcoat > 0 && (mt.clearcoat.value = _t.clearcoat,
        mt.clearcoatRoughness.value = _t.clearcoatRoughness,
        _t.clearcoatMap && (mt.clearcoatMap.value = _t.clearcoatMap),
        _t.clearcoatRoughnessMap && (mt.clearcoatRoughnessMap.value = _t.clearcoatRoughnessMap),
        _t.clearcoatNormalMap && (mt.clearcoatNormalScale.value.copy(_t.clearcoatNormalScale),
        mt.clearcoatNormalMap.value = _t.clearcoatNormalMap,
        _t.side === BackSide && mt.clearcoatNormalScale.value.negate())),
        _t.transmission > 0 && (mt.transmission.value = _t.transmission,
        mt.transmissionSamplerMap.value = bt.texture,
        mt.transmissionSamplerSize.value.set(bt.width, bt.height),
        _t.transmissionMap && (mt.transmissionMap.value = _t.transmissionMap),
        mt.thickness.value = _t.thickness,
        _t.thicknessMap && (mt.thicknessMap.value = _t.thicknessMap),
        mt.attenuationDistance.value = _t.attenuationDistance,
        mt.attenuationColor.value.copy(_t.attenuationColor)),
        mt.specularIntensity.value = _t.specularIntensity,
        mt.specularColor.value.copy(_t.specularColor),
        _t.specularIntensityMap && (mt.specularIntensityMap.value = _t.specularIntensityMap),
        _t.specularColorMap && (mt.specularColorMap.value = _t.specularColorMap)
    }
    function gt(mt, _t) {
        _t.matcap && (mt.matcap.value = _t.matcap),
        _t.bumpMap && (mt.bumpMap.value = _t.bumpMap,
        mt.bumpScale.value = _t.bumpScale,
        _t.side === BackSide && (mt.bumpScale.value *= -1)),
        _t.normalMap && (mt.normalMap.value = _t.normalMap,
        mt.normalScale.value.copy(_t.normalScale),
        _t.side === BackSide && mt.normalScale.value.negate()),
        _t.displacementMap && (mt.displacementMap.value = _t.displacementMap,
        mt.displacementScale.value = _t.displacementScale,
        mt.displacementBias.value = _t.displacementBias)
    }
    function vt(mt, _t) {
        _t.displacementMap && (mt.displacementMap.value = _t.displacementMap,
        mt.displacementScale.value = _t.displacementScale,
        mt.displacementBias.value = _t.displacementBias)
    }
    function yt(mt, _t) {
        _t.displacementMap && (mt.displacementMap.value = _t.displacementMap,
        mt.displacementScale.value = _t.displacementScale,
        mt.displacementBias.value = _t.displacementBias),
        mt.referencePosition.value.copy(_t.referencePosition),
        mt.nearDistance.value = _t.nearDistance,
        mt.farDistance.value = _t.farDistance
    }
    function wt(mt, _t) {
        _t.bumpMap && (mt.bumpMap.value = _t.bumpMap,
        mt.bumpScale.value = _t.bumpScale,
        _t.side === BackSide && (mt.bumpScale.value *= -1)),
        _t.normalMap && (mt.normalMap.value = _t.normalMap,
        mt.normalScale.value.copy(_t.normalScale),
        _t.side === BackSide && mt.normalScale.value.negate()),
        _t.displacementMap && (mt.displacementMap.value = _t.displacementMap,
        mt.displacementScale.value = _t.displacementScale,
        mt.displacementBias.value = _t.displacementBias)
    }
    return {
        refreshFogUniforms: $,
        refreshMaterialUniforms: tt
    }
}
function createCanvasElement() {
    const et = createElementNS("canvas");
    return et.style.display = "block",
    et
}
function WebGLRenderer(et={}) {
    const $ = et.canvas !== void 0 ? et.canvas : createCanvasElement()
      , tt = et.context !== void 0 ? et.context : null
      , nt = et.depth !== void 0 ? et.depth : !0
      , rt = et.stencil !== void 0 ? et.stencil : !0
      , it = et.antialias !== void 0 ? et.antialias : !1
      , ot = et.premultipliedAlpha !== void 0 ? et.premultipliedAlpha : !0
      , st = et.preserveDrawingBuffer !== void 0 ? et.preserveDrawingBuffer : !1
      , lt = et.powerPreference !== void 0 ? et.powerPreference : "default"
      , ut = et.failIfMajorPerformanceCaveat !== void 0 ? et.failIfMajorPerformanceCaveat : !1;
    let ct;
    et.context !== void 0 ? ct = tt.getContextAttributes().alpha : ct = et.alpha !== void 0 ? et.alpha : !1;
    let ht = null
      , ft = null;
    const gt = []
      , vt = [];
    this.domElement = $,
    this.debug = {
        checkShaderErrors: !0
    },
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.outputEncoding = LinearEncoding,
    this.physicallyCorrectLights = !1,
    this.toneMapping = NoToneMapping,
    this.toneMappingExposure = 1;
    const yt = this;
    let wt = !1
      , mt = 0
      , _t = 0
      , bt = null
      , Mt = -1
      , St = null;
    const At = new Vector4
      , Pt = new Vector4;
    let Ot = null
      , Zt = $.width
      , Nt = $.height
      , Tt = 1
      , Ft = null
      , $t = null;
    const Wt = new Vector4(0,0,Zt,Nt)
      , Kt = new Vector4(0,0,Zt,Nt);
    let qt = !1;
    const jt = new Frustum;
    let Bt = !1
      , Xt = !1
      , Jt = null;
    const Lt = new Matrix4
      , Rt = new Vector2
      , _n = new Vector3
      , Fn = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function Vn() {
        return bt === null ? Tt : 1
    }
    let sn = tt;
    function Un(It, Qt) {
        for (let dn = 0; dn < It.length; dn++) {
            const ln = It[dn]
              , gn = $.getContext(ln, Qt);
            if (gn !== null)
                return gn
        }
        return null
    }
    try {
        const It = {
            alpha: !0,
            depth: nt,
            stencil: rt,
            antialias: it,
            premultipliedAlpha: ot,
            preserveDrawingBuffer: st,
            powerPreference: lt,
            failIfMajorPerformanceCaveat: ut
        };
        if ("setAttribute"in $ && $.setAttribute("data-engine", `three.js r ${REVISION}`),
        $.addEventListener("webglcontextlost", Ut, !1),
        $.addEventListener("webglcontextrestored", Cn, !1),
        sn === null) {
            const Qt = ["webgl2", "webgl", "experimental-webgl"];
            if (yt.isWebGL1Renderer === !0 && Qt.shift(),
            sn = Un(Qt, It),
            sn === null)
                throw Un(Qt) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        sn.getShaderPrecisionFormat === void 0 && (sn.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        )
    } catch (It) {
        throw console.error("THREE.WebGLRenderer: " + It.message),
        It
    }
    let zn, Rn, Ln, Gn, cn, bn, Mn, Dn, Pn, $n, On, Wn, rr, Dt, kt, pn, mn, An, In, Gt, Ht, Vt, hn;
    function vn() {
        zn = new WebGLExtensions(sn),
        Rn = new WebGLCapabilities(sn,zn,et),
        zn.init(Rn),
        Vt = new WebGLUtils(sn,zn,Rn),
        Ln = new WebGLState(sn,zn,Rn),
        Gn = new WebGLInfo(sn),
        cn = new WebGLProperties,
        bn = new WebGLTextures(sn,zn,Ln,cn,Rn,Vt,Gn),
        Mn = new WebGLCubeMaps(yt),
        Dn = new WebGLCubeUVMaps(yt),
        Pn = new WebGLAttributes(sn,Rn),
        hn = new WebGLBindingStates(sn,zn,Pn,Rn),
        $n = new WebGLGeometries(sn,Pn,Gn,hn),
        On = new WebGLObjects(sn,$n,Pn,Gn),
        In = new WebGLMorphtargets(sn,Rn,bn),
        pn = new WebGLClipping(cn),
        Wn = new WebGLPrograms(yt,Mn,Dn,zn,Rn,hn,pn),
        rr = new WebGLMaterials(cn),
        Dt = new WebGLRenderLists,
        kt = new WebGLRenderStates(zn,Rn),
        An = new WebGLBackground(yt,Mn,Ln,On,ct,ot),
        mn = new WebGLShadowMap(yt,On,Rn),
        Gt = new WebGLBufferRenderer(sn,zn,Gn,Rn),
        Ht = new WebGLIndexedBufferRenderer(sn,zn,Gn,Rn),
        Gn.programs = Wn.programs,
        yt.capabilities = Rn,
        yt.extensions = zn,
        yt.properties = cn,
        yt.renderLists = Dt,
        yt.shadowMap = mn,
        yt.state = Ln,
        yt.info = Gn
    }
    vn();
    const En = new WebXRManager(yt,sn);
    this.xr = En,
    this.getContext = function() {
        return sn
    }
    ,
    this.getContextAttributes = function() {
        return sn.getContextAttributes()
    }
    ,
    this.forceContextLoss = function() {
        const It = zn.get("WEBGL_lose_context");
        It && It.loseContext()
    }
    ,
    this.forceContextRestore = function() {
        const It = zn.get("WEBGL_lose_context");
        It && It.restoreContext()
    }
    ,
    this.getPixelRatio = function() {
        return Tt
    }
    ,
    this.setPixelRatio = function(It) {
        It !== void 0 && (Tt = It,
        this.setSize(Zt, Nt, !1))
    }
    ,
    this.getSize = function(It) {
        return It.set(Zt, Nt)
    }
    ,
    this.setSize = function(It, Qt, dn) {
        if (En.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
        }
        Zt = It,
        Nt = Qt,
        $.width = Math.floor(It * Tt),
        $.height = Math.floor(Qt * Tt),
        dn !== !1 && ($.style.width = It + "px",
        $.style.height = Qt + "px"),
        this.setViewport(0, 0, It, Qt)
    }
    ,
    this.getDrawingBufferSize = function(It) {
        return It.set(Zt * Tt, Nt * Tt).floor()
    }
    ,
    this.setDrawingBufferSize = function(It, Qt, dn) {
        Zt = It,
        Nt = Qt,
        Tt = dn,
        $.width = Math.floor(It * dn),
        $.height = Math.floor(Qt * dn),
        this.setViewport(0, 0, It, Qt)
    }
    ,
    this.getCurrentViewport = function(It) {
        return It.copy(At)
    }
    ,
    this.getViewport = function(It) {
        return It.copy(Wt)
    }
    ,
    this.setViewport = function(It, Qt, dn, ln) {
        It.isVector4 ? Wt.set(It.x, It.y, It.z, It.w) : Wt.set(It, Qt, dn, ln),
        Ln.viewport(At.copy(Wt).multiplyScalar(Tt).floor())
    }
    ,
    this.getScissor = function(It) {
        return It.copy(Kt)
    }
    ,
    this.setScissor = function(It, Qt, dn, ln) {
        It.isVector4 ? Kt.set(It.x, It.y, It.z, It.w) : Kt.set(It, Qt, dn, ln),
        Ln.scissor(Pt.copy(Kt).multiplyScalar(Tt).floor())
    }
    ,
    this.getScissorTest = function() {
        return qt
    }
    ,
    this.setScissorTest = function(It) {
        Ln.setScissorTest(qt = It)
    }
    ,
    this.setOpaqueSort = function(It) {
        Ft = It
    }
    ,
    this.setTransparentSort = function(It) {
        $t = It
    }
    ,
    this.getClearColor = function(It) {
        return It.copy(An.getClearColor())
    }
    ,
    this.setClearColor = function() {
        An.setClearColor.apply(An, arguments)
    }
    ,
    this.getClearAlpha = function() {
        return An.getClearAlpha()
    }
    ,
    this.setClearAlpha = function() {
        An.setClearAlpha.apply(An, arguments)
    }
    ,
    this.clear = function(It=!0, Qt=!0, dn=!0) {
        let ln = 0;
        It && (ln |= 16384),
        Qt && (ln |= 256),
        dn && (ln |= 1024),
        sn.clear(ln)
    }
    ,
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    }
    ,
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }
    ,
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }
    ,
    this.dispose = function() {
        $.removeEventListener("webglcontextlost", Ut, !1),
        $.removeEventListener("webglcontextrestored", Cn, !1),
        Dt.dispose(),
        kt.dispose(),
        cn.dispose(),
        Mn.dispose(),
        Dn.dispose(),
        On.dispose(),
        hn.dispose(),
        Wn.dispose(),
        En.dispose(),
        En.removeEventListener("sessionstart", Jn),
        En.removeEventListener("sessionend", dr),
        Jt && (Jt.dispose(),
        Jt = null),
        Qn.stop()
    }
    ;
    function Ut(It) {
        It.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        wt = !0
    }
    function Cn() {
        console.log("THREE.WebGLRenderer: Context Restored."),
        wt = !1;
        const It = Gn.autoReset
          , Qt = mn.enabled
          , dn = mn.autoUpdate
          , ln = mn.needsUpdate
          , gn = mn.type;
        vn(),
        Gn.autoReset = It,
        mn.enabled = Qt,
        mn.autoUpdate = dn,
        mn.needsUpdate = ln,
        mn.type = gn
    }
    function Tn(It) {
        const Qt = It.target;
        Qt.removeEventListener("dispose", Tn),
        Hn(Qt)
    }
    function Hn(It) {
        yn(It),
        cn.remove(It)
    }
    function yn(It) {
        const Qt = cn.get(It).programs;
        Qt !== void 0 && (Qt.forEach(function(dn) {
            Wn.releaseProgram(dn)
        }),
        It.isShaderMaterial && Wn.releaseShaderCache(It))
    }
    this.renderBufferDirect = function(It, Qt, dn, ln, gn, jn) {
        Qt === null && (Qt = Fn);
        const Xn = gn.isMesh && gn.matrixWorld.determinant() < 0
          , Zn = so(It, Qt, dn, ln, gn);
        Ln.setMaterial(ln, Xn);
        let Yn = dn.index;
        const sr = dn.attributes.position;
        if (Yn === null) {
            if (sr === void 0 || sr.count === 0)
                return
        } else if (Yn.count === 0)
            return;
        let Kn = 1;
        ln.wireframe === !0 && (Yn = $n.getWireframeAttribute(dn),
        Kn = 2),
        hn.setup(gn, ln, Zn, dn, Yn);
        let tr, ur = Gt;
        Yn !== null && (tr = Pn.get(Yn),
        ur = Ht,
        ur.setIndex(tr));
        const Cr = Yn !== null ? Yn.count : sr.count
          , Tr = dn.drawRange.start * Kn
          , Dr = dn.drawRange.count * Kn
          , yr = jn !== null ? jn.start * Kn : 0
          , ir = jn !== null ? jn.count * Kn : 1 / 0
          , vr = Math.max(Tr, yr)
          , lr = Math.min(Cr, Tr + Dr, yr + ir) - 1
          , br = Math.max(0, lr - vr + 1);
        if (br !== 0) {
            if (gn.isMesh)
                ln.wireframe === !0 ? (Ln.setLineWidth(ln.wireframeLinewidth * Vn()),
                ur.setMode(1)) : ur.setMode(4);
            else if (gn.isLine) {
                let Er = ln.linewidth;
                Er === void 0 && (Er = 1),
                Ln.setLineWidth(Er * Vn()),
                gn.isLineSegments ? ur.setMode(1) : gn.isLineLoop ? ur.setMode(2) : ur.setMode(3)
            } else
                gn.isPoints ? ur.setMode(0) : gn.isSprite && ur.setMode(4);
            if (gn.isInstancedMesh)
                ur.renderInstances(vr, br, gn.count);
            else if (dn.isInstancedBufferGeometry) {
                const Er = Math.min(dn.instanceCount, dn._maxInstanceCount);
                ur.renderInstances(vr, br, Er)
            } else
                ur.render(vr, br)
        }
    }
    ,
    this.compile = function(It, Qt) {
        ft = kt.get(It),
        ft.init(),
        vt.push(ft),
        It.traverseVisible(function(dn) {
            dn.isLight && dn.layers.test(Qt.layers) && (ft.pushLight(dn),
            dn.castShadow && ft.pushShadow(dn))
        }),
        ft.setupLights(yt.physicallyCorrectLights),
        It.traverse(function(dn) {
            const ln = dn.material;
            if (ln)
                if (Array.isArray(ln))
                    for (let gn = 0; gn < ln.length; gn++) {
                        const jn = ln[gn];
                        Ir(jn, It, dn)
                    }
                else
                    Ir(ln, It, dn)
        }),
        vt.pop(),
        ft = null
    }
    ;
    let xn = null;
    function Nn(It) {
        xn && xn(It)
    }
    function Jn() {
        Qn.stop()
    }
    function dr() {
        Qn.start()
    }
    const Qn = new WebGLAnimation;
    Qn.setAnimationLoop(Nn),
    typeof window != "undefined" && Qn.setContext(window),
    this.setAnimationLoop = function(It) {
        xn = It,
        En.setAnimationLoop(It),
        It === null ? Qn.stop() : Qn.start()
    }
    ,
    En.addEventListener("sessionstart", Jn),
    En.addEventListener("sessionend", dr),
    this.render = function(It, Qt) {
        if (Qt !== void 0 && Qt.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        if (wt === !0)
            return;
        It.autoUpdate === !0 && It.updateMatrixWorld(),
        Qt.parent === null && Qt.updateMatrixWorld(),
        En.enabled === !0 && En.isPresenting === !0 && (En.cameraAutoUpdate === !0 && En.updateCamera(Qt),
        Qt = En.getCamera()),
        It.isScene === !0 && It.onBeforeRender(yt, It, Qt, bt),
        ft = kt.get(It, vt.length),
        ft.init(),
        vt.push(ft),
        Lt.multiplyMatrices(Qt.projectionMatrix, Qt.matrixWorldInverse),
        jt.setFromProjectionMatrix(Lt),
        Xt = this.localClippingEnabled,
        Bt = pn.init(this.clippingPlanes, Xt, Qt),
        ht = Dt.get(It, gt.length),
        ht.init(),
        gt.push(ht),
        _r(It, Qt, 0, yt.sortObjects),
        ht.finish(),
        yt.sortObjects === !0 && ht.sort(Ft, $t),
        Bt === !0 && pn.beginShadows();
        const dn = ft.state.shadowsArray;
        if (mn.render(dn, It, Qt),
        Bt === !0 && pn.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        An.render(ht, It),
        ft.setupLights(yt.physicallyCorrectLights),
        Qt.isArrayCamera) {
            const ln = Qt.cameras;
            for (let gn = 0, jn = ln.length; gn < jn; gn++) {
                const Xn = ln[gn];
                hr(ht, It, Xn, Xn.viewport)
            }
        } else
            hr(ht, It, Qt);
        bt !== null && (bn.updateMultisampleRenderTarget(bt),
        bn.updateRenderTargetMipmap(bt)),
        It.isScene === !0 && It.onAfterRender(yt, It, Qt),
        hn.resetDefaultState(),
        Mt = -1,
        St = null,
        vt.pop(),
        vt.length > 0 ? ft = vt[vt.length - 1] : ft = null,
        gt.pop(),
        gt.length > 0 ? ht = gt[gt.length - 1] : ht = null
    }
    ;
    function _r(It, Qt, dn, ln) {
        if (It.visible === !1)
            return;
        if (It.layers.test(Qt.layers)) {
            if (It.isGroup)
                dn = It.renderOrder;
            else if (It.isLOD)
                It.autoUpdate === !0 && It.update(Qt);
            else if (It.isLight)
                ft.pushLight(It),
                It.castShadow && ft.pushShadow(It);
            else if (It.isSprite) {
                if (!It.frustumCulled || jt.intersectsSprite(It)) {
                    ln && _n.setFromMatrixPosition(It.matrixWorld).applyMatrix4(Lt);
                    const Xn = On.update(It)
                      , Zn = It.material;
                    Zn.visible && ht.push(It, Xn, Zn, dn, _n.z, null)
                }
            } else if ((It.isMesh || It.isLine || It.isPoints) && (It.isSkinnedMesh && It.skeleton.frame !== Gn.render.frame && (It.skeleton.update(),
            It.skeleton.frame = Gn.render.frame),
            !It.frustumCulled || jt.intersectsObject(It))) {
                ln && _n.setFromMatrixPosition(It.matrixWorld).applyMatrix4(Lt);
                const Xn = On.update(It)
                  , Zn = It.material;
                if (Array.isArray(Zn)) {
                    const Yn = Xn.groups;
                    for (let sr = 0, Kn = Yn.length; sr < Kn; sr++) {
                        const tr = Yn[sr]
                          , ur = Zn[tr.materialIndex];
                        ur && ur.visible && ht.push(It, Xn, ur, dn, _n.z, tr)
                    }
                } else
                    Zn.visible && ht.push(It, Xn, Zn, dn, _n.z, null)
            }
        }
        const jn = It.children;
        for (let Xn = 0, Zn = jn.length; Xn < Zn; Xn++)
            _r(jn[Xn], Qt, dn, ln)
    }
    function hr(It, Qt, dn, ln) {
        const gn = It.opaque
          , jn = It.transmissive
          , Xn = It.transparent;
        ft.setupLightsView(dn),
        jn.length > 0 && Do(gn, Qt, dn),
        ln && Ln.viewport(At.copy(ln)),
        gn.length > 0 && Mr(gn, Qt, dn),
        jn.length > 0 && Mr(jn, Qt, dn),
        Xn.length > 0 && Mr(Xn, Qt, dn),
        Ln.buffers.depth.setTest(!0),
        Ln.buffers.depth.setMask(!0),
        Ln.buffers.color.setMask(!0),
        Ln.setPolygonOffset(!1)
    }
    function Do(It, Qt, dn) {
        const ln = Rn.isWebGL2;
        Jt === null && (Jt = new WebGLRenderTarget(1,1,{
            generateMipmaps: !0,
            type: Vt.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
            minFilter: LinearMipmapLinearFilter,
            samples: ln && it === !0 ? 4 : 0
        })),
        yt.getDrawingBufferSize(Rt),
        ln ? Jt.setSize(Rt.x, Rt.y) : Jt.setSize(floorPowerOfTwo(Rt.x), floorPowerOfTwo(Rt.y));
        const gn = yt.getRenderTarget();
        yt.setRenderTarget(Jt),
        yt.clear();
        const jn = yt.toneMapping;
        yt.toneMapping = NoToneMapping,
        Mr(It, Qt, dn),
        yt.toneMapping = jn,
        bn.updateMultisampleRenderTarget(Jt),
        bn.updateRenderTargetMipmap(Jt),
        yt.setRenderTarget(gn)
    }
    function Mr(It, Qt, dn) {
        const ln = Qt.isScene === !0 ? Qt.overrideMaterial : null;
        for (let gn = 0, jn = It.length; gn < jn; gn++) {
            const Xn = It[gn]
              , Zn = Xn.object
              , Yn = Xn.geometry
              , sr = ln === null ? Xn.material : ln
              , Kn = Xn.group;
            Zn.layers.test(dn.layers) && wo(Zn, Qt, dn, Yn, sr, Kn)
        }
    }
    function wo(It, Qt, dn, ln, gn, jn) {
        It.onBeforeRender(yt, Qt, dn, ln, gn, jn),
        It.modelViewMatrix.multiplyMatrices(dn.matrixWorldInverse, It.matrixWorld),
        It.normalMatrix.getNormalMatrix(It.modelViewMatrix),
        gn.onBeforeRender(yt, Qt, dn, ln, It, jn),
        gn.transparent === !0 && gn.side === DoubleSide ? (gn.side = BackSide,
        gn.needsUpdate = !0,
        yt.renderBufferDirect(dn, Qt, ln, gn, It, jn),
        gn.side = FrontSide,
        gn.needsUpdate = !0,
        yt.renderBufferDirect(dn, Qt, ln, gn, It, jn),
        gn.side = DoubleSide) : yt.renderBufferDirect(dn, Qt, ln, gn, It, jn),
        It.onAfterRender(yt, Qt, dn, ln, gn, jn)
    }
    function Ir(It, Qt, dn) {
        Qt.isScene !== !0 && (Qt = Fn);
        const ln = cn.get(It)
          , gn = ft.state.lights
          , jn = ft.state.shadowsArray
          , Xn = gn.state.version
          , Zn = Wn.getParameters(It, gn.state, jn, Qt, dn)
          , Yn = Wn.getProgramCacheKey(Zn);
        let sr = ln.programs;
        ln.environment = It.isMeshStandardMaterial ? Qt.environment : null,
        ln.fog = Qt.fog,
        ln.envMap = (It.isMeshStandardMaterial ? Dn : Mn).get(It.envMap || ln.environment),
        sr === void 0 && (It.addEventListener("dispose", Tn),
        sr = new Map,
        ln.programs = sr);
        let Kn = sr.get(Yn);
        if (Kn !== void 0) {
            if (ln.currentProgram === Kn && ln.lightsStateVersion === Xn)
                return Yr(It, Zn),
                Kn
        } else
            Zn.uniforms = Wn.getUniforms(It),
            It.onBuild(dn, Zn, yt),
            It.onBeforeCompile(Zn, yt),
            Kn = Wn.acquireProgram(Zn, Yn),
            sr.set(Yn, Kn),
            ln.uniforms = Zn.uniforms;
        const tr = ln.uniforms;
        (!It.isShaderMaterial && !It.isRawShaderMaterial || It.clipping === !0) && (tr.clippingPlanes = pn.uniform),
        Yr(It, Zn),
        ln.needsLights = Oo(It),
        ln.lightsStateVersion = Xn,
        ln.needsLights && (tr.ambientLightColor.value = gn.state.ambient,
        tr.lightProbe.value = gn.state.probe,
        tr.directionalLights.value = gn.state.directional,
        tr.directionalLightShadows.value = gn.state.directionalShadow,
        tr.spotLights.value = gn.state.spot,
        tr.spotLightShadows.value = gn.state.spotShadow,
        tr.rectAreaLights.value = gn.state.rectArea,
        tr.ltc_1.value = gn.state.rectAreaLTC1,
        tr.ltc_2.value = gn.state.rectAreaLTC2,
        tr.pointLights.value = gn.state.point,
        tr.pointLightShadows.value = gn.state.pointShadow,
        tr.hemisphereLights.value = gn.state.hemi,
        tr.directionalShadowMap.value = gn.state.directionalShadowMap,
        tr.directionalShadowMatrix.value = gn.state.directionalShadowMatrix,
        tr.spotShadowMap.value = gn.state.spotShadowMap,
        tr.spotShadowMatrix.value = gn.state.spotShadowMatrix,
        tr.pointShadowMap.value = gn.state.pointShadowMap,
        tr.pointShadowMatrix.value = gn.state.pointShadowMatrix);
        const ur = Kn.getUniforms()
          , Cr = WebGLUniforms.seqWithValue(ur.seq, tr);
        return ln.currentProgram = Kn,
        ln.uniformsList = Cr,
        Kn
    }
    function Yr(It, Qt) {
        const dn = cn.get(It);
        dn.outputEncoding = Qt.outputEncoding,
        dn.instancing = Qt.instancing,
        dn.skinning = Qt.skinning,
        dn.morphTargets = Qt.morphTargets,
        dn.morphNormals = Qt.morphNormals,
        dn.morphColors = Qt.morphColors,
        dn.morphTargetsCount = Qt.morphTargetsCount,
        dn.numClippingPlanes = Qt.numClippingPlanes,
        dn.numIntersection = Qt.numClipIntersection,
        dn.vertexAlphas = Qt.vertexAlphas,
        dn.vertexTangents = Qt.vertexTangents,
        dn.toneMapping = Qt.toneMapping
    }
    function so(It, Qt, dn, ln, gn) {
        Qt.isScene !== !0 && (Qt = Fn),
        bn.resetTextureUnits();
        const jn = Qt.fog
          , Xn = ln.isMeshStandardMaterial ? Qt.environment : null
          , Zn = bt === null ? yt.outputEncoding : bt.isXRRenderTarget === !0 ? bt.texture.encoding : LinearEncoding
          , Yn = (ln.isMeshStandardMaterial ? Dn : Mn).get(ln.envMap || Xn)
          , sr = ln.vertexColors === !0 && !!dn.attributes.color && dn.attributes.color.itemSize === 4
          , Kn = !!ln.normalMap && !!dn.attributes.tangent
          , tr = !!dn.morphAttributes.position
          , ur = !!dn.morphAttributes.normal
          , Cr = !!dn.morphAttributes.color
          , Tr = ln.toneMapped ? yt.toneMapping : NoToneMapping
          , Dr = dn.morphAttributes.position || dn.morphAttributes.normal || dn.morphAttributes.color
          , yr = Dr !== void 0 ? Dr.length : 0
          , ir = cn.get(ln)
          , vr = ft.state.lights;
        if (Bt === !0 && (Xt === !0 || It !== St)) {
            const gr = It === St && ln.id === Mt;
            pn.setState(ln, It, gr)
        }
        let lr = !1;
        ln.version === ir.__version ? (ir.needsLights && ir.lightsStateVersion !== vr.state.version || ir.outputEncoding !== Zn || gn.isInstancedMesh && ir.instancing === !1 || !gn.isInstancedMesh && ir.instancing === !0 || gn.isSkinnedMesh && ir.skinning === !1 || !gn.isSkinnedMesh && ir.skinning === !0 || ir.envMap !== Yn || ln.fog && ir.fog !== jn || ir.numClippingPlanes !== void 0 && (ir.numClippingPlanes !== pn.numPlanes || ir.numIntersection !== pn.numIntersection) || ir.vertexAlphas !== sr || ir.vertexTangents !== Kn || ir.morphTargets !== tr || ir.morphNormals !== ur || ir.morphColors !== Cr || ir.toneMapping !== Tr || Rn.isWebGL2 === !0 && ir.morphTargetsCount !== yr) && (lr = !0) : (lr = !0,
        ir.__version = ln.version);
        let br = ir.currentProgram;
        lr === !0 && (br = Ir(ln, Qt, gn));
        let Er = !1
          , Fr = !1
          , Zr = !1;
        const pr = br.getUniforms()
          , Or = ir.uniforms;
        if (Ln.useProgram(br.program) && (Er = !0,
        Fr = !0,
        Zr = !0),
        ln.id !== Mt && (Mt = ln.id,
        Fr = !0),
        Er || St !== It) {
            if (pr.setValue(sn, "projectionMatrix", It.projectionMatrix),
            Rn.logarithmicDepthBuffer && pr.setValue(sn, "logDepthBufFC", 2 / (Math.log(It.far + 1) / Math.LN2)),
            St !== It && (St = It,
            Fr = !0,
            Zr = !0),
            ln.isShaderMaterial || ln.isMeshPhongMaterial || ln.isMeshToonMaterial || ln.isMeshStandardMaterial || ln.envMap) {
                const gr = pr.map.cameraPosition;
                gr !== void 0 && gr.setValue(sn, _n.setFromMatrixPosition(It.matrixWorld))
            }
            (ln.isMeshPhongMaterial || ln.isMeshToonMaterial || ln.isMeshLambertMaterial || ln.isMeshBasicMaterial || ln.isMeshStandardMaterial || ln.isShaderMaterial) && pr.setValue(sn, "isOrthographic", It.isOrthographicCamera === !0),
            (ln.isMeshPhongMaterial || ln.isMeshToonMaterial || ln.isMeshLambertMaterial || ln.isMeshBasicMaterial || ln.isMeshStandardMaterial || ln.isShaderMaterial || ln.isShadowMaterial || gn.isSkinnedMesh) && pr.setValue(sn, "viewMatrix", It.matrixWorldInverse)
        }
        if (gn.isSkinnedMesh) {
            pr.setOptional(sn, gn, "bindMatrix"),
            pr.setOptional(sn, gn, "bindMatrixInverse");
            const gr = gn.skeleton;
            gr && (Rn.floatVertexTextures ? (gr.boneTexture === null && gr.computeBoneTexture(),
            pr.setValue(sn, "boneTexture", gr.boneTexture, bn),
            pr.setValue(sn, "boneTextureSize", gr.boneTextureSize)) : pr.setOptional(sn, gr, "boneMatrices"))
        }
        const ao = dn.morphAttributes;
        return (ao.position !== void 0 || ao.normal !== void 0 || ao.color !== void 0 && Rn.isWebGL2 === !0) && In.update(gn, dn, ln, br),
        (Fr || ir.receiveShadow !== gn.receiveShadow) && (ir.receiveShadow = gn.receiveShadow,
        pr.setValue(sn, "receiveShadow", gn.receiveShadow)),
        Fr && (pr.setValue(sn, "toneMappingExposure", yt.toneMappingExposure),
        ir.needsLights && Fo(Or, Zr),
        jn && ln.fog && rr.refreshFogUniforms(Or, jn),
        rr.refreshMaterialUniforms(Or, ln, Tt, Nt, Jt),
        WebGLUniforms.upload(sn, ir.uniformsList, Or, bn)),
        ln.isShaderMaterial && ln.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(sn, ir.uniformsList, Or, bn),
        ln.uniformsNeedUpdate = !1),
        ln.isSpriteMaterial && pr.setValue(sn, "center", gn.center),
        pr.setValue(sn, "modelViewMatrix", gn.modelViewMatrix),
        pr.setValue(sn, "normalMatrix", gn.normalMatrix),
        pr.setValue(sn, "modelMatrix", gn.matrixWorld),
        br
    }
    function Fo(It, Qt) {
        It.ambientLightColor.needsUpdate = Qt,
        It.lightProbe.needsUpdate = Qt,
        It.directionalLights.needsUpdate = Qt,
        It.directionalLightShadows.needsUpdate = Qt,
        It.pointLights.needsUpdate = Qt,
        It.pointLightShadows.needsUpdate = Qt,
        It.spotLights.needsUpdate = Qt,
        It.spotLightShadows.needsUpdate = Qt,
        It.rectAreaLights.needsUpdate = Qt,
        It.hemisphereLights.needsUpdate = Qt
    }
    function Oo(It) {
        return It.isMeshLambertMaterial || It.isMeshToonMaterial || It.isMeshPhongMaterial || It.isMeshStandardMaterial || It.isShadowMaterial || It.isShaderMaterial && It.lights === !0
    }
    this.getActiveCubeFace = function() {
        return mt
    }
    ,
    this.getActiveMipmapLevel = function() {
        return _t
    }
    ,
    this.getRenderTarget = function() {
        return bt
    }
    ,
    this.setRenderTargetTextures = function(It, Qt, dn) {
        cn.get(It.texture).__webglTexture = Qt,
        cn.get(It.depthTexture).__webglTexture = dn;
        const ln = cn.get(It);
        ln.__hasExternalTextures = !0,
        ln.__hasExternalTextures && (ln.__autoAllocateDepthBuffer = dn === void 0,
        ln.__autoAllocateDepthBuffer || zn.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
        ln.__useRenderToTexture = !1))
    }
    ,
    this.setRenderTargetFramebuffer = function(It, Qt) {
        const dn = cn.get(It);
        dn.__webglFramebuffer = Qt,
        dn.__useDefaultFramebuffer = Qt === void 0
    }
    ,
    this.setRenderTarget = function(It, Qt=0, dn=0) {
        bt = It,
        mt = Qt,
        _t = dn;
        let ln = !0;
        if (It) {
            const Yn = cn.get(It);
            Yn.__useDefaultFramebuffer !== void 0 ? (Ln.bindFramebuffer(36160, null),
            ln = !1) : Yn.__webglFramebuffer === void 0 ? bn.setupRenderTarget(It) : Yn.__hasExternalTextures && bn.rebindTextures(It, cn.get(It.texture).__webglTexture, cn.get(It.depthTexture).__webglTexture)
        }
        let gn = null
          , jn = !1
          , Xn = !1;
        if (It) {
            const Yn = It.texture;
            (Yn.isData3DTexture || Yn.isDataArrayTexture) && (Xn = !0);
            const sr = cn.get(It).__webglFramebuffer;
            It.isWebGLCubeRenderTarget ? (gn = sr[Qt],
            jn = !0) : Rn.isWebGL2 && It.samples > 0 && bn.useMultisampledRTT(It) === !1 ? gn = cn.get(It).__webglMultisampledFramebuffer : gn = sr,
            At.copy(It.viewport),
            Pt.copy(It.scissor),
            Ot = It.scissorTest
        } else
            At.copy(Wt).multiplyScalar(Tt).floor(),
            Pt.copy(Kt).multiplyScalar(Tt).floor(),
            Ot = qt;
        if (Ln.bindFramebuffer(36160, gn) && Rn.drawBuffers && ln && Ln.drawBuffers(It, gn),
        Ln.viewport(At),
        Ln.scissor(Pt),
        Ln.setScissorTest(Ot),
        jn) {
            const Yn = cn.get(It.texture);
            sn.framebufferTexture2D(36160, 36064, 34069 + Qt, Yn.__webglTexture, dn)
        } else if (Xn) {
            const Yn = cn.get(It.texture)
              , sr = Qt || 0;
            sn.framebufferTextureLayer(36160, 36064, Yn.__webglTexture, dn || 0, sr)
        }
        Mt = -1
    }
    ,
    this.readRenderTargetPixels = function(It, Qt, dn, ln, gn, jn, Xn) {
        if (!(It && It.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
        }
        let Zn = cn.get(It).__webglFramebuffer;
        if (It.isWebGLCubeRenderTarget && Xn !== void 0 && (Zn = Zn[Xn]),
        Zn) {
            Ln.bindFramebuffer(36160, Zn);
            try {
                const Yn = It.texture
                  , sr = Yn.format
                  , Kn = Yn.type;
                if (sr !== RGBAFormat && Vt.convert(sr) !== sn.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return
                }
                const tr = Kn === HalfFloatType && (zn.has("EXT_color_buffer_half_float") || Rn.isWebGL2 && zn.has("EXT_color_buffer_float"));
                if (Kn !== UnsignedByteType && Vt.convert(Kn) !== sn.getParameter(35738) && !(Kn === FloatType && (Rn.isWebGL2 || zn.has("OES_texture_float") || zn.has("WEBGL_color_buffer_float"))) && !tr) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return
                }
                sn.checkFramebufferStatus(36160) === 36053 ? Qt >= 0 && Qt <= It.width - ln && dn >= 0 && dn <= It.height - gn && sn.readPixels(Qt, dn, ln, gn, Vt.convert(sr), Vt.convert(Kn), jn) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
            } finally {
                const Yn = bt !== null ? cn.get(bt).__webglFramebuffer : null;
                Ln.bindFramebuffer(36160, Yn)
            }
        }
    }
    ,
    this.copyFramebufferToTexture = function(It, Qt, dn=0) {
        if (Qt.isFramebufferTexture !== !0) {
            console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
            return
        }
        const ln = Math.pow(2, -dn)
          , gn = Math.floor(Qt.image.width * ln)
          , jn = Math.floor(Qt.image.height * ln);
        bn.setTexture2D(Qt, 0),
        sn.copyTexSubImage2D(3553, dn, 0, 0, It.x, It.y, gn, jn),
        Ln.unbindTexture()
    }
    ,
    this.copyTextureToTexture = function(It, Qt, dn, ln=0) {
        const gn = Qt.image.width
          , jn = Qt.image.height
          , Xn = Vt.convert(dn.format)
          , Zn = Vt.convert(dn.type);
        bn.setTexture2D(dn, 0),
        sn.pixelStorei(37440, dn.flipY),
        sn.pixelStorei(37441, dn.premultiplyAlpha),
        sn.pixelStorei(3317, dn.unpackAlignment),
        Qt.isDataTexture ? sn.texSubImage2D(3553, ln, It.x, It.y, gn, jn, Xn, Zn, Qt.image.data) : Qt.isCompressedTexture ? sn.compressedTexSubImage2D(3553, ln, It.x, It.y, Qt.mipmaps[0].width, Qt.mipmaps[0].height, Xn, Qt.mipmaps[0].data) : sn.texSubImage2D(3553, ln, It.x, It.y, Xn, Zn, Qt.image),
        ln === 0 && dn.generateMipmaps && sn.generateMipmap(3553),
        Ln.unbindTexture()
    }
    ,
    this.copyTextureToTexture3D = function(It, Qt, dn, ln, gn=0) {
        if (yt.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return
        }
        const jn = It.max.x - It.min.x + 1
          , Xn = It.max.y - It.min.y + 1
          , Zn = It.max.z - It.min.z + 1
          , Yn = Vt.convert(ln.format)
          , sr = Vt.convert(ln.type);
        let Kn;
        if (ln.isData3DTexture)
            bn.setTexture3D(ln, 0),
            Kn = 32879;
        else if (ln.isDataArrayTexture)
            bn.setTexture2DArray(ln, 0),
            Kn = 35866;
        else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return
        }
        sn.pixelStorei(37440, ln.flipY),
        sn.pixelStorei(37441, ln.premultiplyAlpha),
        sn.pixelStorei(3317, ln.unpackAlignment);
        const tr = sn.getParameter(3314)
          , ur = sn.getParameter(32878)
          , Cr = sn.getParameter(3316)
          , Tr = sn.getParameter(3315)
          , Dr = sn.getParameter(32877)
          , yr = dn.isCompressedTexture ? dn.mipmaps[0] : dn.image;
        sn.pixelStorei(3314, yr.width),
        sn.pixelStorei(32878, yr.height),
        sn.pixelStorei(3316, It.min.x),
        sn.pixelStorei(3315, It.min.y),
        sn.pixelStorei(32877, It.min.z),
        dn.isDataTexture || dn.isData3DTexture ? sn.texSubImage3D(Kn, gn, Qt.x, Qt.y, Qt.z, jn, Xn, Zn, Yn, sr, yr.data) : dn.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
        sn.compressedTexSubImage3D(Kn, gn, Qt.x, Qt.y, Qt.z, jn, Xn, Zn, Yn, yr.data)) : sn.texSubImage3D(Kn, gn, Qt.x, Qt.y, Qt.z, jn, Xn, Zn, Yn, sr, yr),
        sn.pixelStorei(3314, tr),
        sn.pixelStorei(32878, ur),
        sn.pixelStorei(3316, Cr),
        sn.pixelStorei(3315, Tr),
        sn.pixelStorei(32877, Dr),
        gn === 0 && ln.generateMipmaps && sn.generateMipmap(Kn),
        Ln.unbindTexture()
    }
    ,
    this.initTexture = function(It) {
        bn.setTexture2D(It, 0),
        Ln.unbindTexture()
    }
    ,
    this.resetState = function() {
        mt = 0,
        _t = 0,
        bt = null,
        Ln.reset(),
        hn.reset()
    }
    ,
    typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
        detail: this
    }))
}
WebGLRenderer.prototype.isWebGLRenderer = !0;
class WebGL1Renderer extends WebGLRenderer {
}
WebGL1Renderer.prototype.isWebGL1Renderer = !0;
class Scene extends Object3D {
    constructor() {
        super(),
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = !0,
        typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy($, tt) {
        return super.copy($, tt),
        $.background !== null && (this.background = $.background.clone()),
        $.environment !== null && (this.environment = $.environment.clone()),
        $.fog !== null && (this.fog = $.fog.clone()),
        $.overrideMaterial !== null && (this.overrideMaterial = $.overrideMaterial.clone()),
        this.autoUpdate = $.autoUpdate,
        this.matrixAutoUpdate = $.matrixAutoUpdate,
        this
    }
    toJSON($) {
        const tt = super.toJSON($);
        return this.fog !== null && (tt.object.fog = this.fog.toJSON()),
        tt
    }
}
Scene.prototype.isScene = !0;
class InterleavedBuffer {
    constructor($, tt) {
        this.array = $,
        this.stride = tt,
        this.count = $ !== void 0 ? $.length / tt : 0,
        this.usage = StaticDrawUsage,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = generateUUID()
    }
    onUploadCallback() {}
    set needsUpdate($) {
        $ === !0 && this.version++
    }
    setUsage($) {
        return this.usage = $,
        this
    }
    copy($) {
        return this.array = new $.array.constructor($.array),
        this.count = $.count,
        this.stride = $.stride,
        this.usage = $.usage,
        this
    }
    copyAt($, tt, nt) {
        $ *= this.stride,
        nt *= tt.stride;
        for (let rt = 0, it = this.stride; rt < it; rt++)
            this.array[$ + rt] = tt.array[nt + rt];
        return this
    }
    set($, tt=0) {
        return this.array.set($, tt),
        this
    }
    clone($) {
        $.arrayBuffers === void 0 && ($.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()),
        $.arrayBuffers[this.array.buffer._uuid] === void 0 && ($.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const tt = new this.array.constructor($.arrayBuffers[this.array.buffer._uuid])
          , nt = new this.constructor(tt,this.stride);
        return nt.setUsage(this.usage),
        nt
    }
    onUpload($) {
        return this.onUploadCallback = $,
        this
    }
    toJSON($) {
        return $.arrayBuffers === void 0 && ($.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()),
        $.arrayBuffers[this.array.buffer._uuid] === void 0 && ($.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
InterleavedBuffer.prototype.isInterleavedBuffer = !0;
const _vector$6 = new Vector3;
class InterleavedBufferAttribute {
    constructor($, tt, nt, rt=!1) {
        this.name = "",
        this.data = $,
        this.itemSize = tt,
        this.offset = nt,
        this.normalized = rt === !0
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate($) {
        this.data.needsUpdate = $
    }
    applyMatrix4($) {
        for (let tt = 0, nt = this.data.count; tt < nt; tt++)
            _vector$6.x = this.getX(tt),
            _vector$6.y = this.getY(tt),
            _vector$6.z = this.getZ(tt),
            _vector$6.applyMatrix4($),
            this.setXYZ(tt, _vector$6.x, _vector$6.y, _vector$6.z);
        return this
    }
    applyNormalMatrix($) {
        for (let tt = 0, nt = this.count; tt < nt; tt++)
            _vector$6.x = this.getX(tt),
            _vector$6.y = this.getY(tt),
            _vector$6.z = this.getZ(tt),
            _vector$6.applyNormalMatrix($),
            this.setXYZ(tt, _vector$6.x, _vector$6.y, _vector$6.z);
        return this
    }
    transformDirection($) {
        for (let tt = 0, nt = this.count; tt < nt; tt++)
            _vector$6.x = this.getX(tt),
            _vector$6.y = this.getY(tt),
            _vector$6.z = this.getZ(tt),
            _vector$6.transformDirection($),
            this.setXYZ(tt, _vector$6.x, _vector$6.y, _vector$6.z);
        return this
    }
    setX($, tt) {
        return this.data.array[$ * this.data.stride + this.offset] = tt,
        this
    }
    setY($, tt) {
        return this.data.array[$ * this.data.stride + this.offset + 1] = tt,
        this
    }
    setZ($, tt) {
        return this.data.array[$ * this.data.stride + this.offset + 2] = tt,
        this
    }
    setW($, tt) {
        return this.data.array[$ * this.data.stride + this.offset + 3] = tt,
        this
    }
    getX($) {
        return this.data.array[$ * this.data.stride + this.offset]
    }
    getY($) {
        return this.data.array[$ * this.data.stride + this.offset + 1]
    }
    getZ($) {
        return this.data.array[$ * this.data.stride + this.offset + 2]
    }
    getW($) {
        return this.data.array[$ * this.data.stride + this.offset + 3]
    }
    setXY($, tt, nt) {
        return $ = $ * this.data.stride + this.offset,
        this.data.array[$ + 0] = tt,
        this.data.array[$ + 1] = nt,
        this
    }
    setXYZ($, tt, nt, rt) {
        return $ = $ * this.data.stride + this.offset,
        this.data.array[$ + 0] = tt,
        this.data.array[$ + 1] = nt,
        this.data.array[$ + 2] = rt,
        this
    }
    setXYZW($, tt, nt, rt, it) {
        return $ = $ * this.data.stride + this.offset,
        this.data.array[$ + 0] = tt,
        this.data.array[$ + 1] = nt,
        this.data.array[$ + 2] = rt,
        this.data.array[$ + 3] = it,
        this
    }
    clone($) {
        if ($ === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const tt = [];
            for (let nt = 0; nt < this.count; nt++) {
                const rt = nt * this.data.stride + this.offset;
                for (let it = 0; it < this.itemSize; it++)
                    tt.push(this.data.array[rt + it])
            }
            return new BufferAttribute(new this.array.constructor(tt),this.itemSize,this.normalized)
        } else
            return $.interleavedBuffers === void 0 && ($.interleavedBuffers = {}),
            $.interleavedBuffers[this.data.uuid] === void 0 && ($.interleavedBuffers[this.data.uuid] = this.data.clone($)),
            new InterleavedBufferAttribute($.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON($) {
        if ($ === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const tt = [];
            for (let nt = 0; nt < this.count; nt++) {
                const rt = nt * this.data.stride + this.offset;
                for (let it = 0; it < this.itemSize; it++)
                    tt.push(this.data.array[rt + it])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: tt,
                normalized: this.normalized
            }
        } else
            return $.interleavedBuffers === void 0 && ($.interleavedBuffers = {}),
            $.interleavedBuffers[this.data.uuid] === void 0 && ($.interleavedBuffers[this.data.uuid] = this.data.toJSON($)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = !0;
class SpriteMaterial extends Material {
    constructor($) {
        super(),
        this.type = "SpriteMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.color.copy($.color),
        this.map = $.map,
        this.alphaMap = $.alphaMap,
        this.rotation = $.rotation,
        this.sizeAttenuation = $.sizeAttenuation,
        this
    }
}
SpriteMaterial.prototype.isSpriteMaterial = !0;
let _geometry;
const _intersectPoint = new Vector3
  , _worldScale = new Vector3
  , _mvPosition = new Vector3
  , _alignedPosition = new Vector2
  , _rotatedPosition = new Vector2
  , _viewWorldMatrix = new Matrix4
  , _vA = new Vector3
  , _vB = new Vector3
  , _vC = new Vector3
  , _uvA = new Vector2
  , _uvB = new Vector2
  , _uvC = new Vector2;
class Sprite extends Object3D {
    constructor($) {
        if (super(),
        this.type = "Sprite",
        _geometry === void 0) {
            _geometry = new BufferGeometry;
            const tt = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , nt = new InterleavedBuffer(tt,5);
            _geometry.setIndex([0, 1, 2, 0, 2, 3]),
            _geometry.setAttribute("position", new InterleavedBufferAttribute(nt,3,0,!1)),
            _geometry.setAttribute("uv", new InterleavedBufferAttribute(nt,2,3,!1))
        }
        this.geometry = _geometry,
        this.material = $ !== void 0 ? $ : new SpriteMaterial,
        this.center = new Vector2(.5,.5)
    }
    raycast($, tt) {
        $.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        _worldScale.setFromMatrixScale(this.matrixWorld),
        _viewWorldMatrix.copy($.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices($.camera.matrixWorldInverse, this.matrixWorld),
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix),
        $.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && _worldScale.multiplyScalar(-_mvPosition.z);
        const nt = this.material.rotation;
        let rt, it;
        nt !== 0 && (it = Math.cos(nt),
        rt = Math.sin(nt));
        const ot = this.center;
        transformVertex(_vA.set(-.5, -.5, 0), _mvPosition, ot, _worldScale, rt, it),
        transformVertex(_vB.set(.5, -.5, 0), _mvPosition, ot, _worldScale, rt, it),
        transformVertex(_vC.set(.5, .5, 0), _mvPosition, ot, _worldScale, rt, it),
        _uvA.set(0, 0),
        _uvB.set(1, 0),
        _uvC.set(1, 1);
        let st = $.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint);
        if (st === null && (transformVertex(_vB.set(-.5, .5, 0), _mvPosition, ot, _worldScale, rt, it),
        _uvB.set(0, 1),
        st = $.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint),
        st === null))
            return;
        const lt = $.ray.origin.distanceTo(_intersectPoint);
        lt < $.near || lt > $.far || tt.push({
            distance: lt,
            point: _intersectPoint.clone(),
            uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2),
            face: null,
            object: this
        })
    }
    copy($) {
        return super.copy($),
        $.center !== void 0 && this.center.copy($.center),
        this.material = $.material,
        this
    }
}
Sprite.prototype.isSprite = !0;
function transformVertex(et, $, tt, nt, rt, it) {
    _alignedPosition.subVectors(et, tt).addScalar(.5).multiply(nt),
    rt !== void 0 ? (_rotatedPosition.x = it * _alignedPosition.x - rt * _alignedPosition.y,
    _rotatedPosition.y = rt * _alignedPosition.x + it * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition),
    et.copy($),
    et.x += _rotatedPosition.x,
    et.y += _rotatedPosition.y,
    et.applyMatrix4(_viewWorldMatrix)
}
const _basePosition = new Vector3
  , _skinIndex = new Vector4
  , _skinWeight = new Vector4
  , _vector$5 = new Vector3
  , _matrix = new Matrix4;
class SkinnedMesh extends Mesh {
    constructor($, tt) {
        super($, tt),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new Matrix4,
        this.bindMatrixInverse = new Matrix4
    }
    copy($) {
        return super.copy($),
        this.bindMode = $.bindMode,
        this.bindMatrix.copy($.bindMatrix),
        this.bindMatrixInverse.copy($.bindMatrixInverse),
        this.skeleton = $.skeleton,
        this
    }
    bind($, tt) {
        this.skeleton = $,
        tt === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        tt = this.matrixWorld),
        this.bindMatrix.copy(tt),
        this.bindMatrixInverse.copy(tt).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const $ = new Vector4
          , tt = this.geometry.attributes.skinWeight;
        for (let nt = 0, rt = tt.count; nt < rt; nt++) {
            $.x = tt.getX(nt),
            $.y = tt.getY(nt),
            $.z = tt.getZ(nt),
            $.w = tt.getW(nt);
            const it = 1 / $.manhattanLength();
            it !== 1 / 0 ? $.multiplyScalar(it) : $.set(1, 0, 0, 0),
            tt.setXYZW(nt, $.x, $.y, $.z, $.w)
        }
    }
    updateMatrixWorld($) {
        super.updateMatrixWorld($),
        this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform($, tt) {
        const nt = this.skeleton
          , rt = this.geometry;
        _skinIndex.fromBufferAttribute(rt.attributes.skinIndex, $),
        _skinWeight.fromBufferAttribute(rt.attributes.skinWeight, $),
        _basePosition.copy(tt).applyMatrix4(this.bindMatrix),
        tt.set(0, 0, 0);
        for (let it = 0; it < 4; it++) {
            const ot = _skinWeight.getComponent(it);
            if (ot !== 0) {
                const st = _skinIndex.getComponent(it);
                _matrix.multiplyMatrices(nt.bones[st].matrixWorld, nt.boneInverses[st]),
                tt.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), ot)
            }
        }
        return tt.applyMatrix4(this.bindMatrixInverse)
    }
}
SkinnedMesh.prototype.isSkinnedMesh = !0;
class Bone extends Object3D {
    constructor() {
        super(),
        this.type = "Bone"
    }
}
Bone.prototype.isBone = !0;
class DataTexture extends Texture {
    constructor($=null, tt=1, nt=1, rt, it, ot, st, lt, ut=NearestFilter, ct=NearestFilter, ht, ft) {
        super(null, ot, st, lt, ut, ct, rt, it, ht, ft),
        this.image = {
            data: $,
            width: tt,
            height: nt
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
DataTexture.prototype.isDataTexture = !0;
class InstancedBufferAttribute extends BufferAttribute {
    constructor($, tt, nt, rt=1) {
        typeof nt == "number" && (rt = nt,
        nt = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        super($, tt, nt),
        this.meshPerAttribute = rt
    }
    copy($) {
        return super.copy($),
        this.meshPerAttribute = $.meshPerAttribute,
        this
    }
    toJSON() {
        const $ = super.toJSON();
        return $.meshPerAttribute = this.meshPerAttribute,
        $.isInstancedBufferAttribute = !0,
        $
    }
}
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = !0;
const _instanceLocalMatrix = new Matrix4
  , _instanceWorldMatrix = new Matrix4
  , _instanceIntersects = []
  , _mesh = new Mesh;
class InstancedMesh extends Mesh {
    constructor($, tt, nt) {
        super($, tt),
        this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(nt * 16),16),
        this.instanceColor = null,
        this.count = nt,
        this.frustumCulled = !1
    }
    copy($) {
        return super.copy($),
        this.instanceMatrix.copy($.instanceMatrix),
        $.instanceColor !== null && (this.instanceColor = $.instanceColor.clone()),
        this.count = $.count,
        this
    }
    getColorAt($, tt) {
        tt.fromArray(this.instanceColor.array, $ * 3)
    }
    getMatrixAt($, tt) {
        tt.fromArray(this.instanceMatrix.array, $ * 16)
    }
    raycast($, tt) {
        const nt = this.matrixWorld
          , rt = this.count;
        if (_mesh.geometry = this.geometry,
        _mesh.material = this.material,
        _mesh.material !== void 0)
            for (let it = 0; it < rt; it++) {
                this.getMatrixAt(it, _instanceLocalMatrix),
                _instanceWorldMatrix.multiplyMatrices(nt, _instanceLocalMatrix),
                _mesh.matrixWorld = _instanceWorldMatrix,
                _mesh.raycast($, _instanceIntersects);
                for (let ot = 0, st = _instanceIntersects.length; ot < st; ot++) {
                    const lt = _instanceIntersects[ot];
                    lt.instanceId = it,
                    lt.object = this,
                    tt.push(lt)
                }
                _instanceIntersects.length = 0
            }
    }
    setColorAt($, tt) {
        this.instanceColor === null && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3),3)),
        tt.toArray(this.instanceColor.array, $ * 3)
    }
    setMatrixAt($, tt) {
        tt.toArray(this.instanceMatrix.array, $ * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
InstancedMesh.prototype.isInstancedMesh = !0;
class LineBasicMaterial extends Material {
    constructor($) {
        super(),
        this.type = "LineBasicMaterial",
        this.color = new Color(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.color.copy($.color),
        this.linewidth = $.linewidth,
        this.linecap = $.linecap,
        this.linejoin = $.linejoin,
        this
    }
}
LineBasicMaterial.prototype.isLineBasicMaterial = !0;
const _start$1 = new Vector3
  , _end$1 = new Vector3
  , _inverseMatrix$1 = new Matrix4
  , _ray$1 = new Ray
  , _sphere$1 = new Sphere;
class Line extends Object3D {
    constructor($=new BufferGeometry, tt=new LineBasicMaterial) {
        super(),
        this.type = "Line",
        this.geometry = $,
        this.material = tt,
        this.updateMorphTargets()
    }
    copy($) {
        return super.copy($),
        this.material = $.material,
        this.geometry = $.geometry,
        this
    }
    computeLineDistances() {
        const $ = this.geometry;
        if ($.isBufferGeometry)
            if ($.index === null) {
                const tt = $.attributes.position
                  , nt = [0];
                for (let rt = 1, it = tt.count; rt < it; rt++)
                    _start$1.fromBufferAttribute(tt, rt - 1),
                    _end$1.fromBufferAttribute(tt, rt),
                    nt[rt] = nt[rt - 1],
                    nt[rt] += _start$1.distanceTo(_end$1);
                $.setAttribute("lineDistance", new Float32BufferAttribute(nt,1))
            } else
                console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        else
            $.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this
    }
    raycast($, tt) {
        const nt = this.geometry
          , rt = this.matrixWorld
          , it = $.params.Line.threshold
          , ot = nt.drawRange;
        if (nt.boundingSphere === null && nt.computeBoundingSphere(),
        _sphere$1.copy(nt.boundingSphere),
        _sphere$1.applyMatrix4(rt),
        _sphere$1.radius += it,
        $.ray.intersectsSphere(_sphere$1) === !1)
            return;
        _inverseMatrix$1.copy(rt).invert(),
        _ray$1.copy($.ray).applyMatrix4(_inverseMatrix$1);
        const st = it / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , lt = st * st
          , ut = new Vector3
          , ct = new Vector3
          , ht = new Vector3
          , ft = new Vector3
          , gt = this.isLineSegments ? 2 : 1;
        if (nt.isBufferGeometry) {
            const vt = nt.index
              , wt = nt.attributes.position;
            if (vt !== null) {
                const mt = Math.max(0, ot.start)
                  , _t = Math.min(vt.count, ot.start + ot.count);
                for (let bt = mt, Mt = _t - 1; bt < Mt; bt += gt) {
                    const St = vt.getX(bt)
                      , At = vt.getX(bt + 1);
                    if (ut.fromBufferAttribute(wt, St),
                    ct.fromBufferAttribute(wt, At),
                    _ray$1.distanceSqToSegment(ut, ct, ft, ht) > lt)
                        continue;
                    ft.applyMatrix4(this.matrixWorld);
                    const Ot = $.ray.origin.distanceTo(ft);
                    Ot < $.near || Ot > $.far || tt.push({
                        distance: Ot,
                        point: ht.clone().applyMatrix4(this.matrixWorld),
                        index: bt,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            } else {
                const mt = Math.max(0, ot.start)
                  , _t = Math.min(wt.count, ot.start + ot.count);
                for (let bt = mt, Mt = _t - 1; bt < Mt; bt += gt) {
                    if (ut.fromBufferAttribute(wt, bt),
                    ct.fromBufferAttribute(wt, bt + 1),
                    _ray$1.distanceSqToSegment(ut, ct, ft, ht) > lt)
                        continue;
                    ft.applyMatrix4(this.matrixWorld);
                    const At = $.ray.origin.distanceTo(ft);
                    At < $.near || At > $.far || tt.push({
                        distance: At,
                        point: ht.clone().applyMatrix4(this.matrixWorld),
                        index: bt,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            }
        } else
            nt.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }
    updateMorphTargets() {
        const $ = this.geometry;
        if ($.isBufferGeometry) {
            const tt = $.morphAttributes
              , nt = Object.keys(tt);
            if (nt.length > 0) {
                const rt = tt[nt[0]];
                if (rt !== void 0) {
                    this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {};
                    for (let it = 0, ot = rt.length; it < ot; it++) {
                        const st = rt[it].name || String(it);
                        this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[st] = it
                    }
                }
            }
        } else {
            const tt = $.morphTargets;
            tt !== void 0 && tt.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
}
Line.prototype.isLine = !0;
const _start = new Vector3
  , _end = new Vector3;
class LineSegments extends Line {
    constructor($, tt) {
        super($, tt),
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const $ = this.geometry;
        if ($.isBufferGeometry)
            if ($.index === null) {
                const tt = $.attributes.position
                  , nt = [];
                for (let rt = 0, it = tt.count; rt < it; rt += 2)
                    _start.fromBufferAttribute(tt, rt),
                    _end.fromBufferAttribute(tt, rt + 1),
                    nt[rt] = rt === 0 ? 0 : nt[rt - 1],
                    nt[rt + 1] = nt[rt] + _start.distanceTo(_end);
                $.setAttribute("lineDistance", new Float32BufferAttribute(nt,1))
            } else
                console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        else
            $.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this
    }
}
LineSegments.prototype.isLineSegments = !0;
class LineLoop extends Line {
    constructor($, tt) {
        super($, tt),
        this.type = "LineLoop"
    }
}
LineLoop.prototype.isLineLoop = !0;
class PointsMaterial extends Material {
    constructor($) {
        super(),
        this.type = "PointsMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.color.copy($.color),
        this.map = $.map,
        this.alphaMap = $.alphaMap,
        this.size = $.size,
        this.sizeAttenuation = $.sizeAttenuation,
        this
    }
}
PointsMaterial.prototype.isPointsMaterial = !0;
const _inverseMatrix = new Matrix4
  , _ray = new Ray
  , _sphere = new Sphere
  , _position$2 = new Vector3;
class Points extends Object3D {
    constructor($=new BufferGeometry, tt=new PointsMaterial) {
        super(),
        this.type = "Points",
        this.geometry = $,
        this.material = tt,
        this.updateMorphTargets()
    }
    copy($) {
        return super.copy($),
        this.material = $.material,
        this.geometry = $.geometry,
        this
    }
    raycast($, tt) {
        const nt = this.geometry
          , rt = this.matrixWorld
          , it = $.params.Points.threshold
          , ot = nt.drawRange;
        if (nt.boundingSphere === null && nt.computeBoundingSphere(),
        _sphere.copy(nt.boundingSphere),
        _sphere.applyMatrix4(rt),
        _sphere.radius += it,
        $.ray.intersectsSphere(_sphere) === !1)
            return;
        _inverseMatrix.copy(rt).invert(),
        _ray.copy($.ray).applyMatrix4(_inverseMatrix);
        const st = it / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , lt = st * st;
        if (nt.isBufferGeometry) {
            const ut = nt.index
              , ht = nt.attributes.position;
            if (ut !== null) {
                const ft = Math.max(0, ot.start)
                  , gt = Math.min(ut.count, ot.start + ot.count);
                for (let vt = ft, yt = gt; vt < yt; vt++) {
                    const wt = ut.getX(vt);
                    _position$2.fromBufferAttribute(ht, wt),
                    testPoint(_position$2, wt, lt, rt, $, tt, this)
                }
            } else {
                const ft = Math.max(0, ot.start)
                  , gt = Math.min(ht.count, ot.start + ot.count);
                for (let vt = ft, yt = gt; vt < yt; vt++)
                    _position$2.fromBufferAttribute(ht, vt),
                    testPoint(_position$2, vt, lt, rt, $, tt, this)
            }
        } else
            console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }
    updateMorphTargets() {
        const $ = this.geometry;
        if ($.isBufferGeometry) {
            const tt = $.morphAttributes
              , nt = Object.keys(tt);
            if (nt.length > 0) {
                const rt = tt[nt[0]];
                if (rt !== void 0) {
                    this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {};
                    for (let it = 0, ot = rt.length; it < ot; it++) {
                        const st = rt[it].name || String(it);
                        this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[st] = it
                    }
                }
            }
        } else {
            const tt = $.morphTargets;
            tt !== void 0 && tt.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
}
Points.prototype.isPoints = !0;
function testPoint(et, $, tt, nt, rt, it, ot) {
    const st = _ray.distanceSqToPoint(et);
    if (st < tt) {
        const lt = new Vector3;
        _ray.closestPointToPoint(et, lt),
        lt.applyMatrix4(nt);
        const ut = rt.ray.origin.distanceTo(lt);
        if (ut < rt.near || ut > rt.far)
            return;
        it.push({
            distance: ut,
            distanceToRay: Math.sqrt(st),
            point: lt,
            index: $,
            face: null,
            object: ot
        })
    }
}
class VideoTexture extends Texture {
    constructor($, tt, nt, rt, it, ot, st, lt, ut) {
        super($, tt, nt, rt, it, ot, st, lt, ut),
        this.minFilter = ot !== void 0 ? ot : LinearFilter,
        this.magFilter = it !== void 0 ? it : LinearFilter,
        this.generateMipmaps = !1;
        const ct = this;
        function ht() {
            ct.needsUpdate = !0,
            $.requestVideoFrameCallback(ht)
        }
        "requestVideoFrameCallback"in $ && $.requestVideoFrameCallback(ht)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const $ = this.image;
        "requestVideoFrameCallback"in $ === !1 && $.readyState >= $.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
VideoTexture.prototype.isVideoTexture = !0;
class FramebufferTexture extends Texture {
    constructor($, tt, nt) {
        super({
            width: $,
            height: tt
        }),
        this.format = nt,
        this.magFilter = NearestFilter,
        this.minFilter = NearestFilter,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
FramebufferTexture.prototype.isFramebufferTexture = !0;
class CompressedTexture extends Texture {
    constructor($, tt, nt, rt, it, ot, st, lt, ut, ct, ht, ft) {
        super(null, ot, st, lt, ut, ct, rt, it, ht, ft),
        this.image = {
            width: tt,
            height: nt
        },
        this.mipmaps = $,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
CompressedTexture.prototype.isCompressedTexture = !0;
class CanvasTexture extends Texture {
    constructor($, tt, nt, rt, it, ot, st, lt, ut) {
        super($, tt, nt, rt, it, ot, st, lt, ut),
        this.needsUpdate = !0
    }
}
CanvasTexture.prototype.isCanvasTexture = !0;
new Vector3;
new Vector3;
new Vector3;
new Triangle;
class Curve {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt($, tt) {
        const nt = this.getUtoTmapping($);
        return this.getPoint(nt, tt)
    }
    getPoints($=5) {
        const tt = [];
        for (let nt = 0; nt <= $; nt++)
            tt.push(this.getPoint(nt / $));
        return tt
    }
    getSpacedPoints($=5) {
        const tt = [];
        for (let nt = 0; nt <= $; nt++)
            tt.push(this.getPointAt(nt / $));
        return tt
    }
    getLength() {
        const $ = this.getLengths();
        return $[$.length - 1]
    }
    getLengths($=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === $ + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const tt = [];
        let nt, rt = this.getPoint(0), it = 0;
        tt.push(0);
        for (let ot = 1; ot <= $; ot++)
            nt = this.getPoint(ot / $),
            it += nt.distanceTo(rt),
            tt.push(it),
            rt = nt;
        return this.cacheArcLengths = tt,
        tt
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping($, tt) {
        const nt = this.getLengths();
        let rt = 0;
        const it = nt.length;
        let ot;
        tt ? ot = tt : ot = $ * nt[it - 1];
        let st = 0, lt = it - 1, ut;
        for (; st <= lt; )
            if (rt = Math.floor(st + (lt - st) / 2),
            ut = nt[rt] - ot,
            ut < 0)
                st = rt + 1;
            else if (ut > 0)
                lt = rt - 1;
            else {
                lt = rt;
                break
            }
        if (rt = lt,
        nt[rt] === ot)
            return rt / (it - 1);
        const ct = nt[rt]
          , ft = nt[rt + 1] - ct
          , gt = (ot - ct) / ft;
        return (rt + gt) / (it - 1)
    }
    getTangent($, tt) {
        let rt = $ - 1e-4
          , it = $ + 1e-4;
        rt < 0 && (rt = 0),
        it > 1 && (it = 1);
        const ot = this.getPoint(rt)
          , st = this.getPoint(it)
          , lt = tt || (ot.isVector2 ? new Vector2 : new Vector3);
        return lt.copy(st).sub(ot).normalize(),
        lt
    }
    getTangentAt($, tt) {
        const nt = this.getUtoTmapping($);
        return this.getTangent(nt, tt)
    }
    computeFrenetFrames($, tt) {
        const nt = new Vector3
          , rt = []
          , it = []
          , ot = []
          , st = new Vector3
          , lt = new Matrix4;
        for (let gt = 0; gt <= $; gt++) {
            const vt = gt / $;
            rt[gt] = this.getTangentAt(vt, new Vector3)
        }
        it[0] = new Vector3,
        ot[0] = new Vector3;
        let ut = Number.MAX_VALUE;
        const ct = Math.abs(rt[0].x)
          , ht = Math.abs(rt[0].y)
          , ft = Math.abs(rt[0].z);
        ct <= ut && (ut = ct,
        nt.set(1, 0, 0)),
        ht <= ut && (ut = ht,
        nt.set(0, 1, 0)),
        ft <= ut && nt.set(0, 0, 1),
        st.crossVectors(rt[0], nt).normalize(),
        it[0].crossVectors(rt[0], st),
        ot[0].crossVectors(rt[0], it[0]);
        for (let gt = 1; gt <= $; gt++) {
            if (it[gt] = it[gt - 1].clone(),
            ot[gt] = ot[gt - 1].clone(),
            st.crossVectors(rt[gt - 1], rt[gt]),
            st.length() > Number.EPSILON) {
                st.normalize();
                const vt = Math.acos(clamp$1(rt[gt - 1].dot(rt[gt]), -1, 1));
                it[gt].applyMatrix4(lt.makeRotationAxis(st, vt))
            }
            ot[gt].crossVectors(rt[gt], it[gt])
        }
        if (tt === !0) {
            let gt = Math.acos(clamp$1(it[0].dot(it[$]), -1, 1));
            gt /= $,
            rt[0].dot(st.crossVectors(it[0], it[$])) > 0 && (gt = -gt);
            for (let vt = 1; vt <= $; vt++)
                it[vt].applyMatrix4(lt.makeRotationAxis(rt[vt], gt * vt)),
                ot[vt].crossVectors(rt[vt], it[vt])
        }
        return {
            tangents: rt,
            normals: it,
            binormals: ot
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy($) {
        return this.arcLengthDivisions = $.arcLengthDivisions,
        this
    }
    toJSON() {
        const $ = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return $.arcLengthDivisions = this.arcLengthDivisions,
        $.type = this.type,
        $
    }
    fromJSON($) {
        return this.arcLengthDivisions = $.arcLengthDivisions,
        this
    }
}
class EllipseCurve extends Curve {
    constructor($=0, tt=0, nt=1, rt=1, it=0, ot=Math.PI * 2, st=!1, lt=0) {
        super(),
        this.type = "EllipseCurve",
        this.aX = $,
        this.aY = tt,
        this.xRadius = nt,
        this.yRadius = rt,
        this.aStartAngle = it,
        this.aEndAngle = ot,
        this.aClockwise = st,
        this.aRotation = lt
    }
    getPoint($, tt) {
        const nt = tt || new Vector2
          , rt = Math.PI * 2;
        let it = this.aEndAngle - this.aStartAngle;
        const ot = Math.abs(it) < Number.EPSILON;
        for (; it < 0; )
            it += rt;
        for (; it > rt; )
            it -= rt;
        it < Number.EPSILON && (ot ? it = 0 : it = rt),
        this.aClockwise === !0 && !ot && (it === rt ? it = -rt : it = it - rt);
        const st = this.aStartAngle + $ * it;
        let lt = this.aX + this.xRadius * Math.cos(st)
          , ut = this.aY + this.yRadius * Math.sin(st);
        if (this.aRotation !== 0) {
            const ct = Math.cos(this.aRotation)
              , ht = Math.sin(this.aRotation)
              , ft = lt - this.aX
              , gt = ut - this.aY;
            lt = ft * ct - gt * ht + this.aX,
            ut = ft * ht + gt * ct + this.aY
        }
        return nt.set(lt, ut)
    }
    copy($) {
        return super.copy($),
        this.aX = $.aX,
        this.aY = $.aY,
        this.xRadius = $.xRadius,
        this.yRadius = $.yRadius,
        this.aStartAngle = $.aStartAngle,
        this.aEndAngle = $.aEndAngle,
        this.aClockwise = $.aClockwise,
        this.aRotation = $.aRotation,
        this
    }
    toJSON() {
        const $ = super.toJSON();
        return $.aX = this.aX,
        $.aY = this.aY,
        $.xRadius = this.xRadius,
        $.yRadius = this.yRadius,
        $.aStartAngle = this.aStartAngle,
        $.aEndAngle = this.aEndAngle,
        $.aClockwise = this.aClockwise,
        $.aRotation = this.aRotation,
        $
    }
    fromJSON($) {
        return super.fromJSON($),
        this.aX = $.aX,
        this.aY = $.aY,
        this.xRadius = $.xRadius,
        this.yRadius = $.yRadius,
        this.aStartAngle = $.aStartAngle,
        this.aEndAngle = $.aEndAngle,
        this.aClockwise = $.aClockwise,
        this.aRotation = $.aRotation,
        this
    }
}
EllipseCurve.prototype.isEllipseCurve = !0;
class ArcCurve extends EllipseCurve {
    constructor($, tt, nt, rt, it, ot) {
        super($, tt, nt, nt, rt, it, ot),
        this.type = "ArcCurve"
    }
}
ArcCurve.prototype.isArcCurve = !0;
function CubicPoly() {
    let et = 0
      , $ = 0
      , tt = 0
      , nt = 0;
    function rt(it, ot, st, lt) {
        et = it,
        $ = st,
        tt = -3 * it + 3 * ot - 2 * st - lt,
        nt = 2 * it - 2 * ot + st + lt
    }
    return {
        initCatmullRom: function(it, ot, st, lt, ut) {
            rt(ot, st, ut * (st - it), ut * (lt - ot))
        },
        initNonuniformCatmullRom: function(it, ot, st, lt, ut, ct, ht) {
            let ft = (ot - it) / ut - (st - it) / (ut + ct) + (st - ot) / ct
              , gt = (st - ot) / ct - (lt - ot) / (ct + ht) + (lt - st) / ht;
            ft *= ct,
            gt *= ct,
            rt(ot, st, ft, gt)
        },
        calc: function(it) {
            const ot = it * it
              , st = ot * it;
            return et + $ * it + tt * ot + nt * st
        }
    }
}
const tmp = new Vector3
  , px = new CubicPoly
  , py = new CubicPoly
  , pz = new CubicPoly;
class CatmullRomCurve3 extends Curve {
    constructor($=[], tt=!1, nt="centripetal", rt=.5) {
        super(),
        this.type = "CatmullRomCurve3",
        this.points = $,
        this.closed = tt,
        this.curveType = nt,
        this.tension = rt
    }
    getPoint($, tt=new Vector3) {
        const nt = tt
          , rt = this.points
          , it = rt.length
          , ot = (it - (this.closed ? 0 : 1)) * $;
        let st = Math.floor(ot)
          , lt = ot - st;
        this.closed ? st += st > 0 ? 0 : (Math.floor(Math.abs(st) / it) + 1) * it : lt === 0 && st === it - 1 && (st = it - 2,
        lt = 1);
        let ut, ct;
        this.closed || st > 0 ? ut = rt[(st - 1) % it] : (tmp.subVectors(rt[0], rt[1]).add(rt[0]),
        ut = tmp);
        const ht = rt[st % it]
          , ft = rt[(st + 1) % it];
        if (this.closed || st + 2 < it ? ct = rt[(st + 2) % it] : (tmp.subVectors(rt[it - 1], rt[it - 2]).add(rt[it - 1]),
        ct = tmp),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const gt = this.curveType === "chordal" ? .5 : .25;
            let vt = Math.pow(ut.distanceToSquared(ht), gt)
              , yt = Math.pow(ht.distanceToSquared(ft), gt)
              , wt = Math.pow(ft.distanceToSquared(ct), gt);
            yt < 1e-4 && (yt = 1),
            vt < 1e-4 && (vt = yt),
            wt < 1e-4 && (wt = yt),
            px.initNonuniformCatmullRom(ut.x, ht.x, ft.x, ct.x, vt, yt, wt),
            py.initNonuniformCatmullRom(ut.y, ht.y, ft.y, ct.y, vt, yt, wt),
            pz.initNonuniformCatmullRom(ut.z, ht.z, ft.z, ct.z, vt, yt, wt)
        } else
            this.curveType === "catmullrom" && (px.initCatmullRom(ut.x, ht.x, ft.x, ct.x, this.tension),
            py.initCatmullRom(ut.y, ht.y, ft.y, ct.y, this.tension),
            pz.initCatmullRom(ut.z, ht.z, ft.z, ct.z, this.tension));
        return nt.set(px.calc(lt), py.calc(lt), pz.calc(lt)),
        nt
    }
    copy($) {
        super.copy($),
        this.points = [];
        for (let tt = 0, nt = $.points.length; tt < nt; tt++) {
            const rt = $.points[tt];
            this.points.push(rt.clone())
        }
        return this.closed = $.closed,
        this.curveType = $.curveType,
        this.tension = $.tension,
        this
    }
    toJSON() {
        const $ = super.toJSON();
        $.points = [];
        for (let tt = 0, nt = this.points.length; tt < nt; tt++) {
            const rt = this.points[tt];
            $.points.push(rt.toArray())
        }
        return $.closed = this.closed,
        $.curveType = this.curveType,
        $.tension = this.tension,
        $
    }
    fromJSON($) {
        super.fromJSON($),
        this.points = [];
        for (let tt = 0, nt = $.points.length; tt < nt; tt++) {
            const rt = $.points[tt];
            this.points.push(new Vector3().fromArray(rt))
        }
        return this.closed = $.closed,
        this.curveType = $.curveType,
        this.tension = $.tension,
        this
    }
}
CatmullRomCurve3.prototype.isCatmullRomCurve3 = !0;
function CatmullRom(et, $, tt, nt, rt) {
    const it = (nt - $) * .5
      , ot = (rt - tt) * .5
      , st = et * et
      , lt = et * st;
    return (2 * tt - 2 * nt + it + ot) * lt + (-3 * tt + 3 * nt - 2 * it - ot) * st + it * et + tt
}
function QuadraticBezierP0(et, $) {
    const tt = 1 - et;
    return tt * tt * $
}
function QuadraticBezierP1(et, $) {
    return 2 * (1 - et) * et * $
}
function QuadraticBezierP2(et, $) {
    return et * et * $
}
function QuadraticBezier(et, $, tt, nt) {
    return QuadraticBezierP0(et, $) + QuadraticBezierP1(et, tt) + QuadraticBezierP2(et, nt)
}
function CubicBezierP0(et, $) {
    const tt = 1 - et;
    return tt * tt * tt * $
}
function CubicBezierP1(et, $) {
    const tt = 1 - et;
    return 3 * tt * tt * et * $
}
function CubicBezierP2(et, $) {
    return 3 * (1 - et) * et * et * $
}
function CubicBezierP3(et, $) {
    return et * et * et * $
}
function CubicBezier(et, $, tt, nt, rt) {
    return CubicBezierP0(et, $) + CubicBezierP1(et, tt) + CubicBezierP2(et, nt) + CubicBezierP3(et, rt)
}
class CubicBezierCurve extends Curve {
    constructor($=new Vector2, tt=new Vector2, nt=new Vector2, rt=new Vector2) {
        super(),
        this.type = "CubicBezierCurve",
        this.v0 = $,
        this.v1 = tt,
        this.v2 = nt,
        this.v3 = rt
    }
    getPoint($, tt=new Vector2) {
        const nt = tt
          , rt = this.v0
          , it = this.v1
          , ot = this.v2
          , st = this.v3;
        return nt.set(CubicBezier($, rt.x, it.x, ot.x, st.x), CubicBezier($, rt.y, it.y, ot.y, st.y)),
        nt
    }
    copy($) {
        return super.copy($),
        this.v0.copy($.v0),
        this.v1.copy($.v1),
        this.v2.copy($.v2),
        this.v3.copy($.v3),
        this
    }
    toJSON() {
        const $ = super.toJSON();
        return $.v0 = this.v0.toArray(),
        $.v1 = this.v1.toArray(),
        $.v2 = this.v2.toArray(),
        $.v3 = this.v3.toArray(),
        $
    }
    fromJSON($) {
        return super.fromJSON($),
        this.v0.fromArray($.v0),
        this.v1.fromArray($.v1),
        this.v2.fromArray($.v2),
        this.v3.fromArray($.v3),
        this
    }
}
CubicBezierCurve.prototype.isCubicBezierCurve = !0;
class CubicBezierCurve3 extends Curve {
    constructor($=new Vector3, tt=new Vector3, nt=new Vector3, rt=new Vector3) {
        super(),
        this.type = "CubicBezierCurve3",
        this.v0 = $,
        this.v1 = tt,
        this.v2 = nt,
        this.v3 = rt
    }
    getPoint($, tt=new Vector3) {
        const nt = tt
          , rt = this.v0
          , it = this.v1
          , ot = this.v2
          , st = this.v3;
        return nt.set(CubicBezier($, rt.x, it.x, ot.x, st.x), CubicBezier($, rt.y, it.y, ot.y, st.y), CubicBezier($, rt.z, it.z, ot.z, st.z)),
        nt
    }
    copy($) {
        return super.copy($),
        this.v0.copy($.v0),
        this.v1.copy($.v1),
        this.v2.copy($.v2),
        this.v3.copy($.v3),
        this
    }
    toJSON() {
        const $ = super.toJSON();
        return $.v0 = this.v0.toArray(),
        $.v1 = this.v1.toArray(),
        $.v2 = this.v2.toArray(),
        $.v3 = this.v3.toArray(),
        $
    }
    fromJSON($) {
        return super.fromJSON($),
        this.v0.fromArray($.v0),
        this.v1.fromArray($.v1),
        this.v2.fromArray($.v2),
        this.v3.fromArray($.v3),
        this
    }
}
CubicBezierCurve3.prototype.isCubicBezierCurve3 = !0;
class LineCurve extends Curve {
    constructor($=new Vector2, tt=new Vector2) {
        super(),
        this.type = "LineCurve",
        this.v1 = $,
        this.v2 = tt
    }
    getPoint($, tt=new Vector2) {
        const nt = tt;
        return $ === 1 ? nt.copy(this.v2) : (nt.copy(this.v2).sub(this.v1),
        nt.multiplyScalar($).add(this.v1)),
        nt
    }
    getPointAt($, tt) {
        return this.getPoint($, tt)
    }
    getTangent($, tt) {
        const nt = tt || new Vector2;
        return nt.copy(this.v2).sub(this.v1).normalize(),
        nt
    }
    copy($) {
        return super.copy($),
        this.v1.copy($.v1),
        this.v2.copy($.v2),
        this
    }
    toJSON() {
        const $ = super.toJSON();
        return $.v1 = this.v1.toArray(),
        $.v2 = this.v2.toArray(),
        $
    }
    fromJSON($) {
        return super.fromJSON($),
        this.v1.fromArray($.v1),
        this.v2.fromArray($.v2),
        this
    }
}
LineCurve.prototype.isLineCurve = !0;
class LineCurve3 extends Curve {
    constructor($=new Vector3, tt=new Vector3) {
        super(),
        this.type = "LineCurve3",
        this.isLineCurve3 = !0,
        this.v1 = $,
        this.v2 = tt
    }
    getPoint($, tt=new Vector3) {
        const nt = tt;
        return $ === 1 ? nt.copy(this.v2) : (nt.copy(this.v2).sub(this.v1),
        nt.multiplyScalar($).add(this.v1)),
        nt
    }
    getPointAt($, tt) {
        return this.getPoint($, tt)
    }
    copy($) {
        return super.copy($),
        this.v1.copy($.v1),
        this.v2.copy($.v2),
        this
    }
    toJSON() {
        const $ = super.toJSON();
        return $.v1 = this.v1.toArray(),
        $.v2 = this.v2.toArray(),
        $
    }
    fromJSON($) {
        return super.fromJSON($),
        this.v1.fromArray($.v1),
        this.v2.fromArray($.v2),
        this
    }
}
class QuadraticBezierCurve extends Curve {
    constructor($=new Vector2, tt=new Vector2, nt=new Vector2) {
        super(),
        this.type = "QuadraticBezierCurve",
        this.v0 = $,
        this.v1 = tt,
        this.v2 = nt
    }
    getPoint($, tt=new Vector2) {
        const nt = tt
          , rt = this.v0
          , it = this.v1
          , ot = this.v2;
        return nt.set(QuadraticBezier($, rt.x, it.x, ot.x), QuadraticBezier($, rt.y, it.y, ot.y)),
        nt
    }
    copy($) {
        return super.copy($),
        this.v0.copy($.v0),
        this.v1.copy($.v1),
        this.v2.copy($.v2),
        this
    }
    toJSON() {
        const $ = super.toJSON();
        return $.v0 = this.v0.toArray(),
        $.v1 = this.v1.toArray(),
        $.v2 = this.v2.toArray(),
        $
    }
    fromJSON($) {
        return super.fromJSON($),
        this.v0.fromArray($.v0),
        this.v1.fromArray($.v1),
        this.v2.fromArray($.v2),
        this
    }
}
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = !0;
class QuadraticBezierCurve3 extends Curve {
    constructor($=new Vector3, tt=new Vector3, nt=new Vector3) {
        super(),
        this.type = "QuadraticBezierCurve3",
        this.v0 = $,
        this.v1 = tt,
        this.v2 = nt
    }
    getPoint($, tt=new Vector3) {
        const nt = tt
          , rt = this.v0
          , it = this.v1
          , ot = this.v2;
        return nt.set(QuadraticBezier($, rt.x, it.x, ot.x), QuadraticBezier($, rt.y, it.y, ot.y), QuadraticBezier($, rt.z, it.z, ot.z)),
        nt
    }
    copy($) {
        return super.copy($),
        this.v0.copy($.v0),
        this.v1.copy($.v1),
        this.v2.copy($.v2),
        this
    }
    toJSON() {
        const $ = super.toJSON();
        return $.v0 = this.v0.toArray(),
        $.v1 = this.v1.toArray(),
        $.v2 = this.v2.toArray(),
        $
    }
    fromJSON($) {
        return super.fromJSON($),
        this.v0.fromArray($.v0),
        this.v1.fromArray($.v1),
        this.v2.fromArray($.v2),
        this
    }
}
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = !0;
class SplineCurve extends Curve {
    constructor($=[]) {
        super(),
        this.type = "SplineCurve",
        this.points = $
    }
    getPoint($, tt=new Vector2) {
        const nt = tt
          , rt = this.points
          , it = (rt.length - 1) * $
          , ot = Math.floor(it)
          , st = it - ot
          , lt = rt[ot === 0 ? ot : ot - 1]
          , ut = rt[ot]
          , ct = rt[ot > rt.length - 2 ? rt.length - 1 : ot + 1]
          , ht = rt[ot > rt.length - 3 ? rt.length - 1 : ot + 2];
        return nt.set(CatmullRom(st, lt.x, ut.x, ct.x, ht.x), CatmullRom(st, lt.y, ut.y, ct.y, ht.y)),
        nt
    }
    copy($) {
        super.copy($),
        this.points = [];
        for (let tt = 0, nt = $.points.length; tt < nt; tt++) {
            const rt = $.points[tt];
            this.points.push(rt.clone())
        }
        return this
    }
    toJSON() {
        const $ = super.toJSON();
        $.points = [];
        for (let tt = 0, nt = this.points.length; tt < nt; tt++) {
            const rt = this.points[tt];
            $.points.push(rt.toArray())
        }
        return $
    }
    fromJSON($) {
        super.fromJSON($),
        this.points = [];
        for (let tt = 0, nt = $.points.length; tt < nt; tt++) {
            const rt = $.points[tt];
            this.points.push(new Vector2().fromArray(rt))
        }
        return this
    }
}
SplineCurve.prototype.isSplineCurve = !0;
var Curves = Object.freeze({
    __proto__: null,
    ArcCurve,
    CatmullRomCurve3,
    CubicBezierCurve,
    CubicBezierCurve3,
    EllipseCurve,
    LineCurve,
    LineCurve3,
    QuadraticBezierCurve,
    QuadraticBezierCurve3,
    SplineCurve
});
class CurvePath extends Curve {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add($) {
        this.curves.push($)
    }
    closePath() {
        const $ = this.curves[0].getPoint(0)
          , tt = this.curves[this.curves.length - 1].getPoint(1);
        $.equals(tt) || this.curves.push(new LineCurve(tt,$))
    }
    getPoint($, tt) {
        const nt = $ * this.getLength()
          , rt = this.getCurveLengths();
        let it = 0;
        for (; it < rt.length; ) {
            if (rt[it] >= nt) {
                const ot = rt[it] - nt
                  , st = this.curves[it]
                  , lt = st.getLength()
                  , ut = lt === 0 ? 0 : 1 - ot / lt;
                return st.getPointAt(ut, tt)
            }
            it++
        }
        return null
    }
    getLength() {
        const $ = this.getCurveLengths();
        return $[$.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const $ = [];
        let tt = 0;
        for (let nt = 0, rt = this.curves.length; nt < rt; nt++)
            tt += this.curves[nt].getLength(),
            $.push(tt);
        return this.cacheLengths = $,
        $
    }
    getSpacedPoints($=40) {
        const tt = [];
        for (let nt = 0; nt <= $; nt++)
            tt.push(this.getPoint(nt / $));
        return this.autoClose && tt.push(tt[0]),
        tt
    }
    getPoints($=12) {
        const tt = [];
        let nt;
        for (let rt = 0, it = this.curves; rt < it.length; rt++) {
            const ot = it[rt]
              , st = ot.isEllipseCurve ? $ * 2 : ot.isLineCurve || ot.isLineCurve3 ? 1 : ot.isSplineCurve ? $ * ot.points.length : $
              , lt = ot.getPoints(st);
            for (let ut = 0; ut < lt.length; ut++) {
                const ct = lt[ut];
                nt && nt.equals(ct) || (tt.push(ct),
                nt = ct)
            }
        }
        return this.autoClose && tt.length > 1 && !tt[tt.length - 1].equals(tt[0]) && tt.push(tt[0]),
        tt
    }
    copy($) {
        super.copy($),
        this.curves = [];
        for (let tt = 0, nt = $.curves.length; tt < nt; tt++) {
            const rt = $.curves[tt];
            this.curves.push(rt.clone())
        }
        return this.autoClose = $.autoClose,
        this
    }
    toJSON() {
        const $ = super.toJSON();
        $.autoClose = this.autoClose,
        $.curves = [];
        for (let tt = 0, nt = this.curves.length; tt < nt; tt++) {
            const rt = this.curves[tt];
            $.curves.push(rt.toJSON())
        }
        return $
    }
    fromJSON($) {
        super.fromJSON($),
        this.autoClose = $.autoClose,
        this.curves = [];
        for (let tt = 0, nt = $.curves.length; tt < nt; tt++) {
            const rt = $.curves[tt];
            this.curves.push(new Curves[rt.type]().fromJSON(rt))
        }
        return this
    }
}
class Path extends CurvePath {
    constructor($) {
        super(),
        this.type = "Path",
        this.currentPoint = new Vector2,
        $ && this.setFromPoints($)
    }
    setFromPoints($) {
        this.moveTo($[0].x, $[0].y);
        for (let tt = 1, nt = $.length; tt < nt; tt++)
            this.lineTo($[tt].x, $[tt].y);
        return this
    }
    moveTo($, tt) {
        return this.currentPoint.set($, tt),
        this
    }
    lineTo($, tt) {
        const nt = new LineCurve(this.currentPoint.clone(),new Vector2($,tt));
        return this.curves.push(nt),
        this.currentPoint.set($, tt),
        this
    }
    quadraticCurveTo($, tt, nt, rt) {
        const it = new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2($,tt),new Vector2(nt,rt));
        return this.curves.push(it),
        this.currentPoint.set(nt, rt),
        this
    }
    bezierCurveTo($, tt, nt, rt, it, ot) {
        const st = new CubicBezierCurve(this.currentPoint.clone(),new Vector2($,tt),new Vector2(nt,rt),new Vector2(it,ot));
        return this.curves.push(st),
        this.currentPoint.set(it, ot),
        this
    }
    splineThru($) {
        const tt = [this.currentPoint.clone()].concat($)
          , nt = new SplineCurve(tt);
        return this.curves.push(nt),
        this.currentPoint.copy($[$.length - 1]),
        this
    }
    arc($, tt, nt, rt, it, ot) {
        const st = this.currentPoint.x
          , lt = this.currentPoint.y;
        return this.absarc($ + st, tt + lt, nt, rt, it, ot),
        this
    }
    absarc($, tt, nt, rt, it, ot) {
        return this.absellipse($, tt, nt, nt, rt, it, ot),
        this
    }
    ellipse($, tt, nt, rt, it, ot, st, lt) {
        const ut = this.currentPoint.x
          , ct = this.currentPoint.y;
        return this.absellipse($ + ut, tt + ct, nt, rt, it, ot, st, lt),
        this
    }
    absellipse($, tt, nt, rt, it, ot, st, lt) {
        const ut = new EllipseCurve($,tt,nt,rt,it,ot,st,lt);
        if (this.curves.length > 0) {
            const ht = ut.getPoint(0);
            ht.equals(this.currentPoint) || this.lineTo(ht.x, ht.y)
        }
        this.curves.push(ut);
        const ct = ut.getPoint(1);
        return this.currentPoint.copy(ct),
        this
    }
    copy($) {
        return super.copy($),
        this.currentPoint.copy($.currentPoint),
        this
    }
    toJSON() {
        const $ = super.toJSON();
        return $.currentPoint = this.currentPoint.toArray(),
        $
    }
    fromJSON($) {
        return super.fromJSON($),
        this.currentPoint.fromArray($.currentPoint),
        this
    }
}
class Shape extends Path {
    constructor($) {
        super($),
        this.uuid = generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles($) {
        const tt = [];
        for (let nt = 0, rt = this.holes.length; nt < rt; nt++)
            tt[nt] = this.holes[nt].getPoints($);
        return tt
    }
    extractPoints($) {
        return {
            shape: this.getPoints($),
            holes: this.getPointsHoles($)
        }
    }
    copy($) {
        super.copy($),
        this.holes = [];
        for (let tt = 0, nt = $.holes.length; tt < nt; tt++) {
            const rt = $.holes[tt];
            this.holes.push(rt.clone())
        }
        return this
    }
    toJSON() {
        const $ = super.toJSON();
        $.uuid = this.uuid,
        $.holes = [];
        for (let tt = 0, nt = this.holes.length; tt < nt; tt++) {
            const rt = this.holes[tt];
            $.holes.push(rt.toJSON())
        }
        return $
    }
    fromJSON($) {
        super.fromJSON($),
        this.uuid = $.uuid,
        this.holes = [];
        for (let tt = 0, nt = $.holes.length; tt < nt; tt++) {
            const rt = $.holes[tt];
            this.holes.push(new Path().fromJSON(rt))
        }
        return this
    }
}
const Earcut = {
    triangulate: function(et, $, tt=2) {
        const nt = $ && $.length
          , rt = nt ? $[0] * tt : et.length;
        let it = linkedList(et, 0, rt, tt, !0);
        const ot = [];
        if (!it || it.next === it.prev)
            return ot;
        let st, lt, ut, ct, ht, ft, gt;
        if (nt && (it = eliminateHoles(et, $, it, tt)),
        et.length > 80 * tt) {
            st = ut = et[0],
            lt = ct = et[1];
            for (let vt = tt; vt < rt; vt += tt)
                ht = et[vt],
                ft = et[vt + 1],
                ht < st && (st = ht),
                ft < lt && (lt = ft),
                ht > ut && (ut = ht),
                ft > ct && (ct = ft);
            gt = Math.max(ut - st, ct - lt),
            gt = gt !== 0 ? 1 / gt : 0
        }
        return earcutLinked(it, ot, tt, st, lt, gt),
        ot
    }
};
function linkedList(et, $, tt, nt, rt) {
    let it, ot;
    if (rt === signedArea(et, $, tt, nt) > 0)
        for (it = $; it < tt; it += nt)
            ot = insertNode(it, et[it], et[it + 1], ot);
    else
        for (it = tt - nt; it >= $; it -= nt)
            ot = insertNode(it, et[it], et[it + 1], ot);
    return ot && equals(ot, ot.next) && (removeNode(ot),
    ot = ot.next),
    ot
}
function filterPoints(et, $) {
    if (!et)
        return et;
    $ || ($ = et);
    let tt = et, nt;
    do
        if (nt = !1,
        !tt.steiner && (equals(tt, tt.next) || area(tt.prev, tt, tt.next) === 0)) {
            if (removeNode(tt),
            tt = $ = tt.prev,
            tt === tt.next)
                break;
            nt = !0
        } else
            tt = tt.next;
    while (nt || tt !== $);
    return $
}
function earcutLinked(et, $, tt, nt, rt, it, ot) {
    if (!et)
        return;
    !ot && it && indexCurve(et, nt, rt, it);
    let st = et, lt, ut;
    for (; et.prev !== et.next; ) {
        if (lt = et.prev,
        ut = et.next,
        it ? isEarHashed(et, nt, rt, it) : isEar(et)) {
            $.push(lt.i / tt),
            $.push(et.i / tt),
            $.push(ut.i / tt),
            removeNode(et),
            et = ut.next,
            st = ut.next;
            continue
        }
        if (et = ut,
        et === st) {
            ot ? ot === 1 ? (et = cureLocalIntersections(filterPoints(et), $, tt),
            earcutLinked(et, $, tt, nt, rt, it, 2)) : ot === 2 && splitEarcut(et, $, tt, nt, rt, it) : earcutLinked(filterPoints(et), $, tt, nt, rt, it, 1);
            break
        }
    }
}
function isEar(et) {
    const $ = et.prev
      , tt = et
      , nt = et.next;
    if (area($, tt, nt) >= 0)
        return !1;
    let rt = et.next.next;
    for (; rt !== et.prev; ) {
        if (pointInTriangle($.x, $.y, tt.x, tt.y, nt.x, nt.y, rt.x, rt.y) && area(rt.prev, rt, rt.next) >= 0)
            return !1;
        rt = rt.next
    }
    return !0
}
function isEarHashed(et, $, tt, nt) {
    const rt = et.prev
      , it = et
      , ot = et.next;
    if (area(rt, it, ot) >= 0)
        return !1;
    const st = rt.x < it.x ? rt.x < ot.x ? rt.x : ot.x : it.x < ot.x ? it.x : ot.x
      , lt = rt.y < it.y ? rt.y < ot.y ? rt.y : ot.y : it.y < ot.y ? it.y : ot.y
      , ut = rt.x > it.x ? rt.x > ot.x ? rt.x : ot.x : it.x > ot.x ? it.x : ot.x
      , ct = rt.y > it.y ? rt.y > ot.y ? rt.y : ot.y : it.y > ot.y ? it.y : ot.y
      , ht = zOrder(st, lt, $, tt, nt)
      , ft = zOrder(ut, ct, $, tt, nt);
    let gt = et.prevZ
      , vt = et.nextZ;
    for (; gt && gt.z >= ht && vt && vt.z <= ft; ) {
        if (gt !== et.prev && gt !== et.next && pointInTriangle(rt.x, rt.y, it.x, it.y, ot.x, ot.y, gt.x, gt.y) && area(gt.prev, gt, gt.next) >= 0 || (gt = gt.prevZ,
        vt !== et.prev && vt !== et.next && pointInTriangle(rt.x, rt.y, it.x, it.y, ot.x, ot.y, vt.x, vt.y) && area(vt.prev, vt, vt.next) >= 0))
            return !1;
        vt = vt.nextZ
    }
    for (; gt && gt.z >= ht; ) {
        if (gt !== et.prev && gt !== et.next && pointInTriangle(rt.x, rt.y, it.x, it.y, ot.x, ot.y, gt.x, gt.y) && area(gt.prev, gt, gt.next) >= 0)
            return !1;
        gt = gt.prevZ
    }
    for (; vt && vt.z <= ft; ) {
        if (vt !== et.prev && vt !== et.next && pointInTriangle(rt.x, rt.y, it.x, it.y, ot.x, ot.y, vt.x, vt.y) && area(vt.prev, vt, vt.next) >= 0)
            return !1;
        vt = vt.nextZ
    }
    return !0
}
function cureLocalIntersections(et, $, tt) {
    let nt = et;
    do {
        const rt = nt.prev
          , it = nt.next.next;
        !equals(rt, it) && intersects(rt, nt, nt.next, it) && locallyInside(rt, it) && locallyInside(it, rt) && ($.push(rt.i / tt),
        $.push(nt.i / tt),
        $.push(it.i / tt),
        removeNode(nt),
        removeNode(nt.next),
        nt = et = it),
        nt = nt.next
    } while (nt !== et);
    return filterPoints(nt)
}
function splitEarcut(et, $, tt, nt, rt, it) {
    let ot = et;
    do {
        let st = ot.next.next;
        for (; st !== ot.prev; ) {
            if (ot.i !== st.i && isValidDiagonal(ot, st)) {
                let lt = splitPolygon(ot, st);
                ot = filterPoints(ot, ot.next),
                lt = filterPoints(lt, lt.next),
                earcutLinked(ot, $, tt, nt, rt, it),
                earcutLinked(lt, $, tt, nt, rt, it);
                return
            }
            st = st.next
        }
        ot = ot.next
    } while (ot !== et)
}
function eliminateHoles(et, $, tt, nt) {
    const rt = [];
    let it, ot, st, lt, ut;
    for (it = 0,
    ot = $.length; it < ot; it++)
        st = $[it] * nt,
        lt = it < ot - 1 ? $[it + 1] * nt : et.length,
        ut = linkedList(et, st, lt, nt, !1),
        ut === ut.next && (ut.steiner = !0),
        rt.push(getLeftmost(ut));
    for (rt.sort(compareX),
    it = 0; it < rt.length; it++)
        eliminateHole(rt[it], tt),
        tt = filterPoints(tt, tt.next);
    return tt
}
function compareX(et, $) {
    return et.x - $.x
}
function eliminateHole(et, $) {
    if ($ = findHoleBridge(et, $),
    $) {
        const tt = splitPolygon($, et);
        filterPoints($, $.next),
        filterPoints(tt, tt.next)
    }
}
function findHoleBridge(et, $) {
    let tt = $;
    const nt = et.x
      , rt = et.y;
    let it = -1 / 0, ot;
    do {
        if (rt <= tt.y && rt >= tt.next.y && tt.next.y !== tt.y) {
            const ft = tt.x + (rt - tt.y) * (tt.next.x - tt.x) / (tt.next.y - tt.y);
            if (ft <= nt && ft > it) {
                if (it = ft,
                ft === nt) {
                    if (rt === tt.y)
                        return tt;
                    if (rt === tt.next.y)
                        return tt.next
                }
                ot = tt.x < tt.next.x ? tt : tt.next
            }
        }
        tt = tt.next
    } while (tt !== $);
    if (!ot)
        return null;
    if (nt === it)
        return ot;
    const st = ot
      , lt = ot.x
      , ut = ot.y;
    let ct = 1 / 0, ht;
    tt = ot;
    do
        nt >= tt.x && tt.x >= lt && nt !== tt.x && pointInTriangle(rt < ut ? nt : it, rt, lt, ut, rt < ut ? it : nt, rt, tt.x, tt.y) && (ht = Math.abs(rt - tt.y) / (nt - tt.x),
        locallyInside(tt, et) && (ht < ct || ht === ct && (tt.x > ot.x || tt.x === ot.x && sectorContainsSector(ot, tt))) && (ot = tt,
        ct = ht)),
        tt = tt.next;
    while (tt !== st);
    return ot
}
function sectorContainsSector(et, $) {
    return area(et.prev, et, $.prev) < 0 && area($.next, et, et.next) < 0
}
function indexCurve(et, $, tt, nt) {
    let rt = et;
    do
        rt.z === null && (rt.z = zOrder(rt.x, rt.y, $, tt, nt)),
        rt.prevZ = rt.prev,
        rt.nextZ = rt.next,
        rt = rt.next;
    while (rt !== et);
    rt.prevZ.nextZ = null,
    rt.prevZ = null,
    sortLinked(rt)
}
function sortLinked(et) {
    let $, tt, nt, rt, it, ot, st, lt, ut = 1;
    do {
        for (tt = et,
        et = null,
        it = null,
        ot = 0; tt; ) {
            for (ot++,
            nt = tt,
            st = 0,
            $ = 0; $ < ut && (st++,
            nt = nt.nextZ,
            !!nt); $++)
                ;
            for (lt = ut; st > 0 || lt > 0 && nt; )
                st !== 0 && (lt === 0 || !nt || tt.z <= nt.z) ? (rt = tt,
                tt = tt.nextZ,
                st--) : (rt = nt,
                nt = nt.nextZ,
                lt--),
                it ? it.nextZ = rt : et = rt,
                rt.prevZ = it,
                it = rt;
            tt = nt
        }
        it.nextZ = null,
        ut *= 2
    } while (ot > 1);
    return et
}
function zOrder(et, $, tt, nt, rt) {
    return et = 32767 * (et - tt) * rt,
    $ = 32767 * ($ - nt) * rt,
    et = (et | et << 8) & 16711935,
    et = (et | et << 4) & 252645135,
    et = (et | et << 2) & 858993459,
    et = (et | et << 1) & 1431655765,
    $ = ($ | $ << 8) & 16711935,
    $ = ($ | $ << 4) & 252645135,
    $ = ($ | $ << 2) & 858993459,
    $ = ($ | $ << 1) & 1431655765,
    et | $ << 1
}
function getLeftmost(et) {
    let $ = et
      , tt = et;
    do
        ($.x < tt.x || $.x === tt.x && $.y < tt.y) && (tt = $),
        $ = $.next;
    while ($ !== et);
    return tt
}
function pointInTriangle(et, $, tt, nt, rt, it, ot, st) {
    return (rt - ot) * ($ - st) - (et - ot) * (it - st) >= 0 && (et - ot) * (nt - st) - (tt - ot) * ($ - st) >= 0 && (tt - ot) * (it - st) - (rt - ot) * (nt - st) >= 0
}
function isValidDiagonal(et, $) {
    return et.next.i !== $.i && et.prev.i !== $.i && !intersectsPolygon(et, $) && (locallyInside(et, $) && locallyInside($, et) && middleInside(et, $) && (area(et.prev, et, $.prev) || area(et, $.prev, $)) || equals(et, $) && area(et.prev, et, et.next) > 0 && area($.prev, $, $.next) > 0)
}
function area(et, $, tt) {
    return ($.y - et.y) * (tt.x - $.x) - ($.x - et.x) * (tt.y - $.y)
}
function equals(et, $) {
    return et.x === $.x && et.y === $.y
}
function intersects(et, $, tt, nt) {
    const rt = sign(area(et, $, tt))
      , it = sign(area(et, $, nt))
      , ot = sign(area(tt, nt, et))
      , st = sign(area(tt, nt, $));
    return !!(rt !== it && ot !== st || rt === 0 && onSegment(et, tt, $) || it === 0 && onSegment(et, nt, $) || ot === 0 && onSegment(tt, et, nt) || st === 0 && onSegment(tt, $, nt))
}
function onSegment(et, $, tt) {
    return $.x <= Math.max(et.x, tt.x) && $.x >= Math.min(et.x, tt.x) && $.y <= Math.max(et.y, tt.y) && $.y >= Math.min(et.y, tt.y)
}
function sign(et) {
    return et > 0 ? 1 : et < 0 ? -1 : 0
}
function intersectsPolygon(et, $) {
    let tt = et;
    do {
        if (tt.i !== et.i && tt.next.i !== et.i && tt.i !== $.i && tt.next.i !== $.i && intersects(tt, tt.next, et, $))
            return !0;
        tt = tt.next
    } while (tt !== et);
    return !1
}
function locallyInside(et, $) {
    return area(et.prev, et, et.next) < 0 ? area(et, $, et.next) >= 0 && area(et, et.prev, $) >= 0 : area(et, $, et.prev) < 0 || area(et, et.next, $) < 0
}
function middleInside(et, $) {
    let tt = et
      , nt = !1;
    const rt = (et.x + $.x) / 2
      , it = (et.y + $.y) / 2;
    do
        tt.y > it != tt.next.y > it && tt.next.y !== tt.y && rt < (tt.next.x - tt.x) * (it - tt.y) / (tt.next.y - tt.y) + tt.x && (nt = !nt),
        tt = tt.next;
    while (tt !== et);
    return nt
}
function splitPolygon(et, $) {
    const tt = new Node(et.i,et.x,et.y)
      , nt = new Node($.i,$.x,$.y)
      , rt = et.next
      , it = $.prev;
    return et.next = $,
    $.prev = et,
    tt.next = rt,
    rt.prev = tt,
    nt.next = tt,
    tt.prev = nt,
    it.next = nt,
    nt.prev = it,
    nt
}
function insertNode(et, $, tt, nt) {
    const rt = new Node(et,$,tt);
    return nt ? (rt.next = nt.next,
    rt.prev = nt,
    nt.next.prev = rt,
    nt.next = rt) : (rt.prev = rt,
    rt.next = rt),
    rt
}
function removeNode(et) {
    et.next.prev = et.prev,
    et.prev.next = et.next,
    et.prevZ && (et.prevZ.nextZ = et.nextZ),
    et.nextZ && (et.nextZ.prevZ = et.prevZ)
}
function Node(et, $, tt) {
    this.i = et,
    this.x = $,
    this.y = tt,
    this.prev = null,
    this.next = null,
    this.z = null,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function signedArea(et, $, tt, nt) {
    let rt = 0;
    for (let it = $, ot = tt - nt; it < tt; it += nt)
        rt += (et[ot] - et[it]) * (et[it + 1] + et[ot + 1]),
        ot = it;
    return rt
}
class ShapeUtils {
    static area($) {
        const tt = $.length;
        let nt = 0;
        for (let rt = tt - 1, it = 0; it < tt; rt = it++)
            nt += $[rt].x * $[it].y - $[it].x * $[rt].y;
        return nt * .5
    }
    static isClockWise($) {
        return ShapeUtils.area($) < 0
    }
    static triangulateShape($, tt) {
        const nt = []
          , rt = []
          , it = [];
        removeDupEndPts($),
        addContour(nt, $);
        let ot = $.length;
        tt.forEach(removeDupEndPts);
        for (let lt = 0; lt < tt.length; lt++)
            rt.push(ot),
            ot += tt[lt].length,
            addContour(nt, tt[lt]);
        const st = Earcut.triangulate(nt, rt);
        for (let lt = 0; lt < st.length; lt += 3)
            it.push(st.slice(lt, lt + 3));
        return it
    }
}
function removeDupEndPts(et) {
    const $ = et.length;
    $ > 2 && et[$ - 1].equals(et[0]) && et.pop()
}
function addContour(et, $) {
    for (let tt = 0; tt < $.length; tt++)
        et.push($[tt].x),
        et.push($[tt].y)
}
class ExtrudeGeometry extends BufferGeometry {
    constructor($=new Shape([new Vector2(.5,.5), new Vector2(-.5,.5), new Vector2(-.5,-.5), new Vector2(.5,-.5)]), tt={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: $,
            options: tt
        },
        $ = Array.isArray($) ? $ : [$];
        const nt = this
          , rt = []
          , it = [];
        for (let st = 0, lt = $.length; st < lt; st++) {
            const ut = $[st];
            ot(ut)
        }
        this.setAttribute("position", new Float32BufferAttribute(rt,3)),
        this.setAttribute("uv", new Float32BufferAttribute(it,2)),
        this.computeVertexNormals();
        function ot(st) {
            const lt = []
              , ut = tt.curveSegments !== void 0 ? tt.curveSegments : 12
              , ct = tt.steps !== void 0 ? tt.steps : 1;
            let ht = tt.depth !== void 0 ? tt.depth : 1
              , ft = tt.bevelEnabled !== void 0 ? tt.bevelEnabled : !0
              , gt = tt.bevelThickness !== void 0 ? tt.bevelThickness : .2
              , vt = tt.bevelSize !== void 0 ? tt.bevelSize : gt - .1
              , yt = tt.bevelOffset !== void 0 ? tt.bevelOffset : 0
              , wt = tt.bevelSegments !== void 0 ? tt.bevelSegments : 3;
            const mt = tt.extrudePath
              , _t = tt.UVGenerator !== void 0 ? tt.UVGenerator : WorldUVGenerator;
            tt.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
            ht = tt.amount);
            let bt, Mt = !1, St, At, Pt, Ot;
            mt && (bt = mt.getSpacedPoints(ct),
            Mt = !0,
            ft = !1,
            St = mt.computeFrenetFrames(ct, !1),
            At = new Vector3,
            Pt = new Vector3,
            Ot = new Vector3),
            ft || (wt = 0,
            gt = 0,
            vt = 0,
            yt = 0);
            const Zt = st.extractPoints(ut);
            let Nt = Zt.shape;
            const Tt = Zt.holes;
            if (!ShapeUtils.isClockWise(Nt)) {
                Nt = Nt.reverse();
                for (let cn = 0, bn = Tt.length; cn < bn; cn++) {
                    const Mn = Tt[cn];
                    ShapeUtils.isClockWise(Mn) && (Tt[cn] = Mn.reverse())
                }
            }
            const $t = ShapeUtils.triangulateShape(Nt, Tt)
              , Wt = Nt;
            for (let cn = 0, bn = Tt.length; cn < bn; cn++) {
                const Mn = Tt[cn];
                Nt = Nt.concat(Mn)
            }
            function Kt(cn, bn, Mn) {
                return bn || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                bn.clone().multiplyScalar(Mn).add(cn)
            }
            const qt = Nt.length
              , jt = $t.length;
            function Bt(cn, bn, Mn) {
                let Dn, Pn, $n;
                const On = cn.x - bn.x
                  , Wn = cn.y - bn.y
                  , rr = Mn.x - cn.x
                  , Dt = Mn.y - cn.y
                  , kt = On * On + Wn * Wn
                  , pn = On * Dt - Wn * rr;
                if (Math.abs(pn) > Number.EPSILON) {
                    const mn = Math.sqrt(kt)
                      , An = Math.sqrt(rr * rr + Dt * Dt)
                      , In = bn.x - Wn / mn
                      , Gt = bn.y + On / mn
                      , Ht = Mn.x - Dt / An
                      , Vt = Mn.y + rr / An
                      , hn = ((Ht - In) * Dt - (Vt - Gt) * rr) / (On * Dt - Wn * rr);
                    Dn = In + On * hn - cn.x,
                    Pn = Gt + Wn * hn - cn.y;
                    const vn = Dn * Dn + Pn * Pn;
                    if (vn <= 2)
                        return new Vector2(Dn,Pn);
                    $n = Math.sqrt(vn / 2)
                } else {
                    let mn = !1;
                    On > Number.EPSILON ? rr > Number.EPSILON && (mn = !0) : On < -Number.EPSILON ? rr < -Number.EPSILON && (mn = !0) : Math.sign(Wn) === Math.sign(Dt) && (mn = !0),
                    mn ? (Dn = -Wn,
                    Pn = On,
                    $n = Math.sqrt(kt)) : (Dn = On,
                    Pn = Wn,
                    $n = Math.sqrt(kt / 2))
                }
                return new Vector2(Dn / $n,Pn / $n)
            }
            const Xt = [];
            for (let cn = 0, bn = Wt.length, Mn = bn - 1, Dn = cn + 1; cn < bn; cn++,
            Mn++,
            Dn++)
                Mn === bn && (Mn = 0),
                Dn === bn && (Dn = 0),
                Xt[cn] = Bt(Wt[cn], Wt[Mn], Wt[Dn]);
            const Jt = [];
            let Lt, Rt = Xt.concat();
            for (let cn = 0, bn = Tt.length; cn < bn; cn++) {
                const Mn = Tt[cn];
                Lt = [];
                for (let Dn = 0, Pn = Mn.length, $n = Pn - 1, On = Dn + 1; Dn < Pn; Dn++,
                $n++,
                On++)
                    $n === Pn && ($n = 0),
                    On === Pn && (On = 0),
                    Lt[Dn] = Bt(Mn[Dn], Mn[$n], Mn[On]);
                Jt.push(Lt),
                Rt = Rt.concat(Lt)
            }
            for (let cn = 0; cn < wt; cn++) {
                const bn = cn / wt
                  , Mn = gt * Math.cos(bn * Math.PI / 2)
                  , Dn = vt * Math.sin(bn * Math.PI / 2) + yt;
                for (let Pn = 0, $n = Wt.length; Pn < $n; Pn++) {
                    const On = Kt(Wt[Pn], Xt[Pn], Dn);
                    Un(On.x, On.y, -Mn)
                }
                for (let Pn = 0, $n = Tt.length; Pn < $n; Pn++) {
                    const On = Tt[Pn];
                    Lt = Jt[Pn];
                    for (let Wn = 0, rr = On.length; Wn < rr; Wn++) {
                        const Dt = Kt(On[Wn], Lt[Wn], Dn);
                        Un(Dt.x, Dt.y, -Mn)
                    }
                }
            }
            const _n = vt + yt;
            for (let cn = 0; cn < qt; cn++) {
                const bn = ft ? Kt(Nt[cn], Rt[cn], _n) : Nt[cn];
                Mt ? (Pt.copy(St.normals[0]).multiplyScalar(bn.x),
                At.copy(St.binormals[0]).multiplyScalar(bn.y),
                Ot.copy(bt[0]).add(Pt).add(At),
                Un(Ot.x, Ot.y, Ot.z)) : Un(bn.x, bn.y, 0)
            }
            for (let cn = 1; cn <= ct; cn++)
                for (let bn = 0; bn < qt; bn++) {
                    const Mn = ft ? Kt(Nt[bn], Rt[bn], _n) : Nt[bn];
                    Mt ? (Pt.copy(St.normals[cn]).multiplyScalar(Mn.x),
                    At.copy(St.binormals[cn]).multiplyScalar(Mn.y),
                    Ot.copy(bt[cn]).add(Pt).add(At),
                    Un(Ot.x, Ot.y, Ot.z)) : Un(Mn.x, Mn.y, ht / ct * cn)
                }
            for (let cn = wt - 1; cn >= 0; cn--) {
                const bn = cn / wt
                  , Mn = gt * Math.cos(bn * Math.PI / 2)
                  , Dn = vt * Math.sin(bn * Math.PI / 2) + yt;
                for (let Pn = 0, $n = Wt.length; Pn < $n; Pn++) {
                    const On = Kt(Wt[Pn], Xt[Pn], Dn);
                    Un(On.x, On.y, ht + Mn)
                }
                for (let Pn = 0, $n = Tt.length; Pn < $n; Pn++) {
                    const On = Tt[Pn];
                    Lt = Jt[Pn];
                    for (let Wn = 0, rr = On.length; Wn < rr; Wn++) {
                        const Dt = Kt(On[Wn], Lt[Wn], Dn);
                        Mt ? Un(Dt.x, Dt.y + bt[ct - 1].y, bt[ct - 1].x + Mn) : Un(Dt.x, Dt.y, ht + Mn)
                    }
                }
            }
            Fn(),
            Vn();
            function Fn() {
                const cn = rt.length / 3;
                if (ft) {
                    let bn = 0
                      , Mn = qt * bn;
                    for (let Dn = 0; Dn < jt; Dn++) {
                        const Pn = $t[Dn];
                        zn(Pn[2] + Mn, Pn[1] + Mn, Pn[0] + Mn)
                    }
                    bn = ct + wt * 2,
                    Mn = qt * bn;
                    for (let Dn = 0; Dn < jt; Dn++) {
                        const Pn = $t[Dn];
                        zn(Pn[0] + Mn, Pn[1] + Mn, Pn[2] + Mn)
                    }
                } else {
                    for (let bn = 0; bn < jt; bn++) {
                        const Mn = $t[bn];
                        zn(Mn[2], Mn[1], Mn[0])
                    }
                    for (let bn = 0; bn < jt; bn++) {
                        const Mn = $t[bn];
                        zn(Mn[0] + qt * ct, Mn[1] + qt * ct, Mn[2] + qt * ct)
                    }
                }
                nt.addGroup(cn, rt.length / 3 - cn, 0)
            }
            function Vn() {
                const cn = rt.length / 3;
                let bn = 0;
                sn(Wt, bn),
                bn += Wt.length;
                for (let Mn = 0, Dn = Tt.length; Mn < Dn; Mn++) {
                    const Pn = Tt[Mn];
                    sn(Pn, bn),
                    bn += Pn.length
                }
                nt.addGroup(cn, rt.length / 3 - cn, 1)
            }
            function sn(cn, bn) {
                let Mn = cn.length;
                for (; --Mn >= 0; ) {
                    const Dn = Mn;
                    let Pn = Mn - 1;
                    Pn < 0 && (Pn = cn.length - 1);
                    for (let $n = 0, On = ct + wt * 2; $n < On; $n++) {
                        const Wn = qt * $n
                          , rr = qt * ($n + 1)
                          , Dt = bn + Dn + Wn
                          , kt = bn + Pn + Wn
                          , pn = bn + Pn + rr
                          , mn = bn + Dn + rr;
                        Rn(Dt, kt, pn, mn)
                    }
                }
            }
            function Un(cn, bn, Mn) {
                lt.push(cn),
                lt.push(bn),
                lt.push(Mn)
            }
            function zn(cn, bn, Mn) {
                Ln(cn),
                Ln(bn),
                Ln(Mn);
                const Dn = rt.length / 3
                  , Pn = _t.generateTopUV(nt, rt, Dn - 3, Dn - 2, Dn - 1);
                Gn(Pn[0]),
                Gn(Pn[1]),
                Gn(Pn[2])
            }
            function Rn(cn, bn, Mn, Dn) {
                Ln(cn),
                Ln(bn),
                Ln(Dn),
                Ln(bn),
                Ln(Mn),
                Ln(Dn);
                const Pn = rt.length / 3
                  , $n = _t.generateSideWallUV(nt, rt, Pn - 6, Pn - 3, Pn - 2, Pn - 1);
                Gn($n[0]),
                Gn($n[1]),
                Gn($n[3]),
                Gn($n[1]),
                Gn($n[2]),
                Gn($n[3])
            }
            function Ln(cn) {
                rt.push(lt[cn * 3 + 0]),
                rt.push(lt[cn * 3 + 1]),
                rt.push(lt[cn * 3 + 2])
            }
            function Gn(cn) {
                it.push(cn.x),
                it.push(cn.y)
            }
        }
    }
    toJSON() {
        const $ = super.toJSON()
          , tt = this.parameters.shapes
          , nt = this.parameters.options;
        return toJSON$1(tt, nt, $)
    }
    static fromJSON($, tt) {
        const nt = [];
        for (let it = 0, ot = $.shapes.length; it < ot; it++) {
            const st = tt[$.shapes[it]];
            nt.push(st)
        }
        const rt = $.options.extrudePath;
        return rt !== void 0 && ($.options.extrudePath = new Curves[rt.type]().fromJSON(rt)),
        new ExtrudeGeometry(nt,$.options)
    }
}
const WorldUVGenerator = {
    generateTopUV: function(et, $, tt, nt, rt) {
        const it = $[tt * 3]
          , ot = $[tt * 3 + 1]
          , st = $[nt * 3]
          , lt = $[nt * 3 + 1]
          , ut = $[rt * 3]
          , ct = $[rt * 3 + 1];
        return [new Vector2(it,ot), new Vector2(st,lt), new Vector2(ut,ct)]
    },
    generateSideWallUV: function(et, $, tt, nt, rt, it) {
        const ot = $[tt * 3]
          , st = $[tt * 3 + 1]
          , lt = $[tt * 3 + 2]
          , ut = $[nt * 3]
          , ct = $[nt * 3 + 1]
          , ht = $[nt * 3 + 2]
          , ft = $[rt * 3]
          , gt = $[rt * 3 + 1]
          , vt = $[rt * 3 + 2]
          , yt = $[it * 3]
          , wt = $[it * 3 + 1]
          , mt = $[it * 3 + 2];
        return Math.abs(st - ct) < Math.abs(ot - ut) ? [new Vector2(ot,1 - lt), new Vector2(ut,1 - ht), new Vector2(ft,1 - vt), new Vector2(yt,1 - mt)] : [new Vector2(st,1 - lt), new Vector2(ct,1 - ht), new Vector2(gt,1 - vt), new Vector2(wt,1 - mt)]
    }
};
function toJSON$1(et, $, tt) {
    if (tt.shapes = [],
    Array.isArray(et))
        for (let nt = 0, rt = et.length; nt < rt; nt++) {
            const it = et[nt];
            tt.shapes.push(it.uuid)
        }
    else
        tt.shapes.push(et.uuid);
    return $.extrudePath !== void 0 && (tt.options.extrudePath = $.extrudePath.toJSON()),
    tt
}
class ShapeGeometry extends BufferGeometry {
    constructor($=new Shape([new Vector2(0,.5), new Vector2(-.5,-.5), new Vector2(.5,-.5)]), tt=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: $,
            curveSegments: tt
        };
        const nt = []
          , rt = []
          , it = []
          , ot = [];
        let st = 0
          , lt = 0;
        if (Array.isArray($) === !1)
            ut($);
        else
            for (let ct = 0; ct < $.length; ct++)
                ut($[ct]),
                this.addGroup(st, lt, ct),
                st += lt,
                lt = 0;
        this.setIndex(nt),
        this.setAttribute("position", new Float32BufferAttribute(rt,3)),
        this.setAttribute("normal", new Float32BufferAttribute(it,3)),
        this.setAttribute("uv", new Float32BufferAttribute(ot,2));
        function ut(ct) {
            const ht = rt.length / 3
              , ft = ct.extractPoints(tt);
            let gt = ft.shape;
            const vt = ft.holes;
            ShapeUtils.isClockWise(gt) === !1 && (gt = gt.reverse());
            for (let wt = 0, mt = vt.length; wt < mt; wt++) {
                const _t = vt[wt];
                ShapeUtils.isClockWise(_t) === !0 && (vt[wt] = _t.reverse())
            }
            const yt = ShapeUtils.triangulateShape(gt, vt);
            for (let wt = 0, mt = vt.length; wt < mt; wt++) {
                const _t = vt[wt];
                gt = gt.concat(_t)
            }
            for (let wt = 0, mt = gt.length; wt < mt; wt++) {
                const _t = gt[wt];
                rt.push(_t.x, _t.y, 0),
                it.push(0, 0, 1),
                ot.push(_t.x, _t.y)
            }
            for (let wt = 0, mt = yt.length; wt < mt; wt++) {
                const _t = yt[wt]
                  , bt = _t[0] + ht
                  , Mt = _t[1] + ht
                  , St = _t[2] + ht;
                nt.push(bt, Mt, St),
                lt += 3
            }
        }
    }
    toJSON() {
        const $ = super.toJSON()
          , tt = this.parameters.shapes;
        return toJSON(tt, $)
    }
    static fromJSON($, tt) {
        const nt = [];
        for (let rt = 0, it = $.shapes.length; rt < it; rt++) {
            const ot = tt[$.shapes[rt]];
            nt.push(ot)
        }
        return new ShapeGeometry(nt,$.curveSegments)
    }
}
function toJSON(et, $) {
    if ($.shapes = [],
    Array.isArray(et))
        for (let tt = 0, nt = et.length; tt < nt; tt++) {
            const rt = et[tt];
            $.shapes.push(rt.uuid)
        }
    else
        $.shapes.push(et.uuid);
    return $
}
class ShadowMaterial extends Material {
    constructor($) {
        super(),
        this.type = "ShadowMaterial",
        this.color = new Color(0),
        this.transparent = !0,
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.color.copy($.color),
        this
    }
}
ShadowMaterial.prototype.isShadowMaterial = !0;
class RawShaderMaterial extends ShaderMaterial {
    constructor($) {
        super($),
        this.type = "RawShaderMaterial"
    }
}
RawShaderMaterial.prototype.isRawShaderMaterial = !0;
class MeshStandardMaterial extends Material {
    constructor($) {
        super(),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Color(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Color(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy($.color),
        this.roughness = $.roughness,
        this.metalness = $.metalness,
        this.map = $.map,
        this.lightMap = $.lightMap,
        this.lightMapIntensity = $.lightMapIntensity,
        this.aoMap = $.aoMap,
        this.aoMapIntensity = $.aoMapIntensity,
        this.emissive.copy($.emissive),
        this.emissiveMap = $.emissiveMap,
        this.emissiveIntensity = $.emissiveIntensity,
        this.bumpMap = $.bumpMap,
        this.bumpScale = $.bumpScale,
        this.normalMap = $.normalMap,
        this.normalMapType = $.normalMapType,
        this.normalScale.copy($.normalScale),
        this.displacementMap = $.displacementMap,
        this.displacementScale = $.displacementScale,
        this.displacementBias = $.displacementBias,
        this.roughnessMap = $.roughnessMap,
        this.metalnessMap = $.metalnessMap,
        this.alphaMap = $.alphaMap,
        this.envMap = $.envMap,
        this.envMapIntensity = $.envMapIntensity,
        this.refractionRatio = $.refractionRatio,
        this.wireframe = $.wireframe,
        this.wireframeLinewidth = $.wireframeLinewidth,
        this.wireframeLinecap = $.wireframeLinecap,
        this.wireframeLinejoin = $.wireframeLinejoin,
        this.flatShading = $.flatShading,
        this
    }
}
MeshStandardMaterial.prototype.isMeshStandardMaterial = !0;
class MeshPhysicalMaterial extends MeshStandardMaterial {
    constructor($) {
        super(),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new Vector2(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return clamp$1(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(tt) {
                this.ior = (1 + .4 * tt) / (1 - .4 * tt)
            }
        }),
        this.sheenColor = new Color(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 0,
        this.attenuationColor = new Color(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Color(1,1,1),
        this.specularColorMap = null,
        this._sheen = 0,
        this._clearcoat = 0,
        this._transmission = 0,
        this.setValues($)
    }
    get sheen() {
        return this._sheen
    }
    set sheen($) {
        this._sheen > 0 != $ > 0 && this.version++,
        this._sheen = $
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat($) {
        this._clearcoat > 0 != $ > 0 && this.version++,
        this._clearcoat = $
    }
    get transmission() {
        return this._transmission
    }
    set transmission($) {
        this._transmission > 0 != $ > 0 && this.version++,
        this._transmission = $
    }
    copy($) {
        return super.copy($),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = $.clearcoat,
        this.clearcoatMap = $.clearcoatMap,
        this.clearcoatRoughness = $.clearcoatRoughness,
        this.clearcoatRoughnessMap = $.clearcoatRoughnessMap,
        this.clearcoatNormalMap = $.clearcoatNormalMap,
        this.clearcoatNormalScale.copy($.clearcoatNormalScale),
        this.ior = $.ior,
        this.sheen = $.sheen,
        this.sheenColor.copy($.sheenColor),
        this.sheenColorMap = $.sheenColorMap,
        this.sheenRoughness = $.sheenRoughness,
        this.sheenRoughnessMap = $.sheenRoughnessMap,
        this.transmission = $.transmission,
        this.transmissionMap = $.transmissionMap,
        this.thickness = $.thickness,
        this.thicknessMap = $.thicknessMap,
        this.attenuationDistance = $.attenuationDistance,
        this.attenuationColor.copy($.attenuationColor),
        this.specularIntensity = $.specularIntensity,
        this.specularIntensityMap = $.specularIntensityMap,
        this.specularColor.copy($.specularColor),
        this.specularColorMap = $.specularColorMap,
        this
    }
}
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0;
class MeshPhongMaterial extends Material {
    constructor($) {
        super(),
        this.type = "MeshPhongMaterial",
        this.color = new Color(16777215),
        this.specular = new Color(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Color(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = MultiplyOperation,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.color.copy($.color),
        this.specular.copy($.specular),
        this.shininess = $.shininess,
        this.map = $.map,
        this.lightMap = $.lightMap,
        this.lightMapIntensity = $.lightMapIntensity,
        this.aoMap = $.aoMap,
        this.aoMapIntensity = $.aoMapIntensity,
        this.emissive.copy($.emissive),
        this.emissiveMap = $.emissiveMap,
        this.emissiveIntensity = $.emissiveIntensity,
        this.bumpMap = $.bumpMap,
        this.bumpScale = $.bumpScale,
        this.normalMap = $.normalMap,
        this.normalMapType = $.normalMapType,
        this.normalScale.copy($.normalScale),
        this.displacementMap = $.displacementMap,
        this.displacementScale = $.displacementScale,
        this.displacementBias = $.displacementBias,
        this.specularMap = $.specularMap,
        this.alphaMap = $.alphaMap,
        this.envMap = $.envMap,
        this.combine = $.combine,
        this.reflectivity = $.reflectivity,
        this.refractionRatio = $.refractionRatio,
        this.wireframe = $.wireframe,
        this.wireframeLinewidth = $.wireframeLinewidth,
        this.wireframeLinecap = $.wireframeLinecap,
        this.wireframeLinejoin = $.wireframeLinejoin,
        this.flatShading = $.flatShading,
        this
    }
}
MeshPhongMaterial.prototype.isMeshPhongMaterial = !0;
class MeshToonMaterial extends Material {
    constructor($) {
        super(),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Color(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.color.copy($.color),
        this.map = $.map,
        this.gradientMap = $.gradientMap,
        this.lightMap = $.lightMap,
        this.lightMapIntensity = $.lightMapIntensity,
        this.aoMap = $.aoMap,
        this.aoMapIntensity = $.aoMapIntensity,
        this.emissive.copy($.emissive),
        this.emissiveMap = $.emissiveMap,
        this.emissiveIntensity = $.emissiveIntensity,
        this.bumpMap = $.bumpMap,
        this.bumpScale = $.bumpScale,
        this.normalMap = $.normalMap,
        this.normalMapType = $.normalMapType,
        this.normalScale.copy($.normalScale),
        this.displacementMap = $.displacementMap,
        this.displacementScale = $.displacementScale,
        this.displacementBias = $.displacementBias,
        this.alphaMap = $.alphaMap,
        this.wireframe = $.wireframe,
        this.wireframeLinewidth = $.wireframeLinewidth,
        this.wireframeLinecap = $.wireframeLinecap,
        this.wireframeLinejoin = $.wireframeLinejoin,
        this
    }
}
MeshToonMaterial.prototype.isMeshToonMaterial = !0;
class MeshNormalMaterial extends Material {
    constructor($) {
        super(),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.flatShading = !1,
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.bumpMap = $.bumpMap,
        this.bumpScale = $.bumpScale,
        this.normalMap = $.normalMap,
        this.normalMapType = $.normalMapType,
        this.normalScale.copy($.normalScale),
        this.displacementMap = $.displacementMap,
        this.displacementScale = $.displacementScale,
        this.displacementBias = $.displacementBias,
        this.wireframe = $.wireframe,
        this.wireframeLinewidth = $.wireframeLinewidth,
        this.flatShading = $.flatShading,
        this
    }
}
MeshNormalMaterial.prototype.isMeshNormalMaterial = !0;
class MeshLambertMaterial extends Material {
    constructor($) {
        super(),
        this.type = "MeshLambertMaterial",
        this.color = new Color(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Color(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = MultiplyOperation,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.color.copy($.color),
        this.map = $.map,
        this.lightMap = $.lightMap,
        this.lightMapIntensity = $.lightMapIntensity,
        this.aoMap = $.aoMap,
        this.aoMapIntensity = $.aoMapIntensity,
        this.emissive.copy($.emissive),
        this.emissiveMap = $.emissiveMap,
        this.emissiveIntensity = $.emissiveIntensity,
        this.specularMap = $.specularMap,
        this.alphaMap = $.alphaMap,
        this.envMap = $.envMap,
        this.combine = $.combine,
        this.reflectivity = $.reflectivity,
        this.refractionRatio = $.refractionRatio,
        this.wireframe = $.wireframe,
        this.wireframeLinewidth = $.wireframeLinewidth,
        this.wireframeLinecap = $.wireframeLinecap,
        this.wireframeLinejoin = $.wireframeLinejoin,
        this
    }
}
MeshLambertMaterial.prototype.isMeshLambertMaterial = !0;
class MeshMatcapMaterial extends Material {
    constructor($) {
        super(),
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Color(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = TangentSpaceNormalMap,
        this.normalScale = new Vector2(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy($.color),
        this.matcap = $.matcap,
        this.map = $.map,
        this.bumpMap = $.bumpMap,
        this.bumpScale = $.bumpScale,
        this.normalMap = $.normalMap,
        this.normalMapType = $.normalMapType,
        this.normalScale.copy($.normalScale),
        this.displacementMap = $.displacementMap,
        this.displacementScale = $.displacementScale,
        this.displacementBias = $.displacementBias,
        this.alphaMap = $.alphaMap,
        this.flatShading = $.flatShading,
        this
    }
}
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = !0;
class LineDashedMaterial extends LineBasicMaterial {
    constructor($) {
        super(),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues($)
    }
    copy($) {
        return super.copy($),
        this.scale = $.scale,
        this.dashSize = $.dashSize,
        this.gapSize = $.gapSize,
        this
    }
}
LineDashedMaterial.prototype.isLineDashedMaterial = !0;
const materialLib = {
    ShadowMaterial,
    SpriteMaterial,
    RawShaderMaterial,
    ShaderMaterial,
    PointsMaterial,
    MeshPhysicalMaterial,
    MeshStandardMaterial,
    MeshPhongMaterial,
    MeshToonMaterial,
    MeshNormalMaterial,
    MeshLambertMaterial,
    MeshDepthMaterial,
    MeshDistanceMaterial,
    MeshBasicMaterial,
    MeshMatcapMaterial,
    LineDashedMaterial,
    LineBasicMaterial,
    Material
};
Material.fromType = function(et) {
    return new materialLib[et]
}
;
const AnimationUtils = {
    arraySlice: function(et, $, tt) {
        return AnimationUtils.isTypedArray(et) ? new et.constructor(et.subarray($, tt !== void 0 ? tt : et.length)) : et.slice($, tt)
    },
    convertArray: function(et, $, tt) {
        return !et || !tt && et.constructor === $ ? et : typeof $.BYTES_PER_ELEMENT == "number" ? new $(et) : Array.prototype.slice.call(et)
    },
    isTypedArray: function(et) {
        return ArrayBuffer.isView(et) && !(et instanceof DataView)
    },
    getKeyframeOrder: function(et) {
        function $(rt, it) {
            return et[rt] - et[it]
        }
        const tt = et.length
          , nt = new Array(tt);
        for (let rt = 0; rt !== tt; ++rt)
            nt[rt] = rt;
        return nt.sort($),
        nt
    },
    sortedArray: function(et, $, tt) {
        const nt = et.length
          , rt = new et.constructor(nt);
        for (let it = 0, ot = 0; ot !== nt; ++it) {
            const st = tt[it] * $;
            for (let lt = 0; lt !== $; ++lt)
                rt[ot++] = et[st + lt]
        }
        return rt
    },
    flattenJSON: function(et, $, tt, nt) {
        let rt = 1
          , it = et[0];
        for (; it !== void 0 && it[nt] === void 0; )
            it = et[rt++];
        if (it === void 0)
            return;
        let ot = it[nt];
        if (ot !== void 0)
            if (Array.isArray(ot))
                do
                    ot = it[nt],
                    ot !== void 0 && ($.push(it.time),
                    tt.push.apply(tt, ot)),
                    it = et[rt++];
                while (it !== void 0);
            else if (ot.toArray !== void 0)
                do
                    ot = it[nt],
                    ot !== void 0 && ($.push(it.time),
                    ot.toArray(tt, tt.length)),
                    it = et[rt++];
                while (it !== void 0);
            else
                do
                    ot = it[nt],
                    ot !== void 0 && ($.push(it.time),
                    tt.push(ot)),
                    it = et[rt++];
                while (it !== void 0)
    },
    subclip: function(et, $, tt, nt, rt=30) {
        const it = et.clone();
        it.name = $;
        const ot = [];
        for (let lt = 0; lt < it.tracks.length; ++lt) {
            const ut = it.tracks[lt]
              , ct = ut.getValueSize()
              , ht = []
              , ft = [];
            for (let gt = 0; gt < ut.times.length; ++gt) {
                const vt = ut.times[gt] * rt;
                if (!(vt < tt || vt >= nt)) {
                    ht.push(ut.times[gt]);
                    for (let yt = 0; yt < ct; ++yt)
                        ft.push(ut.values[gt * ct + yt])
                }
            }
            ht.length !== 0 && (ut.times = AnimationUtils.convertArray(ht, ut.times.constructor),
            ut.values = AnimationUtils.convertArray(ft, ut.values.constructor),
            ot.push(ut))
        }
        it.tracks = ot;
        let st = 1 / 0;
        for (let lt = 0; lt < it.tracks.length; ++lt)
            st > it.tracks[lt].times[0] && (st = it.tracks[lt].times[0]);
        for (let lt = 0; lt < it.tracks.length; ++lt)
            it.tracks[lt].shift(-1 * st);
        return it.resetDuration(),
        it
    },
    makeClipAdditive: function(et, $=0, tt=et, nt=30) {
        nt <= 0 && (nt = 30);
        const rt = tt.tracks.length
          , it = $ / nt;
        for (let ot = 0; ot < rt; ++ot) {
            const st = tt.tracks[ot]
              , lt = st.ValueTypeName;
            if (lt === "bool" || lt === "string")
                continue;
            const ut = et.tracks.find(function(mt) {
                return mt.name === st.name && mt.ValueTypeName === lt
            });
            if (ut === void 0)
                continue;
            let ct = 0;
            const ht = st.getValueSize();
            st.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (ct = ht / 3);
            let ft = 0;
            const gt = ut.getValueSize();
            ut.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (ft = gt / 3);
            const vt = st.times.length - 1;
            let yt;
            if (it <= st.times[0]) {
                const mt = ct
                  , _t = ht - ct;
                yt = AnimationUtils.arraySlice(st.values, mt, _t)
            } else if (it >= st.times[vt]) {
                const mt = vt * ht + ct
                  , _t = mt + ht - ct;
                yt = AnimationUtils.arraySlice(st.values, mt, _t)
            } else {
                const mt = st.createInterpolant()
                  , _t = ct
                  , bt = ht - ct;
                mt.evaluate(it),
                yt = AnimationUtils.arraySlice(mt.resultBuffer, _t, bt)
            }
            lt === "quaternion" && new Quaternion().fromArray(yt).normalize().conjugate().toArray(yt);
            const wt = ut.times.length;
            for (let mt = 0; mt < wt; ++mt) {
                const _t = mt * gt + ft;
                if (lt === "quaternion")
                    Quaternion.multiplyQuaternionsFlat(ut.values, _t, yt, 0, ut.values, _t);
                else {
                    const bt = gt - ft * 2;
                    for (let Mt = 0; Mt < bt; ++Mt)
                        ut.values[_t + Mt] -= yt[Mt]
                }
            }
        }
        return et.blendMode = AdditiveAnimationBlendMode,
        et
    }
};
class Interpolant {
    constructor($, tt, nt, rt) {
        this.parameterPositions = $,
        this._cachedIndex = 0,
        this.resultBuffer = rt !== void 0 ? rt : new tt.constructor(nt),
        this.sampleValues = tt,
        this.valueSize = nt,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate($) {
        const tt = this.parameterPositions;
        let nt = this._cachedIndex
          , rt = tt[nt]
          , it = tt[nt - 1];
        e: {
            t: {
                let ot;
                n: {
                    r: if (!($ < rt)) {
                        for (let st = nt + 2; ; ) {
                            if (rt === void 0) {
                                if ($ < it)
                                    break r;
                                return nt = tt.length,
                                this._cachedIndex = nt,
                                this.afterEnd_(nt - 1, $, it)
                            }
                            if (nt === st)
                                break;
                            if (it = rt,
                            rt = tt[++nt],
                            $ < rt)
                                break t
                        }
                        ot = tt.length;
                        break n
                    }
                    if (!($ >= it)) {
                        const st = tt[1];
                        $ < st && (nt = 2,
                        it = st);
                        for (let lt = nt - 2; ; ) {
                            if (it === void 0)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, $, rt);
                            if (nt === lt)
                                break;
                            if (rt = it,
                            it = tt[--nt - 1],
                            $ >= it)
                                break t
                        }
                        ot = nt,
                        nt = 0;
                        break n
                    }
                    break e
                }
                for (; nt < ot; ) {
                    const st = nt + ot >>> 1;
                    $ < tt[st] ? ot = st : nt = st + 1
                }
                if (rt = tt[nt],
                it = tt[nt - 1],
                it === void 0)
                    return this._cachedIndex = 0,
                    this.beforeStart_(0, $, rt);
                if (rt === void 0)
                    return nt = tt.length,
                    this._cachedIndex = nt,
                    this.afterEnd_(nt - 1, it, $)
            }
            this._cachedIndex = nt,
            this.intervalChanged_(nt, it, rt)
        }
        return this.interpolate_(nt, it, $, rt)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_($) {
        const tt = this.resultBuffer
          , nt = this.sampleValues
          , rt = this.valueSize
          , it = $ * rt;
        for (let ot = 0; ot !== rt; ++ot)
            tt[ot] = nt[it + ot];
        return tt
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
class CubicInterpolant extends Interpolant {
    constructor($, tt, nt, rt) {
        super($, tt, nt, rt),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        }
    }
    intervalChanged_($, tt, nt) {
        const rt = this.parameterPositions;
        let it = $ - 2
          , ot = $ + 1
          , st = rt[it]
          , lt = rt[ot];
        if (st === void 0)
            switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
                it = $,
                st = 2 * tt - nt;
                break;
            case WrapAroundEnding:
                it = rt.length - 2,
                st = tt + rt[it] - rt[it + 1];
                break;
            default:
                it = $,
                st = nt
            }
        if (lt === void 0)
            switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
                ot = $,
                lt = 2 * nt - tt;
                break;
            case WrapAroundEnding:
                ot = 1,
                lt = nt + rt[1] - rt[0];
                break;
            default:
                ot = $ - 1,
                lt = tt
            }
        const ut = (nt - tt) * .5
          , ct = this.valueSize;
        this._weightPrev = ut / (tt - st),
        this._weightNext = ut / (lt - nt),
        this._offsetPrev = it * ct,
        this._offsetNext = ot * ct
    }
    interpolate_($, tt, nt, rt) {
        const it = this.resultBuffer
          , ot = this.sampleValues
          , st = this.valueSize
          , lt = $ * st
          , ut = lt - st
          , ct = this._offsetPrev
          , ht = this._offsetNext
          , ft = this._weightPrev
          , gt = this._weightNext
          , vt = (nt - tt) / (rt - tt)
          , yt = vt * vt
          , wt = yt * vt
          , mt = -ft * wt + 2 * ft * yt - ft * vt
          , _t = (1 + ft) * wt + (-1.5 - 2 * ft) * yt + (-.5 + ft) * vt + 1
          , bt = (-1 - gt) * wt + (1.5 + gt) * yt + .5 * vt
          , Mt = gt * wt - gt * yt;
        for (let St = 0; St !== st; ++St)
            it[St] = mt * ot[ct + St] + _t * ot[ut + St] + bt * ot[lt + St] + Mt * ot[ht + St];
        return it
    }
}
class LinearInterpolant extends Interpolant {
    constructor($, tt, nt, rt) {
        super($, tt, nt, rt)
    }
    interpolate_($, tt, nt, rt) {
        const it = this.resultBuffer
          , ot = this.sampleValues
          , st = this.valueSize
          , lt = $ * st
          , ut = lt - st
          , ct = (nt - tt) / (rt - tt)
          , ht = 1 - ct;
        for (let ft = 0; ft !== st; ++ft)
            it[ft] = ot[ut + ft] * ht + ot[lt + ft] * ct;
        return it
    }
}
class DiscreteInterpolant extends Interpolant {
    constructor($, tt, nt, rt) {
        super($, tt, nt, rt)
    }
    interpolate_($) {
        return this.copySampleValue_($ - 1)
    }
}
class KeyframeTrack {
    constructor($, tt, nt, rt) {
        if ($ === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (tt === void 0 || tt.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + $);
        this.name = $,
        this.times = AnimationUtils.convertArray(tt, this.TimeBufferType),
        this.values = AnimationUtils.convertArray(nt, this.ValueBufferType),
        this.setInterpolation(rt || this.DefaultInterpolation)
    }
    static toJSON($) {
        const tt = $.constructor;
        let nt;
        if (tt.toJSON !== this.toJSON)
            nt = tt.toJSON($);
        else {
            nt = {
                name: $.name,
                times: AnimationUtils.convertArray($.times, Array),
                values: AnimationUtils.convertArray($.values, Array)
            };
            const rt = $.getInterpolation();
            rt !== $.DefaultInterpolation && (nt.interpolation = rt)
        }
        return nt.type = $.ValueTypeName,
        nt
    }
    InterpolantFactoryMethodDiscrete($) {
        return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),$)
    }
    InterpolantFactoryMethodLinear($) {
        return new LinearInterpolant(this.times,this.values,this.getValueSize(),$)
    }
    InterpolantFactoryMethodSmooth($) {
        return new CubicInterpolant(this.times,this.values,this.getValueSize(),$)
    }
    setInterpolation($) {
        let tt;
        switch ($) {
        case InterpolateDiscrete:
            tt = this.InterpolantFactoryMethodDiscrete;
            break;
        case InterpolateLinear:
            tt = this.InterpolantFactoryMethodLinear;
            break;
        case InterpolateSmooth:
            tt = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (tt === void 0) {
            const nt = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if ($ !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(nt);
            return console.warn("THREE.KeyframeTrack:", nt),
            this
        }
        return this.createInterpolant = tt,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift($) {
        if ($ !== 0) {
            const tt = this.times;
            for (let nt = 0, rt = tt.length; nt !== rt; ++nt)
                tt[nt] += $
        }
        return this
    }
    scale($) {
        if ($ !== 1) {
            const tt = this.times;
            for (let nt = 0, rt = tt.length; nt !== rt; ++nt)
                tt[nt] *= $
        }
        return this
    }
    trim($, tt) {
        const nt = this.times
          , rt = nt.length;
        let it = 0
          , ot = rt - 1;
        for (; it !== rt && nt[it] < $; )
            ++it;
        for (; ot !== -1 && nt[ot] > tt; )
            --ot;
        if (++ot,
        it !== 0 || ot !== rt) {
            it >= ot && (ot = Math.max(ot, 1),
            it = ot - 1);
            const st = this.getValueSize();
            this.times = AnimationUtils.arraySlice(nt, it, ot),
            this.values = AnimationUtils.arraySlice(this.values, it * st, ot * st)
        }
        return this
    }
    validate() {
        let $ = !0;
        const tt = this.getValueSize();
        tt - Math.floor(tt) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        $ = !1);
        const nt = this.times
          , rt = this.values
          , it = nt.length;
        it === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        $ = !1);
        let ot = null;
        for (let st = 0; st !== it; st++) {
            const lt = nt[st];
            if (typeof lt == "number" && isNaN(lt)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, st, lt),
                $ = !1;
                break
            }
            if (ot !== null && ot > lt) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, st, lt, ot),
                $ = !1;
                break
            }
            ot = lt
        }
        if (rt !== void 0 && AnimationUtils.isTypedArray(rt))
            for (let st = 0, lt = rt.length; st !== lt; ++st) {
                const ut = rt[st];
                if (isNaN(ut)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, st, ut),
                    $ = !1;
                    break
                }
            }
        return $
    }
    optimize() {
        const $ = AnimationUtils.arraySlice(this.times)
          , tt = AnimationUtils.arraySlice(this.values)
          , nt = this.getValueSize()
          , rt = this.getInterpolation() === InterpolateSmooth
          , it = $.length - 1;
        let ot = 1;
        for (let st = 1; st < it; ++st) {
            let lt = !1;
            const ut = $[st]
              , ct = $[st + 1];
            if (ut !== ct && (st !== 1 || ut !== $[0]))
                if (rt)
                    lt = !0;
                else {
                    const ht = st * nt
                      , ft = ht - nt
                      , gt = ht + nt;
                    for (let vt = 0; vt !== nt; ++vt) {
                        const yt = tt[ht + vt];
                        if (yt !== tt[ft + vt] || yt !== tt[gt + vt]) {
                            lt = !0;
                            break
                        }
                    }
                }
            if (lt) {
                if (st !== ot) {
                    $[ot] = $[st];
                    const ht = st * nt
                      , ft = ot * nt;
                    for (let gt = 0; gt !== nt; ++gt)
                        tt[ft + gt] = tt[ht + gt]
                }
                ++ot
            }
        }
        if (it > 0) {
            $[ot] = $[it];
            for (let st = it * nt, lt = ot * nt, ut = 0; ut !== nt; ++ut)
                tt[lt + ut] = tt[st + ut];
            ++ot
        }
        return ot !== $.length ? (this.times = AnimationUtils.arraySlice($, 0, ot),
        this.values = AnimationUtils.arraySlice(tt, 0, ot * nt)) : (this.times = $,
        this.values = tt),
        this
    }
    clone() {
        const $ = AnimationUtils.arraySlice(this.times, 0)
          , tt = AnimationUtils.arraySlice(this.values, 0)
          , nt = this.constructor
          , rt = new nt(this.name,$,tt);
        return rt.createInterpolant = this.createInterpolant,
        rt
    }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
    constructor($, tt, nt, rt) {
        super($, tt, nt, rt)
    }
    interpolate_($, tt, nt, rt) {
        const it = this.resultBuffer
          , ot = this.sampleValues
          , st = this.valueSize
          , lt = (nt - tt) / (rt - tt);
        let ut = $ * st;
        for (let ct = ut + st; ut !== ct; ut += 4)
            Quaternion.slerpFlat(it, 0, ot, ut - st, ot, ut, lt);
        return it
    }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
    InterpolantFactoryMethodLinear($) {
        return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),$)
    }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
    constructor($, tt=-1, nt, rt=NormalAnimationBlendMode) {
        this.name = $,
        this.tracks = nt,
        this.duration = tt,
        this.blendMode = rt,
        this.uuid = generateUUID(),
        this.duration < 0 && this.resetDuration()
    }
    static parse($) {
        const tt = []
          , nt = $.tracks
          , rt = 1 / ($.fps || 1);
        for (let ot = 0, st = nt.length; ot !== st; ++ot)
            tt.push(parseKeyframeTrack(nt[ot]).scale(rt));
        const it = new this($.name,$.duration,tt,$.blendMode);
        return it.uuid = $.uuid,
        it
    }
    static toJSON($) {
        const tt = []
          , nt = $.tracks
          , rt = {
            name: $.name,
            duration: $.duration,
            tracks: tt,
            uuid: $.uuid,
            blendMode: $.blendMode
        };
        for (let it = 0, ot = nt.length; it !== ot; ++it)
            tt.push(KeyframeTrack.toJSON(nt[it]));
        return rt
    }
    static CreateFromMorphTargetSequence($, tt, nt, rt) {
        const it = tt.length
          , ot = [];
        for (let st = 0; st < it; st++) {
            let lt = []
              , ut = [];
            lt.push((st + it - 1) % it, st, (st + 1) % it),
            ut.push(0, 1, 0);
            const ct = AnimationUtils.getKeyframeOrder(lt);
            lt = AnimationUtils.sortedArray(lt, 1, ct),
            ut = AnimationUtils.sortedArray(ut, 1, ct),
            !rt && lt[0] === 0 && (lt.push(it),
            ut.push(ut[0])),
            ot.push(new NumberKeyframeTrack(".morphTargetInfluences[" + tt[st].name + "]",lt,ut).scale(1 / nt))
        }
        return new this($,-1,ot)
    }
    static findByName($, tt) {
        let nt = $;
        if (!Array.isArray($)) {
            const rt = $;
            nt = rt.geometry && rt.geometry.animations || rt.animations
        }
        for (let rt = 0; rt < nt.length; rt++)
            if (nt[rt].name === tt)
                return nt[rt];
        return null
    }
    static CreateClipsFromMorphTargetSequences($, tt, nt) {
        const rt = {}
          , it = /^([\w-]*?)([\d]+)$/;
        for (let st = 0, lt = $.length; st < lt; st++) {
            const ut = $[st]
              , ct = ut.name.match(it);
            if (ct && ct.length > 1) {
                const ht = ct[1];
                let ft = rt[ht];
                ft || (rt[ht] = ft = []),
                ft.push(ut)
            }
        }
        const ot = [];
        for (const st in rt)
            ot.push(this.CreateFromMorphTargetSequence(st, rt[st], tt, nt));
        return ot
    }
    static parseAnimation($, tt) {
        if (!$)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const nt = function(ht, ft, gt, vt, yt) {
            if (gt.length !== 0) {
                const wt = []
                  , mt = [];
                AnimationUtils.flattenJSON(gt, wt, mt, vt),
                wt.length !== 0 && yt.push(new ht(ft,wt,mt))
            }
        }
          , rt = []
          , it = $.name || "default"
          , ot = $.fps || 30
          , st = $.blendMode;
        let lt = $.length || -1;
        const ut = $.hierarchy || [];
        for (let ht = 0; ht < ut.length; ht++) {
            const ft = ut[ht].keys;
            if (!(!ft || ft.length === 0))
                if (ft[0].morphTargets) {
                    const gt = {};
                    let vt;
                    for (vt = 0; vt < ft.length; vt++)
                        if (ft[vt].morphTargets)
                            for (let yt = 0; yt < ft[vt].morphTargets.length; yt++)
                                gt[ft[vt].morphTargets[yt]] = -1;
                    for (const yt in gt) {
                        const wt = []
                          , mt = [];
                        for (let _t = 0; _t !== ft[vt].morphTargets.length; ++_t) {
                            const bt = ft[vt];
                            wt.push(bt.time),
                            mt.push(bt.morphTarget === yt ? 1 : 0)
                        }
                        rt.push(new NumberKeyframeTrack(".morphTargetInfluence[" + yt + "]",wt,mt))
                    }
                    lt = gt.length * ot
                } else {
                    const gt = ".bones[" + tt[ht].name + "]";
                    nt(VectorKeyframeTrack, gt + ".position", ft, "pos", rt),
                    nt(QuaternionKeyframeTrack, gt + ".quaternion", ft, "rot", rt),
                    nt(VectorKeyframeTrack, gt + ".scale", ft, "scl", rt)
                }
        }
        return rt.length === 0 ? null : new this(it,lt,rt,st)
    }
    resetDuration() {
        const $ = this.tracks;
        let tt = 0;
        for (let nt = 0, rt = $.length; nt !== rt; ++nt) {
            const it = this.tracks[nt];
            tt = Math.max(tt, it.times[it.times.length - 1])
        }
        return this.duration = tt,
        this
    }
    trim() {
        for (let $ = 0; $ < this.tracks.length; $++)
            this.tracks[$].trim(0, this.duration);
        return this
    }
    validate() {
        let $ = !0;
        for (let tt = 0; tt < this.tracks.length; tt++)
            $ = $ && this.tracks[tt].validate();
        return $
    }
    optimize() {
        for (let $ = 0; $ < this.tracks.length; $++)
            this.tracks[$].optimize();
        return this
    }
    clone() {
        const $ = [];
        for (let tt = 0; tt < this.tracks.length; tt++)
            $.push(this.tracks[tt].clone());
        return new this.constructor(this.name,this.duration,$,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function getTrackTypeForValueTypeName(et) {
    switch (et.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return VectorKeyframeTrack;
    case "color":
        return ColorKeyframeTrack;
    case "quaternion":
        return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
        return BooleanKeyframeTrack;
    case "string":
        return StringKeyframeTrack
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + et)
}
function parseKeyframeTrack(et) {
    if (et.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const $ = getTrackTypeForValueTypeName(et.type);
    if (et.times === void 0) {
        const tt = []
          , nt = [];
        AnimationUtils.flattenJSON(et.keys, tt, nt, "value"),
        et.times = tt,
        et.values = nt
    }
    return $.parse !== void 0 ? $.parse(et) : new $(et.name,et.times,et.values,et.interpolation)
}
const Cache = {
    enabled: !1,
    files: {},
    add: function(et, $) {
        this.enabled !== !1 && (this.files[et] = $)
    },
    get: function(et) {
        if (this.enabled !== !1)
            return this.files[et]
    },
    remove: function(et) {
        delete this.files[et]
    },
    clear: function() {
        this.files = {}
    }
};
class LoadingManager {
    constructor($, tt, nt) {
        const rt = this;
        let it = !1, ot = 0, st = 0, lt;
        const ut = [];
        this.onStart = void 0,
        this.onLoad = $,
        this.onProgress = tt,
        this.onError = nt,
        this.itemStart = function(ct) {
            st++,
            it === !1 && rt.onStart !== void 0 && rt.onStart(ct, ot, st),
            it = !0
        }
        ,
        this.itemEnd = function(ct) {
            ot++,
            rt.onProgress !== void 0 && rt.onProgress(ct, ot, st),
            ot === st && (it = !1,
            rt.onLoad !== void 0 && rt.onLoad())
        }
        ,
        this.itemError = function(ct) {
            rt.onError !== void 0 && rt.onError(ct)
        }
        ,
        this.resolveURL = function(ct) {
            return lt ? lt(ct) : ct
        }
        ,
        this.setURLModifier = function(ct) {
            return lt = ct,
            this
        }
        ,
        this.addHandler = function(ct, ht) {
            return ut.push(ct, ht),
            this
        }
        ,
        this.removeHandler = function(ct) {
            const ht = ut.indexOf(ct);
            return ht !== -1 && ut.splice(ht, 2),
            this
        }
        ,
        this.getHandler = function(ct) {
            for (let ht = 0, ft = ut.length; ht < ft; ht += 2) {
                const gt = ut[ht]
                  , vt = ut[ht + 1];
                if (gt.global && (gt.lastIndex = 0),
                gt.test(ct))
                    return vt
            }
            return null
        }
    }
}
const DefaultLoadingManager = new LoadingManager;
class Loader$1 {
    constructor($) {
        this.manager = $ !== void 0 ? $ : DefaultLoadingManager,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync($, tt) {
        const nt = this;
        return new Promise(function(rt, it) {
            nt.load($, rt, tt, it)
        }
        )
    }
    parse() {}
    setCrossOrigin($) {
        return this.crossOrigin = $,
        this
    }
    setWithCredentials($) {
        return this.withCredentials = $,
        this
    }
    setPath($) {
        return this.path = $,
        this
    }
    setResourcePath($) {
        return this.resourcePath = $,
        this
    }
    setRequestHeader($) {
        return this.requestHeader = $,
        this
    }
}
const loading = {};
class FileLoader extends Loader$1 {
    constructor($) {
        super($)
    }
    load($, tt, nt, rt) {
        $ === void 0 && ($ = ""),
        this.path !== void 0 && ($ = this.path + $),
        $ = this.manager.resolveURL($);
        const it = Cache.get($);
        if (it !== void 0)
            return this.manager.itemStart($),
            setTimeout(()=>{
                tt && tt(it),
                this.manager.itemEnd($)
            }
            , 0),
            it;
        if (loading[$] !== void 0) {
            loading[$].push({
                onLoad: tt,
                onProgress: nt,
                onError: rt
            });
            return
        }
        loading[$] = [],
        loading[$].push({
            onLoad: tt,
            onProgress: nt,
            onError: rt
        });
        const ot = new Request($,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , st = this.mimeType
          , lt = this.responseType;
        fetch(ot).then(ut=>{
            if (ut.status === 200 || ut.status === 0) {
                if (ut.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream == "undefined" || ut.body === void 0 || ut.body.getReader === void 0)
                    return ut;
                const ct = loading[$]
                  , ht = ut.body.getReader()
                  , ft = ut.headers.get("Content-Length")
                  , gt = ft ? parseInt(ft) : 0
                  , vt = gt !== 0;
                let yt = 0;
                const wt = new ReadableStream({
                    start(mt) {
                        _t();
                        function _t() {
                            ht.read().then(({done: bt, value: Mt})=>{
                                if (bt)
                                    mt.close();
                                else {
                                    yt += Mt.byteLength;
                                    const St = new ProgressEvent("progress",{
                                        lengthComputable: vt,
                                        loaded: yt,
                                        total: gt
                                    });
                                    for (let At = 0, Pt = ct.length; At < Pt; At++) {
                                        const Ot = ct[At];
                                        Ot.onProgress && Ot.onProgress(St)
                                    }
                                    mt.enqueue(Mt),
                                    _t()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(wt)
            } else
                throw Error(`fetch for "${ut.url}" responded with ${ut.status}: ${ut.statusText}`)
        }
        ).then(ut=>{
            switch (lt) {
            case "arraybuffer":
                return ut.arrayBuffer();
            case "blob":
                return ut.blob();
            case "document":
                return ut.text().then(ct=>new DOMParser().parseFromString(ct, st));
            case "json":
                return ut.json();
            default:
                if (st === void 0)
                    return ut.text();
                {
                    const ht = /charset="?([^;"\s]*)"?/i.exec(st)
                      , ft = ht && ht[1] ? ht[1].toLowerCase() : void 0
                      , gt = new TextDecoder(ft);
                    return ut.arrayBuffer().then(vt=>gt.decode(vt))
                }
            }
        }
        ).then(ut=>{
            Cache.add($, ut);
            const ct = loading[$];
            delete loading[$];
            for (let ht = 0, ft = ct.length; ht < ft; ht++) {
                const gt = ct[ht];
                gt.onLoad && gt.onLoad(ut)
            }
        }
        ).catch(ut=>{
            const ct = loading[$];
            if (ct === void 0)
                throw this.manager.itemError($),
                ut;
            delete loading[$];
            for (let ht = 0, ft = ct.length; ht < ft; ht++) {
                const gt = ct[ht];
                gt.onError && gt.onError(ut)
            }
            this.manager.itemError($)
        }
        ).finally(()=>{
            this.manager.itemEnd($)
        }
        ),
        this.manager.itemStart($)
    }
    setResponseType($) {
        return this.responseType = $,
        this
    }
    setMimeType($) {
        return this.mimeType = $,
        this
    }
}
class ImageLoader extends Loader$1 {
    constructor($) {
        super($)
    }
    load($, tt, nt, rt) {
        this.path !== void 0 && ($ = this.path + $),
        $ = this.manager.resolveURL($);
        const it = this
          , ot = Cache.get($);
        if (ot !== void 0)
            return it.manager.itemStart($),
            setTimeout(function() {
                tt && tt(ot),
                it.manager.itemEnd($)
            }, 0),
            ot;
        const st = createElementNS("img");
        function lt() {
            ct(),
            Cache.add($, this),
            tt && tt(this),
            it.manager.itemEnd($)
        }
        function ut(ht) {
            ct(),
            rt && rt(ht),
            it.manager.itemError($),
            it.manager.itemEnd($)
        }
        function ct() {
            st.removeEventListener("load", lt, !1),
            st.removeEventListener("error", ut, !1)
        }
        return st.addEventListener("load", lt, !1),
        st.addEventListener("error", ut, !1),
        $.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (st.crossOrigin = this.crossOrigin),
        it.manager.itemStart($),
        st.src = $,
        st
    }
}
class CubeTextureLoader extends Loader$1 {
    constructor($) {
        super($)
    }
    load($, tt, nt, rt) {
        const it = new CubeTexture
          , ot = new ImageLoader(this.manager);
        ot.setCrossOrigin(this.crossOrigin),
        ot.setPath(this.path);
        let st = 0;
        function lt(ut) {
            ot.load($[ut], function(ct) {
                it.images[ut] = ct,
                st++,
                st === 6 && (it.needsUpdate = !0,
                tt && tt(it))
            }, void 0, rt)
        }
        for (let ut = 0; ut < $.length; ++ut)
            lt(ut);
        return it
    }
}
class TextureLoader extends Loader$1 {
    constructor($) {
        super($)
    }
    load($, tt, nt, rt) {
        const it = new Texture
          , ot = new ImageLoader(this.manager);
        return ot.setCrossOrigin(this.crossOrigin),
        ot.setPath(this.path),
        ot.load($, function(st) {
            it.image = st,
            it.needsUpdate = !0,
            tt !== void 0 && tt(it)
        }, nt, rt),
        it
    }
}
class Light extends Object3D {
    constructor($, tt=1) {
        super(),
        this.type = "Light",
        this.color = new Color($),
        this.intensity = tt
    }
    dispose() {}
    copy($) {
        return super.copy($),
        this.color.copy($.color),
        this.intensity = $.intensity,
        this
    }
    toJSON($) {
        const tt = super.toJSON($);
        return tt.object.color = this.color.getHex(),
        tt.object.intensity = this.intensity,
        this.groundColor !== void 0 && (tt.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (tt.object.distance = this.distance),
        this.angle !== void 0 && (tt.object.angle = this.angle),
        this.decay !== void 0 && (tt.object.decay = this.decay),
        this.penumbra !== void 0 && (tt.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (tt.object.shadow = this.shadow.toJSON()),
        tt
    }
}
Light.prototype.isLight = !0;
class HemisphereLight extends Light {
    constructor($, tt, nt) {
        super($, nt),
        this.type = "HemisphereLight",
        this.position.copy(Object3D.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new Color(tt)
    }
    copy($) {
        return Light.prototype.copy.call(this, $),
        this.groundColor.copy($.groundColor),
        this
    }
}
HemisphereLight.prototype.isHemisphereLight = !0;
const _projScreenMatrix$1 = new Matrix4
  , _lightPositionWorld$1 = new Vector3
  , _lookTarget$1 = new Vector3;
class LightShadow {
    constructor($) {
        this.camera = $,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new Vector2(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Matrix4,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Frustum,
        this._frameExtents = new Vector2(1,1),
        this._viewportCount = 1,
        this._viewports = [new Vector4(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices($) {
        const tt = this.camera
          , nt = this.matrix;
        _lightPositionWorld$1.setFromMatrixPosition($.matrixWorld),
        tt.position.copy(_lightPositionWorld$1),
        _lookTarget$1.setFromMatrixPosition($.target.matrixWorld),
        tt.lookAt(_lookTarget$1),
        tt.updateMatrixWorld(),
        _projScreenMatrix$1.multiplyMatrices(tt.projectionMatrix, tt.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),
        nt.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        nt.multiply(tt.projectionMatrix),
        nt.multiply(tt.matrixWorldInverse)
    }
    getViewport($) {
        return this._viewports[$]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy($) {
        return this.camera = $.camera.clone(),
        this.bias = $.bias,
        this.radius = $.radius,
        this.mapSize.copy($.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const $ = {};
        return this.bias !== 0 && ($.bias = this.bias),
        this.normalBias !== 0 && ($.normalBias = this.normalBias),
        this.radius !== 1 && ($.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && ($.mapSize = this.mapSize.toArray()),
        $.camera = this.camera.toJSON(!1).object,
        delete $.camera.matrix,
        $
    }
}
class SpotLightShadow extends LightShadow {
    constructor() {
        super(new PerspectiveCamera(50,1,.5,500)),
        this.focus = 1
    }
    updateMatrices($) {
        const tt = this.camera
          , nt = RAD2DEG * 2 * $.angle * this.focus
          , rt = this.mapSize.width / this.mapSize.height
          , it = $.distance || tt.far;
        (nt !== tt.fov || rt !== tt.aspect || it !== tt.far) && (tt.fov = nt,
        tt.aspect = rt,
        tt.far = it,
        tt.updateProjectionMatrix()),
        super.updateMatrices($)
    }
    copy($) {
        return super.copy($),
        this.focus = $.focus,
        this
    }
}
SpotLightShadow.prototype.isSpotLightShadow = !0;
class SpotLight extends Light {
    constructor($, tt, nt=0, rt=Math.PI / 3, it=0, ot=1) {
        super($, tt),
        this.type = "SpotLight",
        this.position.copy(Object3D.DefaultUp),
        this.updateMatrix(),
        this.target = new Object3D,
        this.distance = nt,
        this.angle = rt,
        this.penumbra = it,
        this.decay = ot,
        this.shadow = new SpotLightShadow
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power($) {
        this.intensity = $ / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy($) {
        return super.copy($),
        this.distance = $.distance,
        this.angle = $.angle,
        this.penumbra = $.penumbra,
        this.decay = $.decay,
        this.target = $.target.clone(),
        this.shadow = $.shadow.clone(),
        this
    }
}
SpotLight.prototype.isSpotLight = !0;
const _projScreenMatrix = new Matrix4
  , _lightPositionWorld = new Vector3
  , _lookTarget = new Vector3;
class PointLightShadow extends LightShadow {
    constructor() {
        super(new PerspectiveCamera(90,1,.5,500)),
        this._frameExtents = new Vector2(4,2),
        this._viewportCount = 6,
        this._viewports = [new Vector4(2,1,1,1), new Vector4(0,1,1,1), new Vector4(3,1,1,1), new Vector4(1,1,1,1), new Vector4(3,0,1,1), new Vector4(1,0,1,1)],
        this._cubeDirections = [new Vector3(1,0,0), new Vector3(-1,0,0), new Vector3(0,0,1), new Vector3(0,0,-1), new Vector3(0,1,0), new Vector3(0,-1,0)],
        this._cubeUps = [new Vector3(0,1,0), new Vector3(0,1,0), new Vector3(0,1,0), new Vector3(0,1,0), new Vector3(0,0,1), new Vector3(0,0,-1)]
    }
    updateMatrices($, tt=0) {
        const nt = this.camera
          , rt = this.matrix
          , it = $.distance || nt.far;
        it !== nt.far && (nt.far = it,
        nt.updateProjectionMatrix()),
        _lightPositionWorld.setFromMatrixPosition($.matrixWorld),
        nt.position.copy(_lightPositionWorld),
        _lookTarget.copy(nt.position),
        _lookTarget.add(this._cubeDirections[tt]),
        nt.up.copy(this._cubeUps[tt]),
        nt.lookAt(_lookTarget),
        nt.updateMatrixWorld(),
        rt.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z),
        _projScreenMatrix.multiplyMatrices(nt.projectionMatrix, nt.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(_projScreenMatrix)
    }
}
PointLightShadow.prototype.isPointLightShadow = !0;
class PointLight extends Light {
    constructor($, tt, nt=0, rt=1) {
        super($, tt),
        this.type = "PointLight",
        this.distance = nt,
        this.decay = rt,
        this.shadow = new PointLightShadow
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power($) {
        this.intensity = $ / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy($) {
        return super.copy($),
        this.distance = $.distance,
        this.decay = $.decay,
        this.shadow = $.shadow.clone(),
        this
    }
}
PointLight.prototype.isPointLight = !0;
class DirectionalLightShadow extends LightShadow {
    constructor() {
        super(new OrthographicCamera(-5,5,5,-5,.5,500))
    }
}
DirectionalLightShadow.prototype.isDirectionalLightShadow = !0;
class DirectionalLight extends Light {
    constructor($, tt) {
        super($, tt),
        this.type = "DirectionalLight",
        this.position.copy(Object3D.DefaultUp),
        this.updateMatrix(),
        this.target = new Object3D,
        this.shadow = new DirectionalLightShadow
    }
    dispose() {
        this.shadow.dispose()
    }
    copy($) {
        return super.copy($),
        this.target = $.target.clone(),
        this.shadow = $.shadow.clone(),
        this
    }
}
DirectionalLight.prototype.isDirectionalLight = !0;
class AmbientLight extends Light {
    constructor($, tt) {
        super($, tt),
        this.type = "AmbientLight"
    }
}
AmbientLight.prototype.isAmbientLight = !0;
class RectAreaLight extends Light {
    constructor($, tt, nt=10, rt=10) {
        super($, tt),
        this.type = "RectAreaLight",
        this.width = nt,
        this.height = rt
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power($) {
        this.intensity = $ / (this.width * this.height * Math.PI)
    }
    copy($) {
        return super.copy($),
        this.width = $.width,
        this.height = $.height,
        this
    }
    toJSON($) {
        const tt = super.toJSON($);
        return tt.object.width = this.width,
        tt.object.height = this.height,
        tt
    }
}
RectAreaLight.prototype.isRectAreaLight = !0;
class SphericalHarmonics3 {
    constructor() {
        this.coefficients = [];
        for (let $ = 0; $ < 9; $++)
            this.coefficients.push(new Vector3)
    }
    set($) {
        for (let tt = 0; tt < 9; tt++)
            this.coefficients[tt].copy($[tt]);
        return this
    }
    zero() {
        for (let $ = 0; $ < 9; $++)
            this.coefficients[$].set(0, 0, 0);
        return this
    }
    getAt($, tt) {
        const nt = $.x
          , rt = $.y
          , it = $.z
          , ot = this.coefficients;
        return tt.copy(ot[0]).multiplyScalar(.282095),
        tt.addScaledVector(ot[1], .488603 * rt),
        tt.addScaledVector(ot[2], .488603 * it),
        tt.addScaledVector(ot[3], .488603 * nt),
        tt.addScaledVector(ot[4], 1.092548 * (nt * rt)),
        tt.addScaledVector(ot[5], 1.092548 * (rt * it)),
        tt.addScaledVector(ot[6], .315392 * (3 * it * it - 1)),
        tt.addScaledVector(ot[7], 1.092548 * (nt * it)),
        tt.addScaledVector(ot[8], .546274 * (nt * nt - rt * rt)),
        tt
    }
    getIrradianceAt($, tt) {
        const nt = $.x
          , rt = $.y
          , it = $.z
          , ot = this.coefficients;
        return tt.copy(ot[0]).multiplyScalar(.886227),
        tt.addScaledVector(ot[1], 2 * .511664 * rt),
        tt.addScaledVector(ot[2], 2 * .511664 * it),
        tt.addScaledVector(ot[3], 2 * .511664 * nt),
        tt.addScaledVector(ot[4], 2 * .429043 * nt * rt),
        tt.addScaledVector(ot[5], 2 * .429043 * rt * it),
        tt.addScaledVector(ot[6], .743125 * it * it - .247708),
        tt.addScaledVector(ot[7], 2 * .429043 * nt * it),
        tt.addScaledVector(ot[8], .429043 * (nt * nt - rt * rt)),
        tt
    }
    add($) {
        for (let tt = 0; tt < 9; tt++)
            this.coefficients[tt].add($.coefficients[tt]);
        return this
    }
    addScaledSH($, tt) {
        for (let nt = 0; nt < 9; nt++)
            this.coefficients[nt].addScaledVector($.coefficients[nt], tt);
        return this
    }
    scale($) {
        for (let tt = 0; tt < 9; tt++)
            this.coefficients[tt].multiplyScalar($);
        return this
    }
    lerp($, tt) {
        for (let nt = 0; nt < 9; nt++)
            this.coefficients[nt].lerp($.coefficients[nt], tt);
        return this
    }
    equals($) {
        for (let tt = 0; tt < 9; tt++)
            if (!this.coefficients[tt].equals($.coefficients[tt]))
                return !1;
        return !0
    }
    copy($) {
        return this.set($.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray($, tt=0) {
        const nt = this.coefficients;
        for (let rt = 0; rt < 9; rt++)
            nt[rt].fromArray($, tt + rt * 3);
        return this
    }
    toArray($=[], tt=0) {
        const nt = this.coefficients;
        for (let rt = 0; rt < 9; rt++)
            nt[rt].toArray($, tt + rt * 3);
        return $
    }
    static getBasisAt($, tt) {
        const nt = $.x
          , rt = $.y
          , it = $.z;
        tt[0] = .282095,
        tt[1] = .488603 * rt,
        tt[2] = .488603 * it,
        tt[3] = .488603 * nt,
        tt[4] = 1.092548 * nt * rt,
        tt[5] = 1.092548 * rt * it,
        tt[6] = .315392 * (3 * it * it - 1),
        tt[7] = 1.092548 * nt * it,
        tt[8] = .546274 * (nt * nt - rt * rt)
    }
}
SphericalHarmonics3.prototype.isSphericalHarmonics3 = !0;
class LightProbe extends Light {
    constructor($=new SphericalHarmonics3, tt=1) {
        super(void 0, tt),
        this.sh = $
    }
    copy($) {
        return super.copy($),
        this.sh.copy($.sh),
        this
    }
    fromJSON($) {
        return this.intensity = $.intensity,
        this.sh.fromArray($.sh),
        this
    }
    toJSON($) {
        const tt = super.toJSON($);
        return tt.object.sh = this.sh.toArray(),
        tt
    }
}
LightProbe.prototype.isLightProbe = !0;
class LoaderUtils {
    static decodeText($) {
        if (typeof TextDecoder != "undefined")
            return new TextDecoder().decode($);
        let tt = "";
        for (let nt = 0, rt = $.length; nt < rt; nt++)
            tt += String.fromCharCode($[nt]);
        try {
            return decodeURIComponent(escape(tt))
        } catch {
            return tt
        }
    }
    static extractUrlBase($) {
        const tt = $.lastIndexOf("/");
        return tt === -1 ? "./" : $.slice(0, tt + 1)
    }
    static resolveURL($, tt) {
        return typeof $ != "string" || $ === "" ? "" : (/^https?:\/\//i.test(tt) && /^\//.test($) && (tt = tt.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test($) || /^data:.*,.*$/i.test($) || /^blob:.*$/i.test($) ? $ : tt + $)
    }
}
class InstancedBufferGeometry extends BufferGeometry {
    constructor() {
        super(),
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy($) {
        return super.copy($),
        this.instanceCount = $.instanceCount,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const $ = super.toJSON(this);
        return $.instanceCount = this.instanceCount,
        $.isInstancedBufferGeometry = !0,
        $
    }
}
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = !0;
class ImageBitmapLoader extends Loader$1 {
    constructor($) {
        super($),
        typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions($) {
        return this.options = $,
        this
    }
    load($, tt, nt, rt) {
        $ === void 0 && ($ = ""),
        this.path !== void 0 && ($ = this.path + $),
        $ = this.manager.resolveURL($);
        const it = this
          , ot = Cache.get($);
        if (ot !== void 0)
            return it.manager.itemStart($),
            setTimeout(function() {
                tt && tt(ot),
                it.manager.itemEnd($)
            }, 0),
            ot;
        const st = {};
        st.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        st.headers = this.requestHeader,
        fetch($, st).then(function(lt) {
            return lt.blob()
        }).then(function(lt) {
            return createImageBitmap(lt, Object.assign(it.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(lt) {
            Cache.add($, lt),
            tt && tt(lt),
            it.manager.itemEnd($)
        }).catch(function(lt) {
            rt && rt(lt),
            it.manager.itemError($),
            it.manager.itemEnd($)
        }),
        it.manager.itemStart($)
    }
}
ImageBitmapLoader.prototype.isImageBitmapLoader = !0;
let _context;
const AudioContext = {
    getContext: function() {
        return _context === void 0 && (_context = new (window.AudioContext || window.webkitAudioContext)),
        _context
    },
    setContext: function(et) {
        _context = et
    }
};
class AudioLoader extends Loader$1 {
    constructor($) {
        super($)
    }
    load($, tt, nt, rt) {
        const it = this
          , ot = new FileLoader(this.manager);
        ot.setResponseType("arraybuffer"),
        ot.setPath(this.path),
        ot.setRequestHeader(this.requestHeader),
        ot.setWithCredentials(this.withCredentials),
        ot.load($, function(st) {
            try {
                const lt = st.slice(0);
                AudioContext.getContext().decodeAudioData(lt, function(ct) {
                    tt(ct)
                })
            } catch (lt) {
                rt ? rt(lt) : console.error(lt),
                it.manager.itemError($)
            }
        }, nt, rt)
    }
}
class HemisphereLightProbe extends LightProbe {
    constructor($, tt, nt=1) {
        super(void 0, nt);
        const rt = new Color().set($)
          , it = new Color().set(tt)
          , ot = new Vector3(rt.r,rt.g,rt.b)
          , st = new Vector3(it.r,it.g,it.b)
          , lt = Math.sqrt(Math.PI)
          , ut = lt * Math.sqrt(.75);
        this.sh.coefficients[0].copy(ot).add(st).multiplyScalar(lt),
        this.sh.coefficients[1].copy(ot).sub(st).multiplyScalar(ut)
    }
}
HemisphereLightProbe.prototype.isHemisphereLightProbe = !0;
class AmbientLightProbe extends LightProbe {
    constructor($, tt=1) {
        super(void 0, tt);
        const nt = new Color().set($);
        this.sh.coefficients[0].set(nt.r, nt.g, nt.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
}
AmbientLightProbe.prototype.isAmbientLightProbe = !0;
class Audio$1 extends Object3D {
    constructor($) {
        super(),
        this.type = "Audio",
        this.listener = $,
        this.context = $.context,
        this.gain = this.context.createGain(),
        this.gain.connect($.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource($) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = $,
        this.connect(),
        this
    }
    setMediaElementSource($) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource($),
        this.connect(),
        this
    }
    setMediaStreamSource($) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource($),
        this.connect(),
        this
    }
    setBuffer($) {
        return this.buffer = $,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play($=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + $;
        const tt = this.context.createBufferSource();
        return tt.buffer = this.buffer,
        tt.loop = this.loop,
        tt.loopStart = this.loopStart,
        tt.loopEnd = this.loopEnd,
        tt.onended = this.onEnded.bind(this),
        tt.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = tt,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let $ = 1, tt = this.filters.length; $ < tt; $++)
                this.filters[$ - 1].connect(this.filters[$]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let $ = 1, tt = this.filters.length; $ < tt; $++)
                this.filters[$ - 1].disconnect(this.filters[$]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else
            this.source.disconnect(this.getOutput());
        return this._connected = !1,
        this
    }
    getFilters() {
        return this.filters
    }
    setFilters($) {
        return $ || ($ = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = $.slice(),
        this.connect()) : this.filters = $.slice(),
        this
    }
    setDetune($) {
        if (this.detune = $,
        this.source.detune !== void 0)
            return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
            this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter($) {
        return this.setFilters($ ? [$] : [])
    }
    setPlaybackRate($) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = $,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop($) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = $,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart($) {
        return this.loopStart = $,
        this
    }
    setLoopEnd($) {
        return this.loopEnd = $,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume($) {
        return this.gain.gain.setTargetAtTime($, this.context.currentTime, .01),
        this
    }
}
class PropertyMixer {
    constructor($, tt, nt) {
        this.binding = $,
        this.valueSize = nt;
        let rt, it, ot;
        switch (tt) {
        case "quaternion":
            rt = this._slerp,
            it = this._slerpAdditive,
            ot = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(nt * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            rt = this._select,
            it = this._select,
            ot = this._setAdditiveIdentityOther,
            this.buffer = new Array(nt * 5);
            break;
        default:
            rt = this._lerp,
            it = this._lerpAdditive,
            ot = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(nt * 5)
        }
        this._mixBufferRegion = rt,
        this._mixBufferRegionAdditive = it,
        this._setIdentity = ot,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate($, tt) {
        const nt = this.buffer
          , rt = this.valueSize
          , it = $ * rt + rt;
        let ot = this.cumulativeWeight;
        if (ot === 0) {
            for (let st = 0; st !== rt; ++st)
                nt[it + st] = nt[st];
            ot = tt
        } else {
            ot += tt;
            const st = tt / ot;
            this._mixBufferRegion(nt, it, 0, st, rt)
        }
        this.cumulativeWeight = ot
    }
    accumulateAdditive($) {
        const tt = this.buffer
          , nt = this.valueSize
          , rt = nt * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(tt, rt, 0, $, nt),
        this.cumulativeWeightAdditive += $
    }
    apply($) {
        const tt = this.valueSize
          , nt = this.buffer
          , rt = $ * tt + tt
          , it = this.cumulativeWeight
          , ot = this.cumulativeWeightAdditive
          , st = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        it < 1) {
            const lt = tt * this._origIndex;
            this._mixBufferRegion(nt, rt, lt, 1 - it, tt)
        }
        ot > 0 && this._mixBufferRegionAdditive(nt, rt, this._addIndex * tt, 1, tt);
        for (let lt = tt, ut = tt + tt; lt !== ut; ++lt)
            if (nt[lt] !== nt[lt + tt]) {
                st.setValue(nt, rt);
                break
            }
    }
    saveOriginalState() {
        const $ = this.binding
          , tt = this.buffer
          , nt = this.valueSize
          , rt = nt * this._origIndex;
        $.getValue(tt, rt);
        for (let it = nt, ot = rt; it !== ot; ++it)
            tt[it] = tt[rt + it % nt];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const $ = this.valueSize * 3;
        this.binding.setValue(this.buffer, $)
    }
    _setAdditiveIdentityNumeric() {
        const $ = this._addIndex * this.valueSize
          , tt = $ + this.valueSize;
        for (let nt = $; nt < tt; nt++)
            this.buffer[nt] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const $ = this._origIndex * this.valueSize
          , tt = this._addIndex * this.valueSize;
        for (let nt = 0; nt < this.valueSize; nt++)
            this.buffer[tt + nt] = this.buffer[$ + nt]
    }
    _select($, tt, nt, rt, it) {
        if (rt >= .5)
            for (let ot = 0; ot !== it; ++ot)
                $[tt + ot] = $[nt + ot]
    }
    _slerp($, tt, nt, rt) {
        Quaternion.slerpFlat($, tt, $, tt, $, nt, rt)
    }
    _slerpAdditive($, tt, nt, rt, it) {
        const ot = this._workIndex * it;
        Quaternion.multiplyQuaternionsFlat($, ot, $, tt, $, nt),
        Quaternion.slerpFlat($, tt, $, tt, $, ot, rt)
    }
    _lerp($, tt, nt, rt, it) {
        const ot = 1 - rt;
        for (let st = 0; st !== it; ++st) {
            const lt = tt + st;
            $[lt] = $[lt] * ot + $[nt + st] * rt
        }
    }
    _lerpAdditive($, tt, nt, rt, it) {
        for (let ot = 0; ot !== it; ++ot) {
            const st = tt + ot;
            $[st] = $[st] + $[nt + ot] * rt
        }
    }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/"
  , _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]","g")
  , _wordChar = "[^" + _RESERVED_CHARS_RE + "]"
  , _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]"
  , _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar)
  , _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot)
  , _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar)
  , _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar)
  , _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$")
  , _supportedObjectNames = ["material", "materials", "bones"];
class Composite {
    constructor($, tt, nt) {
        const rt = nt || PropertyBinding.parseTrackName(tt);
        this._targetGroup = $,
        this._bindings = $.subscribe_(tt, rt)
    }
    getValue($, tt) {
        this.bind();
        const nt = this._targetGroup.nCachedObjects_
          , rt = this._bindings[nt];
        rt !== void 0 && rt.getValue($, tt)
    }
    setValue($, tt) {
        const nt = this._bindings;
        for (let rt = this._targetGroup.nCachedObjects_, it = nt.length; rt !== it; ++rt)
            nt[rt].setValue($, tt)
    }
    bind() {
        const $ = this._bindings;
        for (let tt = this._targetGroup.nCachedObjects_, nt = $.length; tt !== nt; ++tt)
            $[tt].bind()
    }
    unbind() {
        const $ = this._bindings;
        for (let tt = this._targetGroup.nCachedObjects_, nt = $.length; tt !== nt; ++tt)
            $[tt].unbind()
    }
}
class PropertyBinding {
    constructor($, tt, nt) {
        this.path = tt,
        this.parsedPath = nt || PropertyBinding.parseTrackName(tt),
        this.node = PropertyBinding.findNode($, this.parsedPath.nodeName) || $,
        this.rootNode = $,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create($, tt, nt) {
        return $ && $.isAnimationObjectGroup ? new PropertyBinding.Composite($,tt,nt) : new PropertyBinding($,tt,nt)
    }
    static sanitizeNodeName($) {
        return $.replace(/\s/g, "_").replace(_reservedRe, "")
    }
    static parseTrackName($) {
        const tt = _trackRe.exec($);
        if (tt === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + $);
        const nt = {
            nodeName: tt[2],
            objectName: tt[3],
            objectIndex: tt[4],
            propertyName: tt[5],
            propertyIndex: tt[6]
        }
          , rt = nt.nodeName && nt.nodeName.lastIndexOf(".");
        if (rt !== void 0 && rt !== -1) {
            const it = nt.nodeName.substring(rt + 1);
            _supportedObjectNames.indexOf(it) !== -1 && (nt.nodeName = nt.nodeName.substring(0, rt),
            nt.objectName = it)
        }
        if (nt.propertyName === null || nt.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + $);
        return nt
    }
    static findNode($, tt) {
        if (tt === void 0 || tt === "" || tt === "." || tt === -1 || tt === $.name || tt === $.uuid)
            return $;
        if ($.skeleton) {
            const nt = $.skeleton.getBoneByName(tt);
            if (nt !== void 0)
                return nt
        }
        if ($.children) {
            const nt = function(it) {
                for (let ot = 0; ot < it.length; ot++) {
                    const st = it[ot];
                    if (st.name === tt || st.uuid === tt)
                        return st;
                    const lt = nt(st.children);
                    if (lt)
                        return lt
                }
                return null
            }
              , rt = nt($.children);
            if (rt)
                return rt
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct($, tt) {
        $[tt] = this.targetObject[this.propertyName]
    }
    _getValue_array($, tt) {
        const nt = this.resolvedProperty;
        for (let rt = 0, it = nt.length; rt !== it; ++rt)
            $[tt++] = nt[rt]
    }
    _getValue_arrayElement($, tt) {
        $[tt] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray($, tt) {
        this.resolvedProperty.toArray($, tt)
    }
    _setValue_direct($, tt) {
        this.targetObject[this.propertyName] = $[tt]
    }
    _setValue_direct_setNeedsUpdate($, tt) {
        this.targetObject[this.propertyName] = $[tt],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate($, tt) {
        this.targetObject[this.propertyName] = $[tt],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array($, tt) {
        const nt = this.resolvedProperty;
        for (let rt = 0, it = nt.length; rt !== it; ++rt)
            nt[rt] = $[tt++]
    }
    _setValue_array_setNeedsUpdate($, tt) {
        const nt = this.resolvedProperty;
        for (let rt = 0, it = nt.length; rt !== it; ++rt)
            nt[rt] = $[tt++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate($, tt) {
        const nt = this.resolvedProperty;
        for (let rt = 0, it = nt.length; rt !== it; ++rt)
            nt[rt] = $[tt++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement($, tt) {
        this.resolvedProperty[this.propertyIndex] = $[tt]
    }
    _setValue_arrayElement_setNeedsUpdate($, tt) {
        this.resolvedProperty[this.propertyIndex] = $[tt],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate($, tt) {
        this.resolvedProperty[this.propertyIndex] = $[tt],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray($, tt) {
        this.resolvedProperty.fromArray($, tt)
    }
    _setValue_fromArray_setNeedsUpdate($, tt) {
        this.resolvedProperty.fromArray($, tt),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate($, tt) {
        this.resolvedProperty.fromArray($, tt),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound($, tt) {
        this.bind(),
        this.getValue($, tt)
    }
    _setValue_unbound($, tt) {
        this.bind(),
        this.setValue($, tt)
    }
    bind() {
        let $ = this.node;
        const tt = this.parsedPath
          , nt = tt.objectName
          , rt = tt.propertyName;
        let it = tt.propertyIndex;
        if ($ || ($ = PropertyBinding.findNode(this.rootNode, tt.nodeName) || this.rootNode,
        this.node = $),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !$) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return
        }
        if (nt) {
            let ut = tt.objectIndex;
            switch (nt) {
            case "materials":
                if (!$.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!$.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                $ = $.material.materials;
                break;
            case "bones":
                if (!$.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                $ = $.skeleton.bones;
                for (let ct = 0; ct < $.length; ct++)
                    if ($[ct].name === ut) {
                        ut = ct;
                        break
                    }
                break;
            default:
                if ($[nt] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                $ = $[nt]
            }
            if (ut !== void 0) {
                if ($[ut] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, $);
                    return
                }
                $ = $[ut]
            }
        }
        const ot = $[rt];
        if (ot === void 0) {
            const ut = tt.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + ut + "." + rt + " but it wasn't found.", $);
            return
        }
        let st = this.Versioning.None;
        this.targetObject = $,
        $.needsUpdate !== void 0 ? st = this.Versioning.NeedsUpdate : $.matrixWorldNeedsUpdate !== void 0 && (st = this.Versioning.MatrixWorldNeedsUpdate);
        let lt = this.BindingType.Direct;
        if (it !== void 0) {
            if (rt === "morphTargetInfluences") {
                if (!$.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if ($.geometry.isBufferGeometry) {
                    if (!$.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return
                    }
                    $.morphTargetDictionary[it] !== void 0 && (it = $.morphTargetDictionary[it])
                } else {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    return
                }
            }
            lt = this.BindingType.ArrayElement,
            this.resolvedProperty = ot,
            this.propertyIndex = it
        } else
            ot.fromArray !== void 0 && ot.toArray !== void 0 ? (lt = this.BindingType.HasFromToArray,
            this.resolvedProperty = ot) : Array.isArray(ot) ? (lt = this.BindingType.EntireArray,
            this.resolvedProperty = ot) : this.propertyName = rt;
        this.getValue = this.GetterByBindingType[lt],
        this.setValue = this.SetterByBindingTypeAndVersioning[lt][st]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class AnimationAction {
    constructor($, tt, nt=null, rt=tt.blendMode) {
        this._mixer = $,
        this._clip = tt,
        this._localRoot = nt,
        this.blendMode = rt;
        const it = tt.tracks
          , ot = it.length
          , st = new Array(ot)
          , lt = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
        for (let ut = 0; ut !== ot; ++ut) {
            const ct = it[ut].createInterpolant(null);
            st[ut] = ct,
            ct.settings = lt
        }
        this._interpolantSettings = lt,
        this._interpolants = st,
        this._propertyBindings = new Array(ot),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = LoopRepeat,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt($) {
        return this._startTime = $,
        this
    }
    setLoop($, tt) {
        return this.loop = $,
        this.repetitions = tt,
        this
    }
    setEffectiveWeight($) {
        return this.weight = $,
        this._effectiveWeight = this.enabled ? $ : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn($) {
        return this._scheduleFading($, 0, 1)
    }
    fadeOut($) {
        return this._scheduleFading($, 1, 0)
    }
    crossFadeFrom($, tt, nt) {
        if ($.fadeOut(tt),
        this.fadeIn(tt),
        nt) {
            const rt = this._clip.duration
              , it = $._clip.duration
              , ot = it / rt
              , st = rt / it;
            $.warp(1, ot, tt),
            this.warp(st, 1, tt)
        }
        return this
    }
    crossFadeTo($, tt, nt) {
        return $.crossFadeFrom(this, tt, nt)
    }
    stopFading() {
        const $ = this._weightInterpolant;
        return $ !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant($)),
        this
    }
    setEffectiveTimeScale($) {
        return this.timeScale = $,
        this._effectiveTimeScale = this.paused ? 0 : $,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration($) {
        return this.timeScale = this._clip.duration / $,
        this.stopWarping()
    }
    syncWith($) {
        return this.time = $.time,
        this.timeScale = $.timeScale,
        this.stopWarping()
    }
    halt($) {
        return this.warp(this._effectiveTimeScale, 0, $)
    }
    warp($, tt, nt) {
        const rt = this._mixer
          , it = rt.time
          , ot = this.timeScale;
        let st = this._timeScaleInterpolant;
        st === null && (st = rt._lendControlInterpolant(),
        this._timeScaleInterpolant = st);
        const lt = st.parameterPositions
          , ut = st.sampleValues;
        return lt[0] = it,
        lt[1] = it + nt,
        ut[0] = $ / ot,
        ut[1] = tt / ot,
        this
    }
    stopWarping() {
        const $ = this._timeScaleInterpolant;
        return $ !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant($)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update($, tt, nt, rt) {
        if (!this.enabled) {
            this._updateWeight($);
            return
        }
        const it = this._startTime;
        if (it !== null) {
            const lt = ($ - it) * nt;
            if (lt < 0 || nt === 0)
                return;
            this._startTime = null,
            tt = nt * lt
        }
        tt *= this._updateTimeScale($);
        const ot = this._updateTime(tt)
          , st = this._updateWeight($);
        if (st > 0) {
            const lt = this._interpolants
              , ut = this._propertyBindings;
            switch (this.blendMode) {
            case AdditiveAnimationBlendMode:
                for (let ct = 0, ht = lt.length; ct !== ht; ++ct)
                    lt[ct].evaluate(ot),
                    ut[ct].accumulateAdditive(st);
                break;
            case NormalAnimationBlendMode:
            default:
                for (let ct = 0, ht = lt.length; ct !== ht; ++ct)
                    lt[ct].evaluate(ot),
                    ut[ct].accumulate(rt, st)
            }
        }
    }
    _updateWeight($) {
        let tt = 0;
        if (this.enabled) {
            tt = this.weight;
            const nt = this._weightInterpolant;
            if (nt !== null) {
                const rt = nt.evaluate($)[0];
                tt *= rt,
                $ > nt.parameterPositions[1] && (this.stopFading(),
                rt === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = tt,
        tt
    }
    _updateTimeScale($) {
        let tt = 0;
        if (!this.paused) {
            tt = this.timeScale;
            const nt = this._timeScaleInterpolant;
            nt !== null && (tt *= nt.evaluate($)[0],
            $ > nt.parameterPositions[1] && (this.stopWarping(),
            tt === 0 ? this.paused = !0 : this.timeScale = tt))
        }
        return this._effectiveTimeScale = tt,
        tt
    }
    _updateTime($) {
        const tt = this._clip.duration
          , nt = this.loop;
        let rt = this.time + $
          , it = this._loopCount;
        const ot = nt === LoopPingPong;
        if ($ === 0)
            return it === -1 ? rt : ot && (it & 1) === 1 ? tt - rt : rt;
        if (nt === LoopOnce) {
            it === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (rt >= tt)
                    rt = tt;
                else if (rt < 0)
                    rt = 0;
                else {
                    this.time = rt;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = rt,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: $ < 0 ? -1 : 1
                })
            }
        } else {
            if (it === -1 && ($ >= 0 ? (it = 0,
            this._setEndings(!0, this.repetitions === 0, ot)) : this._setEndings(this.repetitions === 0, !0, ot)),
            rt >= tt || rt < 0) {
                const st = Math.floor(rt / tt);
                rt -= tt * st,
                it += Math.abs(st);
                const lt = this.repetitions - it;
                if (lt <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    rt = $ > 0 ? tt : 0,
                    this.time = rt,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: $ > 0 ? 1 : -1
                    });
                else {
                    if (lt === 1) {
                        const ut = $ < 0;
                        this._setEndings(ut, !ut, ot)
                    } else
                        this._setEndings(!1, !1, ot);
                    this._loopCount = it,
                    this.time = rt,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: st
                    })
                }
            } else
                this.time = rt;
            if (ot && (it & 1) === 1)
                return tt - rt
        }
        return rt
    }
    _setEndings($, tt, nt) {
        const rt = this._interpolantSettings;
        nt ? (rt.endingStart = ZeroSlopeEnding,
        rt.endingEnd = ZeroSlopeEnding) : ($ ? rt.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : rt.endingStart = WrapAroundEnding,
        tt ? rt.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : rt.endingEnd = WrapAroundEnding)
    }
    _scheduleFading($, tt, nt) {
        const rt = this._mixer
          , it = rt.time;
        let ot = this._weightInterpolant;
        ot === null && (ot = rt._lendControlInterpolant(),
        this._weightInterpolant = ot);
        const st = ot.parameterPositions
          , lt = ot.sampleValues;
        return st[0] = it,
        lt[0] = tt,
        st[1] = it + $,
        lt[1] = nt,
        this
    }
}
class AnimationMixer extends EventDispatcher {
    constructor($) {
        super(),
        this._root = $,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction($, tt) {
        const nt = $._localRoot || this._root
          , rt = $._clip.tracks
          , it = rt.length
          , ot = $._propertyBindings
          , st = $._interpolants
          , lt = nt.uuid
          , ut = this._bindingsByRootAndName;
        let ct = ut[lt];
        ct === void 0 && (ct = {},
        ut[lt] = ct);
        for (let ht = 0; ht !== it; ++ht) {
            const ft = rt[ht]
              , gt = ft.name;
            let vt = ct[gt];
            if (vt !== void 0)
                ++vt.referenceCount,
                ot[ht] = vt;
            else {
                if (vt = ot[ht],
                vt !== void 0) {
                    vt._cacheIndex === null && (++vt.referenceCount,
                    this._addInactiveBinding(vt, lt, gt));
                    continue
                }
                const yt = tt && tt._propertyBindings[ht].binding.parsedPath;
                vt = new PropertyMixer(PropertyBinding.create(nt, gt, yt),ft.ValueTypeName,ft.getValueSize()),
                ++vt.referenceCount,
                this._addInactiveBinding(vt, lt, gt),
                ot[ht] = vt
            }
            st[ht].resultBuffer = vt.buffer
        }
    }
    _activateAction($) {
        if (!this._isActiveAction($)) {
            if ($._cacheIndex === null) {
                const nt = ($._localRoot || this._root).uuid
                  , rt = $._clip.uuid
                  , it = this._actionsByClip[rt];
                this._bindAction($, it && it.knownActions[0]),
                this._addInactiveAction($, rt, nt)
            }
            const tt = $._propertyBindings;
            for (let nt = 0, rt = tt.length; nt !== rt; ++nt) {
                const it = tt[nt];
                it.useCount++ === 0 && (this._lendBinding(it),
                it.saveOriginalState())
            }
            this._lendAction($)
        }
    }
    _deactivateAction($) {
        if (this._isActiveAction($)) {
            const tt = $._propertyBindings;
            for (let nt = 0, rt = tt.length; nt !== rt; ++nt) {
                const it = tt[nt];
                --it.useCount === 0 && (it.restoreOriginalState(),
                this._takeBackBinding(it))
            }
            this._takeBackAction($)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const $ = this;
        this.stats = {
            actions: {
                get total() {
                    return $._actions.length
                },
                get inUse() {
                    return $._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return $._bindings.length
                },
                get inUse() {
                    return $._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return $._controlInterpolants.length
                },
                get inUse() {
                    return $._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction($) {
        const tt = $._cacheIndex;
        return tt !== null && tt < this._nActiveActions
    }
    _addInactiveAction($, tt, nt) {
        const rt = this._actions
          , it = this._actionsByClip;
        let ot = it[tt];
        if (ot === void 0)
            ot = {
                knownActions: [$],
                actionByRoot: {}
            },
            $._byClipCacheIndex = 0,
            it[tt] = ot;
        else {
            const st = ot.knownActions;
            $._byClipCacheIndex = st.length,
            st.push($)
        }
        $._cacheIndex = rt.length,
        rt.push($),
        ot.actionByRoot[nt] = $
    }
    _removeInactiveAction($) {
        const tt = this._actions
          , nt = tt[tt.length - 1]
          , rt = $._cacheIndex;
        nt._cacheIndex = rt,
        tt[rt] = nt,
        tt.pop(),
        $._cacheIndex = null;
        const it = $._clip.uuid
          , ot = this._actionsByClip
          , st = ot[it]
          , lt = st.knownActions
          , ut = lt[lt.length - 1]
          , ct = $._byClipCacheIndex;
        ut._byClipCacheIndex = ct,
        lt[ct] = ut,
        lt.pop(),
        $._byClipCacheIndex = null;
        const ht = st.actionByRoot
          , ft = ($._localRoot || this._root).uuid;
        delete ht[ft],
        lt.length === 0 && delete ot[it],
        this._removeInactiveBindingsForAction($)
    }
    _removeInactiveBindingsForAction($) {
        const tt = $._propertyBindings;
        for (let nt = 0, rt = tt.length; nt !== rt; ++nt) {
            const it = tt[nt];
            --it.referenceCount === 0 && this._removeInactiveBinding(it)
        }
    }
    _lendAction($) {
        const tt = this._actions
          , nt = $._cacheIndex
          , rt = this._nActiveActions++
          , it = tt[rt];
        $._cacheIndex = rt,
        tt[rt] = $,
        it._cacheIndex = nt,
        tt[nt] = it
    }
    _takeBackAction($) {
        const tt = this._actions
          , nt = $._cacheIndex
          , rt = --this._nActiveActions
          , it = tt[rt];
        $._cacheIndex = rt,
        tt[rt] = $,
        it._cacheIndex = nt,
        tt[nt] = it
    }
    _addInactiveBinding($, tt, nt) {
        const rt = this._bindingsByRootAndName
          , it = this._bindings;
        let ot = rt[tt];
        ot === void 0 && (ot = {},
        rt[tt] = ot),
        ot[nt] = $,
        $._cacheIndex = it.length,
        it.push($)
    }
    _removeInactiveBinding($) {
        const tt = this._bindings
          , nt = $.binding
          , rt = nt.rootNode.uuid
          , it = nt.path
          , ot = this._bindingsByRootAndName
          , st = ot[rt]
          , lt = tt[tt.length - 1]
          , ut = $._cacheIndex;
        lt._cacheIndex = ut,
        tt[ut] = lt,
        tt.pop(),
        delete st[it],
        Object.keys(st).length === 0 && delete ot[rt]
    }
    _lendBinding($) {
        const tt = this._bindings
          , nt = $._cacheIndex
          , rt = this._nActiveBindings++
          , it = tt[rt];
        $._cacheIndex = rt,
        tt[rt] = $,
        it._cacheIndex = nt,
        tt[nt] = it
    }
    _takeBackBinding($) {
        const tt = this._bindings
          , nt = $._cacheIndex
          , rt = --this._nActiveBindings
          , it = tt[rt];
        $._cacheIndex = rt,
        tt[rt] = $,
        it._cacheIndex = nt,
        tt[nt] = it
    }
    _lendControlInterpolant() {
        const $ = this._controlInterpolants
          , tt = this._nActiveControlInterpolants++;
        let nt = $[tt];
        return nt === void 0 && (nt = new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
        nt.__cacheIndex = tt,
        $[tt] = nt),
        nt
    }
    _takeBackControlInterpolant($) {
        const tt = this._controlInterpolants
          , nt = $.__cacheIndex
          , rt = --this._nActiveControlInterpolants
          , it = tt[rt];
        $.__cacheIndex = rt,
        tt[rt] = $,
        it.__cacheIndex = nt,
        tt[nt] = it
    }
    clipAction($, tt, nt) {
        const rt = tt || this._root
          , it = rt.uuid;
        let ot = typeof $ == "string" ? AnimationClip.findByName(rt, $) : $;
        const st = ot !== null ? ot.uuid : $
          , lt = this._actionsByClip[st];
        let ut = null;
        if (nt === void 0 && (ot !== null ? nt = ot.blendMode : nt = NormalAnimationBlendMode),
        lt !== void 0) {
            const ht = lt.actionByRoot[it];
            if (ht !== void 0 && ht.blendMode === nt)
                return ht;
            ut = lt.knownActions[0],
            ot === null && (ot = ut._clip)
        }
        if (ot === null)
            return null;
        const ct = new AnimationAction(this,ot,tt,nt);
        return this._bindAction(ct, ut),
        this._addInactiveAction(ct, st, it),
        ct
    }
    existingAction($, tt) {
        const nt = tt || this._root
          , rt = nt.uuid
          , it = typeof $ == "string" ? AnimationClip.findByName(nt, $) : $
          , ot = it ? it.uuid : $
          , st = this._actionsByClip[ot];
        return st !== void 0 && st.actionByRoot[rt] || null
    }
    stopAllAction() {
        const $ = this._actions
          , tt = this._nActiveActions;
        for (let nt = tt - 1; nt >= 0; --nt)
            $[nt].stop();
        return this
    }
    update($) {
        $ *= this.timeScale;
        const tt = this._actions
          , nt = this._nActiveActions
          , rt = this.time += $
          , it = Math.sign($)
          , ot = this._accuIndex ^= 1;
        for (let ut = 0; ut !== nt; ++ut)
            tt[ut]._update(rt, $, it, ot);
        const st = this._bindings
          , lt = this._nActiveBindings;
        for (let ut = 0; ut !== lt; ++ut)
            st[ut].apply(ot);
        return this
    }
    setTime($) {
        this.time = 0;
        for (let tt = 0; tt < this._actions.length; tt++)
            this._actions[tt].time = 0;
        return this.update($)
    }
    getRoot() {
        return this._root
    }
    uncacheClip($) {
        const tt = this._actions
          , nt = $.uuid
          , rt = this._actionsByClip
          , it = rt[nt];
        if (it !== void 0) {
            const ot = it.knownActions;
            for (let st = 0, lt = ot.length; st !== lt; ++st) {
                const ut = ot[st];
                this._deactivateAction(ut);
                const ct = ut._cacheIndex
                  , ht = tt[tt.length - 1];
                ut._cacheIndex = null,
                ut._byClipCacheIndex = null,
                ht._cacheIndex = ct,
                tt[ct] = ht,
                tt.pop(),
                this._removeInactiveBindingsForAction(ut)
            }
            delete rt[nt]
        }
    }
    uncacheRoot($) {
        const tt = $.uuid
          , nt = this._actionsByClip;
        for (const ot in nt) {
            const st = nt[ot].actionByRoot
              , lt = st[tt];
            lt !== void 0 && (this._deactivateAction(lt),
            this._removeInactiveAction(lt))
        }
        const rt = this._bindingsByRootAndName
          , it = rt[tt];
        if (it !== void 0)
            for (const ot in it) {
                const st = it[ot];
                st.restoreOriginalState(),
                this._removeInactiveBinding(st)
            }
    }
    uncacheAction($, tt) {
        const nt = this.existingAction($, tt);
        nt !== null && (this._deactivateAction(nt),
        this._removeInactiveAction(nt))
    }
}
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class InstancedInterleavedBuffer extends InterleavedBuffer {
    constructor($, tt, nt=1) {
        super($, tt),
        this.meshPerAttribute = nt
    }
    copy($) {
        return super.copy($),
        this.meshPerAttribute = $.meshPerAttribute,
        this
    }
    clone($) {
        const tt = super.clone($);
        return tt.meshPerAttribute = this.meshPerAttribute,
        tt
    }
    toJSON($) {
        const tt = super.toJSON($);
        return tt.isInstancedInterleavedBuffer = !0,
        tt.meshPerAttribute = this.meshPerAttribute,
        tt
    }
}
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = !0;
class Spherical {
    constructor($=1, tt=0, nt=0) {
        return this.radius = $,
        this.phi = tt,
        this.theta = nt,
        this
    }
    set($, tt, nt) {
        return this.radius = $,
        this.phi = tt,
        this.theta = nt,
        this
    }
    copy($) {
        return this.radius = $.radius,
        this.phi = $.phi,
        this.theta = $.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3($) {
        return this.setFromCartesianCoords($.x, $.y, $.z)
    }
    setFromCartesianCoords($, tt, nt) {
        return this.radius = Math.sqrt($ * $ + tt * tt + nt * nt),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2($, nt),
        this.phi = Math.acos(clamp$1(tt / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _vector$2 = new Vector3
  , _boneMatrix = new Matrix4
  , _matrixWorldInv = new Matrix4;
class SkeletonHelper extends LineSegments {
    constructor($) {
        const tt = getBoneList($)
          , nt = new BufferGeometry
          , rt = []
          , it = []
          , ot = new Color(0,0,1)
          , st = new Color(0,1,0);
        for (let ut = 0; ut < tt.length; ut++) {
            const ct = tt[ut];
            ct.parent && ct.parent.isBone && (rt.push(0, 0, 0),
            rt.push(0, 0, 0),
            it.push(ot.r, ot.g, ot.b),
            it.push(st.r, st.g, st.b))
        }
        nt.setAttribute("position", new Float32BufferAttribute(rt,3)),
        nt.setAttribute("color", new Float32BufferAttribute(it,3));
        const lt = new LineBasicMaterial({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(nt, lt),
        this.type = "SkeletonHelper",
        this.isSkeletonHelper = !0,
        this.root = $,
        this.bones = tt,
        this.matrix = $.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    updateMatrixWorld($) {
        const tt = this.bones
          , nt = this.geometry
          , rt = nt.getAttribute("position");
        _matrixWorldInv.copy(this.root.matrixWorld).invert();
        for (let it = 0, ot = 0; it < tt.length; it++) {
            const st = tt[it];
            st.parent && st.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, st.matrixWorld),
            _vector$2.setFromMatrixPosition(_boneMatrix),
            rt.setXYZ(ot, _vector$2.x, _vector$2.y, _vector$2.z),
            _boneMatrix.multiplyMatrices(_matrixWorldInv, st.parent.matrixWorld),
            _vector$2.setFromMatrixPosition(_boneMatrix),
            rt.setXYZ(ot + 1, _vector$2.x, _vector$2.y, _vector$2.z),
            ot += 2)
        }
        nt.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld($)
    }
}
function getBoneList(et) {
    const $ = [];
    et.isBone === !0 && $.push(et);
    for (let tt = 0; tt < et.children.length; tt++)
        $.push.apply($, getBoneList(et.children[tt]));
    return $
}
class GridHelper extends LineSegments {
    constructor($=10, tt=10, nt=4473924, rt=8947848) {
        nt = new Color(nt),
        rt = new Color(rt);
        const it = tt / 2
          , ot = $ / tt
          , st = $ / 2
          , lt = []
          , ut = [];
        for (let ft = 0, gt = 0, vt = -st; ft <= tt; ft++,
        vt += ot) {
            lt.push(-st, 0, vt, st, 0, vt),
            lt.push(vt, 0, -st, vt, 0, st);
            const yt = ft === it ? nt : rt;
            yt.toArray(ut, gt),
            gt += 3,
            yt.toArray(ut, gt),
            gt += 3,
            yt.toArray(ut, gt),
            gt += 3,
            yt.toArray(ut, gt),
            gt += 3
        }
        const ct = new BufferGeometry;
        ct.setAttribute("position", new Float32BufferAttribute(lt,3)),
        ct.setAttribute("color", new Float32BufferAttribute(ut,3));
        const ht = new LineBasicMaterial({
            vertexColors: !0,
            toneMapped: !1
        });
        super(ct, ht),
        this.type = "GridHelper"
    }
}
const _floatView = new Float32Array(1);
new Int32Array(_floatView.buffer);
Curve.create = function(et, $) {
    return console.log("THREE.Curve.create() has been deprecated"),
    et.prototype = Object.create(Curve.prototype),
    et.prototype.constructor = et,
    et.prototype.getPoint = $,
    et
}
;
Path.prototype.fromPoints = function(et) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
    this.setFromPoints(et)
}
;
GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
}
;
SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
}
;
Loader$1.prototype.extractUrlBase = function(et) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
    LoaderUtils.extractUrlBase(et)
}
;
Loader$1.Handlers = {
    add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
    },
    get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
    }
};
Box3.prototype.center = function(et) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
    this.getCenter(et)
}
;
Box3.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
}
;
Box3.prototype.isIntersectionBox = function(et) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
    this.intersectsBox(et)
}
;
Box3.prototype.isIntersectionSphere = function(et) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
    this.intersectsSphere(et)
}
;
Box3.prototype.size = function(et) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
    this.getSize(et)
}
;
Euler.prototype.toVector3 = function() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
}
;
Sphere.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
}
;
Frustum.prototype.setFromMatrix = function(et) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
    this.setFromProjectionMatrix(et)
}
;
Matrix3.prototype.flattenToArrayOffset = function(et, $) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
    this.toArray(et, $)
}
;
Matrix3.prototype.multiplyVector3 = function(et) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
    et.applyMatrix3(this)
}
;
Matrix3.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
}
;
Matrix3.prototype.applyToBufferAttribute = function(et) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
    et.applyMatrix3(this)
}
;
Matrix3.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
}
;
Matrix3.prototype.getInverse = function(et) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
    this.copy(et).invert()
}
;
Matrix4.prototype.extractPosition = function(et) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
    this.copyPosition(et)
}
;
Matrix4.prototype.flattenToArrayOffset = function(et, $) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
    this.toArray(et, $)
}
;
Matrix4.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
    new Vector3().setFromMatrixColumn(this, 3)
}
;
Matrix4.prototype.setRotationFromQuaternion = function(et) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
    this.makeRotationFromQuaternion(et)
}
;
Matrix4.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
}
;
Matrix4.prototype.multiplyVector3 = function(et) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
    et.applyMatrix4(this)
}
;
Matrix4.prototype.multiplyVector4 = function(et) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
    et.applyMatrix4(this)
}
;
Matrix4.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
}
;
Matrix4.prototype.rotateAxis = function(et) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
    et.transformDirection(this)
}
;
Matrix4.prototype.crossVector = function(et) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
    et.applyMatrix4(this)
}
;
Matrix4.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.")
}
;
Matrix4.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.")
}
;
Matrix4.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.")
}
;
Matrix4.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.")
}
;
Matrix4.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
}
;
Matrix4.prototype.applyToBufferAttribute = function(et) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
    et.applyMatrix4(this)
}
;
Matrix4.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
}
;
Matrix4.prototype.makeFrustum = function(et, $, tt, nt, rt, it) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
    this.makePerspective(et, $, nt, tt, rt, it)
}
;
Matrix4.prototype.getInverse = function(et) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
    this.copy(et).invert()
}
;
Plane.prototype.isIntersectionLine = function(et) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
    this.intersectsLine(et)
}
;
Quaternion.prototype.multiplyVector3 = function(et) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
    et.applyQuaternion(this)
}
;
Quaternion.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
    this.invert()
}
;
Ray.prototype.isIntersectionBox = function(et) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
    this.intersectsBox(et)
}
;
Ray.prototype.isIntersectionPlane = function(et) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
    this.intersectsPlane(et)
}
;
Ray.prototype.isIntersectionSphere = function(et) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
    this.intersectsSphere(et)
}
;
Triangle.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
    this.getArea()
}
;
Triangle.prototype.barycoordFromPoint = function(et, $) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
    this.getBarycoord(et, $)
}
;
Triangle.prototype.midpoint = function(et) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
    this.getMidpoint(et)
}
;
Triangle.prototypenormal = function(et) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    this.getNormal(et)
}
;
Triangle.prototype.plane = function(et) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
    this.getPlane(et)
}
;
Triangle.barycoordFromPoint = function(et, $, tt, nt, rt) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
    Triangle.getBarycoord(et, $, tt, nt, rt)
}
;
Triangle.normal = function(et, $, tt, nt) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    Triangle.getNormal(et, $, tt, nt)
}
;
Shape.prototype.extractAllPoints = function(et) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
    this.extractPoints(et)
}
;
Shape.prototype.extrude = function(et) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
    new ExtrudeGeometry(this,et)
}
;
Shape.prototype.makeGeometry = function(et) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
    new ShapeGeometry(this,et)
}
;
Vector2.prototype.fromAttribute = function(et, $, tt) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
    this.fromBufferAttribute(et, $, tt)
}
;
Vector2.prototype.distanceToManhattan = function(et) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
    this.manhattanDistanceTo(et)
}
;
Vector2.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
    this.manhattanLength()
}
;
Vector3.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
}
;
Vector3.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
}
;
Vector3.prototype.getPositionFromMatrix = function(et) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
    this.setFromMatrixPosition(et)
}
;
Vector3.prototype.getScaleFromMatrix = function(et) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
    this.setFromMatrixScale(et)
}
;
Vector3.prototype.getColumnFromMatrix = function(et, $) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
    this.setFromMatrixColumn($, et)
}
;
Vector3.prototype.applyProjection = function(et) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
    this.applyMatrix4(et)
}
;
Vector3.prototype.fromAttribute = function(et, $, tt) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
    this.fromBufferAttribute(et, $, tt)
}
;
Vector3.prototype.distanceToManhattan = function(et) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
    this.manhattanDistanceTo(et)
}
;
Vector3.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
    this.manhattanLength()
}
;
Vector4.prototype.fromAttribute = function(et, $, tt) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
    this.fromBufferAttribute(et, $, tt)
}
;
Vector4.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
    this.manhattanLength()
}
;
Object3D.prototype.getChildByName = function(et) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
    this.getObjectByName(et)
}
;
Object3D.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
}
;
Object3D.prototype.translate = function(et, $) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
    this.translateOnAxis($, et)
}
;
Object3D.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
}
;
Object3D.prototype.applyMatrix = function(et) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
    this.applyMatrix4(et)
}
;
Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
        get: function() {
            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            this.rotation.order
        },
        set: function(et) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            this.rotation.order = et
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        }
    }
});
Mesh.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
}
;
Object.defineProperties(Mesh.prototype, {
    drawMode: {
        get: function() {
            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
            TrianglesDrawMode
        },
        set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }
});
SkinnedMesh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.")
}
;
PerspectiveCamera.prototype.setLens = function(et, $) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
    $ !== void 0 && (this.filmGauge = $),
    this.setFocalLength(et)
}
;
Object.defineProperties(Light.prototype, {
    onlyShadow: {
        set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.")
        }
    },
    shadowCameraFov: {
        set: function(et) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
            this.shadow.camera.fov = et
        }
    },
    shadowCameraLeft: {
        set: function(et) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
            this.shadow.camera.left = et
        }
    },
    shadowCameraRight: {
        set: function(et) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
            this.shadow.camera.right = et
        }
    },
    shadowCameraTop: {
        set: function(et) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
            this.shadow.camera.top = et
        }
    },
    shadowCameraBottom: {
        set: function(et) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
            this.shadow.camera.bottom = et
        }
    },
    shadowCameraNear: {
        set: function(et) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
            this.shadow.camera.near = et
        }
    },
    shadowCameraFar: {
        set: function(et) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
            this.shadow.camera.far = et
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
        }
    },
    shadowBias: {
        set: function(et) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
            this.shadow.bias = et
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.")
        }
    },
    shadowMapWidth: {
        set: function(et) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
            this.shadow.mapSize.width = et
        }
    },
    shadowMapHeight: {
        set: function(et) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
            this.shadow.mapSize.height = et
        }
    }
});
Object.defineProperties(BufferAttribute.prototype, {
    length: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
            this.array.length
        }
    },
    dynamic: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
            this.usage === DynamicDrawUsage
        },
        set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
            this.setUsage(DynamicDrawUsage)
        }
    }
});
BufferAttribute.prototype.setDynamic = function(et) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
    this.setUsage(et === !0 ? DynamicDrawUsage : StaticDrawUsage),
    this
}
;
BufferAttribute.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
}
,
BufferAttribute.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
}
;
BufferGeometry.prototype.addIndex = function(et) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
    this.setIndex(et)
}
;
BufferGeometry.prototype.addAttribute = function(et, $) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
    !($ && $.isBufferAttribute) && !($ && $.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
    this.setAttribute(et, new BufferAttribute(arguments[1],arguments[2]))) : et === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
    this.setIndex($),
    this) : this.setAttribute(et, $)
}
;
BufferGeometry.prototype.addDrawCall = function(et, $, tt) {
    tt !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
    this.addGroup(et, $)
}
;
BufferGeometry.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
    this.clearGroups()
}
;
BufferGeometry.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
}
;
BufferGeometry.prototype.removeAttribute = function(et) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
    this.deleteAttribute(et)
}
;
BufferGeometry.prototype.applyMatrix = function(et) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
    this.applyMatrix4(et)
}
;
Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
        get: function() {
            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
            this.groups
        }
    },
    offsets: {
        get: function() {
            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
            this.groups
        }
    }
});
InterleavedBuffer.prototype.setDynamic = function(et) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
    this.setUsage(et === !0 ? DynamicDrawUsage : StaticDrawUsage),
    this
}
;
InterleavedBuffer.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
}
;
ExtrudeGeometry.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
}
;
ExtrudeGeometry.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
}
;
ExtrudeGeometry.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
}
;
Scene.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.")
}
;
Object.defineProperties(Material.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.")
        },
        set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.")
        }
    },
    overdraw: {
        get: function() {
            console.warn("THREE.Material: .overdraw has been removed.")
        },
        set: function() {
            console.warn("THREE.Material: .overdraw has been removed.")
        }
    },
    wrapRGB: {
        get: function() {
            return console.warn("THREE.Material: .wrapRGB has been removed."),
            new Color
        }
    },
    shading: {
        get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
        },
        set: function(et) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
            this.flatShading = et === FlatShading
        }
    },
    stencilMask: {
        get: function() {
            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
            this.stencilFuncMask
        },
        set: function(et) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
            this.stencilFuncMask = et
        }
    },
    vertexTangents: {
        get: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
        },
        set: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
        }
    }
});
Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
        get: function() {
            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
            this.extensions.derivatives
        },
        set: function(et) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
            this.extensions.derivatives = et
        }
    }
});
WebGLRenderer.prototype.clearTarget = function(et, $, tt, nt) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
    this.setRenderTarget(et),
    this.clear($, tt, nt)
}
;
WebGLRenderer.prototype.animate = function(et) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
    this.setAnimationLoop(et)
}
;
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
    this.getRenderTarget()
}
;
WebGLRenderer.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
    this.capabilities.getMaxAnisotropy()
}
;
WebGLRenderer.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
    this.capabilities.precision
}
;
WebGLRenderer.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
    this.state.reset()
}
;
WebGLRenderer.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
    this.extensions.get("OES_texture_float")
}
;
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
    this.extensions.get("OES_texture_half_float")
}
;
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
    this.extensions.get("OES_standard_derivatives")
}
;
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
    this.extensions.get("WEBGL_compressed_texture_s3tc")
}
;
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
    this.extensions.get("WEBGL_compressed_texture_pvrtc")
}
;
WebGLRenderer.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
    this.extensions.get("EXT_blend_minmax")
}
;
WebGLRenderer.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
    this.capabilities.vertexTextures
}
;
WebGLRenderer.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
    this.extensions.get("ANGLE_instanced_arrays")
}
;
WebGLRenderer.prototype.enableScissorTest = function(et) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
    this.setScissorTest(et)
}
;
WebGLRenderer.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
}
;
WebGLRenderer.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
}
;
WebGLRenderer.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
}
;
WebGLRenderer.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
}
;
WebGLRenderer.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
}
;
WebGLRenderer.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
}
;
WebGLRenderer.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
}
;
WebGLRenderer.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
}
;
WebGLRenderer.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
}
;
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
    this.getActiveMipmapLevel()
}
;
Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
            this.shadowMap.enabled = et
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
            this.shadowMap.type = et
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        }
    },
    context: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
            this.getContext()
        }
    },
    vr: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
            this.xr
        }
    },
    gammaInput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
            !1
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
        }
    },
    gammaOutput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
            !1
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
            this.outputEncoding = et === !0 ? sRGBEncoding : LinearEncoding
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
            1
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
        }
    },
    gammaFactor: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),
            2
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
        }
    }
});
Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        }
    }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
            this.texture.wrapS
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
            this.texture.wrapS = et
        }
    },
    wrapT: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
            this.texture.wrapT
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
            this.texture.wrapT = et
        }
    },
    magFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
            this.texture.magFilter
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
            this.texture.magFilter = et
        }
    },
    minFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
            this.texture.minFilter
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
            this.texture.minFilter = et
        }
    },
    anisotropy: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
            this.texture.anisotropy
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
            this.texture.anisotropy = et
        }
    },
    offset: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
            this.texture.offset
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
            this.texture.offset = et
        }
    },
    repeat: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
            this.texture.repeat
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
            this.texture.repeat = et
        }
    },
    format: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
            this.texture.format
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
            this.texture.format = et
        }
    },
    type: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
            this.texture.type
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
            this.texture.type = et
        }
    },
    generateMipmaps: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
            this.texture.generateMipmaps
        },
        set: function(et) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
            this.texture.generateMipmaps = et
        }
    }
});
Audio$1.prototype.load = function(et) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const $ = this;
    return new AudioLoader().load(et, function(nt) {
        $.setBuffer(nt)
    }),
    this
}
;
CubeCamera.prototype.updateCubeMap = function(et, $) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
    this.update(et, $)
}
;
CubeCamera.prototype.clear = function(et, $, tt, nt) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
    this.renderTarget.clear(et, $, tt, nt)
}
;
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(et, $, tt, nt) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const rt = new TextureLoader;
    rt.setCrossOrigin(this.crossOrigin);
    const it = rt.load(et, tt, void 0, nt);
    return $ && (it.mapping = $),
    it
}
;
ImageUtils.loadTextureCube = function(et, $, tt, nt) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const rt = new CubeTextureLoader;
    rt.setCrossOrigin(this.crossOrigin);
    const it = rt.load(et, tt, void 0, nt);
    return $ && (it.mapping = $),
    it
}
;
ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
}
;
ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
}
;
typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: REVISION
    }
}));
typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);
var minSignal$1 = {
    exports: {}
};
(function(et) {
    (function($) {
        function tt() {
            this._listeners = [],
            this.dispatchCount = 0
        }
        var nt = tt.prototype;
        nt.add = st,
        nt.addOnce = lt,
        nt.remove = ut,
        nt.dispatch = ct;
        var rt = "Callback function is missing!"
          , it = Array.prototype.slice;
        function ot(ht) {
            ht.sort(function(ft, gt) {
                return ft = ft.p,
                gt = gt.p,
                gt < ft ? 1 : gt > ft ? -1 : 0
            })
        }
        function st(ht, ft, gt, vt) {
            if (!ht)
                throw rt;
            gt = gt || 0;
            for (var yt = this._listeners, wt, mt, _t, bt = yt.length; bt--; )
                if (wt = yt[bt],
                wt.f === ht && wt.c === ft)
                    return !1;
            typeof gt == "function" && (mt = gt,
            gt = vt,
            _t = 4),
            yt.unshift({
                f: ht,
                c: ft,
                p: gt,
                r: mt || ht,
                a: it.call(arguments, _t || 3),
                j: 0
            }),
            ot(yt)
        }
        function lt(ht, ft, gt, vt) {
            if (!ht)
                throw rt;
            var yt = this
              , wt = function() {
                return yt.remove.call(yt, ht, ft),
                ht.apply(ft, it.call(arguments, 0))
            };
            vt = it.call(arguments, 0),
            vt.length === 1 && vt.push($),
            vt.splice(2, 0, wt),
            st.apply(yt, vt)
        }
        function ut(ht, ft) {
            if (!ht)
                return this._listeners.length = 0,
                !0;
            for (var gt = this._listeners, vt, yt = gt.length; yt--; )
                if (vt = gt[yt],
                vt.f === ht && (!ft || vt.c === ft))
                    return vt.j = 0,
                    gt.splice(yt, 1),
                    !0;
            return !1
        }
        function ct(ht) {
            ht = it.call(arguments, 0),
            this.dispatchCount++;
            for (var ft = this.dispatchCount, gt = this._listeners, vt, yt, wt = gt.length; wt--; )
                if (vt = gt[wt],
                vt && vt.j < ft && (vt.j = ft,
                vt.r.apply(vt.c, vt.a.concat(ht)) === !1)) {
                    yt = vt;
                    break
                }
            for (gt = this._listeners,
            wt = gt.length; wt--; )
                gt[wt].j = 0;
            return yt
        }
        et.exports = tt
    }
    )()
}
)(minSignal$1);
var MinSignal$2 = minSignal$1.exports
  , quickLoader$a = {
    exports: {}
}
  , minSignal = {
    exports: {}
};
(function(et) {
    (function($) {
        function tt() {
            this._listeners = [],
            this.dispatchCount = 0
        }
        var nt = tt.prototype;
        nt.add = st,
        nt.addOnce = lt,
        nt.remove = ut,
        nt.dispatch = ct;
        var rt = "Callback function is missing!"
          , it = Array.prototype.slice;
        function ot(ht) {
            ht.sort(function(ft, gt) {
                return ft = ft.p,
                gt = gt.p,
                gt < ft ? 1 : ft > gt ? -1 : 0
            })
        }
        function st(ht, ft, gt, vt) {
            if (!ht)
                throw rt;
            gt = gt || 0;
            for (var yt = this._listeners, wt, mt, _t, bt = yt.length; bt--; )
                if (wt = yt[bt],
                wt.f === ht && wt.c === ft)
                    return !1;
            typeof gt == "function" && (mt = gt,
            gt = vt,
            _t = 4),
            yt.unshift({
                f: ht,
                c: ft,
                p: gt,
                r: mt || ht,
                a: it.call(arguments, _t || 3),
                j: 0
            }),
            ot(yt)
        }
        function lt(ht, ft, gt, vt) {
            if (!ht)
                throw rt;
            var yt = this
              , wt = function() {
                return yt.remove.call(yt, ht, ft),
                ht.apply(ft, it.call(arguments, 0))
            };
            vt = it.call(arguments, 0),
            vt.length === 1 && vt.push($),
            vt.splice(2, 0, wt),
            st.apply(yt, vt)
        }
        function ut(ht, ft) {
            if (!ht)
                return this._listeners.length = 0,
                !0;
            for (var gt = this._listeners, vt, yt = gt.length; yt--; )
                if (vt = gt[yt],
                vt.f === ht && (!ft || vt.c === ft))
                    return vt.j = 0,
                    gt.splice(yt, 1),
                    !0;
            return !1
        }
        function ct(ht) {
            ht = it.call(arguments, 0),
            this.dispatchCount++;
            for (var ft = this.dispatchCount, gt = this._listeners, vt, yt, wt = gt.length; wt--; )
                if (vt = gt[wt],
                vt && vt.j < ft && (vt.j = ft,
                vt.r.apply(vt.c, vt.a.concat(ht)) === !1)) {
                    yt = vt;
                    break
                }
            for (gt = this._listeners,
            wt = gt.length; wt--; )
                gt[wt].j = 0;
            return yt
        }
        et.exports = tt
    }
    )()
}
)(minSignal);
var MinSignal$1 = minSignal.exports, undef$3;
function QuickLoader() {
    this.isLoading = !1,
    this.totalWeight = 0,
    this.loadedWeight = 0,
    this.itemUrls = {},
    this.itemList = [],
    this.loadingSignal = new MinSignal$1,
    this.crossOriginMap = {},
    this.queue = [],
    this.activeItems = [],
    this.maxActiveItems = 4
}
var _p$9 = QuickLoader.prototype;
_p$9.addChunk = addChunk;
_p$9.setCrossOrigin = setCrossOrigin;
_p$9.add = add;
_p$9.load = load$7;
_p$9.start = start;
_p$9.loadNext = loadNext;
_p$9._createItem = _createItem;
_p$9._onLoading = _onLoading$1;
_p$9.VERSION = "0.1.17";
_p$9.register = register;
_p$9.retrieveAll = retrieveAll;
_p$9.retrieve = retrieve;
_p$9.testExtensions = testExtensions;
_p$9.create = create$2;
_p$9.check = check;
var addedItems = _p$9.addedItems = {}
  , loadedItems = _p$9.loadedItems = {}
  , ITEM_CLASS_LIST = _p$9.ITEM_CLASS_LIST = []
  , ITEM_CLASSES = _p$9.ITEM_CLASSES = {};
quickLoader$a.exports = create$2();
function setCrossOrigin(et, $) {
    this.crossOriginMap[et] = $
}
function addChunk(et, $) {
    var tt, nt, rt, it, ot, st = retrieveAll(et, $);
    for (tt = 0,
    rt = st.length; tt < rt; tt++)
        for (ot = st[tt],
        nt = 0,
        it = ot.items.length; nt < it; nt++)
            this.add(ot.items[nt], {
                type: ot.type
            });
    return st
}
function add(et, $) {
    var tt = addedItems[et];
    return tt || (tt = this._createItem(et, $ && $.type ? $.type : retrieve(et).type, $)),
    $ && $.onLoad && tt.onLoaded.addOnce($.onLoad),
    this.itemUrls[et] || (this.itemUrls[et] = tt,
    this.itemList.push(tt),
    this.totalWeight += tt.weight),
    tt
}
function load$7(et, $) {
    var tt = addedItems[et];
    return tt || (tt = this._createItem(et, $ && $.type ? $.type : retrieve(et).type, $)),
    $ && $.onLoad && tt.onLoaded.addOnce($.onLoad),
    loadedItems[et] ? tt.dispatch() : tt.isStartLoaded || tt.load(),
    tt
}
function start(et) {
    et && this.loadingSignal.add(et),
    this.isLoading = !0;
    var $ = this.itemList.length;
    if ($) {
        var tt = this.itemList.splice(0, this.itemList.length), nt;
        for (var rt in this.itemUrls)
            delete this.itemUrls[rt];
        for (var it = 0; it < $; it++) {
            nt = tt[it];
            var ot = !!loadedItems[nt.url];
            nt.onLoaded.addOnce(_onItemLoad, this, -1024, nt, tt, ot),
            nt.hasLoading && nt.loadingSignal.add(_onLoading$1, this, -1024, nt, tt, undef$3),
            ot ? nt.dispatch(_onItemLoad) : nt.isStartLoaded || this.queue.push(nt)
        }
        this.queue.length && this.loadNext()
    } else
        _onItemLoad.call(this, undef$3, this.itemList)
}
function loadNext() {
    if (this.queue.length && this.activeItems.length < this.maxActiveItems) {
        var et = this.queue.shift();
        this.activeItems.push(et),
        this.loadNext(),
        et.load()
    }
}
function _onLoading$1(et, $, tt, nt, rt) {
    et && !et.isLoaded && et.getCombinedPercent(nt) === 1 || (rt === undef$3 && (this.loadedWeight = _getLoadedWeight($),
    rt = this.loadedWeight / this.totalWeight),
    tt = tt || this.loadingSignal,
    tt.dispatch(rt, et))
}
function _getLoadedWeight(et) {
    for (var $ = 0, tt = 0, nt = et.length; tt < nt; tt++)
        $ += et[tt].loadedWeight;
    return $
}
function _onItemLoad(et, $, tt) {
    if (this.loadedWeight = _getLoadedWeight($),
    !tt) {
        for (var nt = this.activeItems, rt = nt.length; rt--; )
            if (nt[rt] === et) {
                nt.splice(rt, 1);
                break
            }
    }
    var it = this.loadingSignal;
    this.loadedWeight === this.totalWeight ? (this.isLoading = !1,
    this.loadedWeight = 0,
    this.totalWeight = 0,
    this.loadingSignal = new MinSignal$1,
    this._onLoading(et, $, it, 1, 1),
    et && et.noCache && _removeItemCache(et)) : (this._onLoading(et, $, it, 1, this.loadedWeight / this.totalWeight),
    et && et.noCache && _removeItemCache(et),
    tt || this.loadNext())
}
function _removeItemCache(et) {
    var $ = et.url;
    et.content = undef$3,
    addedItems[$] = undef$3,
    loadedItems[$] = undef$3
}
function _createItem(et, $, tt) {
    if (tt = tt || {},
    !tt.crossOrigin) {
        for (var nt in this.crossOriginMap)
            if (et.indexOf(nt) === 0) {
                tt.crossOrigin = this.crossOriginMap[nt];
                break
            }
    }
    return new ITEM_CLASSES[$](et,tt)
}
function register(et) {
    ITEM_CLASSES[et.type] || (ITEM_CLASS_LIST.push(et),
    ITEM_CLASSES[et.type] = et)
}
function retrieveAll(et, $) {
    var tt, nt, rt = et.length, it = [];
    if (rt && typeof et != "string")
        for (tt = 0; tt < rt; tt++)
            nt = retrieve(et[tt], $),
            nt && (it = it.concat(nt));
    else
        nt = retrieve(et, $),
        nt && (it = it.concat(nt));
    return it
}
function retrieve(et, $) {
    var tt, nt, rt, it, ot;
    if ($)
        it = ITEM_CLASSES[$],
        rt = it.retrieve(et);
    else
        for (tt = 0,
        nt = ITEM_CLASS_LIST.length; tt < nt; tt++) {
            if (it = ITEM_CLASS_LIST[tt],
            ot = it.type,
            typeof et == "string") {
                if (testExtensions(et, it)) {
                    rt = [et];
                    break
                }
            } else if (rt = it.retrieve(et),
            rt && rt.length && typeof rt[0] == "string" && testExtensions(rt[0], it))
                break;
            rt = undef$3,
            ot = undef$3
        }
    if (rt)
        return {
            type: $ || ot,
            items: rt
        }
}
function testExtensions(et, $) {
    if (!!et) {
        for (var tt = _getExtension(et), nt = $.extensions, rt = nt.length; rt--; )
            if (tt === nt[rt])
                return !0;
        return !1
    }
}
function _getExtension(et) {
    return et.split(".").pop().split(/#|\?/)[0]
}
function create$2() {
    return new QuickLoader
}
function check() {
    var et = []
      , $ = [];
    for (var tt in addedItems)
        et.push(tt),
        loadedItems[tt] || $.push(addedItems[tt]);
    console.log({
        added: et,
        notLoaded: $
    })
}
var MinSignal = minSignal.exports
  , quickLoader$9 = quickLoader$a.exports;
function AbstractItem$6(et, $) {
    if (!!et) {
        this.url = et,
        this.loadedWeight = 0,
        this.weight = 1,
        this.postPercent = 0;
        for (var tt in $)
            this[tt] = $[tt];
        this.type || (this.type = this.constructor.type),
        this.hasLoading && (this.loadingSignal = new MinSignal,
        this.loadingSignal.add(_onLoading, this),
        this.onLoading && this.loadingSignal.add(this.onLoading)),
        this.onPost ? (this.onPostLoadingSignal = new MinSignal,
        this.onPostLoadingSignal.add(this._onPostLoading, this),
        this.postWeightRatio = this.postWeightRatio || .1) : this.postWeightRatio = 0;
        var nt = this;
        this.boundOnLoad = function() {
            nt._onLoad()
        }
        ,
        this.onLoaded = new MinSignal,
        quickLoader$9.addedItems[et] = this
    }
}
var AbstractItem_1 = AbstractItem$6
  , _p$8 = AbstractItem$6.prototype;
_p$8.load = load$6;
_p$8._onLoad = _onLoad$6;
_p$8._onLoading = _onLoading;
_p$8._onPostLoading = _onPostLoading;
_p$8._onLoadComplete = _onLoadComplete;
_p$8.getCombinedPercent = getCombinedPercent;
_p$8.dispatch = dispatch;
AbstractItem$6.extensions = [];
AbstractItem$6.retrieve = function() {
    return !1
}
;
function load$6() {
    this.isStartLoaded = !0
}
function _onLoad$6() {
    this.onPost ? this.onPost.call(this, this.content, this.onPostLoadingSignal) : this._onLoadComplete()
}
function _onPostLoading(et) {
    this.postPercent = et,
    this.hasLoading && this.loadingSignal.dispatch(1),
    et === 1 && this._onLoadComplete()
}
function _onLoadComplete() {
    this.isLoaded = !0,
    this.loadedWeight = this.weight,
    quickLoader$9.loadedItems[this.url] = this,
    this.onLoaded.dispatch(this.content)
}
function getCombinedPercent(et) {
    return et * (1 - this.postWeightRatio) + this.postWeightRatio * this.postPercent
}
function _onLoading(et) {
    this.loadedWeight = this.weight * this.getCombinedPercent(et)
}
function dispatch() {
    this.hasLoading && this.loadingSignal.remove(),
    this.onLoaded.dispatch(this.content)
}
var AbstractItem$5 = AbstractItem_1
  , quickLoader$8 = quickLoader$a.exports;
function __generateFuncName() {
    return "_jsonp" + new Date().getTime() + ~~(Math.random() * 1e8)
}
function JSONPItem(et) {
    !et || _super$7.constructor.apply(this, arguments)
}
JSONPItem.type = "jsonp";
JSONPItem.extensions = [];
quickLoader$8.register(JSONPItem);
JSONPItem.retrieve = function(et) {
    return typeof et == "string" && et.indexOf("=") > -1 ? [et] : !1
}
;
var _super$7 = AbstractItem$5.prototype
  , _p$7 = JSONPItem.prototype = new AbstractItem$5;
_p$7.constructor = JSONPItem;
_p$7.load = load$5;
function load$5(et) {
    _super$7.load.apply(this, arguments);
    var $ = this
      , tt = this.url.lastIndexOf("=") + 1
      , nt = this.url.substr(0, tt)
      , rt = this.url.substr(tt);
    rt.length === 0 ? (rt = __generateFuncName(),
    this.jsonpCallback = et) : this.jsonpCallback = this.jsonpCallback || window[rt],
    window[rt] = function(ot) {
        it.parentNode && it.parentNode.removeChild(it),
        $.content = ot,
        $._onLoad()
    }
    ;
    var it = document.createElement("script");
    it.type = "text/javascript",
    it.src = nt + rt,
    document.getElementsByTagName("head")[0].appendChild(it)
}
var AbstractItem$4 = AbstractItem_1, quickLoader$7 = quickLoader$a.exports, undef$2, IS_SUPPORT_XML_HTTP_REQUEST = !!window.XMLHttpRequest;
function XHRItem$2(et) {
    !et || (_super$6.constructor.apply(this, arguments),
    this.responseType = this.responseType || "",
    this.method = this.method || "GET")
}
var XHRItem_1 = XHRItem$2;
XHRItem$2.type = "xhr";
XHRItem$2.extensions = [];
quickLoader$7.register(XHRItem$2);
XHRItem$2.retrieve = function() {
    return !1
}
;
var _super$6 = AbstractItem$4.prototype
  , _p$6 = XHRItem$2.prototype = new AbstractItem$4;
_p$6.constructor = XHRItem$2;
_p$6.load = load$4;
_p$6._onXmlHttpChange = _onXmlHttpChange;
_p$6._onXmlHttpProgress = _onXmlHttpProgress;
_p$6._onLoad = _onLoad$5;
function load$4() {
    _super$6.load.apply(this, arguments);
    var et = this, $;
    IS_SUPPORT_XML_HTTP_REQUEST ? $ = this.xmlhttp = new XMLHttpRequest : $ = this.xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"),
    this.hasLoading && ($.onprogress = function(tt) {
        et._onXmlHttpProgress(tt)
    }
    ),
    $.onreadystatechange = function() {
        et._onXmlHttpChange()
    }
    ,
    $.open(this.method, this.url, !0),
    this.xmlhttp.responseType = this.responseType,
    IS_SUPPORT_XML_HTTP_REQUEST ? $.send(null) : $.send()
}
function _onXmlHttpProgress(et) {
    this.loadingSignal.dispatch(et.loaded / et.total)
}
function _onXmlHttpChange() {
    this.xmlhttp.readyState === 4 && this.xmlhttp.status === 200 && this._onLoad(this.xmlhttp)
}
function _onLoad$5() {
    this.content || (this.content = this.xmlhttp.response),
    this.xmlhttp = undef$2,
    _super$6._onLoad.call(this)
}
var XHRItem$1 = XHRItem_1
  , quickLoader$6 = quickLoader$a.exports;
function TextItem$1(et, $) {
    !et || ($.responseType = "text",
    _super$5.constructor.apply(this, arguments))
}
var TextItem_1 = TextItem$1;
TextItem$1.type = "text";
TextItem$1.extensions = ["html", "txt", "svg"];
quickLoader$6.register(TextItem$1);
TextItem$1.retrieve = function() {
    return !1
}
;
var _super$5 = XHRItem$1.prototype
  , _p$5 = TextItem$1.prototype = new XHRItem$1;
_p$5.constructor = TextItem$1;
_p$5._onLoad = _onLoad$4;
function _onLoad$4() {
    this.content || (this.content = this.xmlhttp.responseText),
    _super$5._onLoad.apply(this, arguments)
}
var TextItem = TextItem_1
  , quickLoader$5 = quickLoader$a.exports;
function JSONItem(et) {
    !et || _super$4.constructor.apply(this, arguments)
}
JSONItem.type = "json";
JSONItem.extensions = ["json"];
quickLoader$5.register(JSONItem);
JSONItem.retrieve = function() {
    return !1
}
;
var _super$4 = TextItem.prototype
  , _p$4 = JSONItem.prototype = new TextItem;
_p$4.constructor = JSONItem;
_p$4._onLoad = _onLoad$3;
function _onLoad$3() {
    this.content || (this.content = window.JSON && window.JSON.parse ? JSON.parse(this.xmlhttp.responseText.toString()) : eval(this.xmlhttp.responseText.toString())),
    _super$4._onLoad.call(this)
}
var AbstractItem$3 = AbstractItem_1, quickLoader$4 = quickLoader$a.exports, undef$1;
function AudioItem(et, $) {
    if (!!et) {
        this.loadThrough = !$ || $.loadThrough === undef$1 ? !0 : $.loadThrough,
        _super$3.constructor.apply(this, arguments);
        try {
            this.content = this.content || new Audio
        } catch {
            this.content = this.content || document.createElement("audio")
        }
        this.crossOrigin && (this.content.crossOrigin = this.crossOrigin)
    }
}
AudioItem.type = "audio";
AudioItem.extensions = ["mp3", "ogg"];
quickLoader$4.register(AudioItem);
AudioItem.retrieve = function(et) {
    return !1
}
;
var _super$3 = AbstractItem$3.prototype
  , _p$3 = AudioItem.prototype = new AbstractItem$3;
_p$3.constructor = AudioItem;
_p$3.load = load$3;
_p$3._onLoad = _onLoad$2;
function load$3() {
    _super$3.load.apply(this, arguments);
    var et = this
      , $ = et.content;
    $.src = this.url,
    this.loadThrough ? $.addEventListener("canplaythrough", this.boundOnLoad, !1) : $.addEventListener("canplay", this.boundOnLoad, !1),
    $.load()
}
function _onLoad$2() {
    this.content.removeEventListener("canplaythrough", this.boundOnLoad, !1),
    this.content.removeEventListener("canplay", this.boundOnLoad, !1),
    !this.isLoaded && _super$3._onLoad.call(this)
}
var AbstractItem$2 = AbstractItem_1, quickLoader$3 = quickLoader$a.exports, undef;
function VideoItem(et, $) {
    if (!!et) {
        this.loadThrough = !$ || $.loadThrough === undef ? !0 : $.loadThrough,
        _super$2.constructor.apply(this, arguments);
        try {
            this.content = this.content || new Video
        } catch {
            this.content = this.content || document.createElement("video")
        }
        this.crossOrigin && (this.content.crossOrigin = this.crossOrigin)
    }
}
VideoItem.type = "video";
VideoItem.extensions = ["mp4", "webm", "ogv"];
quickLoader$3.register(VideoItem);
VideoItem.retrieve = function(et) {
    return !1
}
;
var _super$2 = AbstractItem$2.prototype
  , _p$2 = VideoItem.prototype = new AbstractItem$2;
_p$2.constructor = VideoItem;
_p$2.load = load$2;
_p$2._onLoad = _onLoad$1;
function load$2() {
    _super$2.load.apply(this, arguments);
    var et = this.content;
    et.preload = "auto",
    et.src = this.url,
    this.loadThrough ? et.addEventListener("canplaythrough", this.boundOnLoad, !1) : et.addEventListener("canplay", this.boundOnLoad, !1),
    et.load()
}
function _onLoad$1() {
    this.content.removeEventListener("canplaythrough", this.boundOnLoad),
    this.content.removeEventListener("canplay", this.boundOnLoad),
    !this.isLoaded && _super$2._onLoad.call(this)
}
var AbstractItem$1 = AbstractItem_1
  , quickLoader$2 = quickLoader$a.exports;
function AnyItem$2(et, $) {
    !et || (_super$1.constructor.call(this, et, $),
    !this.loadFunc && console && console[console.error || console.log]("require loadFunc in the config object."))
}
AnyItem$2.type = "any";
AnyItem$2.extensions = [];
quickLoader$2.register(AnyItem$2);
AnyItem$2.retrieve = function() {
    return !1
}
;
var _super$1 = AbstractItem$1.prototype
  , _p$1 = AnyItem$2.prototype = new AbstractItem$1;
_p$1.constructor = AnyItem$2;
_p$1.load = load$1;
function load$1() {
    var et = this;
    this.loadFunc(this.url, function($) {
        et.content = $,
        _super$1._onLoad.call(et)
    }, this.loadingSignal)
}
function computedStyle$1(et, $, tt, nt) {
    if (tt = window.getComputedStyle,
    nt = tt ? tt(et) : et.currentStyle,
    nt)
        return nt[$.replace(/-(\w)/gi, function(rt, it) {
            return it.toUpperCase()
        })]
}
var computedStyle_commonjs = computedStyle$1
  , AbstractItem = AbstractItem_1
  , computedStyle = computedStyle_commonjs
  , quickLoader$1 = quickLoader$a.exports;
function ImageItem$1(et, $) {
    !et || (_super.constructor.apply(this, arguments),
    this.content = this.content || new Image,
    this.crossOrigin && (this.content.crossOrigin = this.crossOrigin))
}
var _super = AbstractItem.prototype
  , _p = ImageItem$1.prototype = new AbstractItem;
_p.constructor = ImageItem$1;
_p.load = load;
_p._onLoad = _onLoad;
ImageItem$1.retrieve = function(et) {
    if (et.nodeType && et.style) {
        var $ = [];
        et.nodeName.toLowerCase() === "img" && et.src.indexOf(";") < 0 && $.push(et.src),
        computedStyle(et, "background-image").replace(/s?url\(\s*?['"]?([^;]*?)['"]?\s*?\)/g, function(nt, rt) {
            $.push(rt)
        });
        for (var tt = $.length; tt--; )
            _isNotData($[tt]) || $.splice(tt, 1);
        return $.length ? $ : !1
    } else
        return typeof et == "string" ? [et] : !1
}
;
ImageItem$1.type = "image";
ImageItem$1.extensions = ["jpg", "gif", "png"];
quickLoader$1.register(ImageItem$1);
function load() {
    _super.load.apply(this, arguments);
    var et = this.content;
    et.onload = this.boundOnLoad,
    et.src = this.url
}
function _onLoad() {
    delete this.content.onload,
    this.width = this.content.width,
    this.height = this.content.height,
    _super._onLoad.call(this)
}
function _isNotData(et) {
    return et.indexOf("data:") !== 0
}
var quickLoader = quickLoader$a.exports;
class Properties {
    constructor() {
        Et(this, "isSecureConnection", window.location.protocol === "https:");
        Et(this, "tabInFocus", !0);
        Et(this, "loader", quickLoader.create());
        Et(this, "percent", -1);
        Et(this, "percentActive", 0);
        Et(this, "_isSupportedDevice", !1);
        Et(this, "_isSupportedBrowser", !1);
        Et(this, "_isSupportedWebGL", !1);
        Et(this, "_isSupportedMobileOrientation", !1);
        Et(this, "_isSupported", !1);
        Et(this, "time", 0);
        Et(this, "deltaTime", 0);
        Et(this, "isStageReady", !1);
        Et(this, "hasInitialized", !1);
        Et(this, "rawWidth", 0);
        Et(this, "rawHeight", 0);
        Et(this, "width", 0);
        Et(this, "height", 0);
        Et(this, "renderer", null);
        Et(this, "scene", null);
        Et(this, "camera", null);
        Et(this, "postprocessing", null);
        Et(this, "resolution", null);
        Et(this, "canvas", null);
        Et(this, "gl", null);
        Et(this, "webglOpts", {
            antialias: !1,
            alpha: !1,
            xrCompatible: !0
        });
        Et(this, "sharedUniforms", {
            u_time: {
                value: 0
            },
            u_deltaTime: {
                value: 1
            },
            u_resolution: {
                value: null
            },
            u_bgColor: {
                value: null
            }
        });
        Et(this, "changeCamera", new MinSignal$2);
        Et(this, "cameraDefaultPosition", new Vector3(0,0,5));
        Et(this, "cameraLookX", 0);
        Et(this, "cameraLookY", 0);
        Et(this, "cameraDistance", 5);
        Et(this, "cameraLookStrength", 0);
        Et(this, "cameraLookEaseDamp", 0);
        Et(this, "cameraShakePositionStrength", .2);
        Et(this, "cameraShakePositionSpeed", .12);
        Et(this, "cameraShakeRotationStrength", .0016);
        Et(this, "cameraShakeRotationSpeed", .3);
        Et(this, "cameraDollyZoomFovOffset", 0);
        Et(this, "smaa", null);
        Et(this, "fxaa", null);
        Et(this, "cameraMotionBlur", null);
        Et(this, "gtao", null);
        Et(this, "bokeh", null);
        Et(this, "bloom", null);
        Et(this, "screenPaint", null);
        Et(this, "screenPaintDistortion", null);
        Et(this, "final", null);
        Et(this, "bgColorHex", "#000000");
        Et(this, "bgColor", new Color);
        Et(this, "opacity", 1);
        Et(this, "bloomAmount", 0 * .959);
        Et(this, "bloomRadius", .508);
        Et(this, "bloomThreshold", .158);
        Et(this, "bloomSmoothWidth", .141);
        Et(this, "haloWidth", .538);
        Et(this, "haloRGBShift", .049);
        Et(this, "haloStrength", .278);
        Et(this, "haloMaskInner", .18);
        Et(this, "haloMaskOuter", 0);
        Et(this, "vignetteFrom", 0);
        Et(this, "vignetteTo", 3);
        Et(this, "vignetteColorHex", "#ffffff");
        Et(this, "saturation", 1);
        Et(this, "contrast", -.011);
        Et(this, "brightness", .94);
        Et(this, "postInvert", 0);
        Et(this, "tintColorHex", "#25252b");
        Et(this, "tintOpacity", 0);
        Et(this, "bokehAmount", 0);
        Et(this, "bokehFNumber", .181);
        Et(this, "bokehFocusDistance", 2.5);
        Et(this, "bokehFocalLength", .35);
        Et(this, "bokehKFilmHeight", 25.26);
        Et(this, "screenPaintNeedsMouseDown", !1);
        Et(this, "screenPaintMinRadius", 0);
        Et(this, "screenPaintMaxRadius", 100);
        Et(this, "screenPaintRadiusDistanceRange", 100);
        Et(this, "screenPaintPushStrength", 25);
        Et(this, "screenPaintVelocityDissipation", .975);
        Et(this, "screenPaintWeight1Dissipation", .95);
        Et(this, "screenPaintWeight2Dissipation", .8);
        Et(this, "screenPaintUseNoise", !0);
        Et(this, "screenPaintCurlScale", .03);
        Et(this, "screenPaintCurlStrength", 3);
        Et(this, "screenPaintDistortionAmount", 20);
        Et(this, "screenPaintDistortionRGBShift", .5);
        Et(this, "screenPaintDistortionColorMultiplier", 10);
        Et(this, "screenPaintDistortionMultiplier", 5);
        Et(this, "upscalerSharpness", 1);
        Et(this, "particleMode", 0);
        Et(this, "particleModeRatio", 0);
        Et(this, "particlePresets", [{
            simDieSpeed: .32,
            curlStrMul: .6,
            windStrMul: 1.2
        }, {
            simDieSpeed: .48,
            curlStrMul: .6,
            windStrMul: 1.2
        }]);
        Et(this, "onFirstClicked", new MinSignal$2);
        Et(this, "onPageChanged", new MinSignal$2);
        Et(this, "activePageIndex", null);
        Et(this, "isPreloaderFinished", !1);
        Et(this, "themeSignal", new MinSignal$2);
        Et(this, "orbitControls", null);
        Et(this, "pointer", new Vector2);
        Et(this, "screenPaint", null);
        Et(this, "themeId", 0);
        Et(this, "prevThemeId", 0);
        Et(this, "themeTransitionRatio", 0);
        Et(this, "isThemeTransitionActive", !1);
        Et(this, "uiLoops", new Map);
        Et(this, "infiniteGridSignalStart", new MinSignal$2);
        Et(this, "infiniteGridSignalEnd", new MinSignal$2);
        Et(this, "infiniteGridSignalOnVisibilityEnd", new MinSignal$2)
    }
}

const properties = new Properties;
settings.IS_DEV && (window.properties = properties);
const useAnimationFrame = et=>{
    react.exports.useEffect(()=>{
        const $ = Math.random();
        return properties.uiLoops.set($, et),
        ()=>properties.uiLoops.delete($)
    }
    , [et])
}
  , RECOGNITIONS = {
    WEBBY: "WEBBY",
    AWWWARDS_SOTD: "SOTD awwwards",
    AWWWARDS_SOTM: "SOTM awwwards",
    AWWWARDS_SOTY: "SOTY awwwards",
    AWWWARDS_DEV: "Dev awwwards",
    AWWWARDS_HM: "HM awwwards",
    AWWWARDS_MOBILE: "Mobile Excellence awwwards",
    FWA_FOTD: "FOTD FWA",
    FWA_FOTM: "FOTM FWA",
    FWA_FOTY: "FOTY FWA",
    FWA_PCA: "People's Choice FWA"
}
  , CATEGORIES = {
    ALL: {
        id: 1,
        label: "All"
    },
    EXP: {
        id: 2,
        label: "Experiment"
    },
    GAME: {
        id: 3,
        label: "Game"
    },
    INSTALLATION: {
        id: 4,
        label: "Installation"
    },
    WEB: {
        id: 5,
        label: "Web"
    },
    TOOLS: {
        id: 6,
        label: "Tools"
    },
    CONFIGURATOR: {
        id: 7,
        label: "Configurator"
    }
};
function n$3(et) {
    for (var $ = arguments.length, tt = Array($ > 1 ? $ - 1 : 0), nt = 1; nt < $; nt++)
        tt[nt - 1] = arguments[nt];
    throw Error("[Immer] minified error nr: " + et + (tt.length ? " " + tt.map(function(rt) {
        return "'" + rt + "'"
    }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf")
}
function r$2(et) {
    return !!et && !!et[Q]
}
function t$3(et) {
    return !!et && (function($) {
        if (!$ || typeof $ != "object")
            return !1;
        var tt = Object.getPrototypeOf($);
        if (tt === null)
            return !0;
        var nt = Object.hasOwnProperty.call(tt, "constructor") && tt.constructor;
        return nt === Object || typeof nt == "function" && Function.toString.call(nt) === Z
    }(et) || Array.isArray(et) || !!et[L] || !!et.constructor[L] || s$1(et) || v$2(et))
}
function i(et, $, tt) {
    tt === void 0 && (tt = !1),
    o$1(et) === 0 ? (tt ? Object.keys : nn)(et).forEach(function(nt) {
        tt && typeof nt == "symbol" || $(nt, et[nt], et)
    }) : et.forEach(function(nt, rt) {
        return $(rt, nt, et)
    })
}
function o$1(et) {
    var $ = et[Q];
    return $ ? $.i > 3 ? $.i - 4 : $.i : Array.isArray(et) ? 1 : s$1(et) ? 2 : v$2(et) ? 3 : 0
}
function u$3(et, $) {
    return o$1(et) === 2 ? et.has($) : Object.prototype.hasOwnProperty.call(et, $)
}
function a(et, $) {
    return o$1(et) === 2 ? et.get($) : et[$]
}
function f$1(et, $, tt) {
    var nt = o$1(et);
    nt === 2 ? et.set($, tt) : nt === 3 ? (et.delete($),
    et.add(tt)) : et[$] = tt
}
function c$1(et, $) {
    return et === $ ? et !== 0 || 1 / et == 1 / $ : et != et && $ != $
}
function s$1(et) {
    return X && et instanceof Map
}
function v$2(et) {
    return q$3 && et instanceof Set
}
function p$3(et) {
    return et.o || et.t
}
function l$2(et) {
    if (Array.isArray(et))
        return Array.prototype.slice.call(et);
    var $ = rn(et);
    delete $[Q];
    for (var tt = nn($), nt = 0; nt < tt.length; nt++) {
        var rt = tt[nt]
          , it = $[rt];
        it.writable === !1 && (it.writable = !0,
        it.configurable = !0),
        (it.get || it.set) && ($[rt] = {
            configurable: !0,
            writable: !0,
            enumerable: it.enumerable,
            value: et[rt]
        })
    }
    return Object.create(Object.getPrototypeOf(et), $)
}
function d$2(et, $) {
    return $ === void 0 && ($ = !1),
    y$1(et) || r$2(et) || !t$3(et) || (o$1(et) > 1 && (et.set = et.add = et.clear = et.delete = h$4),
    Object.freeze(et),
    $ && i(et, function(tt, nt) {
        return d$2(nt, !0)
    }, !0)),
    et
}
function h$4() {
    n$3(2)
}
function y$1(et) {
    return et == null || typeof et != "object" || Object.isFrozen(et)
}
function b$1(et) {
    var $ = tn[et];
    return $ || n$3(18, et),
    $
}
function _() {
    return U
}
function j(et, $) {
    $ && (b$1("Patches"),
    et.u = [],
    et.s = [],
    et.v = $)
}
function O(et) {
    g$1(et),
    et.p.forEach(S),
    et.p = null
}
function g$1(et) {
    et === U && (U = et.l)
}
function w$1(et) {
    return U = {
        p: [],
        l: U,
        h: et,
        m: !0,
        _: 0
    }
}
function S(et) {
    var $ = et[Q];
    $.i === 0 || $.i === 1 ? $.j() : $.O = !0
}
function P(et, $) {
    $._ = $.p.length;
    var tt = $.p[0]
      , nt = et !== void 0 && et !== tt;
    return $.h.g || b$1("ES5").S($, et, nt),
    nt ? (tt[Q].P && (O($),
    n$3(4)),
    t$3(et) && (et = M($, et),
    $.l || x($, et)),
    $.u && b$1("Patches").M(tt[Q].t, et, $.u, $.s)) : et = M($, tt, []),
    O($),
    $.u && $.v($.u, $.s),
    et !== H ? et : void 0
}
function M(et, $, tt) {
    if (y$1($))
        return $;
    var nt = $[Q];
    if (!nt)
        return i($, function(it, ot) {
            return A(et, nt, $, it, ot, tt)
        }, !0),
        $;
    if (nt.A !== et)
        return $;
    if (!nt.P)
        return x(et, nt.t, !0),
        nt.t;
    if (!nt.I) {
        nt.I = !0,
        nt.A._--;
        var rt = nt.i === 4 || nt.i === 5 ? nt.o = l$2(nt.k) : nt.o;
        i(nt.i === 3 ? new Set(rt) : rt, function(it, ot) {
            return A(et, nt, rt, it, ot, tt)
        }),
        x(et, rt, !1),
        tt && et.u && b$1("Patches").R(nt, tt, et.u, et.s)
    }
    return nt.o
}
function A(et, $, tt, nt, rt, it) {
    if (r$2(rt)) {
        var ot = M(et, rt, it && $ && $.i !== 3 && !u$3($.D, nt) ? it.concat(nt) : void 0);
        if (f$1(tt, nt, ot),
        !r$2(ot))
            return;
        et.m = !1
    }
    if (t$3(rt) && !y$1(rt)) {
        if (!et.h.F && et._ < 1)
            return;
        M(et, rt),
        $ && $.A.l || x(et, rt)
    }
}
function x(et, $, tt) {
    tt === void 0 && (tt = !1),
    et.h.F && et.m && d$2($, tt)
}
function z(et, $) {
    var tt = et[Q];
    return (tt ? p$3(tt) : et)[$]
}
function I(et, $) {
    if ($ in et)
        for (var tt = Object.getPrototypeOf(et); tt; ) {
            var nt = Object.getOwnPropertyDescriptor(tt, $);
            if (nt)
                return nt;
            tt = Object.getPrototypeOf(tt)
        }
}
function k$2(et) {
    et.P || (et.P = !0,
    et.l && k$2(et.l))
}
function E(et) {
    et.o || (et.o = l$2(et.t))
}
function R(et, $, tt) {
    var nt = s$1($) ? b$1("MapSet").N($, tt) : v$2($) ? b$1("MapSet").T($, tt) : et.g ? function(rt, it) {
        var ot = Array.isArray(rt)
          , st = {
            i: ot ? 1 : 0,
            A: it ? it.A : _(),
            P: !1,
            I: !1,
            D: {},
            l: it,
            t: rt,
            k: null,
            o: null,
            j: null,
            C: !1
        }
          , lt = st
          , ut = en;
        ot && (lt = [st],
        ut = on);
        var ct = Proxy.revocable(lt, ut)
          , ht = ct.revoke
          , ft = ct.proxy;
        return st.k = ft,
        st.j = ht,
        ft
    }($, tt) : b$1("ES5").J($, tt);
    return (tt ? tt.A : _()).p.push(nt),
    nt
}
function D(et) {
    return r$2(et) || n$3(22, et),
    function $(tt) {
        if (!t$3(tt))
            return tt;
        var nt, rt = tt[Q], it = o$1(tt);
        if (rt) {
            if (!rt.P && (rt.i < 4 || !b$1("ES5").K(rt)))
                return rt.t;
            rt.I = !0,
            nt = F(tt, it),
            rt.I = !1
        } else
            nt = F(tt, it);
        return i(nt, function(ot, st) {
            rt && a(rt.t, ot) === st || f$1(nt, ot, $(st))
        }),
        it === 3 ? new Set(nt) : nt
    }(et)
}
function F(et, $) {
    switch ($) {
    case 2:
        return new Map(et);
    case 3:
        return Array.from(et)
    }
    return l$2(et)
}
var G, U, W = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol", X = typeof Map != "undefined", q$3 = typeof Set != "undefined", B = typeof Proxy != "undefined" && Proxy.revocable !== void 0 && typeof Reflect != "undefined", H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = !0,
G), L = W ? Symbol.for("immer-draftable") : "__$immer_draftable", Q = W ? Symbol.for("immer-state") : "__$immer_state", Z = "" + Object.prototype.constructor, nn = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(et) {
    return Object.getOwnPropertyNames(et).concat(Object.getOwnPropertySymbols(et))
}
: Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(et) {
    var $ = {};
    return nn(et).forEach(function(tt) {
        $[tt] = Object.getOwnPropertyDescriptor(et, tt)
    }),
    $
}
, tn = {}, en = {
    get: function(et, $) {
        if ($ === Q)
            return et;
        var tt = p$3(et);
        if (!u$3(tt, $))
            return function(rt, it, ot) {
                var st, lt = I(it, ot);
                return lt ? "value"in lt ? lt.value : (st = lt.get) === null || st === void 0 ? void 0 : st.call(rt.k) : void 0
            }(et, tt, $);
        var nt = tt[$];
        return et.I || !t$3(nt) ? nt : nt === z(et.t, $) ? (E(et),
        et.o[$] = R(et.A.h, nt, et)) : nt
    },
    has: function(et, $) {
        return $ in p$3(et)
    },
    ownKeys: function(et) {
        return Reflect.ownKeys(p$3(et))
    },
    set: function(et, $, tt) {
        var nt = I(p$3(et), $);
        if (nt != null && nt.set)
            return nt.set.call(et.k, tt),
            !0;
        if (!et.P) {
            var rt = z(p$3(et), $)
              , it = rt == null ? void 0 : rt[Q];
            if (it && it.t === tt)
                return et.o[$] = tt,
                et.D[$] = !1,
                !0;
            if (c$1(tt, rt) && (tt !== void 0 || u$3(et.t, $)))
                return !0;
            E(et),
            k$2(et)
        }
        return et.o[$] === tt && typeof tt != "number" && (tt !== void 0 || $ in et.o) || (et.o[$] = tt,
        et.D[$] = !0,
        !0)
    },
    deleteProperty: function(et, $) {
        return z(et.t, $) !== void 0 || $ in et.t ? (et.D[$] = !1,
        E(et),
        k$2(et)) : delete et.D[$],
        et.o && delete et.o[$],
        !0
    },
    getOwnPropertyDescriptor: function(et, $) {
        var tt = p$3(et)
          , nt = Reflect.getOwnPropertyDescriptor(tt, $);
        return nt && {
            writable: !0,
            configurable: et.i !== 1 || $ !== "length",
            enumerable: nt.enumerable,
            value: tt[$]
        }
    },
    defineProperty: function() {
        n$3(11)
    },
    getPrototypeOf: function(et) {
        return Object.getPrototypeOf(et.t)
    },
    setPrototypeOf: function() {
        n$3(12)
    }
}, on = {};
i(en, function(et, $) {
    on[et] = function() {
        return arguments[0] = arguments[0][0],
        $.apply(this, arguments)
    }
}),
on.deleteProperty = function(et, $) {
    return on.set.call(this, et, $, void 0)
}
,
on.set = function(et, $, tt) {
    return en.set.call(this, et[0], $, tt, et[0])
}
;
var un = function() {
    function et(tt) {
        var nt = this;
        this.g = B,
        this.F = !0,
        this.produce = function(rt, it, ot) {
            if (typeof rt == "function" && typeof it != "function") {
                var st = it;
                it = rt;
                var lt = nt;
                return function(yt) {
                    var wt = this;
                    yt === void 0 && (yt = st);
                    for (var mt = arguments.length, _t = Array(mt > 1 ? mt - 1 : 0), bt = 1; bt < mt; bt++)
                        _t[bt - 1] = arguments[bt];
                    return lt.produce(yt, function(Mt) {
                        var St;
                        return (St = it).call.apply(St, [wt, Mt].concat(_t))
                    })
                }
            }
            var ut;
            if (typeof it != "function" && n$3(6),
            ot !== void 0 && typeof ot != "function" && n$3(7),
            t$3(rt)) {
                var ct = w$1(nt)
                  , ht = R(nt, rt, void 0)
                  , ft = !0;
                try {
                    ut = it(ht),
                    ft = !1
                } finally {
                    ft ? O(ct) : g$1(ct)
                }
                return typeof Promise != "undefined" && ut instanceof Promise ? ut.then(function(yt) {
                    return j(ct, ot),
                    P(yt, ct)
                }, function(yt) {
                    throw O(ct),
                    yt
                }) : (j(ct, ot),
                P(ut, ct))
            }
            if (!rt || typeof rt != "object") {
                if ((ut = it(rt)) === void 0 && (ut = rt),
                ut === H && (ut = void 0),
                nt.F && d$2(ut, !0),
                ot) {
                    var gt = []
                      , vt = [];
                    b$1("Patches").M(rt, ut, gt, vt),
                    ot(gt, vt)
                }
                return ut
            }
            n$3(21, rt)
        }
        ,
        this.produceWithPatches = function(rt, it) {
            if (typeof rt == "function")
                return function(ut) {
                    for (var ct = arguments.length, ht = Array(ct > 1 ? ct - 1 : 0), ft = 1; ft < ct; ft++)
                        ht[ft - 1] = arguments[ft];
                    return nt.produceWithPatches(ut, function(gt) {
                        return rt.apply(void 0, [gt].concat(ht))
                    })
                }
                ;
            var ot, st, lt = nt.produce(rt, it, function(ut, ct) {
                ot = ut,
                st = ct
            });
            return typeof Promise != "undefined" && lt instanceof Promise ? lt.then(function(ut) {
                return [ut, ot, st]
            }) : [lt, ot, st]
        }
        ,
        typeof (tt == null ? void 0 : tt.useProxies) == "boolean" && this.setUseProxies(tt.useProxies),
        typeof (tt == null ? void 0 : tt.autoFreeze) == "boolean" && this.setAutoFreeze(tt.autoFreeze)
    }
    var $ = et.prototype;
    return $.createDraft = function(tt) {
        t$3(tt) || n$3(8),
        r$2(tt) && (tt = D(tt));
        var nt = w$1(this)
          , rt = R(this, tt, void 0);
        return rt[Q].C = !0,
        g$1(nt),
        rt
    }
    ,
    $.finishDraft = function(tt, nt) {
        var rt = tt && tt[Q]
          , it = rt.A;
        return j(it, nt),
        P(void 0, it)
    }
    ,
    $.setAutoFreeze = function(tt) {
        this.F = tt
    }
    ,
    $.setUseProxies = function(tt) {
        tt && !B && n$3(20),
        this.g = tt
    }
    ,
    $.applyPatches = function(tt, nt) {
        var rt;
        for (rt = nt.length - 1; rt >= 0; rt--) {
            var it = nt[rt];
            if (it.path.length === 0 && it.op === "replace") {
                tt = it.value;
                break
            }
        }
        rt > -1 && (nt = nt.slice(rt + 1));
        var ot = b$1("Patches").$;
        return r$2(tt) ? ot(tt, nt) : this.produce(tt, function(st) {
            return ot(st, nt)
        })
    }
    ,
    et
}()
  , an = new un
  , fn = an.produce;
an.produceWithPatches.bind(an);
an.setAutoFreeze.bind(an);
an.setUseProxies.bind(an);
an.applyPatches.bind(an);
an.createDraft.bind(an);
an.finishDraft.bind(an);
var produce = fn;
const createStoreImpl = et=>{
    let $;
    const tt = new Set
      , nt = (lt,ut)=>{
        const ct = typeof lt == "function" ? lt($) : lt;
        if (ct !== $) {
            const ht = $;
            $ = ut ? ct : Object.assign({}, $, ct),
            tt.forEach(ft=>ft($, ht))
        }
    }
      , rt = ()=>$
      , st = {
        setState: nt,
        getState: rt,
        subscribe: lt=>(tt.add(lt),
        ()=>tt.delete(lt)),
        destroy: ()=>tt.clear()
    };
    return $ = et(nt, rt, st),
    st
}
  , createStore = et=>et ? createStoreImpl(et) : createStoreImpl;
var withSelector = {
    exports: {}
}
  , withSelector_production_min = {}
  , shim = {
    exports: {}
}
  , useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$1 = react.exports;
function h$3(et, $) {
    return et === $ && (et !== 0 || 1 / et === 1 / $) || et !== et && $ !== $
}
var k$1 = typeof Object.is == "function" ? Object.is : h$3
  , l$1 = e$1.useState
  , m$2 = e$1.useEffect
  , n$2 = e$1.useLayoutEffect
  , p$2 = e$1.useDebugValue;
function q$2(et, $) {
    var tt = $()
      , nt = l$1({
        inst: {
            value: tt,
            getSnapshot: $
        }
    })
      , rt = nt[0].inst
      , it = nt[1];
    return n$2(function() {
        rt.value = tt,
        rt.getSnapshot = $,
        r$1(rt) && it({
            inst: rt
        })
    }, [et, tt, $]),
    m$2(function() {
        return r$1(rt) && it({
            inst: rt
        }),
        et(function() {
            r$1(rt) && it({
                inst: rt
            })
        })
    }, [et]),
    p$2(tt),
    tt
}
function r$1(et) {
    var $ = et.getSnapshot;
    et = et.value;
    try {
        var tt = $();
        return !k$1(et, tt)
    } catch {
        return !0
    }
}
function t$2(et, $) {
    return $()
}
var u$2 = typeof window == "undefined" || typeof window.document == "undefined" || typeof window.document.createElement == "undefined" ? t$2 : q$2;
useSyncExternalStoreShim_production_min.useSyncExternalStore = e$1.useSyncExternalStore !== void 0 ? e$1.useSyncExternalStore : u$2;
shim.exports = useSyncExternalStoreShim_production_min;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$2 = react.exports
  , n$1 = shim.exports;
function p$1(et, $) {
    return et === $ && (et !== 0 || 1 / et === 1 / $) || et !== et && $ !== $
}
var q$1 = typeof Object.is == "function" ? Object.is : p$1
  , r = n$1.useSyncExternalStore
  , t$1 = h$2.useRef
  , u$1 = h$2.useEffect
  , v$1 = h$2.useMemo
  , w = h$2.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(et, $, tt, nt, rt) {
    var it = t$1(null);
    if (it.current === null) {
        var ot = {
            hasValue: !1,
            value: null
        };
        it.current = ot
    } else
        ot = it.current;
    it = v$1(function() {
        function lt(gt) {
            if (!ut) {
                if (ut = !0,
                ct = gt,
                gt = nt(gt),
                rt !== void 0 && ot.hasValue) {
                    var vt = ot.value;
                    if (rt(vt, gt))
                        return ht = vt
                }
                return ht = gt
            }
            if (vt = ht,
            q$1(ct, gt))
                return vt;
            var yt = nt(gt);
            return rt !== void 0 && rt(vt, yt) ? vt : (ct = gt,
            ht = yt)
        }
        var ut = !1, ct, ht, ft = tt === void 0 ? null : tt;
        return [function() {
            return lt($())
        }
        , ft === null ? void 0 : function() {
            return lt(ft())
        }
        ]
    }, [$, tt, nt, rt]);
    var st = r(et, it[0], it[1]);
    return u$1(function() {
        ot.hasValue = !0,
        ot.value = st
    }, [st]),
    w(st),
    st
}
;
withSelector.exports = withSelector_production_min;
function useStore(et, $=et.getState, tt) {
    const nt = withSelector.exports.useSyncExternalStoreWithSelector(et.subscribe, et.getState, et.getServerState || et.getState, $, tt);
    return react.exports.useDebugValue(nt),
    nt
}
const createImpl = et=>{
    const $ = typeof et == "function" ? createStore(et) : et
      , tt = (nt,rt)=>useStore($, nt, rt);
    return Object.assign(tt, $),
    tt
}
  , create$1 = et=>et ? createImpl(et) : createImpl;
var create$1$1 = create$1;
const EXP_VIEWS = {
    GRID: 1,
    LIST: 2
}
  , THEMES = {
    LIGHT: {
        id: 1,
        color: "#ffffff",
        alt: "W",
        name: "light",
        label: "cotton white"
    },
    DARK: {
        id: 2,
        color: "#000000",
        alt: "B",
        name: "dark",
        label: "coal black"
    }
}
  , immer = et=>($,tt,nt)=>et(rt=>$(produce(rt)), tt, nt)
  , useGlobalStore = create$1$1(immer(()=>({
    width: 0,
    height: 0,
    navbarHeight: 0,
    isLoadingComplete: !1,
    isLoaderAnimationComplete: !1,
    experimentsView: EXP_VIEWS.GRID,
    isListAnimationCompleted: !1,
    isCardAnimationCompleted: !1,
    activeFilter: CATEGORIES.ALL.id,
    currentTheme: THEMES.LIGHT.id,
    hoveredExp: null,
    showSubscribeModal: !1,
    showScrollToTop: !1,
    showContactOverlay: !1,
    showMobileMenuOverlay: !1,
    isCursorHovering: !1,
    isInitialLoad: !0
})));
function updateViewport(et, $) {
    useGlobalStore.setState(tt=>{
        tt.width = et,
        tt.height = $
    }
    ),
    updateGrid(et)
}
const disableScroll = react.exports.createRef(!1)
  , disableAbsScroll = react.exports.createRef(!1)
  , useScrollStore = create$1$1(immer(()=>({
    deltaScroll: 0,
    scroll: 0,
    absScroll: 0
})))
  , resetScrollSignal = new MinSignal$2;
resetScrollSignal.add(()=>{
    useScrollStore.setState(et=>{
        et.deltaScroll = 0,
        et.scroll = 0,
        et.absScroll = 0
    }
    )
}
);
const useInfiniteGrid = create$1$1(immer(()=>({
    isInfinteScrollActive: !1
})))
  , useCardGridInteractions = create$1$1(immer(()=>({
    activeScale: react.exports.createRef(),
    mouse: new Vector2,
    mouseLerped: new Vector2,
    hoveCardId: null
})))
  , {activeScale} = useCardGridInteractions.getState();
activeScale.current = 0;
const useCardGrid = create$1$1(immer(()=>({
    gridMaxWidth: 24,
    gridMaxHeight: 9,
    gridPad: 1,
    gridLayout: {},
    gridCardListLayout: {}
})));
function updateGrid(et) {
    et <= 1024 ? useCardGrid.setState(tt=>{
        tt.gridMaxWidth = 1,
        tt.gridPad = 0,
        tt.gridLayout = {
            gridTemplateColumns: "1fr",
            gridGap: "2rem 1.5rem"
        }
    }
    ) : useCardGrid.setState(tt=>{
        tt.gridMaxWidth = 24,
        tt.gridPad = 1,
        tt.gridLayout = {
            gridTemplateColumns: `repeat(${24}, 1fr)`,
            gridGap: "8vh 1.5rem"
        }
    }
    )
}
const useLogoStore = create$1$1(immer(()=>({
    height: 0,
    top: 0,
    left: 0,
    lucyEmote: "base",
    baseLucyEmote: "base",
    isLucyMode: !1,
    isLucyLooking: !0,
    isLucyFloating: !0,
    isLucyStatePending: !1,
    lucyJump: !1,
    lucyWiggle: !1
})));
function updateLucyEmote$1(et="base", $=!0, tt=!1, nt=!1) {
    const {isLucyMode: rt, baseLucyEmote: it, lucyEmote: ot, isLucyStatePending: st} = useLogoStore.getState();
    if (!rt || !tt && st)
        return;
    tt && (lucyTimeouts.forEach(ut=>{
        clearTimeout(ut)
    }
    ),
    lucyTimeouts = []);
    let lt = et || it;
    lt === "random" && (lt = getRandomHappyEmote()),
    ot !== lt && useLogoStore.setState(ut=>ut.lucyEmote = lt),
    useLogoStore.setState(ut=>ut.isLucyLooking = $),
    nt && useLogoStore.setState(ut=>ut.baseLucyEmote = lt)
}
window.updateLucyEmote = updateLucyEmote$1;
function toggleLucyMode(et) {
    typeof et != "undefined" ? useLogoStore.setState($=>$.isLucyMode = et) : useLogoStore.setState($=>$.isLucyMode = !useLogoStore.getState().isLucyMode)
}
let happyEmotes = ["happy", "curious", "doh"];
function getRandomHappyEmote() {
    return happyEmotes[Math.floor(happyEmotes.length * Math.random())]
}
let lucyTimeouts = [];
function makeLucyJump(et) {
    et || (et = getRandomHappyEmote()),
    lucyTimeouts.length && (lucyTimeouts.forEach($=>{
        clearTimeout($)
    }
    ),
    lucyTimeouts = []),
    useLogoStore.setState($=>{
        $.lucyJump = !0,
        $.lucyEmote = et,
        $.isLucyStatePending = !0
    }
    ),
    lucyTimeouts.push(setTimeout(()=>{
        useLogoStore.setState($=>{
            $.lucyJump = !1
        }
        )
    }
    , 150)),
    lucyTimeouts.push(setTimeout(()=>{
        useLogoStore.setState($=>{
            $.lucyEmote = "base",
            $.isLucyStatePending = !1
        }
        )
    }
    , 5e3))
}
function makeLucyWiggle(et="doh") {
    lucyTimeouts.length && (lucyTimeouts.forEach($=>{
        clearTimeout($)
    }
    ),
    lucyTimeouts = []),
    useLogoStore.setState($=>{
        $.lucyWiggle = !0,
        $.lucyEmote = et,
        $.isLucyStatePending = !0
    }
    ),
    lucyTimeouts.push(setTimeout(()=>{
        useLogoStore.setState($=>{
            $.lucyWiggle = !1
        }
        )
    }
    , 150)),
    lucyTimeouts.push(setTimeout(()=>{
        useLogoStore.setState($=>{
            $.lucyEmote = "base",
            $.isLucyStatePending = !1
        }
        )
    }
    , 5e3))
}
class Ease {
    quadIn($) {
        return $ * $
    }
    quadOut($) {
        return $ * (2 - $)
    }
    quadInOut($) {
        return ($ *= 2) < 1 ? .5 * $ * $ : -.5 * (--$ * ($ - 2) - 1)
    }
    cubicIn($) {
        return $ * $ * $
    }
    cubicOut($) {
        return --$ * $ * $ + 1
    }
    cubicInOut($) {
        return ($ *= 2) < 1 ? .5 * $ * $ * $ : .5 * (($ -= 2) * $ * $ + 2)
    }
    quartIn($) {
        return $ * $ * $ * $
    }
    quartOut($) {
        return 1 - --$ * $ * $ * $
    }
    quartInOut($) {
        return ($ *= 2) < 1 ? .5 * $ * $ * $ * $ : -.5 * (($ -= 2) * $ * $ * $ - 2)
    }
    quintIn($) {
        return $ * $ * $ * $ * $
    }
    quintOut($) {
        return --$ * $ * $ * $ * $ + 1
    }
    quintInOut($) {
        return ($ *= 2) < 1 ? .5 * $ * $ * $ * $ * $ : .5 * (($ -= 2) * $ * $ * $ * $ + 2)
    }
    sineIn($) {
        return 1 - Math.cos($ * Math.PI / 2)
    }
    sineOut($) {
        return Math.sin($ * Math.PI / 2)
    }
    sineInOut($) {
        return .5 * (1 - Math.cos(Math.PI * $))
    }
    expoIn($) {
        return $ === 0 ? 0 : Math.pow(1024, $ - 1)
    }
    expoOut($) {
        return $ === 1 ? 1 : 1 - Math.pow(2, -10 * $)
    }
    expoInOut($) {
        return $ === 0 ? 0 : $ === 1 ? 1 : ($ *= 2) < 1 ? .5 * Math.pow(1024, $ - 1) : .5 * (-Math.pow(2, -10 * ($ - 1)) + 2)
    }
    circIn($) {
        return 1 - Math.sqrt(1 - $ * $)
    }
    circOut($) {
        return Math.sqrt(1 - --$ * $)
    }
    circInOut($) {
        return ($ *= 2) < 1 ? -.5 * (Math.sqrt(1 - $ * $) - 1) : .5 * (Math.sqrt(1 - ($ -= 2) * $) + 1)
    }
    elasticIn($) {
        let tt, nt = .1, rt = .4;
        return $ === 0 ? 0 : $ === 1 ? 1 : (!nt || nt < 1 ? (nt = 1,
        tt = rt / 4) : tt = rt * Math.asin(1 / nt) / (2 * Math.PI),
        -(nt * Math.pow(2, 10 * ($ -= 1)) * Math.sin(($ - tt) * 2 * Math.PI / rt)))
    }
    elasticOut($) {
        let tt, nt = .1, rt = .4;
        return $ === 0 ? 0 : $ === 1 ? 1 : (!nt || nt < 1 ? (nt = 1,
        tt = rt / 4) : tt = rt * Math.asin(1 / nt) / (2 * Math.PI),
        nt * Math.pow(2, -10 * $) * Math.sin(($ - tt) * 2 * Math.PI / rt) + 1)
    }
    elasticInOut($) {
        let tt, nt = .1, rt = .4;
        return $ === 0 ? 0 : $ === 1 ? 1 : (!nt || nt < 1 ? (nt = 1,
        tt = rt / 4) : tt = rt * Math.asin(1 / nt) / (2 * Math.PI),
        ($ *= 2) < 1 ? -.5 * nt * Math.pow(2, 10 * ($ -= 1)) * Math.sin(($ - tt) * 2 * Math.PI / rt) : nt * Math.pow(2, -10 * ($ -= 1)) * Math.sin(($ - tt) * 2 * Math.PI / rt) * .5 + 1)
    }
    backIn($) {
        let tt = 1.70158;
        return $ * $ * ((tt + 1) * $ - tt)
    }
    backOut($) {
        let tt = 1.70158;
        return --$ * $ * ((tt + 1) * $ + tt) + 1
    }
    backInOut($) {
        let tt = 2.5949095;
        return ($ *= 2) < 1 ? .5 * $ * $ * ((tt + 1) * $ - tt) : .5 * (($ -= 2) * $ * ((tt + 1) * $ + tt) + 2)
    }
    bounceIn($) {
        return 1 - this.bounceOut(1 - $)
    }
    bounceOut($) {
        return $ < 1 / 2.75 ? 7.5625 * $ * $ : $ < 2 / 2.75 ? 7.5625 * ($ -= 1.5 / 2.75) * $ + .75 : $ < 2.5 / 2.75 ? 7.5625 * ($ -= 2.25 / 2.75) * $ + .9375 : 7.5625 * ($ -= 2.625 / 2.75) * $ + .984375
    }
    bounceInOut($) {
        return $ < .5 ? this.bounceIn($ * 2) * .5 : this.bounceOut($ * 2 - 1) * .5 + .5
    }
    cubicBezier($, tt, nt, rt, it) {
        if ($ <= 0)
            return 0;
        if ($ >= 1)
            return 1;
        if (tt === nt && rt === it)
            return $;
        const ot = ($t,Wt,Kt,qt)=>1 / (3 * Wt * $t * $t + 2 * Kt * $t + qt)
          , st = ($t,Wt,Kt,qt,jt)=>Wt * ($t * $t * $t) + Kt * ($t * $t) + qt * $t + jt
          , lt = ($t,Wt,Kt,qt,jt)=>{
            let Bt = $t * $t;
            return Wt * (Bt * $t) + Kt * Bt + qt * $t + jt
        }
        ;
        let ut = 0, ct = 0, ht = tt, ft = nt, gt = rt, vt = it, yt = 1, wt = 1, mt = yt - 3 * gt + 3 * ht - ut, _t = 3 * gt - 6 * ht + 3 * ut, bt = 3 * ht - 3 * ut, Mt = ut, St = wt - 3 * vt + 3 * ft - ct, At = 3 * vt - 6 * ft + 3 * ct, Pt = 3 * ft - 3 * ct, Ot = ct, Zt = $, Nt, Tt, Ft;
        for (Nt = 0; Nt < 100; Nt++)
            Tt = st(Zt, mt, _t, bt, Mt),
            Ft = ot(Zt, mt, _t, bt),
            Ft === 1 / 0 && (Ft = $),
            Zt -= (Tt - $) * Ft,
            Zt = Math.min(Math.max(Zt, 0), 1);
        return lt(Zt, St, At, Pt, Ot)
    }
}
const CSSEases = {
    easeInSine: "cubic-bezier(0.47, 0, 0.745, 0.715)",
    easeOutSine: "cubic-bezier(0.39, 0.575, 0.565, 1)",
    easeInOutSine: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
    easeInQuad: "cubic-bezier(0.55, 0.085, 0.68, 0.53)",
    easeOutQuad: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
    easeInOutQuad: "cubic-bezier(0.455, 0.03, 0.515, 0.955)",
    easeInCubic: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
    easeOutCubic: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    easeInOutCubic: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    easeInQuart: "cubic-bezier(0.895, 0.03, 0.685, 0.22)",
    easeOutQuart: "cubic-bezier(0.165, 0.84, 0.44, 1)",
    easeInOutQuart: "cubic-bezier(0.77, 0, 0.175, 1)",
    easeInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    easeOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    easeInOutQuint: "cubic-bezier(0.86, 0, 0.07, 1)",
    easeInExpo: "cubic-bezier(0.95, 0.05, 0.795, 0.035)",
    easeOutExpo: "cubic-bezier(0.19, 1, 0.22, 1)",
    easeInOutExpo: "cubic-bezier(1, 0, 0, 1)",
    easeInCirc: "cubic-bezier(0.6, 0.04, 0.98, 0.335)",
    easeOutCirc: "cubic-bezier(0.075, 0.82, 0.165, 1)",
    easeInOutCirc: "cubic-bezier(0.785, 0.135, 0.15, 0.86)",
    easeInBack: "cubic-bezier(0.6, -0.28, 0.735, 0.045)",
    easeOutBack: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
    easeInOutBack: "cubic-bezier(0.68, -0.55, 0.265, 1.55)"
};
var ease = new Ease;
class MathUtils {
    constructor() {
        Et(this, "PI", Math.PI);
        Et(this, "PI2", this.PI * 2);
        Et(this, "HALF_PI", this.PI * .5);
        Et(this, "DEG2RAD", this.PI / 180);
        Et(this, "RAD2DEG", 180 / this.PI)
    }
    step($, tt) {
        return tt < $ ? 0 : 1
    }
    clamp($, tt, nt) {
        return $ < tt ? tt : $ > nt ? nt : $
    }
    mix($, tt, nt) {
        return $ + (tt - $) * nt
    }
    cMix($, tt, nt) {
        return $ + (tt - $) * this.clamp(nt, 0, 1)
    }
    unMix($, tt, nt) {
        return (nt - $) / (tt - $)
    }
    cUnMix($, tt, nt) {
        return this.clamp((nt - $) / (tt - $), 0, 1)
    }
    saturate($) {
        return this.clamp($, 0, 1)
    }
    fit($, tt, nt, rt, it, ot) {
        return $ = this.cUnMix(tt, nt, $),
        ot && ($ = ot($)),
        rt + $ * (it - rt)
    }
    loop($, tt, nt) {
        return $ -= tt,
        nt -= tt,
        ($ < 0 ? (nt - Math.abs($) % nt) % nt : $ % nt) + tt
    }
    normalize($, tt, nt) {
        return Math.max(0, Math.min(1, $ - tt / nt - tt))
    }
    smoothstep($, tt, nt) {
        return nt = this.cUnMix($, tt, nt),
        nt * nt * (3 - nt * 2)
    }
    fract($) {
        return $ - Math.floor($)
    }
    hash($) {
        return this.fract(Math.sin($) * 43758.5453123)
    }
    hash2($, tt) {
        return this.fract(Math.sin($ * 12.9898 + tt * 4.1414) * 43758.5453)
    }
    sign($) {
        return $ ? $ < 0 ? -1 : 1 : 0
    }
    isPowerOfTwo($) {
        return ($ & -$) === $
    }
    powerTwoCeilingBase($) {
        return Math.ceil(Math.log($) / Math.log(2))
    }
    powerTwoCeiling($) {
        return this.isPowerOfTwo($) ? $ : 1 << this.powerTwoCeilingBase($)
    }
    powerTwoFloorBase($) {
        return Math.floor(Math.log($) / Math.log(2))
    }
    powerTwoFloor($) {
        return this.isPowerOfTwo($) ? $ : 1 << this.powerTwoFloorBase($)
    }
    latLngBearing($, tt, nt, rt) {
        let it = Math.sin(rt - tt) * Math.cos(nt)
          , ot = Math.cos($) * Math.sin(nt) - Math.sin($) * Math.cos(nt) * Math.cos(rt - tt);
        return Math.atan2(it, ot)
    }
    distanceTo($, tt) {
        return Math.sqrt($ * $ + tt * tt)
    }
    distanceSqrTo($, tt) {
        return $ * $ + tt * tt
    }
    distanceTo3($, tt, nt) {
        return Math.sqrt($ * $ + tt * tt + nt * nt)
    }
    distanceSqrTo3($, tt, nt) {
        return $ * $ + tt * tt + nt * nt
    }
    latLngDistance($, tt, nt, rt) {
        let it = Math.sin((nt - $) / 2)
          , ot = Math.sin((rt - tt) / 2)
          , st = it * it + Math.cos($) * Math.cos(nt) * ot * ot;
        return 2 * Math.atan2(Math.sqrt(st), Math.sqrt(1 - st))
    }
    cubicBezier($, tt, nt, rt, it) {
        let ot = (tt - $) * 3
          , st = (nt - tt) * 3 - ot
          , lt = rt - $ - ot - st
          , ut = it * it
          , ct = ut * it;
        return lt * ct + st * ut + ot * it + $
    }
    cubicBezierFn($, tt, nt, rt) {
        let it = (tt - $) * 3
          , ot = (nt - tt) * 3 - it
          , st = rt - $ - it - ot;
        return lt=>{
            let ut = lt * lt
              , ct = ut * lt;
            return st * ct + ot * ut + it * lt + $
        }
    }
    normalizeAngle($) {
        return $ += this.PI,
        $ = $ < 0 ? this.PI2 - Math.abs($ % PI2) : $ % this.PI2,
        $ -= this.PI,
        $
    }
    closestAngleTo($, tt) {
        return $ + this.normalizeAngle(tt - $)
    }
    randomRange($, tt) {
        return $ + Math.random() * (tt - $)
    }
    randomRangeInt($, tt) {
        return Math.floor(this.randomRange($, tt + 1))
    }
    padZero($, tt) {
        return $.toString().length >= tt ? $ : (Math.pow(10, tt) + Math.floor($)).toString().substring(1)
    }
    getSeedRandomFn($) {
        let tt = 1779033703
          , nt = 3144134277
          , rt = 1013904242
          , it = 2773480762;
        for (let ot = 0, st; ot < $.length; ot++)
            st = $.charCodeAt(ot),
            tt = nt ^ Math.imul(tt ^ st, 597399067),
            nt = rt ^ Math.imul(nt ^ st, 2869860233),
            rt = it ^ Math.imul(rt ^ st, 951274213),
            it = tt ^ Math.imul(it ^ st, 2716044179);
        return _sfc32(Math.imul(rt ^ tt >>> 18, 597399067), Math.imul(it ^ nt >>> 22, 2869860233), Math.imul(tt ^ rt >>> 17, 951274213), Math.imul(nt ^ it >>> 19, 2716044179))
    }
    mod($, tt) {
        return ($ % tt + tt) % tt
    }
}
function _sfc32(et, $, tt, nt) {
    return function() {
        et |= 0,
        $ |= 0,
        tt |= 0,
        nt |= 0;
        var rt = (et + $ | 0) + nt | 0;
        return nt = nt + 1 | 0,
        et = $ ^ $ >>> 9,
        $ = tt + (tt << 3) | 0,
        tt = tt << 21 | tt >>> 11,
        tt = tt + rt | 0,
        (rt >>> 0) / 4294967296
    }
}
var math = new MathUtils;
function Loader() {
    const et = useGlobalStore(mt=>mt.isLoadingComplete, shallow)
      , [$,tt] = react.exports.useState(0)
      , nt = react.exports.useRef(0)
      , rt = react.exports.useRef()
      , [it,ot] = react.exports.useState(0)
      , st = react.exports.useRef(0)
      , lt = react.exports.useRef()
      , ut = react.exports.useRef(0)
      , ct = react.exports.useRef()
      , ht = react.exports.useRef(!1)
      , ft = react.exports.useRef()
      , gt = react.exports.useRef()
      , vt = react.exports.useRef(0)
      , yt = react.exports.useRef(0)
      , wt = react.exports.useRef(0);
    return useAnimationFrame(mt=>{
        if (vt.current === 1 && yt.current === 1 || !gt.current || !ft.current)
            return;
        wt.current += 4 * mt;
        const {percent: _t} = properties
          , bt = Math.floor(Math.min(wt.current * 10, _t.toFixed(2) * 100))
          , Mt = bt % 10
          , St = Math.max(Math.floor(bt / 10), 0)
          , At = Math.floor(bt / 100);
        At > ut.current && (ut.current = At,
        ht.current = !0),
        ht.current || (Mt > nt.current && (nt.current = Mt,
        tt(Mt)),
        St > st.current && (st.current = St,
        nt.current = 0,
        tt(0),
        ot(St))),
        ht.current && useGlobalStore.setState(Tt=>Tt.isLoadingComplete = !0);
        const Pt = yt.current + .3 * mt * (ht.current ? 1 : 0);
        yt.current < .5 && Pt >= .5 && toggleLucyMode(!1),
        yt.current !== Pt && Pt === 1 && useGlobalStore.setState(Tt=>Tt.isLoaderAnimationComplete = !0),
        yt.current = Pt;
        const Ot = ease.cubicOut(math.saturate(math.fit(Pt, 0, .3, 0, 1)));
        rt.current.style.transform = `translateY(${Ot * -50}%)`,
        lt.current.style.transform = `translateY(${Ot * -50}%)`,
        ct.current.style.transform = `translateY(${Ot * -50}%)`;
        const Zt = ease.cubicOut(math.saturate(math.fit(Pt, .5, 1, 0, 1)));
        ft.current.style.transform = `translateY(${Zt * 50}%)`,
        ft.current.style.opacity = 1 - Zt,
        vt.current = math.saturate(vt.current + mt * (et ? 1 : 0) * .3),
        vt.current += ((et ? 1 : 0) - vt.current) * .4 * mt;
        const Nt = ease.expoInOut(vt.current) * 100;
        gt.current.style.clipPath = `polygon(0 ${Nt}%, 100% ${Nt}%, 100% 100%, 0% 100%)`
    }
    ),
    jsx("div", {
        ref: gt,
        className: "loader",
        children: jsx("div", {
            ref: ft,
            className: "loader__content",
            children: jsxs(GridView, {
                full: !0,
                children: [jsx("div", {
                    className: clsx("loader__item", "loader__item--left"),
                    children: jsxs("div", {
                        ref: ct,
                        className: "loader__animNum",
                        children: [jsx("span", {
                            children: "0"
                        }), jsx("span", {
                            children: "1"
                        })]
                    })
                }), jsx("div", {
                    className: "loader__item loader__item--center"
                }), jsxs("div", {
                    className: clsx("loader__item", "loader__item--right"),
                    children: [jsxs("div", {
                        ref: lt,
                        className: "loader__animNum",
                        children: [jsx("span", {
                            children: it
                        }), jsx("span", {
                            children: "0"
                        })]
                    }), jsxs("div", {
                        ref: rt,
                        className: "loader__animNum",
                        children: [jsx("span", {
                            children: $
                        }), jsx("span", {
                            children: "0"
                        })]
                    })]
                })]
            })
        })
    })
}
function Back() {
    return jsxs("svg", {
        width: "2.4rem",
        height: "2rem",
        viewBox: "0 0 34 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [jsx("path", {
            d: "M0.46967 12.5303C0.176777 12.2374 0.176777 11.7626 0.46967 11.4697C0.762563 11.1768 1.23744 11.1768 1.53033 11.4697L0.46967 12.5303ZM6.03033 15.9697C6.32322 16.2626 6.32322 16.7374 6.03033 17.0303C5.73744 17.3232 5.26256 17.3232 4.96967 17.0303L6.03033 15.9697ZM1.53033 11.4697L6.03033 15.9697L4.96967 17.0303L0.46967 12.5303L1.53033 11.4697Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M0.46967 11.4697C0.176777 11.7626 0.176777 12.2374 0.46967 12.5303C0.762563 12.8232 1.23744 12.8232 1.53033 12.5303L0.46967 11.4697ZM6.03033 8.03033C6.32322 7.73744 6.32322 7.26256 6.03033 6.96967C5.73744 6.67678 5.26256 6.67678 4.96967 6.96967L6.03033 8.03033ZM1.53033 12.5303L6.03033 8.03033L4.96967 6.96967L0.46967 11.4697L1.53033 12.5303Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M1 11.25C0.585786 11.25 0.25 11.5858 0.25 12C0.25 12.4142 0.585786 12.75 1 12.75L1 11.25ZM33 12.75C33.4142 12.75 33.75 12.4142 33.75 12C33.75 11.5858 33.4142 11.25 33 11.25L33 12.75ZM1 12.75L33 12.75L33 11.25L1 11.25L1 12.75Z",
            fill: "currentColor"
        })]
    })
}
var _populated = !1, _ie, _firefox, _opera, _webkit, _chrome, _ie_real_version, _osx, _windows, _linux, _android, _win64, _iphone, _ipad, _native, _mobile;
function _populate() {
    if (!_populated) {
        _populated = !0;
        var et = navigator.userAgent
          , $ = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(et)
          , tt = /(Mac OS X)|(Windows)|(Linux)/.exec(et);
        if (_iphone = /\b(iPhone|iP[ao]d)/.exec(et),
        _ipad = /\b(iP[ao]d)/.exec(et),
        _android = /Android/i.exec(et),
        _native = /FBAN\/\w+;/i.exec(et),
        _mobile = /Mobile/i.exec(et),
        _win64 = !!/Win64/.exec(et),
        $) {
            _ie = $[1] ? parseFloat($[1]) : $[5] ? parseFloat($[5]) : NaN,
            _ie && document && document.documentMode && (_ie = document.documentMode);
            var nt = /(?:Trident\/(\d+.\d+))/.exec(et);
            _ie_real_version = nt ? parseFloat(nt[1]) + 4 : _ie,
            _firefox = $[2] ? parseFloat($[2]) : NaN,
            _opera = $[3] ? parseFloat($[3]) : NaN,
            _webkit = $[4] ? parseFloat($[4]) : NaN,
            _webkit ? ($ = /(?:Chrome\/(\d+\.\d+))/.exec(et),
            _chrome = $ && $[1] ? parseFloat($[1]) : NaN) : _chrome = NaN
        } else
            _ie = _firefox = _opera = _chrome = _webkit = NaN;
        if (tt) {
            if (tt[1]) {
                var rt = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(et);
                _osx = rt ? parseFloat(rt[1].replace("_", ".")) : !0
            } else
                _osx = !1;
            _windows = !!tt[2],
            _linux = !!tt[3]
        } else
            _osx = _windows = _linux = !1
    }
}
var UserAgent_DEPRECATED$1 = {
    ie: function() {
        return _populate() || _ie
    },
    ieCompatibilityMode: function() {
        return _populate() || _ie_real_version > _ie
    },
    ie64: function() {
        return UserAgent_DEPRECATED$1.ie() && _win64
    },
    firefox: function() {
        return _populate() || _firefox
    },
    opera: function() {
        return _populate() || _opera
    },
    webkit: function() {
        return _populate() || _webkit
    },
    safari: function() {
        return UserAgent_DEPRECATED$1.webkit()
    },
    chrome: function() {
        return _populate() || _chrome
    },
    windows: function() {
        return _populate() || _windows
    },
    osx: function() {
        return _populate() || _osx
    },
    linux: function() {
        return _populate() || _linux
    },
    iphone: function() {
        return _populate() || _iphone
    },
    mobile: function() {
        return _populate() || _iphone || _ipad || _android || _mobile
    },
    nativeApp: function() {
        return _populate() || _native
    },
    android: function() {
        return _populate() || _android
    },
    ipad: function() {
        return _populate() || _ipad
    }
}, UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED$1, canUseDOM = !!(typeof window != "undefined" && window.document && window.document.createElement), ExecutionEnvironment$1 = {
    canUseDOM,
    canUseWorkers: typeof Worker != "undefined",
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
}, ExecutionEnvironment_1 = ExecutionEnvironment$1, ExecutionEnvironment = ExecutionEnvironment_1, useHasFeature;
ExecutionEnvironment.canUseDOM && (useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported$1(et, $) {
    if (!ExecutionEnvironment.canUseDOM || $ && !("addEventListener"in document))
        return !1;
    var tt = "on" + et
      , nt = tt in document;
    if (!nt) {
        var rt = document.createElement("div");
        rt.setAttribute(tt, "return;"),
        nt = typeof rt[tt] == "function"
    }
    return !nt && useHasFeature && et === "wheel" && (nt = document.implementation.hasFeature("Events.wheel", "3.0")),
    nt
}
var isEventSupported_1 = isEventSupported$1
  , UserAgent_DEPRECATED = UserAgent_DEPRECATED_1
  , isEventSupported = isEventSupported_1
  , PIXEL_STEP = 10
  , LINE_HEIGHT = 40
  , PAGE_HEIGHT = 800;
function normalizeWheel$1(et) {
    var $ = 0
      , tt = 0
      , nt = 0
      , rt = 0;
    return "detail"in et && (tt = et.detail),
    "wheelDelta"in et && (tt = -et.wheelDelta / 120),
    "wheelDeltaY"in et && (tt = -et.wheelDeltaY / 120),
    "wheelDeltaX"in et && ($ = -et.wheelDeltaX / 120),
    "axis"in et && et.axis === et.HORIZONTAL_AXIS && ($ = tt,
    tt = 0),
    nt = $ * PIXEL_STEP,
    rt = tt * PIXEL_STEP,
    "deltaY"in et && (rt = et.deltaY),
    "deltaX"in et && (nt = et.deltaX),
    (nt || rt) && et.deltaMode && (et.deltaMode == 1 ? (nt *= LINE_HEIGHT,
    rt *= LINE_HEIGHT) : (nt *= PAGE_HEIGHT,
    rt *= PAGE_HEIGHT)),
    nt && !$ && ($ = nt < 1 ? -1 : 1),
    rt && !tt && (tt = rt < 1 ? -1 : 1),
    {
        spinX: $,
        spinY: tt,
        pixelX: nt,
        pixelY: rt
    }
}
normalizeWheel$1.getEventType = function() {
    return UserAgent_DEPRECATED.firefox() ? "DOMMouseScroll" : isEventSupported("wheel") ? "wheel" : "mousewheel"
}
;
var normalizeWheel_1 = normalizeWheel$1
  , normalizeWheel = normalizeWheel_1;
class Input {
    constructor() {
        Et(this, "onDowned", new MinSignal$2);
        Et(this, "onMoved", new MinSignal$2);
        Et(this, "onUped", new MinSignal$2);
        Et(this, "onClicked", new MinSignal$2);
        Et(this, "onWheeled", new MinSignal$2);
        Et(this, "onScrolled", new MinSignal$2);
        Et(this, "wasDown", !1);
        Et(this, "isDown", !1);
        Et(this, "isMobileScrollingY", !1);
        Et(this, "downTime", 0);
        Et(this, "hasClicked", !1);
        Et(this, "hasMoved", !1);
        Et(this, "hadMoved", !1);
        Et(this, "mouseXY", new Vector2);
        Et(this, "prevMouseXY", new Vector2);
        Et(this, "mousePixelXY", new Vector2);
        Et(this, "prevMousePixelXY", new Vector2);
        Et(this, "downXY", new Vector2);
        Et(this, "downPixelXY", new Vector2);
        Et(this, "deltaXY", new Vector2);
        Et(this, "deltaPixelXY", new Vector2);
        Et(this, "deltaDownXY", new Vector2);
        Et(this, "deltaDownPixelXY", new Vector2);
        Et(this, "deltaDownPixelDistance", 0);
        Et(this, "deltaWheel", 0);
        Et(this, "deltaDragScroll", 0);
        Et(this, "deltaScroll", 0);
        Et(this, "canDesktopDragScroll", !1);
        Et(this, "downThroughElems", []);
        Et(this, "currThroughElems", []);
        Et(this, "prevThroughElems", []);
        Et(this, "clickThroughElems", []);
        Et(this, "lerpedWheelDelta", 0);
        Et(this, "WHEEL_DELTA_LERP", .024)
    }
    preInit() {
        const $ = document;
        $.addEventListener("mousedown", this._onDown.bind(this)),
        $.addEventListener("touchstart", this._getTouchBound(this, this._onDown, !1)),
        $.addEventListener("mousemove", this._onMove.bind(this)),
        $.addEventListener("touchmove", this._getTouchBound(this, this._onMove, !1)),
        $.addEventListener("mouseup", this._onUp.bind(this)),
        $.addEventListener("touchend", this._getTouchBound(this, this._onUp, !1)),
        $.addEventListener("wheel", this._onWheel.bind(this)),
        $.addEventListener("mousewheel", this._onWheel.bind(this)),
        $.addEventListener("keydown", tt=>{
            const {key: nt} = tt;
            nt === "ArrowUp" && this._onWheel(null, -300),
            nt === "ArrowDown" && this._onWheel(null, 300)
        }
        )
    }
    init() {}
    update($) {
        this.lerpedWheelDelta += (this.deltaWheel - this.lerpedWheelDelta) * this.WHEEL_DELTA_LERP
    }
    postUpdate($) {
        this.prevThroughElems.length = 0,
        this.prevThroughElems.concat(this.currThroughElems),
        this.deltaWheel = 0,
        this.deltaDragScroll = 0,
        this.deltaScroll = 0,
        this.prevMouseXY.copy(this.mouseXY),
        this.prevMousePixelXY.copy(this.mousePixelXY),
        this.hadMoved = this.hasMoved,
        this.wasDown = this.isDown
    }
    _onWheel($, tt) {
        const {showContactOverlay: nt, showMobileMenuOverlay: rt} = useGlobalStore.getState();
        if (nt || rt)
            return;
        let it = tt && !$ ? tt : normalizeWheel($).pixelY;
        if (this.deltaWheel += it,
        this.deltaScroll = this.deltaDragScroll + this.deltaWheel,
        this.onWheeled.dispatch($ == null ? void 0 : $.target),
        this.onScrolled.dispatch($ == null ? void 0 : $.target),
        !disableScroll.current) {
            if (disableAbsScroll.current && this.deltaScroll > 0)
                return;
            useScrollStore.setState(ot=>{
                ot.deltaScroll = this.deltaScroll,
                ot.scroll = ot.scroll + this.deltaScroll,
                ot.absScroll = Math.max(0, ot.absScroll + this.deltaScroll)
            }
            )
        }
    }
    _onDown($) {
        this.isDown = !0,
        this.downTime = +new Date,
        this.prevThroughElems.length = 0,
        this._setThroughElementsByEvent($, this.downThroughElems),
        this._getInputXY($, this.downXY),
        this._getInputPixelXY($, this.downPixelXY),
        this.prevMouseXY.copy(this.downXY),
        this.prevMousePixelXY.copy(this.downPixelXY),
        this.deltaXY.set(0, 0),
        this.deltaPixelXY.set(0, 0),
        this._getInputXY($, this.mouseXY),
        this._onMove($),
        this.onDowned.dispatch($)
    }
    _onMove($) {
        if (this._getInputXY($, this.mouseXY),
        this._getInputPixelXY($, this.mousePixelXY),
        this.deltaXY.copy(this.mouseXY).sub(this.prevMouseXY),
        this.deltaPixelXY.copy(this.mousePixelXY).sub(this.prevMousePixelXY),
        this.hasMoved = !0,
        this.isDown && (this.deltaDownXY.copy(this.mouseXY).sub(this.downXY),
        this.deltaDownPixelXY.copy(this.mousePixelXY).sub(this.downPixelXY),
        this.deltaDownPixelDistance = this.deltaDownPixelXY.length(),
        browser$1.isMobile || this.canDesktopDragScroll)) {
            const {showContactOverlay: tt, showMobileMenuOverlay: nt} = useGlobalStore.getState();
            if (tt || nt)
                return;
            if (this.isMobileScrollingY = Math.abs(this.deltaPixelXY.y) > .1,
            this.isMobileScrollingY && (this.deltaDragScroll = -this.deltaPixelXY.y,
            this.deltaScroll = 2 * this.deltaDragScroll + this.deltaWheel,
            this.onScrolled.dispatch($.target),
            !disableScroll.current)) {
                if (disableAbsScroll.current && this.deltaScroll > 0)
                    return;
                useScrollStore.setState(rt=>{
                    rt.deltaScroll = this.deltaScroll,
                    rt.scroll = rt.scroll + this.deltaScroll,
                    rt.absScroll = Math.max(0, rt.absScroll + this.deltaScroll)
                }
                )
            }
        }
        this._setThroughElementsByEvent($, this.currThroughElems),
        this.onMoved.dispatch($)
    }
    _onUp($) {
        const tt = $.clientX - this.downPixelXY.x
          , nt = $.clientY - this.downPixelXY.y;
        Math.sqrt(tt * tt + nt * nt) < 40 && +new Date - this.downTime < 300 && (this._setThroughElementsByEvent($, this.clickThroughElems),
        this._getInputXY($, this.mouseXY),
        this.hasClicked = !0,
        this.onClicked.dispatch($)),
        this.deltaXY.set(0, 0),
        this.deltaPixelXY.set(0, 0),
        this.deltaDownXY.set(0, 0),
        this.deltaDownPixelXY.set(0, 0),
        this.deltaDownPixelDistance = 0,
        this.isDown = !1,
        this.isMobileScrollingY = !1,
        this.onUped.dispatch($)
    }
    _getTouchBound($, tt, nt) {
        return function(rt) {
            nt && rt.preventDefault && rt.preventDefault(),
            tt.call($, rt.changedTouches[0] || rt.touches[0])
        }
    }
    _getInputXY($, tt) {
        return tt.set($.clientX / window.innerWidth * 2 - 1, 1 - $.clientY / window.innerHeight * 2),
        tt
    }
    _getInputPixelXY($, tt) {
        tt.set($.clientX, $.clientY)
    }
    _setThroughElementsByEvent($, tt) {
        let nt = $.target;
        for (tt.length = 0; nt.parentNode; )
            tt.push(nt),
            nt = nt.parentNode
    }
    hasThroughElem($, tt) {
        let nt = this[tt + "ThroughElems"] || this.currThroughElems
          , rt = nt.length;
        for (; rt--; )
            if (nt[rt] === $)
                return !0;
        return !1
    }
    hasThroughElemWithClass($, tt) {
        let nt = this[tt + "ThroughElems"] || this.currThroughElems
          , rt = nt.length;
        for (; rt--; )
            if (nt[rt].classList.contains($))
                return nt[rt];
        return null
    }
}
var input = new Input
  , LUCY_DATA = {
    svg: {
        eye: {
            base: "M 46 28 C 48.1525 28 50.078 28.9715 51.3621 30.5 C 52.3843 31.7168 53 33.2865 53 35 C 53 36.9587 52.1955 38.7295 50.899 40 C 49.6364 41.2372 47.9073 42 46 42 C 44.0927 42 42.3636 41.2372 41.101 40 C 40.4134 39.3262 39.8642 38.5117 39.5 37.6031 C 39.1775 36.7984 39 35.9199 39 35 C 39 34.0801 39.1775 33.2016 39.5 32.3969 C 39.7782 31.7028 40.1645 31.0635 40.6379 30.5 C 41.922 28.9715 43.8475 28 46 28 Z",
            shut: "M 32.2862 28.5145 C 33.1066 26.4634 35.4345 25.4657 37.4857 26.2862 C 40.819 27.6195 44.1524 28.9529 47.4857 30.2862 C 48.9218 30.8606 49.8981 32.2117 49.9926 33.7556 C 50.0872 35.2995 49.2831 36.7595 47.9278 37.505 C 44.5945 39.3383 41.2611 41.1717 37.9278 43.005 C 35.9921 44.0696 33.5598 43.3634 32.4952 41.4278 C 31.4306 39.4921 32.1367 37.0598 34.0724 35.9952 C 34.9349 35.5208 35.7974 35.0465 36.6599 34.5721 C 35.9448 34.2861 35.2296 34 34.5145 33.714 C 32.4634 32.8935 31.4657 30.5657 32.2862 28.5145 Z",
            halfshut: "M 46 35 C 48.3333 35 50.6667 35 53 35 C 53 36.0736 52.7583 37.0907 52.3264 38 C 51.7338 39.2473 50.7833 40.2916 49.6076 41 C 48.554 41.6348 47.3197 42 46 42 C 44.6803 42 43.446 41.6348 42.3924 41 C 41.7667 40.6229 41.2047 40.1508 40.7265 39.6035 C 40.3063 39.1225 39.9508 38.5834 39.6736 38 C 39.2417 37.0907 39 36.0736 39 35 C 40.1667 35 41.3333 35 42.5 35 C 43.6667 35 44.8333 35 46 35 Z"
        },
        mouth: {
            base: "M48.4235 83.5349C45.4745 80.629 44 76.7663 44 71.9468C44 67.1274 45.4745 63.2647 48.4235 60.3588C51.4353 57.4529 55.2941 56 60 56C64.7059 56 68.5333 57.4529 71.4824 60.3588C74.4941 63.2647 76 67.1274 76 71.9468C76 76.7663 74.4941 80.629 71.4824 83.5349C68.5333 86.5116 64.7059 88 60 88C55.2941 88 51.4353 86.5116 48.4235 83.5349Z",
            small: "M67.2093 72.2353C65.3931 74.0784 62.979 75 59.9668 75C56.9546 75 54.5404 74.0784 52.7243 72.2353C50.9081 70.3529 50 67.9412 50 65C50 62.0588 50.9081 59.6667 52.7243 57.8235C54.5404 55.9412 56.9546 55 59.9668 55C62.979 55 65.3931 55.9412 67.2093 57.8235C69.0698 59.6667 70 62.0588 70 65C70 67.9412 69.0698 70.3529 67.2093 72.2353Z",
            happy: "M47.7 77.2709C44.5667 74.1933 43 70.1023 43 64.9979C43 62.9999 44.2687 63.0002 47.7 63C53.403 63.0001 55 63.0001 60 63.0001C65 63.0001 66.0896 63.0001 72.2 63C72.2 63 77 63 77 64.9979C77 70.1023 75.4 74.1933 72.2 77.2709C69.0667 80.4236 65 82 60 82C55 82 50.9 80.4236 47.7 77.2709Z",
            shut: "M47.7 63.8605C44.5667 63.7697 43 63.6489 43 63.4983C43 63.3477 44.5667 63.227 47.7 63.1362C50.9 63.0454 55 63 60 63C65 63 69.0667 63.0454 72.2 63.1362C75.4 63.227 77 63.3477 77 63.4983C77 63.6489 75.4 63.7697 72.2 63.8605C69.0667 63.9535 65 64 60 64C55 64 50.9 63.9535 47.7 63.8605Z"
        }
    },
    emotes: {
        base: {
            eyeL: "base",
            eyeR: "base",
            mouth: "base"
        },
        curious: {
            eyeL: "base",
            eyeR: "base",
            mouth: "small"
        },
        k: {
            eyeL: "base",
            eyeR: "base",
            mouth: "shut"
        },
        happy: {
            eyeL: "base",
            eyeR: "base",
            mouth: "happy"
        },
        unamused: {
            eyeL: "halfshut",
            eyeR: "base",
            mouth: "shut"
        },
        doh: {
            eyeL: "shut",
            eyeR: "shut",
            mouth: "small"
        }
    }
};
function Lucy(et) {
    const $ = {
        x: 12,
        y: 8
    }
      , Zt = et
      , {visible: tt, position: nt, isCentered: rt} = Zt
      , it = nr(Zt, ["visible", "position", "isCentered"])
      , [ot,st,lt] = useGlobalStore(Nt=>[Nt.width, Nt.height, Nt.isLoaderAnimationComplete], shallow)
      , [ut,ct,ht] = useLogoStore(Nt=>[Nt.lucyEmote, Nt.isLucyLooking, Nt.isLucyFloating], shallow)
      , [ft,gt] = react.exports.useState(!1)
      , vt = react.exports.useRef(0)
      , yt = react.exports.useRef({
        x: 0,
        y: 0
    })
      , wt = react.exports.useRef({
        x: 0,
        y: 0
    })
      , mt = LUCY_DATA.emotes[ut]
      , _t = useSpring({
        to: {
            eyeL: LUCY_DATA.svg.eye[mt.eyeL],
            eyeR: LUCY_DATA.svg.eye[mt.eyeR],
            mouth: LUCY_DATA.svg.mouth[mt.mouth]
        },
        config: config.wobbly
    })
      , [bt,Mt] = useSpring(()=>({
        x: 0,
        y: 0
    }));
    function St() {
        updateLucyEmote$1(),
        yt.current.x = yt.current.y = 0,
        Mt({
            x: 0,
            y: 0,
            config: {
                duration: 0
            }
        })
    }
    const At = useSpring({
        opacity: tt ? 1 : 0,
        delay: tt ? 700 : 0,
        config: {
            duration: tt ? 250 : 200
        },
        onStart: ()=>{
            gt(!0),
            St()
        }
        ,
        onRest: ()=>{
            setTimeout(()=>gt(!1), 500)
        }
    })
      , Pt = useSpring({
        loop: {
            reverse: !0
        },
        from: {
            y: 0
        },
        to: {
            y: ht && !ft ? -2 : 0
        },
        config: ()=>({
            duration: 640,
            easing: Nt=>Math.sin(Nt * Math.PI * .5)
        })
    })
      , Ot = react.exports.useCallback(Nt=>{
        !tt || !ct || ft || (yt.current.x = (Nt.clientX - wt.current.x) * 2 / ot,
        yt.current.y = (Nt.clientY - wt.current.y) * 2 / st,
        Mt({
            x: yt.current.x,
            y: yt.current.y,
            rotateY: yt.current.x * .1,
            config: {
                mass: 1,
                tension: 240,
                friction: 12
            }
        }))
    }
    , [ot, st, tt, ft, lt]);
    return react.exports.useEffect(()=>{
        const Nt = vt.current.getBoundingClientRect();
        return wt.current.x = Nt.left + Nt.width / 2,
        wt.current.y = Nt.top + Nt.height / 2,
        input.onMoved.add(Ot),
        ()=>input.onMoved.remove(Ot)
    }
    , [Ot, tt]),
    jsxs(animated.svg, kn(wn({
        className: "lucy",
        viewBox: "0 0 120 120",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ref: vt,
        style: {
            opacity: At.opacity,
            y: Pt.y,
            width: "100%",
            height: "100%"
        }
    }, it), {
        children: [jsxs(animated.g, {
            className: "lucy__eyeWrapper",
            style: {
                x: bt.x.to(Nt=>`${Nt * $.x}%`),
                y: bt.y.to(Nt=>`${Nt * $.y}%`),
                rotateY: bt.rotateY
            },
            children: [jsx(animated.path, {
                className: "lucy__eyeL",
                fill: "white",
                d: _t.eyeL
            }), jsx(animated.path, {
                className: "lucy__eyeR",
                fill: "white",
                style: {
                    transform: "translateY(-42%) rotate(180deg)",
                    transformOrigin: "center center"
                },
                d: _t.eyeR
            })]
        }), jsx(animated.g, {
            className: "lucy__mouthWrapper",
            style: {
                x: bt.x.to(Nt=>`${Nt * $.x * .8}%`),
                y: bt.y.to(Nt=>`${Nt * $.y * (Math.sign(Nt) < 0 ? 1.1 : 1)}%`)
            },
            children: jsx(animated.path, {
                className: "lucy__mouth",
                strokeWidth: "11",
                d: _t.mouth
            })
        })]
    }))
}
function SvgLogo() {
    return jsxs("svg", {
        width: "152",
        height: "16",
        viewBox: "0 0 152 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [jsx("path", {
            d: "M0 15.5838V0.143357H2.53664V13.3339H9.17603V15.5838H0Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M14.9146 0.0772386V9.03269C14.9146 10.4885 15.2014 11.584 15.7749 12.3193C16.3484 13.0399 17.238 13.4001 18.4439 13.4001C19.6644 13.4001 20.5614 13.0399 21.1349 12.3193C21.7231 11.584 22.0172 10.4885 22.0172 9.03269V0.0772386H24.5539V8.90035C24.5539 11.1061 24.0318 12.7825 22.9878 13.9295C21.9584 15.0765 20.4438 15.65 18.4439 15.65C16.4587 15.65 14.9514 15.0765 13.922 13.9295C12.8926 12.7825 12.378 11.1061 12.378 8.90035V0.0772386H14.9146Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M30.2484 10.5657C30.3219 11.4774 30.6895 12.2127 31.3512 12.7715C32.0277 13.3156 32.9026 13.5876 33.9761 13.5876C34.9172 13.5876 35.6746 13.3891 36.2481 12.9921C36.8363 12.5803 37.1304 12.0142 37.1304 11.2936C37.1304 10.7789 36.9686 10.3745 36.6451 10.0804C36.3363 9.77162 35.9098 9.53634 35.3658 9.37458C34.8217 9.21283 34.057 9.04372 33.0717 8.86725C32.0718 8.69079 31.2115 8.46286 30.491 8.18346C29.7851 7.88936 29.2043 7.4482 28.7484 6.86C28.3073 6.27179 28.0867 5.49977 28.0867 4.54393C28.0867 3.66162 28.3146 2.87489 28.7705 2.18375C29.241 1.49261 29.8881 0.955867 30.7116 0.573532C31.5498 0.191198 32.5056 3.05176e-05 33.5791 3.05176e-05C34.682 3.05176e-05 35.6672 0.205903 36.5348 0.617648C37.4024 1.02939 38.0862 1.59554 38.5862 2.3161C39.0862 3.03665 39.3582 3.86014 39.4023 4.78657H36.9098C36.8216 3.99249 36.476 3.35281 35.8731 2.86754C35.2702 2.38227 34.5055 2.13963 33.5791 2.13963C32.6821 2.13963 31.9615 2.33815 31.4174 2.73519C30.888 3.11753 30.6233 3.66162 30.6233 4.36747C30.6233 4.86744 30.7777 5.26448 31.0865 5.55859C31.4101 5.85269 31.8365 6.07327 32.3659 6.22032C32.8953 6.36737 33.6526 6.52913 34.6379 6.70559C35.6378 6.88205 36.4981 7.11734 37.2186 7.41144C37.9392 7.70554 38.5274 8.13935 38.9832 8.71285C39.4391 9.28635 39.667 10.0437 39.667 10.9848C39.667 11.8965 39.4244 12.7127 38.9391 13.4332C38.4538 14.1538 37.7774 14.7199 36.9098 15.1317C36.0422 15.5287 35.0569 15.7272 33.9541 15.7272C32.7335 15.7272 31.6601 15.5066 30.7336 15.0655C29.8072 14.6243 29.0793 14.0141 28.5499 13.2347C28.0352 12.4406 27.7705 11.5362 27.7558 10.5216L30.2484 10.5657Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M42.869 0.143357H45.4056V15.5838H42.869V0.143357Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M63.6068 7.86361C63.6068 9.36354 63.2906 10.7091 62.6583 11.9002C62.026 13.0913 61.1363 14.0251 59.9893 14.7015C58.857 15.378 57.5629 15.7162 56.1071 15.7162C54.6513 15.7162 53.3499 15.378 52.2029 14.7015C51.0706 14.0251 50.1883 13.0913 49.556 11.9002C48.9236 10.7091 48.6075 9.36354 48.6075 7.86361C48.6075 6.36368 48.9236 5.01816 49.556 3.82704C50.1883 2.63592 51.0706 1.70214 52.2029 1.0257C53.3499 0.349263 54.6513 0.011044 56.1071 0.011044C57.5629 0.011044 58.857 0.349263 59.9893 1.0257C61.1363 1.70214 62.026 2.63592 62.6583 3.82704C63.2906 5.01816 63.6068 6.36368 63.6068 7.86361ZM51.2103 7.86361C51.2103 8.93709 51.4162 9.90763 51.8279 10.7752C52.2397 11.6281 52.8132 12.2972 53.5484 12.7825C54.2984 13.2531 55.1513 13.4883 56.1071 13.4883C57.063 13.4883 57.9085 13.2531 58.6438 12.7825C59.3937 12.2972 59.9746 11.6281 60.3863 10.7752C60.7981 9.90763 61.004 8.93709 61.004 7.86361C61.004 6.79013 60.7981 5.82694 60.3863 4.97404C59.9746 4.10644 59.3937 3.43735 58.6438 2.96679C57.9085 2.48151 57.063 2.23888 56.1071 2.23888C55.1513 2.23888 54.2984 2.48151 53.5484 2.96679C52.8132 3.43735 52.2397 4.10644 51.8279 4.97404C51.4162 5.82694 51.2103 6.79013 51.2103 7.86361Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M66.8088 15.5838V0.143357H69.1248L76.6465 11.084V0.143357H79.1391V15.5838H76.823L69.3013 4.64314V15.5838H66.8088Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M88.2112 2.17131C87.1305 2.17131 86.2544 3.04737 86.2544 4.12805C86.2544 5.20873 87.1305 6.08479 88.2112 6.08479C89.2918 6.08479 90.1679 5.20873 90.1679 4.12805C90.1679 3.04737 89.2918 2.17131 88.2112 2.17131Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M88.2112 9.64249C87.1305 9.64249 86.2544 10.5186 86.2544 11.5992C86.2544 12.6799 87.1305 13.556 88.2112 13.556C89.2918 13.556 90.1679 12.6799 90.1679 11.5992C90.1679 10.5186 89.2918 9.64249 88.2112 9.64249Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M97.2833 0.143387H99.4891V13.378H97.2833V0.143387Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M99.4891 15.5838L99.4891 13.378L108.312 13.378V15.5838H99.4891Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M118.131 0.143417H115.926V2.34919H118.131V0.143417Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M115.926 2.34919L113.72 2.34918V4.55496H115.926L115.926 2.34919Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M118.131 2.34919L120.337 2.34918V4.55496H118.131L118.131 2.34919Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M113.72 4.55496L111.514 4.55498V15.5838H113.72V11.1723H120.337L120.337 15.5838H122.543V4.55498L120.337 4.55496L120.337 8.96649L113.72 8.96651L113.72 4.55496Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M134.568 0.143417V2.34919H127.951V6.76071L134.568 6.76075V8.96653L127.951 8.96649V13.378H134.568V15.5838H125.745V0.143417H134.568Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M136.774 2.34918L134.568 2.34919V6.76075L136.774 6.76076V2.34918Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M134.568 8.96653L136.774 8.96655V13.3781L134.568 13.378V8.96653Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M148.799 0.143417V2.34919H142.182V6.76071H148.799V8.96649H142.182L142.182 6.76071L139.976 6.76076V2.34918L142.182 2.34919L142.182 0.143417H148.799Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M142.182 11.1723H139.976V13.3781H142.182V15.5838H148.799V13.378L142.182 13.3781L142.182 11.1723Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M151.005 2.34918L148.799 2.34919L148.799 4.55496H151.005V2.34918Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M148.799 8.96649L151.005 8.96651V13.3781L148.799 13.378V8.96649Z",
            fill: "currentColor"
        })]
    })
}
function subArray(et, $) {
    return et.map((tt,nt)=>tt - $[nt])
}
function TrailFade(et) {
    const {children: $, delay: tt, visible: nt} = et
      , rt = React.Children.toArray($)
      , it = useTrail(rt.length, {
        config: {
            mass: 1,
            tension: 400,
            friction: 32
        },
        delay: tt,
        t: nt ? 0 : 1
    });
    return jsx(Fragment, {
        children: it.map(({t: ot},st)=>jsx(animated.g, {
            style: {
                opacity: ot.to(lt=>1 - lt),
                transformOrigin: "center center"
            },
            children: rt[st]
        }, st))
    })
}
function getGlitchVal(et, $=0) {
    return Math.floor((et + $ * 123) * Math.PI % 1 * 10)
}
function glitchEasing(et, $) {
    if (et < .1 || et > .9)
        return et;
    let tt = getGlitchVal(Math.floor(et * 10), $)
      , nt = getGlitchVal(Math.ceil(et * 10), $)
      , rt = et * 10 % 1;
    return et = tt + (nt - tt) * rt,
    et
}
function TrailPixel(et) {
    const {children: $, visible: tt} = et
      , nt = React.Children.toArray($).map(it=>({
        value: it,
        sort: Math.random()
    })).sort((it,ot)=>it.sort - ot.sort).map(({value: it})=>it)
      , rt = useTrail(nt.length, {
        config: {
            mass: .02,
            tension: 480,
            friction: 7
        },
        delay: ()=>tt ? 120 : 0,
        t: tt ? 0 : 1
    });
    return jsx(Fragment, {
        children: rt.map(({t: it},ot)=>jsx(animated.g, {
            style: {
                opacity: it.to(st=>glitchEasing(1 - st, ot))
            },
            children: nt[ot]
        }, ot))
    })
}
const SVG_DATA$1 = {
    base: {
        eyeL: [134.58, 27.44],
        eyeR: [134.58, 17.35],
        mouth: [94, 25]
    },
    lucy: {
        eyeL: [16.3, 11.57],
        eyeR: [28.09, 11.57],
        mouth: [25, 29]
    }
};
function SvgLogoTransition(et) {
    const ot = et
      , {visible: $} = ot
      , tt = nr(ot, ["visible"])
      , nt = {};
    Object.keys(SVG_DATA$1.base).forEach(st=>{
        nt[st] = subArray(SVG_DATA$1.lucy[st], SVG_DATA$1.base[st])
    }
    );
    const rt = useSpring({
        t: $ ? 0 : 1,
        delay: $ ? 0 : 400,
        config: {
            mass: 1,
            tension: 240,
            friction: 32
        }
    })
      , it = useSpring({
        opacity: $ ? 1 : 0,
        delay: $ ? 0 : 850,
        config: {
            duration: $ ? 100 : 300
        }
    });
    return jsxs(animated.svg, kn(wn({
        viewBox: "0 0 241 50",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: {
            height: "100%"
        }
    }, tt), {
        children: [jsx("defs", {
            children: jsx("clipPath", {
                id: "logo-rect-cut",
                children: jsx("rect", {
                    rx: "4",
                    width: "240",
                    height: "49",
                    x: "0.6",
                    y: "0.6"
                })
            })
        }), jsx("g", {
            clipPath: "url(#logo-rect-cut)",
            children: jsx(animated.rect, {
                className: "svgLogo__bg",
                height: "50",
                rx: "6",
                style: {
                    width: rt.t.to(st=>241 - st * (241 - 50))
                }
            })
        }), jsxs(animated.g, {
            style: {
                opacity: it.opacity
            },
            children: [jsxs("g", {
                className: "svgLogo__inactive-letters",
                children: [jsxs(TrailFade, {
                    visible: $,
                    children: [jsx("path", {
                        id: "l",
                        d: "M19.06 35.46V14.61h3.4v17.81h8.89v3.04h-12.3Z"
                    }), jsx("path", {
                        id: "u",
                        d: "M39.03 14.52v12.1c0 1.96.39 3.44 1.16 4.43.76.98 1.96 1.46 3.57 1.46 1.64 0 2.84-.48 3.6-1.46.8-.99 1.19-2.47 1.19-4.44V14.52h3.4v11.92c0 2.97-.7 5.24-2.1 6.79-1.38 1.55-3.41 2.32-6.09 2.32-2.66 0-4.68-.77-6.06-2.32-1.37-1.55-2.06-3.82-2.06-6.8v-11.9h3.4Z"
                    }), jsx("path", {
                        id: "s",
                        d: "M59.57 28.68a4.2 4.2 0 0 0 1.48 2.98 5.4 5.4 0 0 0 3.51 1.1c1.26 0 2.28-.26 3.05-.8a2.66 2.66 0 0 0 1.18-2.3c0-.69-.22-1.23-.65-1.63a3.96 3.96 0 0 0-1.72-.95 28.9 28.9 0 0 0-3.07-.69 18.96 18.96 0 0 1-3.45-.92 5.7 5.7 0 0 1-2.34-1.79 5.14 5.14 0 0 1-.88-3.13 5.7 5.7 0 0 1 3.51-5.36 9.1 9.1 0 0 1 3.84-.78 9 9 0 0 1 3.96.84 6.83 6.83 0 0 1 2.75 2.3 6.28 6.28 0 0 1 1.09 3.33h-3.34a3.73 3.73 0 0 0-1.39-2.6 4.72 4.72 0 0 0-3.07-.98c-1.2 0-2.17.27-2.9.8a2.56 2.56 0 0 0-1.06 2.21c0 .68.2 1.21.62 1.61.44.4 1 .7 1.72.9.7.2 1.72.41 3.04.65 1.34.24 2.5.56 3.46.95.96.4 1.75.99 2.36 1.76.6.78.91 1.8.91 3.07 0 1.23-.32 2.33-.97 3.3a6.61 6.61 0 0 1-2.72 2.3c-1.16.54-2.48.8-3.96.8-1.63 0-3.07-.3-4.31-.89a7.19 7.19 0 0 1-2.92-2.47 6.82 6.82 0 0 1-1.07-3.67l3.34.06Z"
                    }), jsx("path", {
                        id: "i",
                        d: "M76.47 14.6h3.4v20.86h-3.4V14.61Z"
                    }), jsx("path", {
                        id: "n",
                        d: "M108.53 35.46V14.61h3.1l10.08 14.77V14.61h3.34v20.85h-3.1L111.87 20.7v14.77h-3.34Z"
                    })]
                }), jsx("g", {
                    className: "svgLogo__labs",
                    children: jsxs(TrailPixel, {
                        visible: $,
                        children: [jsx("path", {
                            d: "M206.306 18H209.245V21H206.306V18Z"
                        }), jsx("path", {
                            d: "M206.306 21H209.245V24H206.306V21Z"
                        }), jsx("path", {
                            d: "M206.306 30H209.245V33H206.306V30Z"
                        }), jsx("path", {
                            d: "M209.245 15H212.184V18H209.245V15Z"
                        }), jsx("path", {
                            d: "M209.245 24H212.184V27H209.245V24Z"
                        }), jsx("path", {
                            d: "M209.245 33H212.184V36H209.245V33Z"
                        }), jsx("path", {
                            d: "M212.184 15H215.122V18H212.184V15Z"
                        }), jsx("path", {
                            d: "M212.184 24H215.122V27H212.184V24Z"
                        }), jsx("path", {
                            d: "M212.184 33H215.122V36H212.184V33Z"
                        }), jsx("path", {
                            d: "M215.123 15H218.061V18H215.123V15Z"
                        }), jsx("path", {
                            d: "M215.123 24H218.061V27H215.123V24Z"
                        }), jsx("path", {
                            d: "M215.123 33H218.061V36H215.123V33Z"
                        }), jsx("path", {
                            d: "M218.061 18H221V21H218.061V18Z"
                        }), jsx("path", {
                            d: "M218.061 27H221V30H218.061V27Z"
                        }), jsx("path", {
                            d: "M218.061 30H221V33H218.061V30Z"
                        }), jsx("path", {
                            d: "M187.204 15H190.143V18H187.204V15Z"
                        }), jsx("path", {
                            d: "M187.204 18H190.143V21H187.204V18Z"
                        }), jsx("path", {
                            d: "M187.204 21H190.143V24H187.204V21Z"
                        }), jsx("path", {
                            d: "M187.204 24H190.143V27H187.204V24Z"
                        }), jsx("path", {
                            d: "M187.204 27H190.143V30H187.204V27Z"
                        }), jsx("path", {
                            d: "M187.204 30H190.143V33H187.204V30Z"
                        }), jsx("path", {
                            d: "M187.204 33H190.143V36H187.204V33Z"
                        }), jsx("path", {
                            d: "M190.143 15H193.082V18H190.143V15Z"
                        }), jsx("path", {
                            d: "M190.143 24H193.082V27H190.143V24Z"
                        }), jsx("path", {
                            d: "M190.143 33H193.082V36H190.143V33Z"
                        }), jsx("path", {
                            d: "M193.082 15H196.02V18H193.082V15Z"
                        }), jsx("path", {
                            d: "M193.082 24H196.02V27H193.082V24Z"
                        }), jsx("path", {
                            d: "M193.082 33H196.02V36H193.082V33Z"
                        }), jsx("path", {
                            d: "M196.021 15H198.959V18H196.021V15Z"
                        }), jsx("path", {
                            d: "M196.021 24H198.959V27H196.021V24Z"
                        }), jsx("path", {
                            d: "M196.021 33H198.959V36H196.021V33Z"
                        }), jsx("path", {
                            d: "M198.959 18H201.898V21H198.959V18Z"
                        }), jsx("path", {
                            d: "M198.959 21H201.898V24H198.959V21Z"
                        }), jsx("path", {
                            d: "M198.959 27H201.898V30H198.959V27Z"
                        }), jsx("path", {
                            d: "M198.959 30H201.898V33H198.959V30Z"
                        }), jsx("path", {
                            d: "M168.102 21H171.041V24H168.102V21Z"
                        }), jsx("path", {
                            d: "M168.102 24H171.041V27H168.102V24Z"
                        }), jsx("path", {
                            d: "M168.102 27H171.041V30H168.102V27Z"
                        }), jsx("path", {
                            d: "M168.102 30H171.041V33H168.102V30Z"
                        }), jsx("path", {
                            d: "M168.102 33H171.041V36H168.102V33Z"
                        }), jsx("path", {
                            d: "M171.041 18H173.98V21H171.041V18Z"
                        }), jsx("path", {
                            d: "M171.041 27H173.98V30H171.041V27Z"
                        }), jsx("path", {
                            d: "M173.979 15H176.918V18H173.979V15Z"
                        }), jsx("path", {
                            d: "M173.979 27H176.918V30H173.979V27Z"
                        }), jsx("path", {
                            d: "M176.918 18H179.857V21H176.918V18Z"
                        }), jsx("path", {
                            d: "M176.918 27H179.857V30H176.918V27Z"
                        }), jsx("path", {
                            d: "M179.857 21H182.796V24H179.857V21Z"
                        }), jsx("path", {
                            d: "M179.857 24H182.796V27H179.857V24Z"
                        }), jsx("path", {
                            d: "M179.857 27H182.796V30H179.857V27Z"
                        }), jsx("path", {
                            d: "M179.857 30H182.796V33H179.857V30Z"
                        }), jsx("path", {
                            d: "M179.857 33H182.796V36H179.857V33Z"
                        }), jsx("path", {
                            d: "M149 15H151.939V18H149V15Z"
                        }), jsx("path", {
                            d: "M149 18H151.939V21H149V18Z"
                        }), jsx("path", {
                            d: "M149 21H151.939V24H149V21Z"
                        }), jsx("path", {
                            d: "M149 24H151.939V27H149V24Z"
                        }), jsx("path", {
                            d: "M149 27H151.939V30H149V27Z"
                        }), jsx("path", {
                            d: "M149 30H151.939V33H149V30Z"
                        }), jsx("path", {
                            d: "M151.939 33H154.878V36H151.939V33Z"
                        }), jsx("path", {
                            d: "M154.877 33H157.816V36H154.877V33Z"
                        }), jsx("path", {
                            d: "M157.816 33H160.755V36H157.816V33Z"
                        }), jsx("path", {
                            d: "M160.755 33H163.694V36H160.755V33Z"
                        })]
                    })
                })]
            }), jsx(animated.path, {
                className: "svgLogo__eye_r",
                d: "M137.2 17.35a2.63 2.63 0 0 0-2.62 2.64 2.63 2.63 0 0 0 2.62 2.64 2.63 2.63 0 0 0 2.62-2.64 2.63 2.63 0 0 0-2.62-2.64Z",
                fill: "#fff",
                style: {
                    x: rt.t.to(st=>nt.eyeR[0] * Math.max(st * 1.08 - .08, 0)),
                    y: rt.t.to(st=>nt.eyeR[1] * Math.max(st * 1.08 - .08, 0))
                }
            }), jsx(animated.path, {
                className: "svgLogo__eye_l",
                d: "M137.2 27.44a2.63 2.63 0 0 0-2.62 2.64 2.63 2.63 0 0 0 2.62 2.64 2.63 2.63 0 0 0 2.62-2.64 2.63 2.63 0 0 0-2.62-2.64Z",
                fill: "#fff",
                style: {
                    x: rt.t.to(st=>nt.eyeL[0] * st),
                    y: rt.t.to(st=>nt.eyeL[1] * st)
                }
            }), jsx(animated.circle, {
                className: "svgLogo__eye_mouth",
                cx: "94",
                cy: "25",
                stroke: "#fff",
                style: {
                    x: rt.t.to(st=>nt.mouth[0] * st),
                    y: rt.t.to(st=>nt.mouth[1] * st),
                    strokeWidth: rt.t.to(st=>3.6 + 1 * st),
                    r: rt.t.to(st=>9 - 2.5 * st)
                }
            })]
        })]
    }))
}
const SVG_DATA = {
    base: {
        eyeL: [41.47, 27.44],
        eyeR: [41.47, 17.35],
        mouth: [25, 64]
    },
    lucy: {
        eyeL: [16.3, 11.57],
        eyeR: [28.09, 11.57],
        mouth: [25, 29]
    }
};
function SvgLogoTransitionMobile(et) {
    const ot = et
      , {visible: $} = ot
      , tt = nr(ot, ["visible"])
      , nt = {};
    Object.keys(SVG_DATA.base).forEach(st=>{
        nt[st] = subArray(SVG_DATA.lucy[st], SVG_DATA.base[st])
    }
    );
    const rt = useSpring({
        t: $ ? 0 : 1,
        delay: $ ? 0 : 400,
        config: {
            mass: 1,
            tension: 240,
            friction: 32
        }
    })
      , it = useSpring({
        opacity: $ ? 1 : 0,
        delay: $ ? 50 : 850,
        config: {
            duration: $ ? 100 : 300
        }
    });
    return jsxs(animated.svg, kn(wn({
        viewBox: "0 0 149 50",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: {
            width: "100%",
            height: "100%"
        }
    }, tt), {
        children: [jsx(animated.rect, {
            className: "svgLogo__bg",
            height: "50",
            rx: "6",
            fill: "black",
            style: {
                width: rt.t.to(st=>149 - st * (149 - 50))
            }
        }), jsxs(animated.g, {
            style: {
                opacity: it.opacity
            },
            children: [jsxs("g", {
                className: "svgLogo__inactive-letters",
                children: [jsx(TrailFade, {
                    visible: $,
                    delay: 100,
                    children: jsx("path", {
                        id: "l",
                        d: "M19.3 35.46V14.61h3.45v17.81h9.04v3.04H19.3Z",
                        fill: "#fff"
                    })
                }), jsx("g", {
                    className: "svgLogo__labs",
                    children: jsxs(TrailPixel, {
                        visible: $,
                        children: [jsx("path", {
                            d: "M113.306 18H116.245V21H113.306V18Z"
                        }), jsx("path", {
                            d: "M113.306 21H116.245V24H113.306V21Z"
                        }), jsx("path", {
                            d: "M113.306 30H116.245V33H113.306V30Z"
                        }), jsx("path", {
                            d: "M116.245 15H119.184V18H116.245V15Z"
                        }), jsx("path", {
                            d: "M116.245 24H119.184V27H116.245V24Z"
                        }), jsx("path", {
                            d: "M116.245 33H119.184V36H116.245V33Z"
                        }), jsx("path", {
                            d: "M119.184 15H122.122V18H119.184V15Z"
                        }), jsx("path", {
                            d: "M119.184 24H122.122V27H119.184V24Z"
                        }), jsx("path", {
                            d: "M119.184 33H122.122V36H119.184V33Z"
                        }), jsx("path", {
                            d: "M122.123 15H125.061V18H122.123V15Z"
                        }), jsx("path", {
                            d: "M122.123 24H125.061V27H122.123V24Z"
                        }), jsx("path", {
                            d: "M122.123 33H125.061V36H122.123V33Z"
                        }), jsx("path", {
                            d: "M125.061 18H128V21H125.061V18Z"
                        }), jsx("path", {
                            d: "M125.061 27H128V30H125.061V27Z"
                        }), jsx("path", {
                            d: "M125.061 30H128V33H125.061V30Z"
                        }), jsx("path", {
                            d: "M94.2041 15H97.1429V18H94.2041V15Z"
                        }), jsx("path", {
                            d: "M94.2041 18H97.1429V21H94.2041V18Z"
                        }), jsx("path", {
                            d: "M94.2041 21H97.1429V24H94.2041V21Z"
                        }), jsx("path", {
                            d: "M94.2041 24H97.1429V27H94.2041V24Z"
                        }), jsx("path", {
                            d: "M94.2041 27H97.1429V30H94.2041V27Z"
                        }), jsx("path", {
                            d: "M94.2041 30H97.1429V33H94.2041V30Z"
                        }), jsx("path", {
                            d: "M94.2041 33H97.1429V36H94.2041V33Z"
                        }), jsx("path", {
                            d: "M97.1431 15H100.082V18H97.1431V15Z"
                        }), jsx("path", {
                            d: "M97.1431 24H100.082V27H97.1431V24Z"
                        }), jsx("path", {
                            d: "M97.1431 33H100.082V36H97.1431V33Z"
                        }), jsx("path", {
                            d: "M100.082 15H103.02V18H100.082V15Z"
                        }), jsx("path", {
                            d: "M100.082 24H103.02V27H100.082V24Z"
                        }), jsx("path", {
                            d: "M100.082 33H103.02V36H100.082V33Z"
                        }), jsx("path", {
                            d: "M103.021 15H105.959V18H103.021V15Z"
                        }), jsx("path", {
                            d: "M103.021 24H105.959V27H103.021V24Z"
                        }), jsx("path", {
                            d: "M103.021 33H105.959V36H103.021V33Z"
                        }), jsx("path", {
                            d: "M105.959 18H108.898V21H105.959V18Z"
                        }), jsx("path", {
                            d: "M105.959 21H108.898V24H105.959V21Z"
                        }), jsx("path", {
                            d: "M105.959 27H108.898V30H105.959V27Z"
                        }), jsx("path", {
                            d: "M105.959 30H108.898V33H105.959V30Z"
                        }), jsx("path", {
                            d: "M75.1021 21H78.0408V24H75.1021V21Z"
                        }), jsx("path", {
                            d: "M75.1021 24H78.0408V27H75.1021V24Z"
                        }), jsx("path", {
                            d: "M75.1021 27H78.0408V30H75.1021V27Z"
                        }), jsx("path", {
                            d: "M75.1021 30H78.0408V33H75.1021V30Z"
                        }), jsx("path", {
                            d: "M75.1021 33H78.0408V36H75.1021V33Z"
                        }), jsx("path", {
                            d: "M78.041 18H80.9798V21H78.041V18Z"
                        }), jsx("path", {
                            d: "M78.041 27H80.9798V30H78.041V27Z"
                        }), jsx("path", {
                            d: "M80.9795 15H83.9183V18H80.9795V15Z"
                        }), jsx("path", {
                            d: "M80.9795 27H83.9183V30H80.9795V27Z"
                        }), jsx("path", {
                            d: "M83.9185 18H86.8572V21H83.9185V18Z"
                        }), jsx("path", {
                            d: "M83.9185 27H86.8572V30H83.9185V27Z"
                        }), jsx("path", {
                            d: "M86.8569 21H89.7957V24H86.8569V21Z"
                        }), jsx("path", {
                            d: "M86.8569 24H89.7957V27H86.8569V24Z"
                        }), jsx("path", {
                            d: "M86.8569 27H89.7957V30H86.8569V27Z"
                        }), jsx("path", {
                            d: "M86.8569 30H89.7957V33H86.8569V30Z"
                        }), jsx("path", {
                            d: "M86.8569 33H89.7957V36H86.8569V33Z"
                        }), jsx("path", {
                            d: "M56 15H58.9388V18H56V15Z"
                        }), jsx("path", {
                            d: "M56 18H58.9388V21H56V18Z"
                        }), jsx("path", {
                            d: "M56 21H58.9388V24H56V21Z"
                        }), jsx("path", {
                            d: "M56 24H58.9388V27H56V24Z"
                        }), jsx("path", {
                            d: "M56 27H58.9388V30H56V27Z"
                        }), jsx("path", {
                            d: "M56 30H58.9388V33H56V30Z"
                        }), jsx("path", {
                            d: "M58.939 33H61.8777V36H58.939V33Z"
                        }), jsx("path", {
                            d: "M61.8774 33H64.8162V36H61.8774V33Z"
                        }), jsx("path", {
                            d: "M64.8164 33H67.7552V36H64.8164V33Z"
                        }), jsx("path", {
                            d: "M67.7549 33H70.6937V36H67.7549V33Z"
                        })]
                    })
                })]
            }), jsx(animated.path, {
                className: "svgLogo__eye_r",
                d: "M44.13 17.35a2.65 2.65 0 0 0-2.66 2.64 2.65 2.65 0 0 0 2.66 2.64A2.65 2.65 0 0 0 46.79 20a2.65 2.65 0 0 0-2.66-2.64Z",
                fill: "#fff",
                style: {
                    x: rt.t.to(st=>nt.eyeR[0] * Math.max(st * 1.08 - .08, 0)),
                    y: rt.t.to(st=>nt.eyeR[1] * Math.max(st * 1.08 - .08, 0))
                }
            }), jsx(animated.path, {
                className: "svgLogo__eye_l",
                d: "M44.13 27.44a2.65 2.65 0 0 0-2.66 2.64 2.65 2.65 0 0 0 2.66 2.64 2.65 2.65 0 0 0 2.66-2.64 2.65 2.65 0 0 0-2.66-2.64Z",
                fill: "#fff",
                style: {
                    x: rt.t.to(st=>nt.eyeL[0] * st),
                    y: rt.t.to(st=>nt.eyeL[1] * st)
                }
            }), jsx(animated.circle, {
                className: "svgLogo__eye_mouth",
                cx: "25",
                cy: "64",
                stroke: "#fff",
                style: {
                    x: rt.t.to(st=>nt.mouth[0] * st),
                    y: rt.t.to(st=>nt.mouth[1] * st),
                    strokeWidth: rt.t.to(st=>3.6 + 1 * st),
                    r: rt.t.to(st=>9 - 2.5 * st)
                }
            })]
        })]
    }))
}
function Logo(et) {
    const {center: $, large: tt, noInteraction: nt} = et
      , rt = useLogoStore(vt=>vt.isLucyMode, shallow)
      , it = useLogoStore(vt=>vt.isLucyLooking, shallow)
      , ot = useLogoStore(vt=>vt.lucyJump, shallow)
      , st = useLogoStore(vt=>vt.lucyWiggle, shallow)
      , lt = useGlobalStore(vt=>vt.width, shallow)
      , [ut,ct] = react.exports.useState(Math.random());
    react.exports.useEffect(()=>{
        ct(Math.random())
    }
    , [ot]);
    const ht = useSpring({
        x: $ && rt ? lt > 1024 ? "40%" : "28%" : "0%",
        delay: 400
    })
      , ft = useSpring({
        x: st && rt ? "8%" : "0%",
        y: ot && rt ? "-60%" : "0%",
        rotate: (ot || st) && rt ? getRotateVal(ut) * -12 : 0,
        config: {
            tension: 200,
            friction: 8
        }
    });
    function gt(vt=!1) {
        nt || !it || useLogoStore.setState(yt=>yt.isLucyMode = vt)
    }
    return jsx(Link, {
        to: `/${window.location.search}`,
        children: jsx(animated.div, {
            style: {
                x: ht.x
            },
            children: jsxs(animated.div, {
                style: {
                    x: ft.x,
                    y: ft.y,
                    rotate: ft.rotate,
                    transformOrigin: "20% 50%"
                },
                className: clsx("svgLogo", tt && "svgLogo--large"),
                children: [lt <= 1024 && lt != 0 ? jsx(SvgLogoTransitionMobile, {
                    className: "svgLogo__svg",
                    visible: !rt
                }) : jsx(SvgLogoTransition, {
                    visible: !rt,
                    className: "svgLogo__svg"
                }), jsx("div", {
                    className: "svgLogo__lucy",
                    onPointerEnter: ()=>gt(!1),
                    onPointerLeave: ()=>gt(!0),
                    children: jsx(Lucy, {
                        visible: rt,
                        isCentered: $
                    })
                })]
            })
        })
    })
}
function getRotateVal(et) {
    let $ = et * .4 + .6;
    return $ *= Math.random() > .5 ? 1 : -1,
    $
}
const THEMES_ARRAY = Object.values(THEMES);
function ThemeSwitcher() {
    const et = useGlobalStore(st=>st.currentTheme, shallow)
      , $ = THEMES_ARRAY.findIndex(st=>st.id === et)
      , tt = THEMES_ARRAY[$]
      , nt = react.exports.useRef()
      , rt = react.exports.useRef(0)
      , it = st=>{
        st ? (updateLucyEmote$1("curious", !0, !0),
        useGlobalStore.setState(lt=>{
            lt.isCursorHovering = !0
        }
        )) : (updateLucyEmote$1(),
        useGlobalStore.setState(lt=>{
            lt.isCursorHovering = !1
        }
        ))
    }
      , ot = ()=>{
        makeLucyWiggle("happy");
        let st = THEMES_ARRAY[($ + 1) % THEMES_ARRAY.length];
        useGlobalStore.setState(lt=>lt.currentTheme = st.id)
    }
    ;
    return react.exports.useEffect(()=>{
        document.documentElement.setAttribute("data-theme", tt.name),
        properties.themeSignal.dispatch(tt.id)
    }
    , [et]),
    useAnimationFrame(st=>{
        rt.current = math.saturate(rt.current + 2 * st * (tt.id === 2 ? 1 : -1)),
        nt.current.style.transform = `translateY(${math.mix(-50, 0, ease.cubicInOut(rt.current))}%)`
    }
    ),
    jsxs("button", {
        className: "theme-switcher",
        "aria-label": "Change theme",
        onClick: ot,
        onMouseOver: ()=>it(!0),
        onMouseOut: ()=>it(),
        children: [jsx("div", {
            className: "theme-switcher__init",
            children: jsxs("div", {
                className: "theme-switcher__opts",
                ref: nt,
                children: [jsx("div", {
                    children: "B"
                }), jsx("div", {
                    children: "W"
                })]
            })
        }), jsx("div", {
            className: "theme-switcher__point"
        })]
    })
}
function ViewSwitch(tt) {
    var nt = tt
      , {className: et} = nt
      , $ = nr(nt, ["className"]);
    const rt = react.exports.useRef()
      , it = react.exports.useRef()
      , ot = react.exports.useRef()
      , st = react.exports.useRef()
      , lt = react.exports.useRef(0)
      , ut = react.exports.useRef({
        grid: 0,
        list: 0
    })
      , ct = react.exports.useRef({
        grid: 0,
        list: 0
    })
      , ht = react.exports.useRef({
        grid: 0,
        list: 0
    })
      , ft = useGlobalStore(yt=>yt.experimentsView, shallow)
      , gt = useGlobalStore(yt=>yt.width, shallow)
      , vt = yt=>{
        const {experimentsView: wt} = useGlobalStore.getState();
        yt !== wt && (disableScroll.current || (disableAbsScroll.current = !1,
        disableScroll.current = !0,
        useGlobalStore.setState(mt=>mt.experimentsView = yt)))
    }
    ;
    return react.exports.useEffect(()=>{
        const yt = rt.current.getBoundingClientRect()
          , wt = it.current.getBoundingClientRect()
          , mt = ot.current.getBoundingClientRect();
        ut.current.grid = 0,
        ut.current.list = Math.floor(mt.x - yt.x),
        ct.current.grid = Math.ceil(wt.width),
        ct.current.list = Math.ceil(mt.width),
        ht.current.grid = Math.ceil(wt.height),
        ht.current.list = Math.ceil(mt.height)
    }
    , [gt]),
    useAnimationFrame(yt=>{
        if (!st.current)
            return;
        lt.current = math.saturate(lt.current + yt * (ft === EXP_VIEWS.GRID ? 1 : -1));
        const wt = ease.expoInOut(lt.current);
        st.current.style.width = `${math.mix(ct.current.list, ct.current.grid, wt)}px`,
        st.current.style.height = `${math.mix(ht.current.list, ht.current.grid, wt)}px`,
        st.current.style.transform = `translateX(${math.mix(ut.current.list, ut.current.grid, wt)}px)`
    }
    ),
    jsx("div", {
        className: clsx("view-switch", et),
        onMouseEnter: ()=>{
            updateLucyEmote$1("curious"),
            useGlobalStore.setState(yt=>{
                yt.isCursorHovering = !0
            }
            )
        }
        ,
        onMouseLeave: ()=>{
            updateLucyEmote$1(),
            useGlobalStore.setState(yt=>{
                yt.isCursorHovering = !1
            }
            )
        }
        ,
        children: jsxs("div", {
            ref: rt,
            className: "view-switch__options",
            children: [jsx("div", {
                ref: st,
                className: "view-switch__option-background"
            }), jsx("button", {
                ref: it,
                "aria-label": "Enable grid view",
                className: clsx("view-switch__option", ft === EXP_VIEWS.GRID && "view-switch__option--isActive"),
                onClick: ()=>vt(EXP_VIEWS.GRID),
                children: "grid"
            }), jsx("button", {
                ref: ot,
                "aria-label": "Enable link view",
                className: clsx("view-switch__option", ft === EXP_VIEWS.LIST && "view-switch__option--isActive"),
                onClick: ()=>vt(EXP_VIEWS.LIST),
                children: "list"
            })]
        })
    })
}
function Dot(et) {
    const nt = et
      , {fill: $="white"} = nt
      , tt = nr(nt, ["fill"]);
    return jsx("svg", kn(wn({
        width: "1.25rem",
        height: "1.25rem",
        viewBox: "0 0 16 16",
        fill: "none",
        name: "iconDot",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: jsx("rect", {
            x: "5",
            y: "5",
            width: "6",
            height: "6",
            rx: "3",
            fill: $
        })
    }))
}
function ArrowTopRight24(et) {
    const nt = et
      , {fill: $="currentColor"} = nt
      , tt = nr(nt, ["fill"]);
    return jsxs("svg", kn(wn({
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: [jsx("path", {
            d: "M18.75 6C18.75 5.58579 18.4142 5.25 18 5.25C17.5858 5.25 17.25 5.58579 17.25 6H18.75ZM17.25 16C17.25 16.4142 17.5858 16.75 18 16.75C18.4142 16.75 18.75 16.4142 18.75 16H17.25ZM17.25 6V16H18.75V6H17.25Z",
            fill: $
        }), jsx("path", {
            d: "M18 6.75C18.4142 6.75 18.75 6.41421 18.75 6C18.75 5.58579 18.4142 5.25 18 5.25L18 6.75ZM8 5.25C7.58579 5.25 7.25 5.58579 7.25 6C7.25 6.41421 7.58579 6.75 8 6.75L8 5.25ZM18 5.25L8 5.25L8 6.75L18 6.75L18 5.25Z",
            fill: $
        }), jsx("path", {
            d: "M18.5303 6.53033C18.8232 6.23744 18.8232 5.76256 18.5303 5.46967C18.2374 5.17678 17.7626 5.17678 17.4697 5.46967L18.5303 6.53033ZM5.46967 17.4697C5.17678 17.7626 5.17678 18.2374 5.46967 18.5303C5.76256 18.8232 6.23744 18.8232 6.53033 18.5303L5.46967 17.4697ZM17.4697 5.46967L5.46967 17.4697L6.53033 18.5303L18.5303 6.53033L17.4697 5.46967Z",
            fill: $
        })]
    }))
}
function ArrowTopRight16(et) {
    const nt = et
      , {fill: $="currentColor"} = nt
      , tt = nr(nt, ["fill"]);
    return jsxs("svg", kn(wn({
        width: "1.25rem",
        height: "1.25rem",
        viewBox: "0 0 16 16",
        fill: "none",
        name: "iconArrow",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: [jsx("path", {
            d: "M12.75 4C12.75 3.58579 12.4142 3.25 12 3.25C11.5858 3.25 11.25 3.58579 11.25 4H12.75ZM11.25 10C11.25 10.4142 11.5858 10.75 12 10.75C12.4142 10.75 12.75 10.4142 12.75 10H11.25ZM11.25 4V10H12.75V4H11.25Z",
            fill: $
        }), jsx("path", {
            d: "M12 4.75C12.4142 4.75 12.75 4.41421 12.75 4C12.75 3.58579 12.4142 3.25 12 3.25L12 4.75ZM6 3.25C5.58579 3.25 5.25 3.58579 5.25 4C5.25 4.41421 5.58579 4.75 6 4.75L6 3.25ZM12 3.25L6 3.25L6 4.75L12 4.75L12 3.25Z",
            fill: $
        }), jsx("path", {
            d: "M12.5303 4.53033C12.8232 4.23744 12.8232 3.76256 12.5303 3.46967C12.2374 3.17678 11.7626 3.17678 11.4697 3.46967L12.5303 4.53033ZM3.46967 11.4697C3.17678 11.7626 3.17678 12.2374 3.46967 12.5303C3.76256 12.8232 4.23744 12.8232 4.53033 12.5303L3.46967 11.4697ZM11.4697 3.46967L3.46967 11.4697L4.53033 12.5303L12.5303 4.53033L11.4697 3.46967Z",
            fill: $
        })]
    }))
}
function ArrowRight24(et) {
    const nt = et
      , {fill: $="currentColor"} = nt
      , tt = nr(nt, ["fill"]);
    return jsx("svg", kn(wn({
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: jsx("path", {
            d: "M2.49951 11.2503C2.0853 11.2503 1.74951 11.5861 1.74951 12.0003C1.74951 12.4145 2.0853 12.7503 2.49951 12.7503L2.49951 11.2503ZM21.4999 12.0002L22.0303 12.5306L22.5606 12.0002L22.0303 11.4699L21.4999 12.0002ZM13.0303 2.46978C12.7374 2.17688 12.2626 2.17688 11.9697 2.46977C11.6768 2.76266 11.6768 3.23753 11.9697 3.53043L13.0303 2.46978ZM11.9697 20.4699C11.6768 20.7627 11.6768 21.2376 11.9697 21.5305C12.2626 21.8234 12.7374 21.8234 13.0303 21.5305L11.9697 20.4699ZM2.49951 12.7503L21.4999 12.7502L21.4999 11.2502L2.49951 11.2503L2.49951 12.7503ZM22.0303 11.4699L13.0303 2.46978L11.9697 3.53043L20.9696 12.5306L22.0303 11.4699ZM20.9696 11.4699L11.9697 20.4699L13.0303 21.5305L22.0303 12.5306L20.9696 11.4699Z",
            fill: $
        })
    }))
}
function ArrowRight16(et) {
    const nt = et
      , {fill: $="currentColor"} = nt
      , tt = nr(nt, ["fill"]);
    return jsxs("svg", kn(wn({
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        fill: "none",
        name: "iconArrowMobile",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: [jsx("path", {
            d: "M14.5303 8.53033C14.8232 8.23744 14.8232 7.76256 14.5303 7.46967C14.2374 7.17678 13.7626 7.17678 13.4697 7.46967L14.5303 8.53033ZM9.46967 11.4697C9.17678 11.7626 9.17678 12.2374 9.46967 12.5303C9.76256 12.8232 10.2374 12.8232 10.5303 12.5303L9.46967 11.4697ZM13.4697 7.46967L9.46967 11.4697L10.5303 12.5303L14.5303 8.53033L13.4697 7.46967Z",
            fill: $
        }), jsx("path", {
            d: "M13.4697 8.53033C13.7626 8.82322 14.2374 8.82322 14.5303 8.53033C14.8232 8.23744 14.8232 7.76256 14.5303 7.46967L13.4697 8.53033ZM10.5303 3.46967C10.2374 3.17678 9.76256 3.17678 9.46967 3.46967C9.17678 3.76256 9.17678 4.23744 9.46967 4.53033L10.5303 3.46967ZM14.5303 7.46967L10.5303 3.46967L9.46967 4.53033L13.4697 8.53033L14.5303 7.46967Z",
            fill: $
        }), jsx("path", {
            d: "M14 8.75C14.4142 8.75 14.75 8.41421 14.75 8C14.75 7.58579 14.4142 7.25 14 7.25L14 8.75ZM2 7.25C1.58579 7.25 1.25 7.58579 1.25 8C1.25 8.41421 1.58579 8.75 2 8.75L2 7.25ZM14 7.25L2 7.25L2 8.75L14 8.75L14 7.25Z",
            fill: $
        })]
    }))
}
function ArrowRight12(et) {
    const nt = et
      , {fill: $="currentColor"} = nt
      , tt = nr(nt, ["fill"]);
    return jsxs("svg", kn(wn({
        width: "12",
        height: "12",
        viewBox: "0 0 12 12",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: [jsx("path", {
            d: "M9.64645 6.35355C9.84171 6.54882 10.1583 6.54882 10.3536 6.35355C10.5488 6.15829 10.5488 5.84171 10.3536 5.64645L9.64645 6.35355ZM7.02022 2.31311C6.82496 2.11785 6.50837 2.11785 6.31311 2.31311C6.11785 2.50838 6.11785 2.82496 6.31311 3.02022L7.02022 2.31311ZM10.3536 5.64645L7.02022 2.31311L6.31311 3.02022L9.64645 6.35355L10.3536 5.64645Z",
            fill: $
        }), jsx("path", {
            d: "M10.3536 6.35372C10.5489 6.15845 10.5489 5.84187 10.3536 5.64661C10.1584 5.45135 9.84179 5.45135 9.64653 5.64661L10.3536 6.35372ZM6.31319 8.97994C6.11793 9.1752 6.11793 9.49179 6.31319 9.68705C6.50846 9.88231 6.82504 9.88231 7.0203 9.68705L6.31319 8.97994ZM9.64653 5.64661L6.31319 8.97994L7.0203 9.68705L10.3536 6.35372L9.64653 5.64661Z",
            fill: $
        }), jsx("path", {
            d: "M10 5.5C10.2761 5.5 10.5 5.72386 10.5 6C10.5 6.27614 10.2761 6.5 10 6.5L10 5.5ZM2 6.5C1.72386 6.5 1.5 6.27614 1.5 6C1.5 5.72386 1.72386 5.5 2 5.5L2 6.5ZM10 6.5L2 6.5L2 5.5L10 5.5L10 6.5Z",
            fill: $
        })]
    }))
}
function CardButton(et) {
    const {onClick: $, isHovering: tt, className: nt, arrow: rt=!1, darkMode: it=!1} = et
      , [ot,st] = react.exports.useState(!1)
      , ut = useGlobalStore(ct=>ct.width, shallow) <= 1024;
    return jsx("div", {
        onClick: $,
        className: clsx("card-button", nt, ot && "card-button--hover"),
        onPointerEnter: ()=>st(!0),
        onPointerLeave: ()=>st(!1),
        children: ut ? jsx(ArrowRight16, {
            fill: "currentColor"
        }) : ot || tt || rt ? jsx(ArrowTopRight16, {
            fill: "currentColor"
        }) : jsx(Dot, {
            fill: "currentColor"
        })
    })
}
function ExpInfoId(et) {
    const {id: $=0, inline: tt, className: nt} = et;
    return jsx("div", {
        className: clsx("exp-info", "exp-info__id", tt && "exp-info--inline", nt),
        children: `EXP ${$.toString().padStart(3, 0)}`
    })
}
function ExpInfoDate(et) {
    const {releaseDate: $, inline: tt, className: nt} = et;
    return jsx("div", {
        className: clsx("exp-info", "exp-info__date", tt && "exp-info--inline", nt),
        children: $
    })
}
function ExpInfo(et) {
    return jsxs(Fragment, {
        children: [jsx(ExpInfoId, wn({}, et)), jsx(ExpInfoDate, wn({}, et))]
    })
}
function Tags(et) {
    const {tags: $=["tag0", "tag1", "tag2"], className: tt} = et;
    return jsx("ul", {
        className: clsx("tags", tt),
        children: $.map((nt,rt)=>jsx("li", {
            className: `tags__item tags__item--${rt}`,
            children: nt
        }, nt))
    })
}
const LusionExtLink = withHover(et=>{
    const it = et
      , {className: $, arrowBefore: tt=!1, isHovered: nt} = it
      , rt = nr(it, ["className", "arrowBefore", "isHovered"]);
    return jsxs("div", kn(wn({
        className: clsx("ext-lusion-link", $)
    }, rt), {
        children: [tt && jsx(ArrowTopRight16, {}), jsx("a", {
            className: "link",
            target: "_blank",
            href: "https://lusion.co/",
            children: "Lusion"
        }), !tt && jsx(ArrowTopRight16, {})]
    }))
}
);
function withHover(et) {
    return $=>{
        const [tt,nt] = react.exports.useState(!1)
          , rt = ()=>{
            useGlobalStore.setState(ot=>{
                ot.isCursorHovering = !0
            }
            ),
            updateLucyEmote("random"),
            nt(!0)
        }
          , it = ()=>{
            useGlobalStore.setState(ot=>{
                ot.isCursorHovering = !1
            }
            ),
            updateLucyEmote(),
            nt(!1)
        }
        ;
        return jsx(et, kn(wn({}, $), {
            onMouseEnter: rt,
            onMouseLeave: it
        }))
    }
}
function Menu$1() {
    return jsxs("svg", {
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [jsx("path", {
            d: "M23 8.75C23.4142 8.75 23.75 8.41421 23.75 8C23.75 7.58579 23.4142 7.25 23 7.25V8.75ZM1 7.25C0.585786 7.25 0.25 7.58579 0.25 8C0.25 8.41421 0.585786 8.75 1 8.75V7.25ZM23 7.25H1V8.75H23V7.25Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M23 12.75C23.4142 12.75 23.75 12.4142 23.75 12C23.75 11.5858 23.4142 11.25 23 11.25V12.75ZM1 11.25C0.585786 11.25 0.25 11.5858 0.25 12C0.25 12.4142 0.585786 12.75 1 12.75V11.25ZM23 11.25H1V12.75H23V11.25Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M23 16.75C23.4142 16.75 23.75 16.4142 23.75 16C23.75 15.5858 23.4142 15.25 23 15.25V16.75ZM1 15.25C0.585786 15.25 0.25 15.5858 0.25 16C0.25 16.4142 0.585786 16.75 1 16.75V15.25ZM23 15.25H1V16.75H23V15.25Z",
            fill: "currentColor"
        })]
    })
}
function CloseSvg(et) {
    return jsxs("svg", kn(wn({
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, et), {
        children: [jsx("path", {
            d: "M6.46967 16.4697C6.17678 16.7626 6.17678 17.2374 6.46967 17.5303C6.76256 17.8232 7.23744 17.8232 7.53033 17.5303L6.46967 16.4697ZM17.5303 7.53033C17.8232 7.23744 17.8232 6.76256 17.5303 6.46967C17.2374 6.17678 16.7626 6.17678 16.4697 6.46967L17.5303 7.53033ZM7.53033 17.5303L17.5303 7.53033L16.4697 6.46967L6.46967 16.4697L7.53033 17.5303Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M16.4697 17.5303C16.7626 17.8232 17.2374 17.8232 17.5303 17.5303C17.8232 17.2374 17.8232 16.7626 17.5303 16.4697L16.4697 17.5303ZM7.53033 6.46967C7.23744 6.17678 6.76256 6.17678 6.46967 6.46967C6.17678 6.76256 6.17678 7.23744 6.46967 7.53033L7.53033 6.46967ZM17.5303 16.4697L7.53033 6.46967L6.46967 7.53033L16.4697 17.5303L17.5303 16.4697Z",
            fill: "currentColor"
        })]
    }))
}
const Close = withHover(CloseSvg);
function CloseMenu() {
    return jsxs("svg", {
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [jsx("path", {
            d: "M19.2477 20.3084C19.5406 20.6013 20.0155 20.6013 20.3084 20.3084C20.6013 20.0155 20.6013 19.5406 20.3084 19.2477L19.2477 20.3084ZM4.75201 3.69135C4.45912 3.39846 3.98424 3.39846 3.69135 3.69135C3.39846 3.98424 3.39846 4.45912 3.69135 4.75201L4.75201 3.69135ZM20.3084 19.2477L4.75201 3.69135L3.69135 4.75201L19.2477 20.3084L20.3084 19.2477Z",
            fill: "currentColor"
        }), jsx("path", {
            d: "M3.69164 19.2477C3.39875 19.5406 3.39875 20.0155 3.69164 20.3084C3.98453 20.6013 4.45941 20.6013 4.7523 20.3084L3.69164 19.2477ZM20.3087 4.75201C20.6015 4.45912 20.6015 3.98424 20.3087 3.69135C20.0158 3.39846 19.5409 3.39846 19.248 3.69135L20.3087 4.75201ZM4.7523 20.3084L20.3087 4.75201L19.248 3.69135L3.69164 19.2477L4.7523 20.3084Z",
            fill: "currentColor"
        })]
    })
}
const INITIAL_DELAY = .2
  , LinkWithHover = withHover(Link)
  , ButtonWithHover = withHover(et=>{
    let rt = et
      , {children: $, isHovered: tt} = rt
      , nt = nr(rt, ["children", "isHovered"]);
    return jsx("button", kn(wn({}, nt), {
        children: $
    }))
}
);
function Navbar({location: et}) {
    const $ = react.exports.useRef()
      , tt = react.exports.useRef(-INITIAL_DELAY)
      , [nt,rt] = useGlobalStore(ot=>[ot.showMobileMenuOverlay, ot.width], shallow)
      , it = ()=>{
        useGlobalStore.setState(ot=>{
            ot.showContactOverlay = !0,
            ot.showSubscribeModal = !1
        }
        )
    }
    ;
    return react.exports.useEffect(()=>{
        if (!$.current)
            return;
        const {height: ot} = $.current.getBoundingClientRect();
        useGlobalStore.setState(st=>{
            st.navbarHeight = ot
        }
        )
    }
    , [rt]),
    useAnimationFrame(ot=>{
        tt.current = Math.min(1, tt.current + ot),
        $.current.style.transform = `translateY(${math.mix(-100, 0, ease.cubicInOut(math.saturate(tt.current)))}%)`
    }
    ),
    jsx(Fragment, {
        children: jsxs("nav", {
            ref: $,
            className: "grid-view navbar",
            id: "navbar",
            children: [jsx("div", {
                className: "navbar__left",
                children: jsx("div", {
                    className: "navbar__logo",
                    children: jsx(LinkWithHover, {
                        to: "/",
                        children: jsx(Logo, {})
                    })
                })
            }), jsxs("div", {
                className: "navbar__wrapper navbar__buttons",
                children: [jsx(LinkWithHover, {
                    to: `/about ${window.location.search}`,
                    className: clsx("navbar__item", "link", et === "/about" && "link--disable"),
                    onClick: ()=>{
                        properties.infiniteGridSignalEnd.dispatch()
                    }
                    ,
                    children: "About"
                }), jsx(ButtonWithHover, {
                    "aria-label": "Open contact modal",
                    className: clsx("navbar__item", "link"),
                    onClick: it,
                    children: "Contact"
                }), jsx(LusionExtLink, {
                    className: "navbar__item"
                })]
            }), nt ? null : et === "/" ? jsx(ViewSwitch, {
                className: clsx("navbar__wrapper navbar__views")
            }) : jsx("div", {
                className: "navbar__wrapper navbar__views",
                children: jsxs(LinkWithHover, {
                    to: `/${window.location.search}`,
                    className: "link go_back",
                    children: [jsx(Back, {}), jsx("span", {
                        children: "BACK"
                    })]
                })
            }), jsx("div", {
                className: clsx("navbar__wrapper navbar__theme", nt && "navbar__theme--show"),
                children: jsx(ThemeSwitcher, {})
            }), jsx("div", {
                className: "navbar__wrapper navbar__menu",
                onClick: ()=>{
                    useGlobalStore.setState(ot=>{
                        ot.showMobileMenuOverlay = !ot.showMobileMenuOverlay
                    }
                    )
                }
                ,
                children: nt ? jsx(CloseMenu, {}) : jsx(Menu$1, {})
            })]
        })
    })
}
function Check(et) {
    const nt = et
      , {fill: $="currentColor"} = nt
      , tt = nr(nt, ["fill"]);
    return jsxs("svg", kn(wn({
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: [jsx("path", {
            d: "M10.3934 16.5589C10.1498 16.8939 10.2239 17.3629 10.5589 17.6066C10.8939 17.8502 11.3629 17.7761 11.6066 17.4411L10.3934 16.5589ZM19.6066 6.44113C19.8502 6.10614 19.7761 5.63708 19.4411 5.39345C19.1061 5.14982 18.6371 5.22388 18.3934 5.55887L19.6066 6.44113ZM11.6066 17.4411L19.6066 6.44113L18.3934 5.55887L10.3934 16.5589L11.6066 17.4411Z",
            fill: $
        }), jsx("path", {
            d: "M10.4143 17.4685C10.6731 17.792 11.1451 17.8444 11.4685 17.5857C11.792 17.3269 11.8444 16.8549 11.5857 16.5315L10.4143 17.4685ZM7.58565 11.5315C7.32689 11.208 6.85493 11.1556 6.53148 11.4143C6.20803 11.6731 6.15559 12.1451 6.41435 12.4685L7.58565 11.5315ZM11.5857 16.5315L7.58565 11.5315L6.41435 12.4685L10.4143 17.4685L11.5857 16.5315Z",
            fill: $
        })]
    }))
}
const DAY_MS = 24 * 60 * 60 * 1e3
  , KEYS = {
    hasClosedSubscriptionModal: "hasClosedSubscriptionModal",
    subscriptionModalCloseTime: "subscriptionModalCloseTime",
    hasSubmittedSubcriptionModal: "hasSubmittedSubcriptionModal"
}
  , useLocalStore = create$1$1(et=>({
    hasClosedSubscriptionModal: !1,
    subscriptionModalCloseTime: -1,
    hasSubmittedSubcriptionModal: !1,
    fetchSubscriptionData: ()=>{
        let $ = Boolean(localStorage.getItem(KEYS.hasClosedSubscriptionModal)) || !1
          , tt = parseInt(localStorage.getItem(KEYS.subscriptionModalCloseTime)) || -1
          , nt = Boolean(localStorage.getItem(KEYS.hasSubmittedSubcriptionModal)) || !1;
        new Date().getTime() > tt + DAY_MS && (tt = -1,
        $ = !1),
        et(it=>kn(wn({}, it), {
            hasClosedSubscriptionModal: $,
            subscriptionModalCloseTime: tt,
            hasSubmittedSubcriptionModal: nt
        }))
    }
    ,
    closeSubscriptionModal: ()=>{
        let $ = !0
          , tt = new Date().getTime();
        localStorage.setItem(KEYS.hasClosedSubscriptionModal, $),
        localStorage.setItem(KEYS.subscriptionModalCloseTime, tt),
        et(nt=>kn(wn({}, nt), {
            hasClosedSubscriptionModal: $,
            subscriptionModalCloseTime: tt
        }))
    }
    ,
    submittedSubscriptionModal: ()=>{
        let $ = !0;
        localStorage.setItem(KEYS.hasSubmittedSubcriptionModal, $),
        et(tt=>kn(wn({}, tt), {
            hasSubmittedSubcriptionModal: $
        }))
    }
}));
var propTypes = {
    exports: {}
}
  , ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
  , ReactPropTypesSecret_1 = ReactPropTypesSecret$1
  , ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
    function et(nt, rt, it, ot, st, lt) {
        if (lt !== ReactPropTypesSecret) {
            var ut = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw ut.name = "Invariant Violation",
            ut
        }
    }
    et.isRequired = et;
    function $() {
        return et
    }
    var tt = {
        array: et,
        bigint: et,
        bool: et,
        func: et,
        number: et,
        object: et,
        string: et,
        symbol: et,
        any: et,
        arrayOf: $,
        element: et,
        elementType: et,
        instanceOf: $,
        node: et,
        objectOf: $,
        oneOf: $,
        oneOfType: $,
        shape: $,
        exact: $,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
    };
    return tt.PropTypes = tt,
    tt
};
propTypes.exports = factoryWithThrowingShims();
var PropTypes = propTypes.exports
  , browser = {
    exports: {}
}
  , debug$1 = {
    exports: {}
}
  , s = 1e3
  , m$1 = s * 60
  , h$1 = m$1 * 60
  , d$1 = h$1 * 24
  , y = d$1 * 365.25
  , ms = function(et, $) {
    $ = $ || {};
    var tt = typeof et;
    if (tt === "string" && et.length > 0)
        return parse$2(et);
    if (tt === "number" && isNaN(et) === !1)
        return $.long ? fmtLong(et) : fmtShort(et);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(et))
};
function parse$2(et) {
    if (et = String(et),
    !(et.length > 100)) {
        var $ = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(et);
        if (!!$) {
            var tt = parseFloat($[1])
              , nt = ($[2] || "ms").toLowerCase();
            switch (nt) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
                return tt * y;
            case "days":
            case "day":
            case "d":
                return tt * d$1;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
                return tt * h$1;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
                return tt * m$1;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
                return tt * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
                return tt;
            default:
                return
            }
        }
    }
}
function fmtShort(et) {
    return et >= d$1 ? Math.round(et / d$1) + "d" : et >= h$1 ? Math.round(et / h$1) + "h" : et >= m$1 ? Math.round(et / m$1) + "m" : et >= s ? Math.round(et / s) + "s" : et + "ms"
}
function fmtLong(et) {
    return plural(et, d$1, "day") || plural(et, h$1, "hour") || plural(et, m$1, "minute") || plural(et, s, "second") || et + " ms"
}
function plural(et, $, tt) {
    if (!(et < $))
        return et < $ * 1.5 ? Math.floor(et / $) + " " + tt : Math.ceil(et / $) + " " + tt + "s"
}
(function(et, $) {
    $ = et.exports = rt.debug = rt.default = rt,
    $.coerce = lt,
    $.disable = ot,
    $.enable = it,
    $.enabled = st,
    $.humanize = ms,
    $.names = [],
    $.skips = [],
    $.formatters = {};
    var tt;
    function nt(ut) {
        var ct = 0, ht;
        for (ht in ut)
            ct = (ct << 5) - ct + ut.charCodeAt(ht),
            ct |= 0;
        return $.colors[Math.abs(ct) % $.colors.length]
    }
    function rt(ut) {
        function ct() {
            if (!!ct.enabled) {
                var ht = ct
                  , ft = +new Date
                  , gt = ft - (tt || ft);
                ht.diff = gt,
                ht.prev = tt,
                ht.curr = ft,
                tt = ft;
                for (var vt = new Array(arguments.length), yt = 0; yt < vt.length; yt++)
                    vt[yt] = arguments[yt];
                vt[0] = $.coerce(vt[0]),
                typeof vt[0] != "string" && vt.unshift("%O");
                var wt = 0;
                vt[0] = vt[0].replace(/%([a-zA-Z%])/g, function(_t, bt) {
                    if (_t === "%%")
                        return _t;
                    wt++;
                    var Mt = $.formatters[bt];
                    if (typeof Mt == "function") {
                        var St = vt[wt];
                        _t = Mt.call(ht, St),
                        vt.splice(wt, 1),
                        wt--
                    }
                    return _t
                }),
                $.formatArgs.call(ht, vt);
                var mt = ct.log || $.log || console.log.bind(console);
                mt.apply(ht, vt)
            }
        }
        return ct.namespace = ut,
        ct.enabled = $.enabled(ut),
        ct.useColors = $.useColors(),
        ct.color = nt(ut),
        typeof $.init == "function" && $.init(ct),
        ct
    }
    function it(ut) {
        $.save(ut),
        $.names = [],
        $.skips = [];
        for (var ct = (typeof ut == "string" ? ut : "").split(/[\s,]+/), ht = ct.length, ft = 0; ft < ht; ft++)
            !ct[ft] || (ut = ct[ft].replace(/\*/g, ".*?"),
            ut[0] === "-" ? $.skips.push(new RegExp("^" + ut.substr(1) + "$")) : $.names.push(new RegExp("^" + ut + "$")))
    }
    function ot() {
        $.enable("")
    }
    function st(ut) {
        var ct, ht;
        for (ct = 0,
        ht = $.skips.length; ct < ht; ct++)
            if ($.skips[ct].test(ut))
                return !1;
        for (ct = 0,
        ht = $.names.length; ct < ht; ct++)
            if ($.names[ct].test(ut))
                return !0;
        return !1
    }
    function lt(ut) {
        return ut instanceof Error ? ut.stack || ut.message : ut
    }
}
)(debug$1, debug$1.exports);
(function(et, $) {
    $ = et.exports = debug$1.exports,
    $.log = rt,
    $.formatArgs = nt,
    $.save = it,
    $.load = ot,
    $.useColors = tt,
    $.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : st(),
    $.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"];
    function tt() {
        return typeof window != "undefined" && window.process && window.process.type === "renderer" ? !0 : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
    }
    $.formatters.j = function(lt) {
        try {
            return JSON.stringify(lt)
        } catch (ut) {
            return "[UnexpectedJSONParseError]: " + ut.message
        }
    }
    ;
    function nt(lt) {
        var ut = this.useColors;
        if (lt[0] = (ut ? "%c" : "") + this.namespace + (ut ? " %c" : " ") + lt[0] + (ut ? "%c " : " ") + "+" + $.humanize(this.diff),
        !!ut) {
            var ct = "color: " + this.color;
            lt.splice(1, 0, ct, "color: inherit");
            var ht = 0
              , ft = 0;
            lt[0].replace(/%[a-zA-Z%]/g, function(gt) {
                gt !== "%%" && (ht++,
                gt === "%c" && (ft = ht))
            }),
            lt.splice(ft, 0, ct)
        }
    }
    function rt() {
        return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments)
    }
    function it(lt) {
        try {
            lt == null ? $.storage.removeItem("debug") : $.storage.debug = lt
        } catch {}
    }
    function ot() {
        var lt;
        try {
            lt = $.storage.debug
        } catch {}
        return !lt && typeof process != "undefined" && "env"in process && (lt = {}.DEBUG),
        lt
    }
    $.enable(ot());
    function st() {
        try {
            return window.localStorage
        } catch {}
    }
}
)(browser, browser.exports);
var debug = browser.exports("jsonp")
  , jsonp_1 = jsonp
  , count = 0;
function noop() {}
function jsonp(et, $, tt) {
    typeof $ == "function" && (tt = $,
    $ = {}),
    $ || ($ = {});
    var nt = $.prefix || "__jp", rt = $.name || nt + count++, it = $.param || "callback", ot = $.timeout != null ? $.timeout : 6e4, st = encodeURIComponent, lt = document.getElementsByTagName("script")[0] || document.head, ut, ct;
    ot && (ct = setTimeout(function() {
        ht(),
        tt && tt(new Error("Timeout"))
    }, ot));
    function ht() {
        ut.parentNode && ut.parentNode.removeChild(ut),
        window[rt] = noop,
        ct && clearTimeout(ct)
    }
    function ft() {
        window[rt] && ht()
    }
    return window[rt] = function(gt) {
        debug("jsonp got", gt),
        ht(),
        tt && tt(null, gt)
    }
    ,
    et += (~et.indexOf("?") ? "&" : "?") + it + "=" + st(rt),
    et = et.replace("?&", "?"),
    debug('jsonp req "%s"', et),
    ut = document.createElement("script"),
    ut.src = et,
    lt.parentNode.insertBefore(ut, lt),
    ft
}
var toQuerystring_min = {
    exports: {}
};
(function(et, $) {
    (function(tt, nt) {
        et.exports = nt()
    }
    )(commonjsGlobal, function() {
        return (()=>{
            var tt = {
                d: (ct,ht)=>{
                    for (var ft in ht)
                        tt.o(ht, ft) && !tt.o(ct, ft) && Object.defineProperty(ct, ft, {
                            enumerable: !0,
                            get: ht[ft]
                        })
                }
                ,
                o: (ct,ht)=>Object.prototype.hasOwnProperty.call(ct, ht),
                r: ct=>{
                    typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(ct, Symbol.toStringTag, {
                        value: "Module"
                    }),
                    Object.defineProperty(ct, "__esModule", {
                        value: !0
                    })
                }
            }
              , nt = {};
            function rt(ct) {
                return rt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ht) {
                    return typeof ht
                }
                : function(ht) {
                    return ht && typeof Symbol == "function" && ht.constructor === Symbol && ht !== Symbol.prototype ? "symbol" : typeof ht
                }
                ,
                rt(ct)
            }
            tt.r(nt),
            tt.d(nt, {
                default: ()=>ut
            });
            var it = encodeURIComponent;
            function ot(ct, ht, ft, gt, vt) {
                var yt = gt && vt.arrayPrefix || "";
                if (rt(ht) === "object") {
                    var wt = "".concat(ct).concat(yt).concat(ft && "]", "[");
                    return "".concat(lt(ht, "".concat(ft).concat(wt), vt))
                }
                return ft && ft.length ? "".concat(ft).concat(ct, "]").concat(yt, "=").concat(it(ht)) : "".concat(ct).concat(yt, "=").concat(it(ht))
            }
            function st(ct, ht, ft, gt) {
                return ht.map(function(vt) {
                    return ot(ct, vt, ft, !0, gt)
                }).join("&")
            }
            function lt(ct) {
                var ht = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ""
                  , ft = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                return (Array.isArray(ct) ? ct.map(function(gt, vt) {
                    return ot("".concat(vt), gt, ht, !0, ft)
                }) : Object.keys(ct).filter(function(gt) {
                    return ct[gt] !== void 0
                }).map(function(gt) {
                    return ct[gt] && Array.isArray(ct[gt]) ? st("".concat(gt), ct[gt], ht, ft) : ot(gt, ct[gt], ht, !1, ft)
                })).join("&").replace(/%20/g, "+")
            }
            const ut = lt;
            return nt
        }
        )()
    })
}
)(toQuerystring_min);
var toQueryString = getDefaultExportFromCjs(toQuerystring_min.exports)
  , SimpleForm = function et($) {
    var tt = $.status
      , nt = $.message
      , rt = $.className
      , it = $.style
      , ot = $.onSubmitted
      , st = void 0
      , lt = function() {
        return st && st.value.indexOf("@") > -1 && ot({
            EMAIL: st.value
        })
    };
    return React.createElement("div", {
        className: rt,
        style: it
    }, tt === "sending" && React.createElement("div", {
        style: {
            color: "blue"
        }
    }, "sending..."), tt === "error" && React.createElement("div", {
        style: {
            color: "red"
        },
        dangerouslySetInnerHTML: {
            __html: nt
        }
    }), tt === "success" && React.createElement("div", {
        style: {
            color: "green"
        },
        dangerouslySetInnerHTML: {
            __html: nt
        }
    }), React.createElement("input", {
        ref: function(ct) {
            return st = ct
        },
        type: "email",
        placeholder: "Your email"
    }), React.createElement("button", {
        onClick: lt
    }, "Submit"))
};
function _classCallCheck(et, $) {
    if (!(et instanceof $))
        throw new TypeError("Cannot call a class as a function")
}
function _possibleConstructorReturn(et, $) {
    if (!et)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return $ && (typeof $ == "object" || typeof $ == "function") ? $ : et
}
function _inherits(et, $) {
    if (typeof $ != "function" && $ !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof $);
    et.prototype = Object.create($ && $.prototype, {
        constructor: {
            value: et,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    $ && (Object.setPrototypeOf ? Object.setPrototypeOf(et, $) : et.__proto__ = $)
}
var getAjaxUrl = function et($) {
    return $.replace("/post?", "/post-json?")
}
  , MailchimpSubscribe = function(et) {
    _inherits($, et);
    function $() {
        var tt, nt, rt;
        _classCallCheck(this, $);
        for (var it = arguments.length, ot = Array(it), st = 0; st < it; st++)
            ot[st] = arguments[st];
        return rt = (tt = (nt = _possibleConstructorReturn(this, et.call.apply(et, [this].concat(ot))),
        nt),
        nt.state = {
            status: null,
            message: null
        },
        nt.subscribe = function(lt) {
            var ut = toQueryString(lt)
              , ct = getAjaxUrl(nt.props.url) + "&" + ut;
            nt.setState({
                status: "sending",
                message: null
            }, function() {
                return jsonp_1(ct, {
                    param: "c"
                }, function(ht, ft) {
                    ht ? nt.setState({
                        status: "error",
                        message: ht
                    }) : ft.result !== "success" ? nt.setState({
                        status: "error",
                        message: ft.msg
                    }) : nt.setState({
                        status: "success",
                        message: ft.msg
                    })
                })
            })
        }
        ,
        tt),
        _possibleConstructorReturn(nt, rt)
    }
    return $.prototype.render = function() {
        return this.props.render({
            subscribe: this.subscribe,
            status: this.state.status,
            message: this.state.message
        })
    }
    ,
    $
}(React.Component);
MailchimpSubscribe.propTypes = {};
MailchimpSubscribe.defaultProps = {
    render: function et($) {
        var tt = $.subscribe
          , nt = $.status
          , rt = $.message;
        return React.createElement(SimpleForm, {
            status: nt,
            message: rt,
            onSubmitted: function(ot) {
                return tt(ot)
            }
        })
    }
};
const URL$1 = "https://lusion.us20.list-manage.com/subscribe/post?u=ea813c53ac6d7a0b76f2e36a1&amp;id=44b41b41bf&amp;v_id=4233&amp;f_id=001e18e7f0"
  , MailchimpForm = it=>{
    var ot = it
      , {status: et, message: $, onValidated: tt, modal: nt} = ot
      , rt = nr(ot, ["status", "message", "onValidated", "modal"]);
    let[st,lt] = react.exports.useState("");
    const ut = gt=>{
        gt.preventDefault(),
        st && st.indexOf("@") > -1 && tt({
            EMAIL: st
        }),
        useLocalStore.getState().submittedSubscriptionModal()
    }
      , ct = et === "sending"
      , ht = et === "success"
      , ft = et === "error";
    return react.exports.useEffect(()=>{
        st && ht && (lt("check your email to confirm!".toUpperCase()),
        nt && setTimeout(()=>{
            useGlobalStore.setState(gt=>gt.showSubscribeModal = !1)
        }
        , 1e3))
    }
    , [st, ht]),
    jsxs("form", {
        className: "mcForm",
        onSubmit: ut,
        children: [jsx("input", {
            className: clsx("input", "subscribe__input", ht && "subscribe__input--success", ft && "subscribe__input--error"),
            id: nt ? "modal-subscribe-email" : "subscribe-email",
            placeholder: "EMAIL ADDRESS",
            type: "email",
            autoComplete: "email",
            required: !0,
            disabled: ht,
            value: st,
            onChange: gt=>lt(gt.target.value)
        }), ht ? jsx(Check, {
            fill: "white",
            className: "subscribe__submit-btn"
        }) : jsx(CardButton, {
            onClick: ut,
            arrow: !!((st == null ? void 0 : st.length) && !ct),
            className: clsx("subscribe__submit-btn", ct && "--sending")
        })]
    })
}
;
function Subscribe(et) {
    const {modal: $, className: tt} = et
      , nt = ()=>{
        useGlobalStore.setState(it=>{
            updateLucyEmote("happy"),
            it.isCursorHovering = !0
        }
        )
    }
      , rt = ()=>{
        useGlobalStore.setState(it=>{
            updateLucyEmote(),
            it.isCursorHovering = !1
        }
        )
    }
    ;
    return jsxs("div", {
        className: clsx("subscribe", tt),
        onMouseEnter: nt,
        onMouseLeave: rt,
        children: [jsxs("div", {
            children: [jsx("span", {
                className: "subscribe__label",
                children: "subscribe"
            }), jsx("span", {
                className: "subscribe__spam",
                children: "(you may opt out anytime)"
            })]
        }), jsx(MailchimpSubscribe, {
            url: URL$1,
            render: ({subscribe: it, status: ot, message: st})=>jsx(MailchimpForm, {
                modal: $,
                status: ot,
                message: st,
                onValidated: lt=>it(lt)
            })
        })]
    })
}
function SubscribeModal(et) {
    const {active: $} = et
      , tt = react.exports.useRef()
      , nt = react.exports.useRef(0)
      , [rt,it] = react.exports.useState(1e3)
      , ot = useGlobalStore(ut=>ut.width, shallow)
      , st = useGlobalStore(ut=>ut.height, shallow);
    react.exports.useEffect(()=>{
        const {height: ut} = tt.current.getBoundingClientRect();
        it(ut)
    }
    , [it, ot, st]);
    const lt = ()=>{
        useGlobalStore.setState(ut=>ut.showSubscribeModal = !1),
        useLocalStore.getState().closeSubscriptionModal()
    }
    ;
    return useAnimationFrame(ut=>{
        nt.current = math.saturate(nt.current + ut * ($ ? 1 : -1)),
        tt.current.style.transform = `translateY(${math.mix(rt + 80, 0, ease.cubicInOut(nt.current))}px)`
    }
    ),
    jsx("div", {
        ref: tt,
        className: "subscribe-modal",
        children: jsxs("div", {
            className: "subscribe-modal__content",
            children: [jsx(Subscribe, {
                modal: !0
            }), jsx(Close, {
                className: "subscribe-modal__close-btn",
                onClick: lt
            })]
        })
    })
}
function LusionLogoMobile(et) {
    const nt = et
      , {fill: $="currentColor"} = nt
      , tt = nr(nt, ["fill"]);
    return jsxs("svg", kn(wn({
        width: "20",
        height: "24",
        viewBox: "0 0 20 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: [jsx("path", {
            d: "M0.548828 0H6.7377V18H0.548828V0Z",
            fill: $
        }), jsx("path", {
            d: "M6.7377 18L6.73769 24H19.1154V18L6.7377 18Z",
            fill: $
        })]
    }))
}
function LusionLogoDesktop(et) {
    const nt = et
      , {fill: $="currentColor"} = nt
      , tt = nr(nt, ["fill"]);
    return jsxs("svg", kn(wn({
        width: "22",
        height: "30",
        viewBox: "0 0 22 30",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: [jsx("path", {
            d: "M0 0H7.33333V22.5H0V0Z",
            fill: $
        }), jsx("path", {
            d: "M7.33333 22.5L7.33333 30H22V22.5L7.33333 22.5Z",
            fill: $
        })]
    }))
}
function LusionLogo(et) {
    return useGlobalStore(nt=>nt.width, shallow) <= 1024 ? jsx(LusionLogoMobile, wn({}, et)) : jsx(LusionLogoDesktop, wn({}, et))
}
const HOUR_MESSAGES = {
    MORNING: "Good Morning",
    AFTERNOON: "Good Afternoon",
    EVENING: "Good Evening",
    NIGHT: "Good Night"
};
function getMessage(et) {
    return et >= 21 ? HOUR_MESSAGES.NIGHT : et >= 17 ? HOUR_MESSAGES.EVENING : et >= 12 ? HOUR_MESSAGES.AFTERNOON : et >= 5 ? HOUR_MESSAGES.MORNING : HOUR_MESSAGES.NIGHT
}
function CurrentHour() {
    const [et,$] = react.exports.useState()
      , [tt,nt] = react.exports.useState();
    return react.exports.useEffect(()=>{
        const rt = setInterval(()=>{
            const it = new Date
              , ot = it.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1")
              , st = it.getHours();
            nt(getMessage(st)),
            $(ot)
        }
        , 1e3);
        return ()=>clearInterval(rt)
    }
    , []),
    jsxs(Fragment, {
        children: [jsx("span", {
            children: et
        }), jsx("span", {
            className: "footer__current-time--message",
            children: tt
        })]
    })
}
function CurlyLine() {
    return jsx("div", {
        className: "footer__line-wrapper",
        children: jsx("svg", {
            className: "footer__line",
            width: "823",
            height: "7",
            viewBox: "0 0 823 7",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: jsx("path", {
                d: "M1 3.5C5.2.2 9.4.2 13.7 3.5c4.2 3.3 8.4 3.3 12.6 0C30.6.2 34.8.2 39 3.5c4.2 3.3 8.5 3.3 12.7 0C55.9.2 60 .2 64.3 3.5c4.3 3.3 8.5 3.3 12.7 0 4.2-3.3 8.5-3.3 12.7 0 4.2 3.3 8.4 3.3 12.7 0 4.2-3.3 8.4-3.3 12.6 0 4.3 3.3 8.5 3.3 12.7 0 4.2-3.3 8.4-3.3 12.7 0 4.2 3.3 8.4 3.3 12.6 0 4.3-3.3 8.5-3.3 12.7 0 4.2 3.3 8.5 3.3 12.7 0 4.2-3.3 8.4-3.3 12.6 0 4.3 3.3 8.5 3.3 12.7 0 4.2-3.3 8.5-3.3 12.7 0 4.2 3.3 8.4 3.3 12.7 0 4.2-3.3 8.4-3.3 12.6 0 4.2 3.3 8.5 3.3 12.7 0 4.2-3.3 8.4-3.3 12.7 0 4.2 3.3 8.4 3.3 12.6 0 4.3-3.3 8.5-3.3 12.7 0 4.2 3.3 8.5 3.3 12.7 0 4.2-3.3 8.4-3.3 12.6 0 4.3 3.3 8.5 3.3 12.7 0 4.2-3.3 8.5-3.3 12.7 0 4.2 3.3 8.4 3.3 12.7 0 4.2-3.3 8.4-3.3 12.6 0 4.2 3.3 8.5 3.3 12.7 0 4.2-3.3 8.4-3.3 12.7 0 4.2 3.3 8.4 3.3 12.6 0 4.3-3.3 8.5-3.3 12.7 0 4.2 3.3 8.4 3.3 12.7 0 4.2-3.3 8.4-3.3 12.6 0 4.3 3.3 8.5 3.3 12.7 0 4.2-3.3 8.5-3.3 12.7 0 4.2 3.3 8.4 3.3 12.7 0 4.2-3.3 8.4-3.3 12.6 0 4.2 3.3 8.5 3.3 12.7 0 4.2-3.3 8.4-3.3 12.7 0 4.2 3.3 8.4 3.3 12.6 0 4.3-3.3 8.5-3.3 12.7 0 4.2 3.3 8.4 3.3 12.7 0 4.2-3.3 8.4-3.3 12.6 0 4.3 3.3 8.5 3.3 12.7 0 4.2-3.3 8.5-3.3 12.7 0 4.2 3.3 8.4 3.3 12.6 0 4.3-3.3 8.5-3.3 12.7 0 4.2 3.3 8.5 3.3 12.7 0 4.2-3.3 8.4-3.3 12.7 0 4.2 3.3 8.4 3.3 12.6 0 4.3-3.3 8.5-3.3 12.7 0 4.2 3.3 8.4 3.3 12.7 0 4.2-3.3 8.4-3.3 12.6 0 4.3 3.3 8.5 3.3 12.7 0 4.2-3.3 8.5-3.3 12.7 0 4.2 3.3 8.4 3.3 12.6 0 4.3-3.3 8.5-3.3 12.7 0 4.2 3.3 8.5 3.3 12.7 0 4.2-3.3 8.4-3.3 12.7 0 4.2 3.3 8.4 3.3 12.6 0 4.2-3.3 8.5-3.3 12.7 0 4.2 3.3 8.4 3.3 12.7 0m-15.2 0c4.2-3.3 8.4-3.3 12.6 0 4.3 3.3 8.5 3.3 12.7 0",
                stroke: "currentColor"
            })
        })
    })
}
function Footer(et) {
    const {isContact: $} = et
      , tt = react.exports.useRef();
    return jsxs("div", {
        id: $ ? null : "footer",
        className: "footer",
        ref: tt,
        children: [jsxs(GridView, {
            className: "footer__first-row",
            children: [jsx("div", {
                className: "footer__logo",
                children: jsx(SvgLogo, {})
            }), jsxs("div", {
                className: "footer__follow",
                children: [jsx("div", {
                    className: "footer__title t-title-mono",
                    children: "labs area"
                }), jsxs("div", {
                    className: "footer__desc",
                    children: [jsx("span", {
                        children: "play ground"
                    }), jsx("span", {
                        children: "r&d collection"
                    }), jsx("span", {
                        children: "experiments"
                    })]
                })]
            }), jsxs("div", {
                className: "footer__share",
                children: [jsx("div", {
                    className: "footer__title t-title-mono",
                    children: "follow"
                }), jsx(SocialLinks, {
                    className: "footer__share-links"
                })]
            }), jsx(Close, {
                className: "footer__close-btn",
                onClick: ()=>useGlobalStore.setState(nt=>nt.showContactOverlay = !1)
            })]
        }), jsxs(GridView, {
            className: "footer__second-row",
            children: [jsx("div", {
                className: "footer__empty --half"
            }), jsxs("div", {
                className: "footer__subscribe",
                children: [jsx("div", {
                    className: "footer__title t-title-mono",
                    children: "newsletter"
                }), jsx(Subscribe, {
                    modal: $
                })]
            }), jsxs("div", {
                className: "footer__contact",
                children: [jsx("div", {
                    className: "footer__title t-title-mono",
                    children: "contact"
                }), jsx(ContactEmail, {})]
            })]
        }), jsxs(GridView, {
            children: [jsx(CurrentDate, {}), jsxs("div", {
                className: "footer__flex-stuff",
                children: [jsx("span", {
                    children: "the r&d division"
                }), jsxs("div", {
                    className: "footer__flex-stuff--inline",
                    children: [jsx("span", {
                        children: "of creative studio"
                    }), jsx(CurlyLine, {}), jsx(LusionExtLink, {
                        arrowBefore: !0
                    })]
                })]
            }), jsx("div", {
                className: "footer__current-time",
                children: jsx(CurrentHour, {})
            }), jsx(LusionLogo, {
                className: "footer__lusion-logo"
            })]
        })]
    })
}
function CurrentDate() {
    const et = react.exports.useState(()=>`\xA9 ${new Date().getFullYear()}`)[0];
    return jsx("span", {
        className: "footer__current-year",
        children: et
    })
}
function SocialLinks(et) {
    return jsxs("div", kn(wn({}, et), {
        children: [jsx(ContactLinkedin, {}), jsx(ContactInstagram, {}), jsx(ContactTwitter, {})]
    }))
}
const ExtLinkWithHover = withHover(et=>{
    let rt = et
      , {children: $, isHovered: tt} = rt
      , nt = nr(rt, ["children", "isHovered"]);
    return jsx("a", kn(wn({}, nt), {
        children: $
    }))
}
);
function ContactLinkedin(et) {
    return jsx(ExtLinkWithHover, kn(wn({
        className: "link",
        target: "_blank",
        href: "https://www.linkedin.com/company/lusionltd/"
    }, et), {
        children: "linkedin"
    }))
}
function ContactInstagram(et) {
    return jsx(ExtLinkWithHover, kn(wn({
        className: "link",
        target: "_blank",
        href: "https://www.instagram.com/lusionltd/"
    }, et), {
        children: "instagram"
    }))
}
function ContactTwitter(et) {
    return jsx(ExtLinkWithHover, kn(wn({
        className: "link",
        target: "_blank",
        href: "https://twitter.com/lusionltd"
    }, et), {
        children: "twitter"
    }))
}
function ContactEmail(et) {
    return jsx(ExtLinkWithHover, kn(wn({
        className: "link",
        href: "mailto:hello@lusion.co"
    }, et), {
        children: "hello@lusion.co"
    }))
}
function Contact() {
    const et = react.exports.useRef()
      , $ = react.exports.useRef()
      , tt = react.exports.useRef(0)
      , nt = react.exports.useRef(0)
      , rt = useGlobalStore(ot=>ot.width, shallow)
      , it = useGlobalStore(ot=>ot.showContactOverlay, shallow);
    return react.exports.useEffect(()=>{
        if (!et.current)
            return;
        const ot = et.current.getBoundingClientRect();
        tt.current = ot.height
    }
    , [rt]),
    useAnimationFrame(ot=>{
        !et.current || !$.current || tt.current !== 0 && (nt.current += ot * (it ? 1 : -1),
        nt.current = math.saturate(nt.current),
        et.current.style.transform = `translateY(${ease.quintInOut(1 - nt.current) * tt.current}px)`,
        $.current.style.opacity = .75 * ease.cubicInOut(nt.current),
        $.current.style.display = nt.current === 0 ? "none" : "block")
    }
    ),
    rt > 768 ? jsxs(Fragment, {
        children: [jsx("div", {
            ref: $,
            className: "contact__blocking-bg",
            onClick: ()=>{
                useGlobalStore.setState(ot=>{
                    ot.showContactOverlay = !1
                }
                )
            }
        }), jsx("div", {
            ref: et,
            className: "contact",
            children: jsx(Footer, {})
        })]
    }) : null
}
const STYLES$1 = {
    position: "fixed",
    width: "100vw",
    height: "100vh",
    zIndex: 100,
    left: 0,
    top: 0
};
let DPR = window.devicePixelRatio
  , viewportWidth = window.innerWidth
  , viewportHeight = window.innerHeight
  , direction = 1
  , duration = 2.5
  , progress = -1;
const colorsLight = ["#000", "#555", "#fff"]
  , colorsDark = ["#fff", "#555", "#000"];
function easeInOutPow(et, $) {
    return et > .5 ? 1 - Math.pow((1 - et) * 2, $) * .5 : Math.pow(et * 2, $) * .5
}
function clamp(et, $, tt) {
    return et < $ ? $ : et > tt ? tt : et
}
function cUnMix(et, $, tt) {
    return clamp((tt - et) / ($ - et), 0, 1)
}
function fit(et, $, tt, nt, rt, it) {
    return et = cUnMix($, tt, et),
    it && (et = it(et)),
    nt + et * (rt - nt)
}
function TransitionCover({active: et, callback: $}) {
    const tt = react.exports.useRef()
      , nt = react.exports.useRef()
      , rt = react.exports.useRef(duration)
      , it = useGlobalStore(({currentTheme: ot})=>ot);
    return react.exports.useEffect(()=>{
        const ot = ()=>{
            !tt.current || (viewportWidth = window.innerWidth,
            viewportHeight = window.innerHeight,
            tt.current.width = viewportWidth * DPR,
            tt.current.height = viewportHeight * DPR)
        }
        ;
        return ot(),
        window.addEventListener("resize", ot),
        ()=>window.removeEventListener("resize", ot)
    }
    , []),
    react.exports.useEffect(()=>{
        et && (rt.current = 0)
    }
    , [et]),
    useAnimationFrame(ot=>{
        if (!tt.current)
            return;
        nt.current || (nt.current = tt.current.getContext("2d")),
        rt.current += ot;
        const st = progress;
        if (progress = Math.max(-1, Math.min(1, rt.current / duration * 2 - 1)),
        st !== progress) {
            nt.current.save(),
            nt.current.scale(DPR, DPR),
            nt.current.clearRect(0, 0, viewportWidth, viewportHeight);
            const lt = 8 * Math.PI / 180
              , ut = Math.tan(lt) * viewportWidth
              , ct = it === THEMES.DARK.id ? colorsDark : colorsLight
              , ht = ct.length
              , ft = .08
              , gt = ft / (ht - 1);
            for (let vt = 0; vt < ht; vt++) {
                let yt = (progress + 1) % 1;
                const wt = progress > 0 ? ht - 1 - vt : vt;
                yt = fit(yt, wt * gt, 1 - ft + wt * gt, 0, 1);
                const mt = easeInOutPow(yt, 3)
                  , bt = (Math.floor(progress) + mt) * (viewportHeight + ut) * direction;
                nt.current.fillStyle = ct[vt],
                nt.current.beginPath(),
                nt.current.moveTo(0, bt),
                nt.current.lineTo(viewportWidth, -ut + bt),
                nt.current.lineTo(viewportWidth, viewportHeight + bt),
                nt.current.lineTo(0, viewportHeight + ut + bt),
                nt.current.closePath(),
                nt.current.fill()
            }
            nt.current.restore(),
            $ && st < 0 && progress >= 0 && $()
        }
        tt.current.style.display = progress === 1 ? "none" : "block"
    }
    ),
    jsx("canvas", {
        ref: tt,
        className: "transition-cover",
        style: STYLES$1
    })
}
const lineStyle = {
    height: "100vh",
    width: "1px",
    background: "red",
    position: "fixed"
}
  , COUNT = 4;
function TestGrid() {
    return jsx("div", {
        style: {
            position: "fixed",
            zIndex: 99999
        },
        children: new Array(COUNT).fill(1).map((et,$)=>jsx("div", {
            style: kn(wn({}, lineStyle), {
                left: `${$ / COUNT * 100}%`
            })
        }, $))
    })
}
function useFetch(et, $=!1) {
    const [tt,nt] = react.exports.useState(null)
      , [rt,it] = react.exports.useState(!0)
      , [ot,st] = react.exports.useState(!1);
    return react.exports.useEffect(()=>{
        !et || (it(!0),
        fetch(et).then(lt=>$ ? lt.json() : lt.text()).then(lt=>{
            nt(lt),
            st(!1),
            it(!1)
        }
        ).catch(lt=>{
            it(!1),
            st(!0),
            nt(null)
        }
        ))
    }
    , [et, $]),
    {
        data: tt,
        isLoading: rt,
        isError: ot
    }
}
const CARD_WIDTH = {
    0: 7,
    1: 9,
    2: 11,
    3: 13,
    4: 17,
    5: 22
}
  , CARD_HEIGHT = {
    0: 9,
    1: 12,
    2: 15
};
let dataCount = 0;
const useDataStore = create$1$1(et=>({
    experimentsInGrid: [],
    experimentsFlatList: [],
    hasLoaded: !1,
    resizeTicker: 0,
    setData: $=>{
        dataCount = 0;
        const {experiments: tt, grid: nt} = $
          , it = nt.map(ot=>dataInGridRow(ot, tt)).map(processExperimentData).filter(ot=>ot);
        et(ot=>kn(wn({}, ot), {
            experimentsInGrid: it,
            experimentsFlatList: it,
            hasLoaded: !0
        }))
    }
    ,
    tickResize: ()=>{
        et($=>kn(wn({}, $), {
            resizeTicker: $.resizeTicker + 1
        }))
    }
}));
function dataInGridRow(et, $) {
    let tt = Object.values($).find(nt=>nt.id === et.id);
    return tt ? wn(wn({}, tt), et) : null
}
function processExperimentData(et, $) {
    if (!et)
        return null;
    const {id: tt, card: nt} = et
      , {width: rt, height: it} = nt;
    return kn(wn({}, et), {
        index: $,
        nId: ++dataCount,
        listImg: `/assets/images/${tt}/list_thumb.jpg`,
        detailImg: `/assets/images/${tt}/detail_page.jpg`,
        homepageImg: `/assets/images/${tt}/homepage_thumb.jpg`,
        originalImg: `/assets/images/${tt}/original.jpg`,
        smallImg: `/assets/images/${tt}/small_thumb.jpg`,
        socialImg: `/assets/images/${tt}/social.jpg`,
        isFullscreen: rt === 5 || rt === 4,
        card: {
            width: CARD_WIDTH[rt],
            height: CARD_HEIGHT[it],
            __width: CARD_WIDTH[rt],
            __height: CARD_HEIGHT[it]
        },
        aspect: .5 + 1.2 * Math.random()
    })
}
function Menu({location: et}) {
    const $ = et === "/about"
      , tt = ()=>useGlobalStore.setState(nt=>nt.showMobileMenuOverlay = !1);
    return jsxs("div", {
        children: [jsxs(Link, {
            onClick: tt,
            to: `/${$ ? "" : "about"}${window.location.search}`,
            className: clsx("grid-view mobile-menu__row link"),
            children: [jsx("div", {
                className: "mobile-menu__link-label",
                children: $ ? "Home" : "About"
            }), jsx("div", {
                className: "mobile-menu__link-icon",
                children: jsx(ArrowRight24, {})
            })]
        }), jsxs("a", {
            onClick: tt,
            className: "grid-view  mobile-menu__row link",
            target: "_blank",
            href: "https://lusion.co/",
            children: [jsx("div", {
                className: "mobile-menu__link-label",
                children: "Lusion"
            }), jsx("div", {
                className: "mobile-menu__link-icon",
                children: jsx(ArrowTopRight24, {})
            })]
        }), jsx("div", {
            className: "grid-view  mobile-menu__row",
            children: jsx(Subscribe, {
                className: "mobile-menu__subscribe"
            })
        }), jsxs("div", {
            className: "grid-view mobile-menu__row mobile-menu__ext-links",
            children: [jsx(ContactLinkedin, {
                onClick: tt
            }), jsx(ContactInstagram, {
                onClick: tt
            }), jsx(ContactTwitter, {
                onClick: tt
            }), jsx(ContactEmail, {})]
        }), jsxs("div", {
            className: "grid-view mobile-menu__row",
            children: [jsx(CurrentDate, {}), jsx(LusionLogo, {
                className: "mobile-menu__link-icon"
            })]
        })]
    })
}
function MobileMenu() {
    const et = react.exports.useRef()
      , $ = react.exports.useRef()
      , tt = react.exports.useRef(0)
      , nt = react.exports.useRef(0)
      , rt = useGlobalStore(ot=>ot.width, shallow)
      , it = useGlobalStore(ot=>ot.showMobileMenuOverlay, shallow);
    return react.exports.useEffect(()=>{
        if (!et.current)
            return;
        const ot = et.current.getBoundingClientRect();
        tt.current = ot.height
    }
    , [rt]),
    useAnimationFrame(ot=>{
        !et.current || !$.current || tt.current !== 0 && (nt.current += ot * (it ? 1 : -1),
        nt.current = math.saturate(nt.current),
        et.current.style.transform = `translateY(${ease.expoInOut(1 - nt.current) * tt.current}px)`,
        $.current.style.opacity = .75 * ease.cubicInOut(nt.current),
        $.current.style.display = nt.current === 0 ? "none" : "block")
    }
    ),
    rt <= 768 ? jsxs(Fragment, {
        children: [jsx("div", {
            ref: $,
            className: "mobile-menu__blocking-bg",
            onClick: ()=>{
                useGlobalStore.setState(ot=>{
                    ot.showMobileMenuOverlay = !1
                }
                )
            }
        }), jsx("div", {
            ref: et,
            className: "mobile-menu",
            children: jsx(Menu, {})
        })]
    }) : null
}
function Cursor() {
    const [et,$,tt] = useGlobalStore(ct=>[ct.width, ct.height, ct.isCursorHovering], shallow)
      , [nt,rt] = react.exports.useState(!1)
      , it = react.exports.useRef({
        x: 0,
        y: 0
    })
      , [ot,st] = useSpring(()=>({
        x: -1e3,
        y: -1e3
    }))
      , lt = useSpring({
        t: tt ? 1 : 0,
        scale: tt ? .5 : 1,
        config: {
            mass: 1,
            tension: 320,
            friction: 12
        }
    })
      , ut = react.exports.useCallback(ct=>{
        it.current.x = ct.clientX,
        it.current.y = ct.clientY,
        st({
            x: it.current.x,
            y: it.current.y,
            config: {
                mass: 1,
                tension: 120,
                friction: 14
            }
        })
    }
    , [et, $]);
    return react.exports.useEffect(()=>{
        if (!browser$1.isMobile)
            return rt(!0),
            input.onMoved.add(ut),
            ()=>input.onMoved.remove(ut)
    }
    , [ut]),
    jsx(animated.div, {
        className: clsx("cursor", nt && "cursor--visible"),
        style: {
            x: ot.x,
            y: ot.y,
            scale: lt.scale
        }
    })
}
var Swipe = react.exports.forwardRef(function(et, $) {
    const ft = et
      , {children: tt, active: nt=!0, delay: rt=0, style: it, params: ot} = ft
      , st = nr(ft, ["children", "active", "delay", "style", "params"])
      , [lt,ut] = useSpring(()=>({
        opacity: 0
    }))
      , [ct,ht] = useSpring(()=>({
        scaleX: 0,
        transformOrigin: "center left"
    }));
    return react.exports.useEffect(()=>{
        ut.stop(),
        ht.stop(),
        nt && (ht(()=>({
            to: [{
                scaleX: 1,
                config: {
                    duration: ot.swipeDur,
                    easing: easings[ot.swipeEase]
                }
            }, {
                transformOrigin: "center right",
                config: {
                    duration: ot.swipeHold
                }
            }, {
                scaleX: 0,
                config: {
                    duration: ot.swipeDur,
                    easing: easings[ot.swipeEase]
                }
            }],
            delay: rt
        })),
        ut(()=>({
            to: [{
                opacity: 0,
                config: {
                    duration: .01
                }
            }, {
                opacity: 1,
                config: {
                    duration: .01
                },
                delay: 400 + rt
            }]
        })))
    }
    , [nt]),
    jsxs(animated.div, kn(wn({}, st), {
        ref: $,
        style: kn(wn({}, it), {
            position: "relative"
        }),
        children: [jsx(animated.div, {
            style: wn({
                position: "absolute",
                width: "100%",
                height: "100%",
                background: "black"
            }, ct)
        }), jsx(animated.div, {
            style: kn(wn({}, lt), {
                width: "100%"
            }),
            children: tt
        })]
    }))
});
const PARAMS$2 = {
    clipStart: "polygon(0 0, 0 0, 0 100%, 0 100%)",
    clipEnd: "polygon(0 0, 100% 0, 100% 100%, 0 100%)"
};
var ClipRight = react.exports.forwardRef(function(et, $) {
    const ct = et
      , {children: tt, active: nt=!0, delay: rt=0, style: it, params: ot} = ct
      , st = nr(ct, ["children", "active", "delay", "style", "params"])
      , [lt,ut] = useSpring(()=>({
        clipPath: PARAMS$2.clipStart,
        transition: `clip-path ${ot.duration}ms ${CSSEases[ot.easing]} ${rt}ms`
    }));
    return react.exports.useEffect(()=>{
        ut.stop(),
        nt && ut(()=>({
            to: {
                clipPath: PARAMS$2.clipEnd
            },
            delay: rt,
            config: {
                duration: 0
            }
        }))
    }
    , [nt]),
    jsx(animated.div, kn(wn({}, st), {
        ref: $,
        style: wn({}, it),
        children: jsx(animated.div, {
            style: kn(wn({}, lt), {
                width: "100%"
            }),
            children: tt
        })
    }))
})
  , ClipBottom = react.exports.forwardRef(function(et, $) {
    const mt = et
      , {children: tt, active: nt=!0, delay: rt=0, style: it, params: ot, layers: st=1} = mt
      , lt = nr(mt, ["children", "active", "delay", "style", "params", "layers"])
      , ut = react.exports.useRef(0)
      , ct = useGlobalStore(({currentTheme: _t})=>_t)
      , [ht,ft] = react.exports.useState(!1)
      , [gt,vt] = useSprings(st, ()=>({
        y: "100%",
        opacity: 0
    }))
      , yt = ct === THEMES.DARK ? ["#cccccc", "#999999"] : ["#999999", "#cccccc"]
      , wt = ot.config || {
        easing: easings[ot.easing],
        duration: ot.duration
    };
    return react.exports.useEffect(()=>{
        vt.stop(),
        vt(_t=>{
            let bt = nt ? "0%" : "100%";
            return _t > 0 && (bt = nt ? "-100%" : "0%"),
            {
                y: bt,
                opacity: nt ? 1 : 0,
                config: wt,
                delay: rt + _t * 50,
                onRest: ()=>{
                    ut.current += 1,
                    ut.current === st && ft(!0)
                }
            }
        }
        )
    }
    , [nt]),
    jsx(animated.div, kn(wn({}, lt), {
        ref: $,
        style: kn(wn({}, it), {
            overflow: ht ? "visible" : "hidden",
            position: "relative",
            display: "block"
        }),
        children: gt.map((_t,bt)=>ht && bt !== 0 ? null : jsx(animated.div, {
            style: kn(wn({}, _t), {
                width: "100%",
                position: bt === 0 ? "relative" : "absolute",
                display: "block",
                zIndex: st - bt,
                color: bt === 0 ? "unset" : yt[bt - 1]
            }),
            children: tt
        }, bt))
    }))
});
const PARAMS$1 = {
    xOffset: 30,
    xOverOffset: 10,
    endDelay: 200,
    rotateOffset: 45
};
var CustomAbout = react.exports.forwardRef(function(et, $) {
    const St = et
      , {children: tt, active: nt=!0, delay: rt=0, style: it, params: ot, layers: st=1, animProps: lt={}} = St
      , ut = nr(St, ["children", "active", "delay", "style", "params", "layers", "animProps"])
      , ct = react.exports.useRef(0)
      , ht = useGlobalStore(({currentTheme: At})=>At)
      , [ft,gt] = react.exports.useState(!1);
    let {right: vt, secondary: yt, xOffset: wt} = lt;
    wt = wt || PARAMS$1.xOffset;
    const [mt,_t] = useSprings(st, ()=>({
        y: "100%",
        x: `${wt * (vt ? -1 : 1)}%`,
        rotateX: PARAMS$1.rotateOffset,
        opacity: 0
    }))
      , bt = ht === THEMES.DARK ? ["#cccccc", "#999999"] : ["#999999", "#cccccc"]
      , Mt = ot.config || {
        easing: easings[ot.easing],
        duration: ot.duration
    };
    return react.exports.useEffect(()=>{
        _t.stop(),
        _t(At=>{
            let Pt = nt ? "0%" : "100%"
              , Ot = nt ? `${wt * (vt ? -1 : 1) * (yt ? 1 : 0)}%` : `${wt * (vt ? 1 : -1)}%`
              , Zt = nt ? 0 : PARAMS$1.rotateOffset;
            return {
                y: Pt,
                x: Ot,
                rotateX: Zt,
                opacity: nt ? 1 : 0,
                config: Mt,
                delay: rt + At * 50,
                onRest: ()=>{
                    _t({
                        x: "0%",
                        y: "0%",
                        rotateX: 0,
                        delay: PARAMS$1.endDelay,
                        config: Mt
                    }),
                    ct.current += 1,
                    ct.current === st && gt(!0)
                }
            }
        }
        )
    }
    , [nt]),
    jsx(animated.div, kn(wn({}, ut), {
        ref: $,
        style: kn(wn({}, it), {
            position: "relative",
            display: "block"
        }),
        children: mt.map((At,Pt)=>ft && Pt !== 0 ? null : jsx(animated.div, {
            style: kn(wn({}, At), {
                width: "100%",
                position: Pt === 0 ? "relative" : "absolute",
                display: "block",
                zIndex: st - Pt,
                color: Pt === 0 ? "unset" : bt[Pt - 1],
                transformOrigin: "center bottom",
                top: 0
            }),
            children: tt
        }, Pt))
    }))
});
const animParams = {
    rotateX: 90,
    transformOriginZ: "0.4em"
}
  , commonWordStyles = {
    display: "inline-block",
    transformOrigin: `50% 50% ${animParams.transformOriginZ}`
};
var RotateIn = react.exports.forwardRef(function(et, $) {
    const yt = et
      , {children: tt, active: nt=!0, delay: rt=0, style: it, params: ot, byWord: st=!1} = yt
      , lt = nr(yt, ["children", "active", "delay", "style", "params", "byWord"])
      , [ut,ct] = react.exports.useState(!1);
    let ht = 1;
    st && (ht = React.Children.count(tt));
    const [ft,gt] = useSprings(ht, ()=>({
        y: "100%",
        rotateX: animParams.rotateX,
        opacity: 0
    }))
      , vt = {
        duration: ot.duration,
        easing: easings[ot.easing]
    };
    return react.exports.useEffect(()=>{
        gt.stop(),
        gt.start(wt=>{
            let mt = nt ? "0%" : "100%"
              , _t = nt ? 1 : 0
              , bt = nt ? 0 : animParams.rotateX;
            return {
                y: mt,
                opacity: _t,
                rotateX: bt,
                config: vt,
                delay: rt + wt * 50,
                onStart: ()=>{
                    ct(!1)
                }
                ,
                onRest: ()=>{
                    ct(!0)
                }
            }
        }
        )
    }
    , [nt]),
    jsx(animated.div, kn(wn({}, lt), {
        ref: $,
        style: kn(wn({}, it), {
            position: "relative",
            overflow: ut ? "visible" : "hidden"
        }),
        children: st ? React.Children.map(tt, (wt,mt)=>jsx(animated.div, {
            style: wn(wn({}, ft[mt]), commonWordStyles),
            children: wt
        })) : jsx(animated.div, {
            style: wn({}, ft[0]),
            children: tt
        })
    }))
});
function useInView(et, $=1, tt="0px") {
    const [nt,rt] = react.exports.useState(!1)
      , it = new IntersectionObserver(([ot])=>rt(ot.isIntersecting),{
        rootMargin: tt,
        threshold: $
    });
    return react.exports.useEffect(()=>(it.observe(et.current),
    ()=>{
        it.disconnect()
    }
    ), []),
    nt
}
var Fade = react.exports.forwardRef(function(et, $) {
    const gt = et
      , {children: tt, active: nt=!0, delay: rt=0, style: it, params: ot, byWord: st=!1} = gt
      , lt = nr(gt, ["children", "active", "delay", "style", "params", "byWord"])
      , [ut,ct] = react.exports.useState(!1)
      , [ht,ft] = useSpring(()=>({
        opacity: 0
    }));
    return react.exports.useEffect(()=>{
        ft.stop(),
        ft.start(()=>({
            opacity: nt ? 1 : 0,
            delay: nt ? rt : 0,
            config: config.gentle,
            onStart: ()=>{
                ct(!1)
            }
            ,
            onRest: ()=>{
                ct(!0)
            }
        }))
    }
    , [nt]),
    jsx(animated.div, kn(wn({}, lt), {
        ref: $,
        style: wn(wn({}, it), ht),
        children: tt
    }))
});
const TYPES = {
    swipe: "swipe",
    clipRight: "clip-right",
    clipBottom: "clip-bottom",
    about: "about",
    rotateIn: "rotate-in",
    fade: "fade"
}
  , PARAMS = {
    stagger: 200,
    "rotate-in": {
        easing: "easeOutCubic",
        duration: 600
    },
    swipe: {
        duration: 500,
        hold: 50,
        easing: "easeInOutQuart"
    },
    "clip-right": {
        easing: "easeOutQuad",
        duration: 950
    },
    "clip-bottom": {
        config: {
            tension: 280,
            friction: 40
        }
    },
    about: {
        config: {
            tension: 280,
            friction: 40
        }
    }
};
function ClipRevealAnim(ut) {
    var ct = ut
      , {delay: et=0, stagger: $=0, staggerOrder: tt=0, type: nt=TYPES.rotateIn, activeOnReveal: rt=!1, revealMargin: it=150, active: ot, debug: st=!1} = ct
      , lt = nr(ct, ["delay", "stagger", "staggerOrder", "type", "activeOnReveal", "revealMargin", "active", "debug"]);
    const ht = react.exports.useRef()
      , [ft,gt] = react.exports.useState(rt ? !1 : ot)
      , vt = tt * ($ || PARAMS.stagger)
      , wt = {
        delay: et + vt,
        params: PARAMS[nt]
    }
      , mt = react.exports.useMemo(()=>{
        switch (nt) {
        case TYPES.swipe:
            return Swipe;
        case TYPES.clipRight:
            return ClipRight;
        case TYPES.about:
            return CustomAbout;
        case TYPES.clipBottom:
            return ClipBottom;
        case TYPES.fade:
            return Fade;
        case TYPES.rotateIn:
        default:
            return RotateIn
        }
    }
    , [nt]);
    rt && st && console.log("test");
    const _t = useInView(ht, .125);
    return react.exports.useEffect(()=>{
        if (ot && !ft) {
            gt(!0);
            return
        }
        if (!rt && !ot && ft) {
            gt(!1);
            return
        }
        !rt || ft || _t && gt(!0)
    }
    , [ot, ft, rt, _t]),
    jsx(mt, kn(wn(wn({}, wt), lt), {
        ref: ht,
        active: ft
    }))
}
function Filter() {
    const et = useDataStore(st=>st.hasLoaded, shallow)
      , $ = useDataStore(st=>st.experimentsFlatList, shallow)
      , tt = useGlobalStore(st=>st.activeFilter, shallow)
      , nt = useGlobalStore(st=>st.experimentsView, shallow)
      , [rt,it] = react.exports.useState([]);
    react.exports.useEffect(()=>{
        let st = Object.entries(CATEGORIES).map(([lt,ut])=>{
            if (ut.id === 1)
                return kn(wn({}, ut), {
                    count: $.length
                });
            const ct = $.reduce((ht,{category: ft})=>ht + (ft === ut.id ? 1 : 0), 0);
            return kn(wn({}, ut), {
                count: ct
            })
        }
        );
        it(st)
    }
    , [et]);
    const ot = st=>{
        useGlobalStore.setState(lt=>lt.activeFilter = st),
        resetScrollSignal.dispatch()
    }
    ;
    return react.exports.useEffect(()=>{
        useGlobalStore.setState(st=>st.activeFilter = CATEGORIES.ALL.id)
    }
    , [nt]),
    jsx("div", {
        className: clsx("filter", nt === EXP_VIEWS.LIST && "filter--active"),
        children: rt.map((st,lt)=>jsx(ClipRevealAnim, {
            delay: 0,
            stagger: 50,
            staggerOrder: lt,
            active: nt === EXP_VIEWS.LIST,
            type: "fade",
            children: jsxs("div", {
                onClick: ()=>ot(st.id),
                className: clsx("filter__item", st.id === tt && "filter__item--active"),
                children: [jsx("span", {
                    className: "filter__name",
                    children: st.label
                }), jsx("span", {
                    className: "filter__count",
                    children: st.count
                })]
            })
        }, st.id))
    })
}
const letterPerSecond = 80
  , maxRandLetterCount = 5
  , letterVelocity = .75;
function ListViewItem(et) {
    const {id: $, nId: tt, slug: nt, releaseDate: rt, projectName: it, tags: ot, projectLink: st, delay: lt=0} = et
      , ut = react.exports.useRef()
      , ct = react.exports.useRef()
      , ht = react.exports.useRef()
      , ft = react.exports.useRef(-lt / 1e3)
      , gt = react.exports.useRef(-lt / 1e3)
      , vt = react.exports.useRef(0)
      , yt = react.exports.useRef(0)
      , wt = react.exports.useRef()
      , mt = react.exports.useRef(0)
      , _t = react.exports.useRef(!1)
      , bt = useGlobalStore(At=>At.hoveredExp, shallow)
      , Mt = !!bt
      , St = Mt && bt === $;
    return useAnimationFrame(At=>{
        if (!ut.current || !ct.current || !ht.current)
            return;
        ft.current = ft.current + At,
        gt.current = gt.current + 2.5 * At;
        const Pt = math.saturate(ft.current);
        ct.current.style.transform = `scale(${ease.expoInOut(Pt)})`,
        vt.current = math.saturate(vt.current + 4 * At * (St || !Mt ? -1 : 1)),
        ut.current.style.opacity = 1 - .8 * ease.cubicInOut(vt.current),
        yt.current = math.saturate(yt.current + 2 * At * (St ? 1 : -1)),
        ht.current.style.transform = `translateX(-${ease.expoInOut(1 - yt.current) * 100}%)`,
        !_t.current && St && (mt.current = 0),
        _t.current = St,
        mt.current += letterVelocity * At;
        const Ot = it
          , Zt = Math.min(Ot.length, Math.floor(letterPerSecond * mt.current) - maxRandLetterCount)
          , Nt = Math.min(Ot.length, Math.floor(letterPerSecond * mt.current));
        let Tt = "";
        for (let Ft = 0; Ft < Zt; Ft++)
            Tt += Ot[Ft];
        for (let Ft = 0; Ft < Nt - Zt; Ft++)
            Tt += String.fromCharCode(33 + Math.random() * 93);
        wt.current.innerHTML = Tt
    }
    ),
    jsxs(Fragment, {
        children: [jsx(Link, {
            to: `/exp/${nt}${window.location.search}`,
            children: jsxs("div", {
                ref: ut,
                className: clsx("grid-view", "grid-view--24", "exp-list__item"),
                onPointerEnter: ()=>{
                    useGlobalStore.setState(At=>At.hoveredExp = $),
                    useGlobalStore.setState(At=>{
                        At.isCursorHovering = !0
                    }
                    ),
                    updateLucyEmote$1("random")
                }
                ,
                onPointerLeave: ()=>{
                    updateLucyEmote$1(),
                    useGlobalStore.setState(At=>{
                        At.isCursorHovering = !1
                    }
                    )
                }
                ,
                children: [jsx(ClipRevealAnim, {
                    active: !0,
                    delay: lt,
                    stagger: 100,
                    staggerOrder: 0,
                    className: "exp-list__info",
                    children: jsx(ExpInfoId, {
                        id: tt
                    })
                }), jsx(ClipRevealAnim, {
                    active: !0,
                    delay: lt,
                    stagger: 100,
                    staggerOrder: 1,
                    className: "exp-list__info exp-list__year",
                    children: jsx(ExpInfoDate, {
                        releaseDate: rt
                    })
                }), jsx(ClipRevealAnim, {
                    active: !0,
                    delay: lt,
                    stagger: 100,
                    staggerOrder: 2,
                    className: "exp-list__name",
                    children: jsx("div", {
                        ref: wt,
                        children: it
                    })
                }), jsx(ClipRevealAnim, {
                    active: !0,
                    delay: lt,
                    stagger: 100,
                    staggerOrder: 3,
                    className: "exp-list__tags",
                    children: jsx(Tags, {
                        tags: ot
                    })
                }), jsx("a", {
                    href: st,
                    target: "_blank",
                    className: "exp-list__link",
                    onClick: At=>At.stopPropagation(),
                    ref: ct,
                    children: jsx(CardButton, {
                        isHovering: St
                    })
                })]
            }, `card-${$}`)
        }), jsxs("div", {
            className: "grid-view grid-view--block exp-list__hr",
            style: {
                position: "relative",
                overflow: "hidden"
            },
            children: [jsx("div", {
                style: {
                    opacity: .2
                }
            }), jsx("div", {
                ref: ht,
                style: {
                    position: "absolute",
                    inset: 0
                }
            })]
        })]
    })
}
const globalListViewScroll = react.exports.createRef();
function ListView() {
    const et = react.exports.useRef()
      , $ = react.exports.useRef(0)
      , tt = react.exports.useRef(0)
      , nt = react.exports.useRef(0)
      , rt = react.exports.useRef(0)
      , [it,ot] = react.exports.useState(!1)
      , [st,lt] = useDataStore(mt=>[mt.hasLoaded, mt.experimentsFlatList], shallow)
      , [ut,ct,ht,ft] = useGlobalStore(mt=>[mt.experimentsView, mt.isCardAnimationCompleted, mt.activeFilter, mt.hoveredExp], shallow)
      , gt = ut === EXP_VIEWS.LIST
      , vt = react.exports.useMemo(()=>ht === 1 ? lt : lt.filter(({category: _t})=>_t === ht), [ht, st])
      , [yt,wt] = useSpring(()=>({
        from: {
            opacity: 0
        },
        to: {
            opacity: 1
        }
    }));
    return react.exports.useEffect(()=>{
        gt && useGlobalStore.setState(mt=>mt.isListAnimationCompleted = !1)
    }
    , [gt]),
    react.exports.useEffect(()=>{
        gt && it && (resetScrollSignal.dispatch(!0),
        wt({
            from: {
                opacity: 0
            },
            to: {
                opacity: 1
            },
            config: config.stiff,
            onRest: ()=>{
                disableScroll.current = !1
            }
        })),
        gt || wt({
            from: {
                opacity: 1
            },
            to: {
                opacity: 0
            },
            onRest: ()=>{
                ot(!1),
                useGlobalStore.setState(mt=>mt.isListAnimationCompleted = !0)
            }
        })
    }
    , [gt, wt, it]),
    react.exports.useEffect(()=>{
        gt && ct && ot(!0)
    }
    , [gt, ct]),
    react.exports.useEffect(()=>{
        if (!et.current)
            return;
        const mt = new ResizeObserver(_t=>{
            var bt;
            for (let Mt of _t) {
                const St = Mt.contentRect;
                nt.current = 0,
                $.current = St.height - (window.innerHeight - (((bt = et.current) == null ? void 0 : bt.offsetTop) || 0)),
                $.current = Math.max($.current, 0)
            }
        }
        );
        return mt.observe(et.current),
        ()=>{
            !mt || mt.disconnect()
        }
    }
    , []),
    useAnimationFrame(mt=>{
        !et.current || (nt.current += input.deltaScroll,
        nt.current = math.clamp(nt.current, 0, $.current),
        globalListViewScroll.current = nt.current,
        rt.current = math.mix(rt.current, nt.current, .05),
        tt.current = rt.current / $.current,
        et.current.style.transform = `translateY(${-rt.current}px)`)
    }
    ),
    jsxs(Fragment, {
        children: [jsx("div", {
            ref: et,
            style: {
                position: "relative"
            },
            children: it ? jsxs(Fragment, {
                children: [jsx("div", {
                    className: "exp-list__filter",
                    children: jsx(Filter, {})
                }), jsx("div", {
                    className: "grid-view grid-view--block",
                    style: {
                        position: "relative"
                    },
                    children: jsx("div", {
                        className: clsx("exp-list__first-border")
                    })
                }), jsxs(animated.div, {
                    className: "exp-list",
                    style: yt,
                    onPointerLeave: ()=>useGlobalStore.setState(mt=>mt.hoveredExp = null),
                    children: [vt.map((mt,_t)=>{
                        const {id: bt} = mt;
                        return jsx(ListViewItem, wn({
                            delay: 250 + _t * 100
                        }, mt), `card-${bt}-${_t}`)
                    }
                    ), jsx("div", {
                        className: clsx("exp-list__empty", vt.length === 0 && "exp-list__empty--show"),
                        children: "No experiments"
                    })]
                })]
            }) : null
        }), gt && browser$1.isDesktop && jsx(BackImage, {})]
    })
}
function BackImage() {
    var it;
    const et = react.exports.useRef()
      , $ = react.exports.useRef(0)
      , tt = useGlobalStore(ot=>ot.hoveredExp, shallow)
      , rt = (it = useDataStore(ot=>ot.experimentsFlatList, shallow).filter(({id: ot})=>ot === tt)[0]) == null ? void 0 : it.listImg;
    return useAnimationFrame(ot=>{
        !et.current || ($.current = math.saturate($.current + 1.5 * ot * (rt ? 1 : -1)),
        rt && (et.current.src = rt),
        et.current.style.opacity = ease.expoInOut(math.fit($.current, .2, .8, 0, .6)),
        et.current.style.transform = `translate(-50%, -50%) scale(${ease.circInOut(math.fit($.current, .4, 1, .7, 1))})`)
    }
    ),
    jsx("img", {
        ref: et,
        className: "exp-list__back-image"
    })
}
function CardView() {
    const [et,$] = react.exports.useState(!1)
      , tt = useDataStore(ut=>ut.hasLoaded, shallow)
      , nt = useDataStore(ut=>ut.experimentsInGrid, shallow)
      , rt = useGlobalStore(ut=>ut.isListAnimationCompleted, shallow)
      , ot = useGlobalStore(ut=>ut.experimentsView, shallow) === EXP_VIEWS.GRID
      , st = react.exports.useRef()
      , lt = react.exports.useRef();
    return react.exports.useEffect(()=>{
        if (!tt || !nt || !st.current || !lt.current)
            return;
        let ut = null;
        return et && ot && (ut = setTimeout(()=>{
            properties.infiniteGridSignalStart.dispatch(st.current, lt.current, nt)
        }
        , 500)),
        !ot && et && properties.infiniteGridSignalEnd.dispatch(),
        ()=>{
            ut && clearTimeout(ut)
        }
    }
    , [ot, et, tt, nt]),
    react.exports.useEffect(()=>{
        ot && useGlobalStore.setState(ut=>ut.isCardAnimationCompleted = !1)
    }
    , [ot]),
    react.exports.useEffect(()=>{
        rt && (resetScrollSignal.dispatch(!0),
        $(!0))
    }
    , [rt]),
    react.exports.useEffect(()=>{
        const ut = ()=>{
            useGlobalStore.setState(ct=>ct.isCardAnimationCompleted = !0),
            $(!1)
        }
        ;
        return properties.infiniteGridSignalOnVisibilityEnd.add(ut),
        ()=>{
            properties.infiniteGridSignalEnd.dispatch(),
            properties.infiniteGridSignalOnVisibilityEnd.remove(ut)
        }
    }
    , []),
    et ? jsx("div", {
        className: "cards-wrapper grid-view grid-view--24 grid-view--no-padding",
        children: jsx("div", {
            ref: st,
            className: "cards-wrapper2",
            children: jsxs("button", {
                ref: lt,
                className: "card card--abs",
                style: {
                    display: "none"
                },
                children: [jsx("div", {
                    className: "card__img"
                }), jsxs("div", {
                    className: "card__text",
                    children: [jsxs("div", {
                        className: "card__top",
                        children: [jsx("div", {
                            children: jsx(ExpInfo, {})
                        }), jsx("a", {
                            className: "card__ext-link",
                            target: "_blank",
                            onClick: ut=>ut.stopPropagation(),
                            style: {
                                pointerEvents: "all"
                            },
                            children: jsxs("div", {
                                className: "card-button",
                                children: [jsx(ArrowRight16, {
                                    fill: "currentColor"
                                }), jsx(ArrowTopRight16, {
                                    fill: "currentColor"
                                }), jsx(Dot, {
                                    fill: "currentColor"
                                })]
                            })
                        })]
                    }), jsxs("div", {
                        className: "card__bottom",
                        children: [jsxs("div", {
                            className: "card__title",
                            style: {
                                lineHeight: "120%"
                            },
                            children: [jsx("span", {
                                className: "card__title--top"
                            }), jsx("span", {
                                className: "card__title--bottom"
                            })]
                        }), jsx(Tags, {})]
                    })]
                })]
            })
        })
    }) : null
}
function ArrowBottomRight16(nt) {
    var rt = nt
      , {active: et, delay: $} = rt
      , tt = nr(rt, ["active", "delay"]);
    const [it,ot] = useSpring(()=>({
        x: 0,
        y: 0
    }));
    return react.exports.useEffect(()=>{
        et && ot(()=>({
            to: [{
                x: -20,
                y: -20,
                config: {
                    duration: 0
                }
            }, {
                x: 0,
                y: 0,
                config: {
                    duration: 750,
                    easing: easings.easeInOutCubic
                },
                delay: $
            }]
        }))
    }
    , [ot]),
    jsx("svg", kn(wn({
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: jsxs(animated.g, {
            style: it,
            children: [jsx("path", {
                d: "M12.75 12C12.75 12.4142 12.4142 12.75 12 12.75C11.5858 12.75 11.25 12.4142 11.25 12H12.75ZM11.25 6C11.25 5.58579 11.5858 5.25 12 5.25C12.4142 5.25 12.75 5.58579 12.75 6H11.25ZM11.25 12V6H12.75V12H11.25Z",
                fill: "currentColor"
            }), jsx("path", {
                d: "M12 11.25C12.4142 11.25 12.75 11.5858 12.75 12C12.75 12.4142 12.4142 12.75 12 12.75L12 11.25ZM6 12.75C5.58579 12.75 5.25 12.4142 5.25 12C5.25 11.5858 5.58579 11.25 6 11.25L6 12.75ZM12 12.75L6 12.75L6 11.25L12 11.25L12 12.75Z",
                fill: "currentColor"
            }), jsx("path", {
                d: "M12.5303 11.4697C12.8232 11.7626 12.8232 12.2374 12.5303 12.5303C12.2374 12.8232 11.7626 12.8232 11.4697 12.5303L12.5303 11.4697ZM3.46967 4.53033C3.17678 4.23744 3.17678 3.76256 3.46967 3.46967C3.76256 3.17678 4.23744 3.17678 4.53033 3.46967L3.46967 4.53033ZM11.4697 12.5303L3.46967 4.53033L4.53033 3.46967L12.5303 11.4697L11.4697 12.5303Z",
                fill: "currentColor"
            })]
        })
    }))
}
function o(et) {
    return $=>{
        et.forEach(tt=>{
            typeof tt == "function" ? tt($) : tt != null && (tt.current = $)
        }
        )
    }
}
const LetterWrapper = ({children: et})=>jsx("span", {
    children: et
})
  , WordWrapper = ({children: et})=>jsx("span", {
    style: {
        whiteSpace: "pre"
    },
    children: et
})
  , LineWrapper = ({children: et})=>jsx("div", {
    children: et
})
  , DefaultLineWrapper = LineWrapper
  , DefaultWordWrapper = WordWrapper
  , DefaultLetterWrapper = LetterWrapper
  , SplitTextInner = react.exports.forwardRef(function et({children: $, className: tt, style: nt, LineWrapper: rt=DefaultLineWrapper, WordWrapper: it=DefaultWordWrapper, LetterWrapper: ot=DefaultLetterWrapper, setLineCount: st, extraProps: lt}, ut) {
    const ct = react.exports.useRef(null)
      , ht = react.exports.useRef(0)
      , [ft,gt] = react.exports.useState([])
      , [vt,yt] = react.exports.useState("")
      , wt = react.exports.useMemo(()=>{
        let bt = -1;
        return ft.map(Mt=>{
            const St = Mt.split(" ");
            return St.map((Pt,Ot)=>(bt += 1,
            {
                wordCount: bt,
                word: Ot === St.length - 1 ? Pt : Pt + " "
            }))
        }
        )
    }
    , [ft])
      , mt = react.exports.useCallback((bt,Mt)=>{
        const St = ht.current || bt.map(Nt=>Nt.length).sort((Nt,Tt)=>Tt - Nt)[0]
          , At = [];
        let Pt = ""
          , Ot = 0;
        const Zt = Mt.split(" ");
        for (const [Nt,Tt] of Zt.entries())
            Ot += Tt.length + 1,
            Ot > St + 1 && (At.push(Pt),
            Pt = "",
            Ot = 0),
            Pt += Tt.trim() + " ";
        At.push(Pt),
        gt(At.map(Nt=>Nt.trim())),
        St > ht.current && (ht.current = St)
    }
    , [gt]);
    react.exports.useEffect(()=>{
        typeof ut == "function" ? ut(ct.current) : ut && (ut.current = ct.current)
    }
    , []),
    react.exports.useEffect(()=>{
        let bt = "";
        React.Children.forEach($, Mt=>{
            if (typeof Mt == "string" || typeof Mt == "number")
                bt += String(Mt);
            else
                throw new Error("SplitText expect a text as children")
        }
        ),
        yt(bt)
    }
    , [$]),
    react.exports.useLayoutEffect(()=>{
        const bt = ct.current;
        if (!bt || vt.length === 0)
            return;
        if (ft.length > 0)
            return mt(ft, vt);
        let Mt, St = [], At = [];
        for (const Pt of Array.from(bt.children)) {
            const Ot = Pt.getBoundingClientRect().top;
            Mt == null && (Mt = Ot),
            Ot !== Mt && (St.push(At.join(" ")),
            At = []),
            Mt = Ot,
            At.push((Pt.textContent || "").trim())
        }
        St.push(At.join(" ")),
        gt(St),
        st && st(St.length)
    }
    , [vt, mt, st]);
    let _t = 0;
    return ft.length ? jsx("div", {
        className: tt,
        ref: ct,
        style: nt,
        children: wt.map((bt,Mt)=>jsx(rt, {
            lineIndex: Mt,
            extraProps: lt,
            children: bt.map(({word: St, wordCount: At},Pt)=>{
                const Ot = St.split("");
                return jsx(it, {
                    lineIndex: Mt,
                    wordIndex: Pt,
                    countIndex: At,
                    extraProps: lt,
                    children: Ot.map((Zt,Nt)=>jsx(ot, {
                        lineIndex: Mt,
                        wordIndex: Pt,
                        letterIndex: Nt,
                        countIndex: _t++,
                        extraProps: lt,
                        children: Zt
                    }, Nt))
                }, Pt)
            }
            )
        }, Mt))
    }) : jsx("div", {
        className: tt,
        ref: ct,
        style: nt,
        children: vt.split(" ").map((bt,Mt)=>jsxs("span", {
            children: [bt, " "]
        }, Mt))
    })
});
function guiAddUniforms(et, $, tt, nt) {
    nt || (nt = Object.keys($.uniforms).filter(it=>$.uniforms[it].gui));
    let rt = et;
    return tt && (rt = et.addFolder({
        title: tt,
        expanded: !0
    })),
    nt.forEach(it=>{
        let ot = $.uniforms[it]
          , st = ot.gui[0] || 0
          , lt = ot.gui[1] || 1
          , ut = ot.gui[2] || .001;
        rt.addInput(ot, "value", {
            label: it.replace("u_", ""),
            min: st,
            max: lt,
            step: ut
        })
    }
    ),
    rt
}
const SplitLinesInner = react.exports.forwardRef(function et({children: $, className: tt, style: nt, active: rt, LineWrapper: it=LineWrapper, WordWrapper: ot=WordWrapper, wrapperProps: st={}}, lt) {
    const ut = react.exports.useRef(null)
      , ct = react.exports.useRef(0)
      , [ht,ft] = react.exports.useState([])
      , [gt,vt] = react.exports.useState("")
      , yt = react.exports.useCallback((mt,_t)=>{
        const bt = ct.current || mt.map(Ot=>Ot.length).sort((Ot,Zt)=>Zt - Ot)[0]
          , Mt = [];
        let St = ""
          , At = 0;
        const Pt = _t.split(" ");
        for (const [Ot,Zt] of Pt.entries())
            At += Zt.length + 1,
            At > bt + 1 && (Mt.push(St),
            St = "",
            At = 0),
            St += Zt.trim() + " ";
        Mt.push(St),
        ft(Mt.map(Ot=>Ot.trim())),
        bt > ct.current && (ct.current = bt)
    }
    , [ft])
      , wt = react.exports.useMemo(()=>ht.map((mt,_t)=>mt.trim().split(" ").map((St,At)=>St.charAt(0) === "$" ? jsx("i", {
        children: `${St.substring(1)} `
    }, `${St}-${At}`) : jsx(ot, kn(wn({}, typeof st == "function" ? st(At, _t) : st), {
        children: `${St} `
    }), `${St}-${At}`))), [ht]);
    return react.exports.useEffect(()=>{
        typeof lt == "function" ? lt(ut.current) : lt && (lt.current = ut.current)
    }
    , []),
    react.exports.useEffect(()=>{
        let mt = "";
        React.Children.forEach($, _t=>{
            if (typeof _t == "string" || typeof _t == "number")
                mt += String(_t);
            else
                throw new Error("SplitText expect a text as children")
        }
        ),
        vt(mt)
    }
    , [$]),
    react.exports.useLayoutEffect(()=>{
        const mt = ut.current;
        if (!mt || gt.length === 0)
            return;
        if (ht.length > 0)
            return yt(ht, gt);
        let _t, bt = [], Mt = [];
        for (const St of Array.from(mt.children)) {
            const At = St.getBoundingClientRect().top;
            _t == null && (_t = At),
            At !== _t && (bt.push(Mt.join(" ")),
            Mt = []),
            _t = At,
            Mt.push((St.textContent || "").trim())
        }
        bt.push(Mt.join(" ")),
        ft(bt)
    }
    , [gt, yt]),
    ht.length ? jsx("div", {
        className: tt,
        ref: ut,
        style: nt,
        children: wt.map((mt,_t)=>jsx(it, kn(wn({
            active: rt
        }, typeof st == "function" ? st(_t) : st), {
            revealMargin: 0,
            children: mt
        }), _t))
    }) : jsx("div", {
        className: tt,
        ref: ut,
        style: nt,
        children: gt.split(" ").map((mt,_t)=>mt === "<br/>" ? jsx("br", {}, _t) : jsxs("span", {
            children: [mt, " "]
        }, _t))
    })
});
react.exports.forwardRef(function et(rt, nt) {
    var it = rt
      , {children: $} = it
      , tt = nr(it, ["children"]);
    const [ot,st] = react.exports.useState(0);
    return jsx(SplitTextInner, kn(wn({}, tt), {
        ref: nt,
        children: $
    }), ot)
});
const SplitLines = react.exports.forwardRef(function et(ot, it) {
    var st = ot
      , {children: $, activeOnReveal: tt, revealMargin: nt=150} = st
      , rt = nr(st, ["children", "activeOnReveal", "revealMargin"]);
    const lt = react.exports.useRef()
      , [ut,ct] = react.exports.useState(0)
      , [ht,ft] = react.exports.useState(tt ? !1 : rt.active);
    return react.exports.useEffect(()=>{
        if (!tt || ht)
            return;
        const gt = ()=>{
            const {top: yt} = lt.current.getBoundingClientRect();
            yt < window.innerHeight - nt && ft(!0)
        }
        ;
        gt();
        const vt = useScrollStore.subscribe(gt);
        return ()=>void vt()
    }
    , [ht, tt]),
    jsx(SplitLinesInner, kn(wn({}, rt), {
        ref: o([it, lt]),
        active: ht,
        children: $
    }), ut)
})
  , experiments = [{
    id: "mind-flayer",
    slug: "mind-flayer",
    projectName: "Mind Flayer",
    projectLink: "https://exp-mind-flayer.lusion.co/",
    category: 7,
    tags: ["MONTHLY", "WEBGL", "PRODUCT"],
    recognitions: [],
    twitterId: "1544684568229412866",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2022,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "choochoo",
    slug: "choochoo",
    projectName: "Choo-Choo World",
    tags: ["MONTHLY", "MINIGAME"],
    category: 3,
    projectLink: "https://choochooworld.com/",
    recognitions: ["FWA_FOTD"],
    twitterId: "1539966295017267200",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2022,
    darkModeTop: !1,
    darkModeBottom: !1
}, {
    id: "ion-speaker",
    slug: "ion-speaker",
    projectName: "Ion",
    projectLink: "https://exp-ion.lusion.co/",
    category: 5,
    tags: ["MONTHLY", "PRODUCT", "DESIGN"],
    recognitions: ["AWWWARDS_SOTD", "FWA_FOTD", "AWWWARDS_DEV"],
    twitterId: "1509539344264089604",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2022,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "infinite-passerella",
    slug: "infinite-passerella",
    projectName: "Infinite Passerella",
    projectLink: "https://exp-infinite-passerella.lusion.co/",
    category: 5,
    tags: ["MONTHLY", "FASHION"],
    recognitions: ["AWWWARDS_SOTD", "FWA_FOTD", "AWWWARDS_DEV"],
    twitterId: "1496499002522673155",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2022,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "trappist-1d",
    slug: "trappist-1d",
    projectName: "Trappist-1D UE5",
    category: 2,
    projectLink: "https://vimeo.com/662312889",
    tags: ["MONTHLY", "UNREAL_ENGINE", "VIDEO"],
    recognitions: [],
    twitterId: "1478415308952117248",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2022,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "digital-city",
    slug: "digital-city",
    projectName: "Digital City",
    projectLink: "https://exp-digital-city.lusion.co/",
    category: 5,
    tags: ["MONTHLY", "DATAVIS", "WEBGL"],
    recognitions: ["FWA_FOTD"],
    twitterId: "1472956766795218951",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2021,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "my-little-story-book",
    slug: "my-little-story-book",
    projectName: "My Little Story Book",
    projectLink: "https://exp-my-little-storybook.lusion.co/",
    category: 5,
    tags: ["MONTHLY", "WEBGL", "STORYTELLING"],
    recognitions: ["AWWWARDS_SOTD", "FWA_FOTD", "AWWWARDS_DEV", "WEBBY"],
    twitterId: "1453364220079267844",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2021,
    darkModeTop: !1,
    darkModeBottom: !1
}, {
    id: "gemini-car",
    slug: "gemini-car",
    projectName: "Gemini Car Demo",
    projectLink: "https://exp-gemini.lusion.co/",
    category: 7,
    tags: ["MONTHLY", "PRODUCT"],
    recognitions: ["AWWWARDS_SOTD", "FWA_FOTD", "AWWWARDS_DEV"],
    twitterId: "1460988982028865550",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2021,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "small-world",
    slug: "small-world",
    projectName: "Small World",
    projectLink: "https://exp-small-world.lusion.co/",
    category: 5,
    tags: ["MONTHLY", "WEBGL", "DATAVIS"],
    recognitions: [],
    twitterId: "1443617628539478032",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2022,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "abduction",
    slug: "abduction",
    projectName: "Abduction",
    projectLink: "https://exp-abduction.lusion.co",
    category: 3,
    tags: ["MONTHLY", "WEBGL", "MINIGAME"],
    recognitions: ["FWA_FOTD"],
    twitterId: "1440311156858449921",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2021,
    darkModeTop: !1,
    darkModeBottom: !1
}, {
    id: "covid-spike",
    slug: "covid-spike",
    projectName: "Covid Spike",
    projectLink: "https://exp-covid-spike.lusion.co/",
    category: 5,
    tags: ["WEBGL", "DATAVIS"],
    recognitions: [],
    twitterId: "1445700508543434759",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2021,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "lazy-plot",
    slug: "lazy-plot",
    projectName: "Lazy Plot",
    projectLink: "https://lazy-plot.lusion.co/",
    category: 6,
    tags: ["TOOL"],
    recognitions: [],
    twitterId: "1441073689395609607",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2022,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "webxr-sneakers",
    slug: "webxr-sneakers",
    projectName: "WebXR Sneakers",
    projectLink: "https://webxr-sneakers.lusion.co/",
    category: 2,
    tags: ["DEMO", "WEBGL", "XR", "AR"],
    recognitions: [],
    twitterId: "1255856973578407936",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2020,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "cineshader",
    slug: "cineshader",
    projectName: "CineShader",
    projectLink: "https://cineshader.com/",
    category: 5,
    tags: ["DEMO", "WEBGL", "VR", "XR", "TOOL"],
    recognitions: ["FWA_FOTD"],
    twitterId: "1222121803499393025",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2020,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "particle-love",
    slug: "particle-love",
    projectName: "Particle Love",
    projectLink: "https://particle-love.com/",
    category: 5,
    tags: ["WEBGL"],
    recognitions: ["FWA_FOTD"],
    twitterId: "",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2016,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "surface-floater",
    slug: "surface-floater",
    projectName: "Surface Floater",
    projectLink: "https://surface-floater.lusion.co/",
    category: 5,
    tags: ["WEBGL"],
    recognitions: [],
    twitterId: "922811876861468672",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2017,
    darkModeTop: !0,
    darkModeBottom: !0
}, {
    id: "hair-simulation",
    slug: "hair-simulation",
    projectName: "Hair Simulation",
    projectLink: "https://hair-simulation.lusion.co/",
    category: 5,
    tags: ["WEBGL"],
    recognitions: [],
    twitterId: "1146411441949487104",
    hashTags: ["webgl", "lusion", "threejs", "creativecoding"],
    socialMessage: "Hey look at the cool stuff we do in Lusion!",
    releaseDate: 2019,
    darkModeTop: !0,
    darkModeBottom: !0
}]
  , grid = [{
    id: "choochoo",
    card: {
        width: 3,
        height: 2
    }
}, {
    id: "ion-speaker",
    card: {
        width: 0,
        height: 1
    }
}, {
    id: "my-little-story-book",
    card: {
        width: 4,
        height: 0
    }
}, {
    id: "infinite-passerella",
    card: {
        width: 0,
        height: 1
    }
}, {
    id: "gemini-car",
    card: {
        width: 3,
        height: 0
    }
}, {
    id: "mind-flayer",
    card: {
        width: 2,
        height: 0
    }
}, {
    id: "abduction",
    card: {
        width: 1,
        height: 2
    }
}, {
    id: "cineshader",
    card: {
        width: 4,
        height: 1
    }
}, {
    id: "digital-city",
    card: {
        width: 1,
        height: 0
    }
}, {
    id: "particle-love",
    card: {
        width: 2,
        height: 1
    }
}, {
    id: "small-world",
    card: {
        width: 2,
        height: 1
    }
}, {
    id: "lazy-plot",
    card: {
        width: 1,
        height: 0
    }
}, {
    id: "webxr-sneakers",
    card: {
        width: 2,
        height: 0
    }
}, {
    id: "hair-simulation",
    card: {
        width: 1,
        height: 2
    }
}, {
    id: "surface-floater",
    card: {
        width: 1,
        height: 0
    }
}, {
    id: "covid-spike",
    card: {
        width: 2,
        height: 2
    }
}, {
    id: "trappist-1d",
    card: {
        width: 5,
        height: 0
    }
}];
var experimentData = {
    experiments,
    grid
};
let _projectsContainer, _projectsContainerY = 0, _viewportHeight, _projectList = [], _gridColumnCount = 22, _gridColumnSpaceRatio = .25, _gridColumnSolidWidth, _gridColumnSpaceWidth, _rowMargin = 0, _projectsContainerWidth, _prevScrollY = 0, _scrollY = 0, _targetScrollY = 0, _projectRowList = [], _isMobileOrTablet = window.innerWidth <= 1024, projectDataList = [], _navigateCallback = null, _isFullscreenRight = !1, _isRightSideAnimationForSingleColumn = !1, tmpl = "", div = document.createElement("div");
function _getProjectDom() {
    div.innerHTML = tmpl;
    let et = div.firstChild;
    return div.removeChild(et),
    et
}
const eventPushState = "pushState"
  , eventReplaceState = "replaceState"
  , navigate = (et,{replace: $=!1}={})=>history[$ ? eventReplaceState : eventPushState](null, "", et);
class Project {
    constructor($, tt) {
        Et(this, "index", -1);
        Et(this, "id", "");
        Et(this, "nId", 0);
        Et(this, "name", "");
        Et(this, "slug", "");
        Et(this, "imgName", null);
        Et(this, "aspect", 1);
        Et(this, "dataAspect", 1);
        Et(this, "isReady", !1);
        Et(this, "isFullscreen", !1);
        Et(this, "isFullscreenRight", !1);
        Et(this, "darkModeTop");
        Et(this, "darkModeBottom");
        Et(this, "tags");
        Et(this, "releaseDate");
        Et(this, "projectLink");
        Et(this, "widthColumnNum", 1);
        Et(this, "heightColumnNum", 1);
        Et(this, "width", 1);
        Et(this, "height", 1);
        Et(this, "imgHeight", 0);
        this.index = $,
        this.id = tt.id,
        this.nId = tt.nId,
        this.name = tt.projectName,
        this.slug = tt.slug,
        this.widthColumnNum = tt.card.width,
        this.heightColumnNum = tt.card.height,
        this.dataAspect = this.widthColumnNum / this.heightColumnNum,
        this.aspect = _isMobileOrTablet ? 4 / 3 : this.dataAspect,
        this.imgName = tt.homepageImg,
        this.isFullscreen = tt.isFullscreen,
        this.isFullscreen && (this.isFullscreenRight = _isFullscreenRight,
        _isFullscreenRight = !_isFullscreenRight),
        this.darkModeTop = tt.darkModeTop || !1,
        this.darkModeBottom = tt.darkModeBottom || !1,
        this.tags = tt.tags || [],
        this.releaseDate = tt.releaseDate || "",
        this.projectLink = tt.projectLink || "/"
    }
    preload() {
        !this.img && !this.isEmpty && (this.img = new Image,
        this.img.src = `${this.imgName}`,
        this.img.naturalWidth ? this._onload() : this.img.onload = this._onload.bind(this))
    }
    _onload() {
        this.isReady = !0,
        this.imgHeight = this.img.height
    }
    onResize() {
        this.aspect = _isMobileOrTablet ? 4 / 3 : this.dataAspect
    }
}
class ProjectRowItem {
    constructor($) {
        Et(this, "project", null);
        Et(this, "gridColumnCount", 0);
        Et(this, "x", 0);
        Et(this, "y", 0);
        Et(this, "isRight", !1);
        Et(this, "container", null);
        Et(this, "topWrapper", null);
        Et(this, "bottomWrapper", null);
        Et(this, "imgContainer", null);
        Et(this, "title", null);
        Et(this, "infoId", null);
        Et(this, "infoDate", null);
        Et(this, "tags", null);
        Et(this, "extLink", null);
        Et(this, "extButton", null);
        Et(this, "iconDot", null);
        Et(this, "iconArrow", null);
        Et(this, "iconArrowMobile", null);
        Et(this, "isHover", !1);
        Et(this, "hoverRatio", 0);
        Et(this, "hoverRatioText", 0);
        Et(this, "parallax", 1);
        this.project = $,
        this.container = _getProjectDom(),
        this.imgContainer = this.container.querySelector(".card__img"),
        this.titleTop = this.container.querySelector(".card__title--top"),
        this.titleBottom = this.container.querySelector(".card__title--bottom"),
        this.topWrapper = this.container.querySelector(".card__top"),
        this.bottomWrapper = this.container.querySelector(".card__bottom"),
        this.infoId = this.container.querySelector(".exp-info__id"),
        this.infoDate = this.container.querySelector(".exp-info__date"),
        this.tags = this.container.querySelectorAll(".tags__item"),
        this.extLink = this.container.querySelector(".card__ext-link"),
        this.extButton = this.extLink.querySelector(".card-button"),
        this.iconDot = this.container.querySelector("[name='iconDot']"),
        this.iconArrow = this.container.querySelector("[name='iconArrow']"),
        this.iconArrowMobile = this.container.querySelector("[name='iconArrowMobile']"),
        this.iconArrow.style.display = "none",
        this.iconArrowMobile.style.display = "none",
        this.titleTop.innerHTML = $.name,
        this.titleBottom.innerHTML = $.name,
        $.darkModeTop && this.topWrapper.classList.add("card--dark"),
        $.darkModeBottom && this.bottomWrapper.classList.add("card--dark"),
        this.tags.forEach((tt,nt)=>{
            var it;
            const rt = (it = $.tags) == null ? void 0 : it[nt];
            rt ? tt.innerHTML = rt : tt.remove()
        }
        ),
        this.infoId.innerHTML = `EXP ${$.nId.toString().padStart(3, 0)}`,
        this.infoDate.innerHTML = $.releaseDate,
        this.extLink.href = $.projectLink,
        this.extLink.addEventListener("click", tt=>{
            tt.stopPropagation()
        }
        ),
        this.container.addEventListener("click", tt=>{
            tt.preventDefault(),
            _navigateCallback = ()=>navigate(`/exp/${$.slug}`),
            properties.infiniteGridSignalEnd.dispatch()
        }
        ),
        browser$1.isDesktop && (this.container.addEventListener("mouseenter", ()=>{
            this.iconDot.style.display = "none",
            this.iconArrow.style.display = _isMobileOrTablet ? "none" : "block",
            this.iconArrowMobile.style.display = _isMobileOrTablet ? "block" : "none",
            this.isHover = !0,
            this.project.nameAnimationTime = 0,
            useGlobalStore.setState(tt=>{
                tt.isCursorHovering = !0
            }
            ),
            updateLucyEmote$1("random")
        }
        ),
        this.container.addEventListener("mouseleave", ()=>{
            this.iconDot.style.display = "block",
            this.iconArrow.style.display = "none",
            this.iconArrowMobile.style.display = "none",
            this.isHover = !1,
            useGlobalStore.setState(tt=>{
                tt.isCursorHovering = !1
            }
            ),
            updateLucyEmote$1()
        }
        ),
        this.extLink.addEventListener("mouseenter", ()=>{
            this.extButton.classList.add("card-button--hover")
        }
        ),
        this.extLink.addEventListener("mouseleave", ()=>{
            this.extButton.classList.remove("card-button--hover")
        }
        )),
        _projectsContainer.appendChild(this.container),
        this.imgContainer.appendChild($.img),
        this.parallax = 1
    }
    syncSize() {
        this.project.onResize(),
        _isMobileOrTablet ? this.width = _gridColumnSolidWidth * _gridColumnCount + (_gridColumnCount - 1) * _gridColumnSpaceWidth : this.width = this.project.widthColumnNum * _gridColumnSolidWidth + (this.project.widthColumnNum - 1) * _gridColumnSpaceWidth,
        this.project.width = this.width,
        this.height = this.width / this.project.aspect,
        this.project.height = this.height,
        this.container.style.width = `${this.width}px`,
        this.container.style.height = `${this.height}px`,
        this.project.imgHeight = this.project.img.height
    }
    dispose() {
        this.container.parentNode && this.container.parentNode.removeChild(this.container)
    }
    update($) {
        this.hoverRatio = math.saturate(this.hoverRatio + $ / .35 * (this.isHover ? 1 : -1));
        const tt = 2 * ((this.y + this.project.height * .5) / _viewportHeight - .5)
          , nt = .4 * Math.max(0, this.project.imgHeight - this.project.height);
        this.imgContainer.style.transform = `translateY(${-nt * tt}px) scale(${1 + .075 * ease.quintInOut(this.hoverRatio)})`;
        const rt = Math.max(0, this.y / _viewportHeight)
          , it = this.project.isFullscreen || _isMobileOrTablet ? 0 : ease.quadIn(rt) * (this.isRight ? 1 : -1)
          , ot = this.project.isFullscreen || _isMobileOrTablet ? 0 : ease.sineIn(rt) * (this.isRight ? 1 : -1);
        this.container.style.transformOrigin = `top ${this.isRight ? "right" : "left"}`,
        this.container.style.transform = `translate3d(${this.x + .15 * this.width * it * it * Math.sign(it)}px, ${this.parallax * this.y}px, 0) rotate(${-4 * ot * ot * Math.sign(ot)}deg)`,
        this.hoverRatioText = math.saturate(this.hoverRatioText + $ / .8 * (this.isHover ? 1 : -1));
        const st = ease.expoInOut(this.hoverRatioText);
        this.titleTop.style.transform = `translateY(${st * -100}%)`,
        this.titleBottom.style.transform = `translateY(${st * -100}%)`
    }
}
class ProjectRow {
    constructor($, tt=!0) {
        Et(this, "itemList", []);
        Et(this, "maxProjectColumnCount", 2);
        Et(this, "occupiedProjectColumnCount", 0);
        Et(this, "occupiedGridColumnCount", 0);
        Et(this, "y", 0);
        Et(this, "height", 0);
        let nt = !0
          , rt = $;
        for (this.maxProjectColumnCount = _isMobileOrTablet ? 1 : 2; nt; )
            rt = math.loop(rt + (tt ? 1 : -1), 0, projectDataList.length),
            nt = this._addProject(_projectList[rt], tt);
        this.onResize()
    }
    _addProject($, tt=!0) {
        let nt = this.maxProjectColumnCount - this.occupiedProjectColumnCount;
        if (nt > 0) {
            let rt = 1;
            this.occupiedProjectColumnCount++,
            nt > 1 && $.isFullscreen && (rt = 2,
            this.occupiedProjectColumnCount++);
            let it = Math.floor(_gridColumnCount / this.maxProjectColumnCount * rt);
            this.occupiedGridColumnCount += it;
            let ot = new ProjectRowItem($,it);
            return tt ? this.itemList.push(ot) : this.itemList.unshift(ot),
            !0
        }
        return !1
    }
    onResize() {
        this.itemList.length;
        let $ = 0
          , tt = 0;
        for (let nt = 0; nt < this.itemList.length; nt++) {
            let rt = this.itemList[nt];
            rt.syncSize(),
            $ = Math.max($, rt.height),
            this.itemList.length == 1 ? _isMobileOrTablet ? (rt.isRight = _isRightSideAnimationForSingleColumn,
            _isRightSideAnimationForSingleColumn = !_isRightSideAnimationForSingleColumn) : rt.x = rt.project.isFullscreenRight ? _projectsContainerWidth - rt.width : 0 : (nt == 0 ? (rt.x = 0,
            rt.isRight = !1) : nt == this.itemList.length - 1 ? (rt.x = _projectsContainerWidth - rt.width,
            rt.isRight = !0) : rt.x = tt,
            tt += rt.x + rt.width + _gridColumnSpaceWidth)
        }
        this.height = $
    }
    dispose() {
        let $ = this.itemList.length;
        for (; $--; )
            this.itemList[$].dispose()
    }
    testInRange() {
        return this.y + this.height > 0 && this.y < _viewportHeight
    }
    update($) {
        for (let tt = 0; tt < this.itemList.length; tt++) {
            let nt = this.itemList[tt];
            nt.y = this.y,
            nt.update($)
        }
    }
}
class InfiniteGrid {
    constructor() {
        Et(this, "isInfiniteScrollActive", !1);
        Et(this, "isFirstIteration", !0);
        Et(this, "_scrollYInit", 0);
        Et(this, "_initialMargin", 400);
        Et(this, "isReady", !1);
        Et(this, "isActive", !1);
        Et(this, "opacity", 0);
        Et(this, "navbarDomEl", null);
        Et(this, "headerDomEl", null)
    }
    preInit() {
        properties.loader.add(`/assets/images/${experimentData.grid[0].id}/homepage_thumb.jpg`),
        properties.loader.add(`/assets/images/${experimentData.grid[1].id}/homepage_thumb.jpg`)
    }
    init() {
        properties.infiniteGridSignalStart.add(($,tt,nt)=>this.start($, tt, nt)),
        properties.infiniteGridSignalEnd.add(()=>this.end())
    }
    start($, tt, nt) {
        if (projectDataList = nt,
        this.isActive)
            return;
        disableScroll.current = !1,
        _projectsContainer = $;
        let rt = tt;
        rt.style.display = "flex",
        tmpl = rt.outerHTML,
        rt.parentNode.removeChild(rt),
        _projectList = [];
        for (let it = 0; it < projectDataList.length; it++) {
            let ot = new Project(it,projectDataList[it]);
            _projectList.push(ot),
            ot.preload()
        }
        this.isActive = !0,
        this.isInfiniteScrollActive = !1,
        useInfiniteGrid.setState(it=>{
            it.isInfinteScrollActive = !1
        }
        ),
        this.isFirstIteration = !0,
        this._scrollYInit = 0,
        this.navbarDomEl = null,
        this.headerDomEl = null,
        this.isReady = !0,
        this.onResize()
    }
    end() {
        !this.isActive || (this.isActive = !1,
        disableScroll.current = !0,
        setTimeout(()=>{
            useInfiniteGrid.setState($=>{
                $.isInfinteScrollActive = !1
            }
            )
        }
        , 200))
    }
    reset() {
        _prevScrollY = 0,
        _scrollY = 0,
        _targetScrollY = 0,
        _projectRowList.forEach($=>$.dispose()),
        _projectRowList = []
    }
    onResize() {
        if (!this.isReady || !this.isActive)
            return;
        this.navbarDomEl || (this.navbarDomEl = document.getElementById("navbar")),
        this.headerDomEl || (this.headerDomEl = document.getElementById("header")),
        document.documentElement.classList.add("disable-transitions"),
        _projectsContainer.style.transform = "none";
        const $ = _projectsContainer.getBoundingClientRect()
          , tt = this.navbarDomEl.getBoundingClientRect()
          , nt = this.headerDomEl.getBoundingClientRect();
        document.documentElement.classList.remove("disable-transitions"),
        this._initialMargin = $.height + tt.height + nt.height,
        this.isInfiniteScrollActive && (this._scrollYInit = this._initialMargin),
        _projectsContainer.style.transform = `translateY(${-math.clamp(this._scrollYInit, 0, this._initialMargin)}px)`;
        const rt = window.innerWidth <= 1024;
        _isMobileOrTablet !== rt && (_isMobileOrTablet = rt,
        _projectRowList.forEach(st=>st.dispose()),
        _projectRowList = []),
        _viewportHeight = window.innerHeight,
        _rowMargin = _viewportHeight * (_isMobileOrTablet ? .0802 : 2 * .0902),
        _projectsContainerWidth = _projectsContainer.getBoundingClientRect().width;
        let it = _gridColumnCount - 1;
        _gridColumnSpaceWidth = _projectsContainerWidth / (_gridColumnCount / _gridColumnSpaceRatio + it),
        _gridColumnSolidWidth = _gridColumnSpaceWidth / _gridColumnSpaceRatio,
        _projectRowList.length;
        let ot = _projectRowList.length ? _projectRowList[0].y : 0;
        for (let st = 0; st < _projectRowList.length; st++) {
            let lt = _projectRowList[st];
            lt.onResize(),
            lt.y = ot,
            ot += lt.height + _rowMargin
        }
    }
    update($) {
        if (!this.isReady)
            return;
        const tt = math.saturate(this.opacity + $ * 3 * (this.isActive ? 1 : -1));
        if (!this.isActive && this.opacity < .5 && _navigateCallback && (_navigateCallback(),
        _navigateCallback = null),
        !this.isActive && tt === 0 && this.opacity !== tt && (this.reset(),
        properties.infiniteGridSignalOnVisibilityEnd.dispatch()),
        this.opacity = tt,
        _projectsContainer.style.opacity = ease.cubicIn(this.opacity),
        this.opacity === 0)
            return;
        if (this.isActive && (_targetScrollY += input.deltaScroll),
        !this.isInfiniteScrollActive) {
            _targetScrollY = Math.max(_targetScrollY, 0);
            const ot = (_targetScrollY - this._scrollYInit) * .05;
            if (Math.abs(ot) > .01) {
                this._scrollYInit += ot;
                const st = math.clamp(this._scrollYInit, 0, this._initialMargin);
                Math.abs(_projectsContainerY - st) > .001 && (_projectsContainerY = st,
                _projectsContainer.style.transform = `translateY(${-_projectsContainerY}px)`,
                _projectsContainerY === this._initialMargin && (this.isInfiniteScrollActive = !0,
                useInfiniteGrid.setState(lt=>{
                    lt.isInfinteScrollActive = !0
                }
                )))
            }
        }
        let nt = _projectRowList.slice(0);
        _scrollY += (_targetScrollY - this._initialMargin * (this.isFirstIteration ? 0 : 1) - _scrollY) * .05,
        _scrollY *= this.isInfiniteScrollActive ? 1 : 0;
        let rt = _scrollY - _prevScrollY
          , it = _projectRowList.length;
        for (; it--; ) {
            let ot = _projectRowList[it];
            ot.y -= rt,
            ot.testInRange() || (ot.dispose(),
            _projectRowList.splice(it, 1))
        }
        if (_projectRowList.length == 0)
            if (nt.length > 0)
                if (rt >= 0) {
                    let ot = nt[nt.length - 1]
                      , st = ot.itemList[ot.itemList.length - 1].project.index
                      , lt = new ProjectRow(st,!0);
                    _projectRowList.push(lt)
                } else {
                    let st = nt[0].itemList[0].project.index
                      , lt = new ProjectRow(st,!1);
                    lt.y = _viewportHeight - 100,
                    _projectRowList.push(lt)
                }
            else {
                let ot = new ProjectRow(-1,!0);
                _projectRowList.push(ot)
            }
        for (; ; ) {
            let ot = _projectRowList[_projectRowList.length - 1]
              , st = ot.y + ot.height + _rowMargin;
            if (st < _viewportHeight) {
                let lt = new ProjectRow(ot.itemList[ot.itemList.length - 1].project.index,!0);
                lt.y = st,
                _projectRowList.push(lt)
            } else
                break
        }
        for (; ; ) {
            let ot = _projectRowList[0]
              , st = ot.y - _rowMargin;
            if (st > 0) {
                let lt = new ProjectRow(ot.itemList[0].project.index,!1);
                lt.y = st - lt.height,
                _projectRowList.unshift(lt)
            } else
                break
        }
        for (let ot = 0; ot < _projectRowList.length; ot++)
            _projectRowList[ot].update($);
        _prevScrollY = _scrollY,
        this.isFirstIteration = !1
    }
}
var InfiniteGrid$1 = new InfiniteGrid;
const INIT_DELAY = 700
  , STAGGER_DELAY = 250;
function Header(et) {
    const tt = react.exports.useRef()
      , nt = react.exports.useRef(0)
      , rt = react.exports.useRef(0)
      , it = react.exports.useRef(0)
      , ot = useGlobalStore(vt=>vt.width, shallow)
      , st = useGlobalStore(vt=>vt.experimentsView, shallow)
      , lt = st === EXP_VIEWS.LIST
      , ut = ot <= 1024
      , [ct,ht] = react.exports.useState(!1)
      , [ft] = useLocation()
      , gt = ft === "/";
    return react.exports.useEffect(()=>{
        const vt = tt.current.getBoundingClientRect();
        rt.current = vt.height
    }
    , [ot]),
    react.exports.useEffect(()=>{
        it.current = 0
    }
    , [st]),
    useAnimationFrame(vt=>{
        if (rt.current === 0 || !tt.current)
            return;
        const {isInfinteScrollActive: yt} = useInfiniteGrid.getState()
          , {experimentsView: wt} = useGlobalStore.getState();
        if (wt === EXP_VIEWS.GRID ? InfiniteGrid$1.isActive && (it.current += input.deltaScroll) : it.current = globalListViewScroll.current * 3,
        it.current = math.clamp(it.current, 0, rt.current),
        nt.current = math.mix(nt.current, (1 - it.current / rt.current) * (yt || !gt ? 0 : 1), .05),
        nt.current < .01 ? ct || (ht(!0),
        nt.current = 0) : ct && ht(!1),
        !ct) {
            let mt = ease.sineIn(nt.current);
            tt.current.style.opacity = mt,
            tt.current.style.transform = `scale(${math.fit(mt, 0, 1, .96, 1)})`
        }
    }
    ),
    jsxs(GridView, {
        ref: tt,
        id: "header",
        className: clsx("header", lt && "header--mini", ct && "header--hidden"),
        children: [jsxs("div", {
            className: "header__title",
            children: [jsx(ClipRevealAnim, {
                delay: INIT_DELAY,
                active: !0,
                type: "clip-right",
                children: jsx("span", {
                    className: "header-stat__label",
                    children: "Labs area"
                })
            }), jsx("h1", {
                children: "Play Ground <br/> R&D Collection <br/> Experiments".split(" <br/> ").map((vt,yt)=>jsx(ClipRevealAnim, {
                    delay: INIT_DELAY,
                    stagger: 150,
                    staggerOrder: yt,
                    byWord: !0,
                    style: {
                        paddingBottom: ut ? "0" : "1.5rem",
                        lineHeight: ut ? 1 : .7,
                        whiteSpace: "pre"
                    },
                    children: vt
                }, vt))
            })]
        }), jsx("div", {
            className: "header__description",
            children: jsx(SplitLines, {
                LineWrapper: ClipRevealAnim,
                active: !0,
                wrapperProps: vt=>({
                    delay: INIT_DELAY + STAGGER_DELAY * 1,
                    stagger: 150,
                    staggerOrder: vt,
                    layers: 3
                }),
                children: "A space dedicated to anticipate how new technologies will affect brands and how we interact with them through R&D."
            })
        }), jsx("div", {
            className: "header__scroll-down",
            children: jsxs("div", {
                className: "header-stat__content--with-icon",
                children: [jsx(ArrowBottomRight16, {
                    active: !0,
                    delay: INIT_DELAY + STAGGER_DELAY * 2
                }), jsx(ClipRevealAnim, {
                    active: !0,
                    delay: INIT_DELAY + STAGGER_DELAY * 3,
                    children: jsx("span", {
                        children: "Scroll Down"
                    })
                })]
            })
        })]
    })
}
function Main(et) {
    const {active: $} = et;
    return jsx(Fragment, {
        children: $ ? jsxs("div", {
            className: "page-wrapper",
            children: [jsx(Header, {}), jsx(CardView, {}), jsx(ListView, {})]
        }) : null
    })
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer = function et($) {
    return $ != null && $.constructor != null && typeof $.constructor.isBuffer == "function" && $.constructor.isBuffer($)
};
function stringifyPosition(et) {
    return !et || typeof et != "object" ? "" : "position"in et || "type"in et ? position$1(et.position) : "start"in et || "end"in et ? position$1(et) : "line"in et || "column"in et ? point$2(et) : ""
}
function point$2(et) {
    return index(et && et.line) + ":" + index(et && et.column)
}
function position$1(et) {
    return point$2(et && et.start) + "-" + point$2(et && et.end)
}
function index(et) {
    return et && typeof et == "number" ? et : 1
}
class VFileMessage extends Error {
    constructor($, tt, nt) {
        const rt = [null, null];
        let it = {
            start: {
                line: null,
                column: null
            },
            end: {
                line: null,
                column: null
            }
        };
        if (super(),
        typeof tt == "string" && (nt = tt,
        tt = void 0),
        typeof nt == "string") {
            const ot = nt.indexOf(":");
            ot === -1 ? rt[1] = nt : (rt[0] = nt.slice(0, ot),
            rt[1] = nt.slice(ot + 1))
        }
        tt && ("type"in tt || "position"in tt ? tt.position && (it = tt.position) : "start"in tt || "end"in tt ? it = tt : ("line"in tt || "column"in tt) && (it.start = tt)),
        this.name = stringifyPosition(tt) || "1:1",
        this.message = typeof $ == "object" ? $.message : $,
        this.stack = "",
        typeof $ == "object" && $.stack && (this.stack = $.stack),
        this.reason = this.message,
        this.fatal,
        this.line = it.start.line,
        this.column = it.start.column,
        this.position = it,
        this.source = rt[0],
        this.ruleId = rt[1],
        this.file,
        this.actual,
        this.expected,
        this.url,
        this.note
    }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;
const path = {
    basename,
    dirname,
    extname,
    join,
    sep: "/"
};
function basename(et, $) {
    if ($ !== void 0 && typeof $ != "string")
        throw new TypeError('"ext" argument must be a string');
    assertPath$1(et);
    let tt = 0, nt = -1, rt = et.length, it;
    if ($ === void 0 || $.length === 0 || $.length > et.length) {
        for (; rt--; )
            if (et.charCodeAt(rt) === 47) {
                if (it) {
                    tt = rt + 1;
                    break
                }
            } else
                nt < 0 && (it = !0,
                nt = rt + 1);
        return nt < 0 ? "" : et.slice(tt, nt)
    }
    if ($ === et)
        return "";
    let ot = -1
      , st = $.length - 1;
    for (; rt--; )
        if (et.charCodeAt(rt) === 47) {
            if (it) {
                tt = rt + 1;
                break
            }
        } else
            ot < 0 && (it = !0,
            ot = rt + 1),
            st > -1 && (et.charCodeAt(rt) === $.charCodeAt(st--) ? st < 0 && (nt = rt) : (st = -1,
            nt = ot));
    return tt === nt ? nt = ot : nt < 0 && (nt = et.length),
    et.slice(tt, nt)
}
function dirname(et) {
    if (assertPath$1(et),
    et.length === 0)
        return ".";
    let $ = -1, tt = et.length, nt;
    for (; --tt; )
        if (et.charCodeAt(tt) === 47) {
            if (nt) {
                $ = tt;
                break
            }
        } else
            nt || (nt = !0);
    return $ < 0 ? et.charCodeAt(0) === 47 ? "/" : "." : $ === 1 && et.charCodeAt(0) === 47 ? "//" : et.slice(0, $)
}
function extname(et) {
    assertPath$1(et);
    let $ = et.length, tt = -1, nt = 0, rt = -1, it = 0, ot;
    for (; $--; ) {
        const st = et.charCodeAt($);
        if (st === 47) {
            if (ot) {
                nt = $ + 1;
                break
            }
            continue
        }
        tt < 0 && (ot = !0,
        tt = $ + 1),
        st === 46 ? rt < 0 ? rt = $ : it !== 1 && (it = 1) : rt > -1 && (it = -1)
    }
    return rt < 0 || tt < 0 || it === 0 || it === 1 && rt === tt - 1 && rt === nt + 1 ? "" : et.slice(rt, tt)
}
function join(...et) {
    let $ = -1, tt;
    for (; ++$ < et.length; )
        assertPath$1(et[$]),
        et[$] && (tt = tt === void 0 ? et[$] : tt + "/" + et[$]);
    return tt === void 0 ? "." : normalize$1(tt)
}
function normalize$1(et) {
    assertPath$1(et);
    const $ = et.charCodeAt(0) === 47;
    let tt = normalizeString(et, !$);
    return tt.length === 0 && !$ && (tt = "."),
    tt.length > 0 && et.charCodeAt(et.length - 1) === 47 && (tt += "/"),
    $ ? "/" + tt : tt
}
function normalizeString(et, $) {
    let tt = "", nt = 0, rt = -1, it = 0, ot = -1, st, lt;
    for (; ++ot <= et.length; ) {
        if (ot < et.length)
            st = et.charCodeAt(ot);
        else {
            if (st === 47)
                break;
            st = 47
        }
        if (st === 47) {
            if (!(rt === ot - 1 || it === 1))
                if (rt !== ot - 1 && it === 2) {
                    if (tt.length < 2 || nt !== 2 || tt.charCodeAt(tt.length - 1) !== 46 || tt.charCodeAt(tt.length - 2) !== 46) {
                        if (tt.length > 2) {
                            if (lt = tt.lastIndexOf("/"),
                            lt !== tt.length - 1) {
                                lt < 0 ? (tt = "",
                                nt = 0) : (tt = tt.slice(0, lt),
                                nt = tt.length - 1 - tt.lastIndexOf("/")),
                                rt = ot,
                                it = 0;
                                continue
                            }
                        } else if (tt.length > 0) {
                            tt = "",
                            nt = 0,
                            rt = ot,
                            it = 0;
                            continue
                        }
                    }
                    $ && (tt = tt.length > 0 ? tt + "/.." : "..",
                    nt = 2)
                } else
                    tt.length > 0 ? tt += "/" + et.slice(rt + 1, ot) : tt = et.slice(rt + 1, ot),
                    nt = ot - rt - 1;
            rt = ot,
            it = 0
        } else
            st === 46 && it > -1 ? it++ : it = -1
    }
    return tt
}
function assertPath$1(et) {
    if (typeof et != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(et))
}
const proc = {
    cwd
};
function cwd() {
    return "/"
}
function isUrl(et) {
    return et !== null && typeof et == "object" && et.href && et.origin
}
function urlToPath(et) {
    if (typeof et == "string")
        et = new URL(et);
    else if (!isUrl(et)) {
        const $ = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + et + "`");
        throw $.code = "ERR_INVALID_ARG_TYPE",
        $
    }
    if (et.protocol !== "file:") {
        const $ = new TypeError("The URL must be of scheme file");
        throw $.code = "ERR_INVALID_URL_SCHEME",
        $
    }
    return getPathFromURLPosix(et)
}
function getPathFromURLPosix(et) {
    if (et.hostname !== "") {
        const nt = new TypeError('File URL host must be "localhost" or empty on darwin');
        throw nt.code = "ERR_INVALID_FILE_URL_HOST",
        nt
    }
    const $ = et.pathname;
    let tt = -1;
    for (; ++tt < $.length; )
        if ($.charCodeAt(tt) === 37 && $.charCodeAt(tt + 1) === 50) {
            const nt = $.charCodeAt(tt + 2);
            if (nt === 70 || nt === 102) {
                const rt = new TypeError("File URL path must not include encoded / characters");
                throw rt.code = "ERR_INVALID_FILE_URL_PATH",
                rt
            }
        }
    return decodeURIComponent($)
}
const order = ["history", "path", "basename", "stem", "extname", "dirname"];
class VFile {
    constructor($) {
        let tt;
        $ ? typeof $ == "string" || buffer($) ? tt = {
            value: $
        } : isUrl($) ? tt = {
            path: $
        } : tt = $ : tt = {},
        this.data = {},
        this.messages = [],
        this.history = [],
        this.cwd = proc.cwd(),
        this.value,
        this.stored,
        this.result,
        this.map;
        let nt = -1;
        for (; ++nt < order.length; ) {
            const it = order[nt];
            it in tt && tt[it] !== void 0 && tt[it] !== null && (this[it] = it === "history" ? [...tt[it]] : tt[it])
        }
        let rt;
        for (rt in tt)
            order.includes(rt) || (this[rt] = tt[rt])
    }
    get path() {
        return this.history[this.history.length - 1]
    }
    set path($) {
        isUrl($) && ($ = urlToPath($)),
        assertNonEmpty($, "path"),
        this.path !== $ && this.history.push($)
    }
    get dirname() {
        return typeof this.path == "string" ? path.dirname(this.path) : void 0
    }
    set dirname($) {
        assertPath(this.basename, "dirname"),
        this.path = path.join($ || "", this.basename)
    }
    get basename() {
        return typeof this.path == "string" ? path.basename(this.path) : void 0
    }
    set basename($) {
        assertNonEmpty($, "basename"),
        assertPart($, "basename"),
        this.path = path.join(this.dirname || "", $)
    }
    get extname() {
        return typeof this.path == "string" ? path.extname(this.path) : void 0
    }
    set extname($) {
        if (assertPart($, "extname"),
        assertPath(this.dirname, "extname"),
        $) {
            if ($.charCodeAt(0) !== 46)
                throw new Error("`extname` must start with `.`");
            if ($.includes(".", 1))
                throw new Error("`extname` cannot contain multiple dots")
        }
        this.path = path.join(this.dirname, this.stem + ($ || ""))
    }
    get stem() {
        return typeof this.path == "string" ? path.basename(this.path, this.extname) : void 0
    }
    set stem($) {
        assertNonEmpty($, "stem"),
        assertPart($, "stem"),
        this.path = path.join(this.dirname || "", $ + (this.extname || ""))
    }
    toString($) {
        return (this.value || "").toString($ || void 0)
    }
    message($, tt, nt) {
        const rt = new VFileMessage($,tt,nt);
        return this.path && (rt.name = this.path + ":" + rt.name,
        rt.file = this.path),
        rt.fatal = !1,
        this.messages.push(rt),
        rt
    }
    info($, tt, nt) {
        const rt = this.message($, tt, nt);
        return rt.fatal = null,
        rt
    }
    fail($, tt, nt) {
        const rt = this.message($, tt, nt);
        throw rt.fatal = !0,
        rt
    }
}
function assertPart(et, $) {
    if (et && et.includes(path.sep))
        throw new Error("`" + $ + "` cannot be a path: did not expect `" + path.sep + "`")
}
function assertNonEmpty(et, $) {
    if (!et)
        throw new Error("`" + $ + "` cannot be empty")
}
function assertPath(et, $) {
    if (!et)
        throw new Error("Setting `" + $ + "` requires `path` to be set too")
}
function buffer(et) {
    return isBuffer(et)
}
function bail(et) {
    if (et)
        throw et
}
var hasOwn = Object.prototype.hasOwnProperty
  , toStr = Object.prototype.toString
  , defineProperty = Object.defineProperty
  , gOPD = Object.getOwnPropertyDescriptor
  , isArray = function et($) {
    return typeof Array.isArray == "function" ? Array.isArray($) : toStr.call($) === "[object Array]"
}
  , isPlainObject$1 = function et($) {
    if (!$ || toStr.call($) !== "[object Object]")
        return !1;
    var tt = hasOwn.call($, "constructor")
      , nt = $.constructor && $.constructor.prototype && hasOwn.call($.constructor.prototype, "isPrototypeOf");
    if ($.constructor && !tt && !nt)
        return !1;
    var rt;
    for (rt in $)
        ;
    return typeof rt == "undefined" || hasOwn.call($, rt)
}
  , setProperty = function et($, tt) {
    defineProperty && tt.name === "__proto__" ? defineProperty($, tt.name, {
        enumerable: !0,
        configurable: !0,
        value: tt.newValue,
        writable: !0
    }) : $[tt.name] = tt.newValue
}
  , getProperty = function et($, tt) {
    if (tt === "__proto__")
        if (hasOwn.call($, tt)) {
            if (gOPD)
                return gOPD($, tt).value
        } else
            return;
    return $[tt]
}
  , extend = function et() {
    var $, tt, nt, rt, it, ot, st = arguments[0], lt = 1, ut = arguments.length, ct = !1;
    for (typeof st == "boolean" && (ct = st,
    st = arguments[1] || {},
    lt = 2),
    (st == null || typeof st != "object" && typeof st != "function") && (st = {}); lt < ut; ++lt)
        if ($ = arguments[lt],
        $ != null)
            for (tt in $)
                nt = getProperty(st, tt),
                rt = getProperty($, tt),
                st !== rt && (ct && rt && (isPlainObject$1(rt) || (it = isArray(rt))) ? (it ? (it = !1,
                ot = nt && isArray(nt) ? nt : []) : ot = nt && isPlainObject$1(nt) ? nt : {},
                setProperty(st, {
                    name: tt,
                    newValue: et(ct, ot, rt)
                })) : typeof rt != "undefined" && setProperty(st, {
                    name: tt,
                    newValue: rt
                }));
    return st
};
function isPlainObject(et) {
    if (typeof et != "object" || et === null)
        return !1;
    const $ = Object.getPrototypeOf(et);
    return ($ === null || $ === Object.prototype || Object.getPrototypeOf($) === null) && !(Symbol.toStringTag in et) && !(Symbol.iterator in et)
}
function trough() {
    const et = []
      , $ = {
        run: tt,
        use: nt
    };
    return $;
    function tt(...rt) {
        let it = -1;
        const ot = rt.pop();
        if (typeof ot != "function")
            throw new TypeError("Expected function as last argument, not " + ot);
        st(null, ...rt);
        function st(lt, ...ut) {
            const ct = et[++it];
            let ht = -1;
            if (lt) {
                ot(lt);
                return
            }
            for (; ++ht < rt.length; )
                (ut[ht] === null || ut[ht] === void 0) && (ut[ht] = rt[ht]);
            rt = ut,
            ct ? wrap$1(ct, st)(...ut) : ot(null, ...ut)
        }
    }
    function nt(rt) {
        if (typeof rt != "function")
            throw new TypeError("Expected `middelware` to be a function, not " + rt);
        return et.push(rt),
        $
    }
}
function wrap$1(et, $) {
    let tt;
    return nt;
    function nt(...ot) {
        const st = et.length > ot.length;
        let lt;
        st && ot.push(rt);
        try {
            lt = et.apply(this, ot)
        } catch (ut) {
            const ct = ut;
            if (st && tt)
                throw ct;
            return rt(ct)
        }
        st || (lt instanceof Promise ? lt.then(it, rt) : lt instanceof Error ? rt(lt) : it(lt))
    }
    function rt(ot, ...st) {
        tt || (tt = !0,
        $(ot, ...st))
    }
    function it(ot) {
        rt(null, ot)
    }
}
const unified = base().freeze()
  , own$6 = {}.hasOwnProperty;
function base() {
    const et = trough()
      , $ = [];
    let tt = {}, nt, rt = -1;
    return it.data = ot,
    it.Parser = void 0,
    it.Compiler = void 0,
    it.freeze = st,
    it.attachers = $,
    it.use = lt,
    it.parse = ut,
    it.stringify = ct,
    it.run = ht,
    it.runSync = ft,
    it.process = gt,
    it.processSync = vt,
    it;
    function it() {
        const yt = base();
        let wt = -1;
        for (; ++wt < $.length; )
            yt.use(...$[wt]);
        return yt.data(extend(!0, {}, tt)),
        yt
    }
    function ot(yt, wt) {
        return typeof yt == "string" ? arguments.length === 2 ? (assertUnfrozen("data", nt),
        tt[yt] = wt,
        it) : own$6.call(tt, yt) && tt[yt] || null : yt ? (assertUnfrozen("data", nt),
        tt = yt,
        it) : tt
    }
    function st() {
        if (nt)
            return it;
        for (; ++rt < $.length; ) {
            const [yt,...wt] = $[rt];
            if (wt[0] === !1)
                continue;
            wt[0] === !0 && (wt[0] = void 0);
            const mt = yt.call(it, ...wt);
            typeof mt == "function" && et.use(mt)
        }
        return nt = !0,
        rt = Number.POSITIVE_INFINITY,
        it
    }
    function lt(yt, ...wt) {
        let mt;
        if (assertUnfrozen("use", nt),
        yt != null)
            if (typeof yt == "function")
                St(yt, ...wt);
            else if (typeof yt == "object")
                Array.isArray(yt) ? Mt(yt) : bt(yt);
            else
                throw new TypeError("Expected usable value, not `" + yt + "`");
        return mt && (tt.settings = Object.assign(tt.settings || {}, mt)),
        it;
        function _t(At) {
            if (typeof At == "function")
                St(At);
            else if (typeof At == "object")
                if (Array.isArray(At)) {
                    const [Pt,...Ot] = At;
                    St(Pt, ...Ot)
                } else
                    bt(At);
            else
                throw new TypeError("Expected usable value, not `" + At + "`")
        }
        function bt(At) {
            Mt(At.plugins),
            At.settings && (mt = Object.assign(mt || {}, At.settings))
        }
        function Mt(At) {
            let Pt = -1;
            if (At != null)
                if (Array.isArray(At))
                    for (; ++Pt < At.length; ) {
                        const Ot = At[Pt];
                        _t(Ot)
                    }
                else
                    throw new TypeError("Expected a list of plugins, not `" + At + "`")
        }
        function St(At, Pt) {
            let Ot = -1, Zt;
            for (; ++Ot < $.length; )
                if ($[Ot][0] === At) {
                    Zt = $[Ot];
                    break
                }
            Zt ? (isPlainObject(Zt[1]) && isPlainObject(Pt) && (Pt = extend(!0, Zt[1], Pt)),
            Zt[1] = Pt) : $.push([...arguments])
        }
    }
    function ut(yt) {
        it.freeze();
        const wt = vfile(yt)
          , mt = it.Parser;
        return assertParser("parse", mt),
        newable(mt, "parse") ? new mt(String(wt),wt).parse() : mt(String(wt), wt)
    }
    function ct(yt, wt) {
        it.freeze();
        const mt = vfile(wt)
          , _t = it.Compiler;
        return assertCompiler("stringify", _t),
        assertNode(yt),
        newable(_t, "compile") ? new _t(yt,mt).compile() : _t(yt, mt)
    }
    function ht(yt, wt, mt) {
        if (assertNode(yt),
        it.freeze(),
        !mt && typeof wt == "function" && (mt = wt,
        wt = void 0),
        !mt)
            return new Promise(_t);
        _t(null, mt);
        function _t(bt, Mt) {
            et.run(yt, vfile(wt), St);
            function St(At, Pt, Ot) {
                Pt = Pt || yt,
                At ? Mt(At) : bt ? bt(Pt) : mt(null, Pt, Ot)
            }
        }
    }
    function ft(yt, wt) {
        let mt, _t;
        return it.run(yt, wt, bt),
        assertDone("runSync", "run", _t),
        mt;
        function bt(Mt, St) {
            bail(Mt),
            mt = St,
            _t = !0
        }
    }
    function gt(yt, wt) {
        if (it.freeze(),
        assertParser("process", it.Parser),
        assertCompiler("process", it.Compiler),
        !wt)
            return new Promise(mt);
        mt(null, wt);
        function mt(_t, bt) {
            const Mt = vfile(yt);
            it.run(it.parse(Mt), Mt, (At,Pt,Ot)=>{
                if (At || !Pt || !Ot)
                    St(At);
                else {
                    const Zt = it.stringify(Pt, Ot);
                    Zt == null || (looksLikeAVFileValue(Zt) ? Ot.value = Zt : Ot.result = Zt),
                    St(At, Ot)
                }
            }
            );
            function St(At, Pt) {
                At || !Pt ? bt(At) : _t ? _t(Pt) : wt(null, Pt)
            }
        }
    }
    function vt(yt) {
        let wt;
        it.freeze(),
        assertParser("processSync", it.Parser),
        assertCompiler("processSync", it.Compiler);
        const mt = vfile(yt);
        return it.process(mt, _t),
        assertDone("processSync", "process", wt),
        mt;
        function _t(bt) {
            wt = !0,
            bail(bt)
        }
    }
}
function newable(et, $) {
    return typeof et == "function" && et.prototype && (keys(et.prototype) || $ in et.prototype)
}
function keys(et) {
    let $;
    for ($ in et)
        if (own$6.call(et, $))
            return !0;
    return !1
}
function assertParser(et, $) {
    if (typeof $ != "function")
        throw new TypeError("Cannot `" + et + "` without `Parser`")
}
function assertCompiler(et, $) {
    if (typeof $ != "function")
        throw new TypeError("Cannot `" + et + "` without `Compiler`")
}
function assertUnfrozen(et, $) {
    if ($)
        throw new Error("Cannot call `" + et + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")
}
function assertNode(et) {
    if (!isPlainObject(et) || typeof et.type != "string")
        throw new TypeError("Expected node, got `" + et + "`")
}
function assertDone(et, $, tt) {
    if (!tt)
        throw new Error("`" + et + "` finished async. Use `" + $ + "` instead")
}
function vfile(et) {
    return looksLikeAVFile(et) ? et : new VFile(et)
}
function looksLikeAVFile(et) {
    return Boolean(et && typeof et == "object" && "message"in et && "messages"in et)
}
function looksLikeAVFileValue(et) {
    return typeof et == "string" || isBuffer(et)
}
function toString(et, $) {
    const tt = ($ || {}).includeImageAlt;
    return one$1(et, typeof tt == "boolean" ? tt : !0)
}
function one$1(et, $) {
    return node(et) && ("value"in et && et.value || $ && "alt"in et && et.alt || "children"in et && all$1(et.children, $)) || Array.isArray(et) && all$1(et, $) || ""
}
function all$1(et, $) {
    const tt = [];
    let nt = -1;
    for (; ++nt < et.length; )
        tt[nt] = one$1(et[nt], $);
    return tt.join("")
}
function node(et) {
    return Boolean(et && typeof et == "object")
}
function splice(et, $, tt, nt) {
    const rt = et.length;
    let it = 0, ot;
    if ($ < 0 ? $ = -$ > rt ? 0 : rt + $ : $ = $ > rt ? rt : $,
    tt = tt > 0 ? tt : 0,
    nt.length < 1e4)
        ot = Array.from(nt),
        ot.unshift($, tt),
        [].splice.apply(et, ot);
    else
        for (tt && [].splice.apply(et, [$, tt]); it < nt.length; )
            ot = nt.slice(it, it + 1e4),
            ot.unshift($, 0),
            [].splice.apply(et, ot),
            it += 1e4,
            $ += 1e4
}
function push(et, $) {
    return et.length > 0 ? (splice(et, et.length, 0, $),
    et) : $
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(et) {
    const $ = {};
    let tt = -1;
    for (; ++tt < et.length; )
        syntaxExtension($, et[tt]);
    return $
}
function syntaxExtension(et, $) {
    let tt;
    for (tt in $) {
        const rt = (hasOwnProperty.call(et, tt) ? et[tt] : void 0) || (et[tt] = {})
          , it = $[tt];
        let ot;
        for (ot in it) {
            hasOwnProperty.call(rt, ot) || (rt[ot] = []);
            const st = it[ot];
            constructs(rt[ot], Array.isArray(st) ? st : st ? [st] : [])
        }
    }
}
function constructs(et, $) {
    let tt = -1;
    const nt = [];
    for (; ++tt < $.length; )
        ($[tt].add === "after" ? et : nt).push($[tt]);
    splice(et, 0, 0, nt)
}
const unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/
  , asciiAlpha = regexCheck(/[A-Za-z]/)
  , asciiDigit = regexCheck(/\d/)
  , asciiHexDigit = regexCheck(/[\dA-Fa-f]/)
  , asciiAlphanumeric = regexCheck(/[\dA-Za-z]/)
  , asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)
  , asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(et) {
    return et !== null && (et < 32 || et === 127)
}
function markdownLineEndingOrSpace(et) {
    return et !== null && (et < 0 || et === 32)
}
function markdownLineEnding(et) {
    return et !== null && et < -2
}
function markdownSpace(et) {
    return et === -2 || et === -1 || et === 32
}
const unicodeWhitespace = regexCheck(/\s/)
  , unicodePunctuation = regexCheck(unicodePunctuationRegex);
function regexCheck(et) {
    return $;
    function $(tt) {
        return tt !== null && et.test(String.fromCharCode(tt))
    }
}
function factorySpace(et, $, tt, nt) {
    const rt = nt ? nt - 1 : Number.POSITIVE_INFINITY;
    let it = 0;
    return ot;
    function ot(lt) {
        return markdownSpace(lt) ? (et.enter(tt),
        st(lt)) : $(lt)
    }
    function st(lt) {
        return markdownSpace(lt) && it++ < rt ? (et.consume(lt),
        st) : (et.exit(tt),
        $(lt))
    }
}
const content$1 = {
    tokenize: initializeContent
};
function initializeContent(et) {
    const $ = et.attempt(this.parser.constructs.contentInitial, nt, rt);
    let tt;
    return $;
    function nt(st) {
        if (st === null) {
            et.consume(st);
            return
        }
        return et.enter("lineEnding"),
        et.consume(st),
        et.exit("lineEnding"),
        factorySpace(et, $, "linePrefix")
    }
    function rt(st) {
        return et.enter("paragraph"),
        it(st)
    }
    function it(st) {
        const lt = et.enter("chunkText", {
            contentType: "text",
            previous: tt
        });
        return tt && (tt.next = lt),
        tt = lt,
        ot(st)
    }
    function ot(st) {
        if (st === null) {
            et.exit("chunkText"),
            et.exit("paragraph"),
            et.consume(st);
            return
        }
        return markdownLineEnding(st) ? (et.consume(st),
        et.exit("chunkText"),
        it) : (et.consume(st),
        ot)
    }
}
const document$2 = {
    tokenize: initializeDocument
}
  , containerConstruct = {
    tokenize: tokenizeContainer
};
function initializeDocument(et) {
    const $ = this
      , tt = [];
    let nt = 0, rt, it, ot;
    return st;
    function st(bt) {
        if (nt < tt.length) {
            const Mt = tt[nt];
            return $.containerState = Mt[1],
            et.attempt(Mt[0].continuation, lt, ut)(bt)
        }
        return ut(bt)
    }
    function lt(bt) {
        if (nt++,
        $.containerState._closeFlow) {
            $.containerState._closeFlow = void 0,
            rt && _t();
            const Mt = $.events.length;
            let St = Mt, At;
            for (; St--; )
                if ($.events[St][0] === "exit" && $.events[St][1].type === "chunkFlow") {
                    At = $.events[St][1].end;
                    break
                }
            mt(nt);
            let Pt = Mt;
            for (; Pt < $.events.length; )
                $.events[Pt][1].end = Object.assign({}, At),
                Pt++;
            return splice($.events, St + 1, 0, $.events.slice(Mt)),
            $.events.length = Pt,
            ut(bt)
        }
        return st(bt)
    }
    function ut(bt) {
        if (nt === tt.length) {
            if (!rt)
                return ft(bt);
            if (rt.currentConstruct && rt.currentConstruct.concrete)
                return vt(bt);
            $.interrupt = Boolean(rt.currentConstruct && !rt._gfmTableDynamicInterruptHack)
        }
        return $.containerState = {},
        et.check(containerConstruct, ct, ht)(bt)
    }
    function ct(bt) {
        return rt && _t(),
        mt(nt),
        ft(bt)
    }
    function ht(bt) {
        return $.parser.lazy[$.now().line] = nt !== tt.length,
        ot = $.now().offset,
        vt(bt)
    }
    function ft(bt) {
        return $.containerState = {},
        et.attempt(containerConstruct, gt, vt)(bt)
    }
    function gt(bt) {
        return nt++,
        tt.push([$.currentConstruct, $.containerState]),
        ft(bt)
    }
    function vt(bt) {
        if (bt === null) {
            rt && _t(),
            mt(0),
            et.consume(bt);
            return
        }
        return rt = rt || $.parser.flow($.now()),
        et.enter("chunkFlow", {
            contentType: "flow",
            previous: it,
            _tokenizer: rt
        }),
        yt(bt)
    }
    function yt(bt) {
        if (bt === null) {
            wt(et.exit("chunkFlow"), !0),
            mt(0),
            et.consume(bt);
            return
        }
        return markdownLineEnding(bt) ? (et.consume(bt),
        wt(et.exit("chunkFlow")),
        nt = 0,
        $.interrupt = void 0,
        st) : (et.consume(bt),
        yt)
    }
    function wt(bt, Mt) {
        const St = $.sliceStream(bt);
        if (Mt && St.push(null),
        bt.previous = it,
        it && (it.next = bt),
        it = bt,
        rt.defineSkip(bt.start),
        rt.write(St),
        $.parser.lazy[bt.start.line]) {
            let At = rt.events.length;
            for (; At--; )
                if (rt.events[At][1].start.offset < ot && (!rt.events[At][1].end || rt.events[At][1].end.offset > ot))
                    return;
            const Pt = $.events.length;
            let Ot = Pt, Zt, Nt;
            for (; Ot--; )
                if ($.events[Ot][0] === "exit" && $.events[Ot][1].type === "chunkFlow") {
                    if (Zt) {
                        Nt = $.events[Ot][1].end;
                        break
                    }
                    Zt = !0
                }
            for (mt(nt),
            At = Pt; At < $.events.length; )
                $.events[At][1].end = Object.assign({}, Nt),
                At++;
            splice($.events, Ot + 1, 0, $.events.slice(Pt)),
            $.events.length = At
        }
    }
    function mt(bt) {
        let Mt = tt.length;
        for (; Mt-- > bt; ) {
            const St = tt[Mt];
            $.containerState = St[1],
            St[0].exit.call($, et)
        }
        tt.length = bt
    }
    function _t() {
        rt.write([null]),
        it = void 0,
        rt = void 0,
        $.containerState._closeFlow = void 0
    }
}
function tokenizeContainer(et, $, tt) {
    return factorySpace(et, et.attempt(this.parser.constructs.document, $, tt), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)
}
function classifyCharacter(et) {
    if (et === null || markdownLineEndingOrSpace(et) || unicodeWhitespace(et))
        return 1;
    if (unicodePunctuation(et))
        return 2
}
function resolveAll(et, $, tt) {
    const nt = [];
    let rt = -1;
    for (; ++rt < et.length; ) {
        const it = et[rt].resolveAll;
        it && !nt.includes(it) && ($ = it($, tt),
        nt.push(it))
    }
    return $
}
const attention = {
    name: "attention",
    tokenize: tokenizeAttention,
    resolveAll: resolveAllAttention
};
function resolveAllAttention(et, $) {
    let tt = -1, nt, rt, it, ot, st, lt, ut, ct;
    for (; ++tt < et.length; )
        if (et[tt][0] === "enter" && et[tt][1].type === "attentionSequence" && et[tt][1]._close) {
            for (nt = tt; nt--; )
                if (et[nt][0] === "exit" && et[nt][1].type === "attentionSequence" && et[nt][1]._open && $.sliceSerialize(et[nt][1]).charCodeAt(0) === $.sliceSerialize(et[tt][1]).charCodeAt(0)) {
                    if ((et[nt][1]._close || et[tt][1]._open) && (et[tt][1].end.offset - et[tt][1].start.offset) % 3 && !((et[nt][1].end.offset - et[nt][1].start.offset + et[tt][1].end.offset - et[tt][1].start.offset) % 3))
                        continue;
                    lt = et[nt][1].end.offset - et[nt][1].start.offset > 1 && et[tt][1].end.offset - et[tt][1].start.offset > 1 ? 2 : 1;
                    const ht = Object.assign({}, et[nt][1].end)
                      , ft = Object.assign({}, et[tt][1].start);
                    movePoint(ht, -lt),
                    movePoint(ft, lt),
                    ot = {
                        type: lt > 1 ? "strongSequence" : "emphasisSequence",
                        start: ht,
                        end: Object.assign({}, et[nt][1].end)
                    },
                    st = {
                        type: lt > 1 ? "strongSequence" : "emphasisSequence",
                        start: Object.assign({}, et[tt][1].start),
                        end: ft
                    },
                    it = {
                        type: lt > 1 ? "strongText" : "emphasisText",
                        start: Object.assign({}, et[nt][1].end),
                        end: Object.assign({}, et[tt][1].start)
                    },
                    rt = {
                        type: lt > 1 ? "strong" : "emphasis",
                        start: Object.assign({}, ot.start),
                        end: Object.assign({}, st.end)
                    },
                    et[nt][1].end = Object.assign({}, ot.start),
                    et[tt][1].start = Object.assign({}, st.end),
                    ut = [],
                    et[nt][1].end.offset - et[nt][1].start.offset && (ut = push(ut, [["enter", et[nt][1], $], ["exit", et[nt][1], $]])),
                    ut = push(ut, [["enter", rt, $], ["enter", ot, $], ["exit", ot, $], ["enter", it, $]]),
                    ut = push(ut, resolveAll($.parser.constructs.insideSpan.null, et.slice(nt + 1, tt), $)),
                    ut = push(ut, [["exit", it, $], ["enter", st, $], ["exit", st, $], ["exit", rt, $]]),
                    et[tt][1].end.offset - et[tt][1].start.offset ? (ct = 2,
                    ut = push(ut, [["enter", et[tt][1], $], ["exit", et[tt][1], $]])) : ct = 0,
                    splice(et, nt - 1, tt - nt + 3, ut),
                    tt = nt + ut.length - ct - 2;
                    break
                }
        }
    for (tt = -1; ++tt < et.length; )
        et[tt][1].type === "attentionSequence" && (et[tt][1].type = "data");
    return et
}
function tokenizeAttention(et, $) {
    const tt = this.parser.constructs.attentionMarkers.null
      , nt = this.previous
      , rt = classifyCharacter(nt);
    let it;
    return ot;
    function ot(lt) {
        return et.enter("attentionSequence"),
        it = lt,
        st(lt)
    }
    function st(lt) {
        if (lt === it)
            return et.consume(lt),
            st;
        const ut = et.exit("attentionSequence")
          , ct = classifyCharacter(lt)
          , ht = !ct || ct === 2 && rt || tt.includes(lt)
          , ft = !rt || rt === 2 && ct || tt.includes(nt);
        return ut._open = Boolean(it === 42 ? ht : ht && (rt || !ft)),
        ut._close = Boolean(it === 42 ? ft : ft && (ct || !ht)),
        $(lt)
    }
}
function movePoint(et, $) {
    et.column += $,
    et.offset += $,
    et._bufferIndex += $
}
const autolink = {
    name: "autolink",
    tokenize: tokenizeAutolink
};
function tokenizeAutolink(et, $, tt) {
    let nt = 1;
    return rt;
    function rt(vt) {
        return et.enter("autolink"),
        et.enter("autolinkMarker"),
        et.consume(vt),
        et.exit("autolinkMarker"),
        et.enter("autolinkProtocol"),
        it
    }
    function it(vt) {
        return asciiAlpha(vt) ? (et.consume(vt),
        ot) : asciiAtext(vt) ? ut(vt) : tt(vt)
    }
    function ot(vt) {
        return vt === 43 || vt === 45 || vt === 46 || asciiAlphanumeric(vt) ? st(vt) : ut(vt)
    }
    function st(vt) {
        return vt === 58 ? (et.consume(vt),
        lt) : (vt === 43 || vt === 45 || vt === 46 || asciiAlphanumeric(vt)) && nt++ < 32 ? (et.consume(vt),
        st) : ut(vt)
    }
    function lt(vt) {
        return vt === 62 ? (et.exit("autolinkProtocol"),
        gt(vt)) : vt === null || vt === 32 || vt === 60 || asciiControl(vt) ? tt(vt) : (et.consume(vt),
        lt)
    }
    function ut(vt) {
        return vt === 64 ? (et.consume(vt),
        nt = 0,
        ct) : asciiAtext(vt) ? (et.consume(vt),
        ut) : tt(vt)
    }
    function ct(vt) {
        return asciiAlphanumeric(vt) ? ht(vt) : tt(vt)
    }
    function ht(vt) {
        return vt === 46 ? (et.consume(vt),
        nt = 0,
        ct) : vt === 62 ? (et.exit("autolinkProtocol").type = "autolinkEmail",
        gt(vt)) : ft(vt)
    }
    function ft(vt) {
        return (vt === 45 || asciiAlphanumeric(vt)) && nt++ < 63 ? (et.consume(vt),
        vt === 45 ? ft : ht) : tt(vt)
    }
    function gt(vt) {
        return et.enter("autolinkMarker"),
        et.consume(vt),
        et.exit("autolinkMarker"),
        et.exit("autolink"),
        $
    }
}
const blankLine = {
    tokenize: tokenizeBlankLine,
    partial: !0
};
function tokenizeBlankLine(et, $, tt) {
    return factorySpace(et, nt, "linePrefix");
    function nt(rt) {
        return rt === null || markdownLineEnding(rt) ? $(rt) : tt(rt)
    }
}
const blockQuote = {
    name: "blockQuote",
    tokenize: tokenizeBlockQuoteStart,
    continuation: {
        tokenize: tokenizeBlockQuoteContinuation
    },
    exit
};
function tokenizeBlockQuoteStart(et, $, tt) {
    const nt = this;
    return rt;
    function rt(ot) {
        if (ot === 62) {
            const st = nt.containerState;
            return st.open || (et.enter("blockQuote", {
                _container: !0
            }),
            st.open = !0),
            et.enter("blockQuotePrefix"),
            et.enter("blockQuoteMarker"),
            et.consume(ot),
            et.exit("blockQuoteMarker"),
            it
        }
        return tt(ot)
    }
    function it(ot) {
        return markdownSpace(ot) ? (et.enter("blockQuotePrefixWhitespace"),
        et.consume(ot),
        et.exit("blockQuotePrefixWhitespace"),
        et.exit("blockQuotePrefix"),
        $) : (et.exit("blockQuotePrefix"),
        $(ot))
    }
}
function tokenizeBlockQuoteContinuation(et, $, tt) {
    return factorySpace(et, et.attempt(blockQuote, $, tt), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)
}
function exit(et) {
    et.exit("blockQuote")
}
const characterEscape = {
    name: "characterEscape",
    tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(et, $, tt) {
    return nt;
    function nt(it) {
        return et.enter("characterEscape"),
        et.enter("escapeMarker"),
        et.consume(it),
        et.exit("escapeMarker"),
        rt
    }
    function rt(it) {
        return asciiPunctuation(it) ? (et.enter("characterEscapeValue"),
        et.consume(it),
        et.exit("characterEscapeValue"),
        et.exit("characterEscape"),
        $) : tt(it)
    }
}
const element = document.createElement("i");
function decodeNamedCharacterReference(et) {
    const $ = "&" + et + ";";
    element.innerHTML = $;
    const tt = element.textContent;
    return tt.charCodeAt(tt.length - 1) === 59 && et !== "semi" || tt === $ ? !1 : tt
}
const characterReference = {
    name: "characterReference",
    tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(et, $, tt) {
    const nt = this;
    let rt = 0, it, ot;
    return st;
    function st(ht) {
        return et.enter("characterReference"),
        et.enter("characterReferenceMarker"),
        et.consume(ht),
        et.exit("characterReferenceMarker"),
        lt
    }
    function lt(ht) {
        return ht === 35 ? (et.enter("characterReferenceMarkerNumeric"),
        et.consume(ht),
        et.exit("characterReferenceMarkerNumeric"),
        ut) : (et.enter("characterReferenceValue"),
        it = 31,
        ot = asciiAlphanumeric,
        ct(ht))
    }
    function ut(ht) {
        return ht === 88 || ht === 120 ? (et.enter("characterReferenceMarkerHexadecimal"),
        et.consume(ht),
        et.exit("characterReferenceMarkerHexadecimal"),
        et.enter("characterReferenceValue"),
        it = 6,
        ot = asciiHexDigit,
        ct) : (et.enter("characterReferenceValue"),
        it = 7,
        ot = asciiDigit,
        ct(ht))
    }
    function ct(ht) {
        let ft;
        return ht === 59 && rt ? (ft = et.exit("characterReferenceValue"),
        ot === asciiAlphanumeric && !decodeNamedCharacterReference(nt.sliceSerialize(ft)) ? tt(ht) : (et.enter("characterReferenceMarker"),
        et.consume(ht),
        et.exit("characterReferenceMarker"),
        et.exit("characterReference"),
        $)) : ot(ht) && rt++ < it ? (et.consume(ht),
        ct) : tt(ht)
    }
}
const codeFenced = {
    name: "codeFenced",
    tokenize: tokenizeCodeFenced,
    concrete: !0
};
function tokenizeCodeFenced(et, $, tt) {
    const nt = this
      , rt = {
        tokenize: St,
        partial: !0
    }
      , it = {
        tokenize: Mt,
        partial: !0
    }
      , ot = this.events[this.events.length - 1]
      , st = ot && ot[1].type === "linePrefix" ? ot[2].sliceSerialize(ot[1], !0).length : 0;
    let lt = 0, ut;
    return ct;
    function ct(At) {
        return et.enter("codeFenced"),
        et.enter("codeFencedFence"),
        et.enter("codeFencedFenceSequence"),
        ut = At,
        ht(At)
    }
    function ht(At) {
        return At === ut ? (et.consume(At),
        lt++,
        ht) : (et.exit("codeFencedFenceSequence"),
        lt < 3 ? tt(At) : factorySpace(et, ft, "whitespace")(At))
    }
    function ft(At) {
        return At === null || markdownLineEnding(At) ? wt(At) : (et.enter("codeFencedFenceInfo"),
        et.enter("chunkString", {
            contentType: "string"
        }),
        gt(At))
    }
    function gt(At) {
        return At === null || markdownLineEndingOrSpace(At) ? (et.exit("chunkString"),
        et.exit("codeFencedFenceInfo"),
        factorySpace(et, vt, "whitespace")(At)) : At === 96 && At === ut ? tt(At) : (et.consume(At),
        gt)
    }
    function vt(At) {
        return At === null || markdownLineEnding(At) ? wt(At) : (et.enter("codeFencedFenceMeta"),
        et.enter("chunkString", {
            contentType: "string"
        }),
        yt(At))
    }
    function yt(At) {
        return At === null || markdownLineEnding(At) ? (et.exit("chunkString"),
        et.exit("codeFencedFenceMeta"),
        wt(At)) : At === 96 && At === ut ? tt(At) : (et.consume(At),
        yt)
    }
    function wt(At) {
        return et.exit("codeFencedFence"),
        nt.interrupt ? $(At) : mt(At)
    }
    function mt(At) {
        return At === null ? bt(At) : markdownLineEnding(At) ? et.attempt(it, et.attempt(rt, bt, st ? factorySpace(et, mt, "linePrefix", st + 1) : mt), bt)(At) : (et.enter("codeFlowValue"),
        _t(At))
    }
    function _t(At) {
        return At === null || markdownLineEnding(At) ? (et.exit("codeFlowValue"),
        mt(At)) : (et.consume(At),
        _t)
    }
    function bt(At) {
        return et.exit("codeFenced"),
        $(At)
    }
    function Mt(At, Pt, Ot) {
        const Zt = this;
        return Nt;
        function Nt(Ft) {
            return At.enter("lineEnding"),
            At.consume(Ft),
            At.exit("lineEnding"),
            Tt
        }
        function Tt(Ft) {
            return Zt.parser.lazy[Zt.now().line] ? Ot(Ft) : Pt(Ft)
        }
    }
    function St(At, Pt, Ot) {
        let Zt = 0;
        return factorySpace(At, Nt, "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
        function Nt($t) {
            return At.enter("codeFencedFence"),
            At.enter("codeFencedFenceSequence"),
            Tt($t)
        }
        function Tt($t) {
            return $t === ut ? (At.consume($t),
            Zt++,
            Tt) : Zt < lt ? Ot($t) : (At.exit("codeFencedFenceSequence"),
            factorySpace(At, Ft, "whitespace")($t))
        }
        function Ft($t) {
            return $t === null || markdownLineEnding($t) ? (At.exit("codeFencedFence"),
            Pt($t)) : Ot($t)
        }
    }
}
const codeIndented = {
    name: "codeIndented",
    tokenize: tokenizeCodeIndented
}
  , indentedContent = {
    tokenize: tokenizeIndentedContent,
    partial: !0
};
function tokenizeCodeIndented(et, $, tt) {
    const nt = this;
    return rt;
    function rt(ut) {
        return et.enter("codeIndented"),
        factorySpace(et, it, "linePrefix", 4 + 1)(ut)
    }
    function it(ut) {
        const ct = nt.events[nt.events.length - 1];
        return ct && ct[1].type === "linePrefix" && ct[2].sliceSerialize(ct[1], !0).length >= 4 ? ot(ut) : tt(ut)
    }
    function ot(ut) {
        return ut === null ? lt(ut) : markdownLineEnding(ut) ? et.attempt(indentedContent, ot, lt)(ut) : (et.enter("codeFlowValue"),
        st(ut))
    }
    function st(ut) {
        return ut === null || markdownLineEnding(ut) ? (et.exit("codeFlowValue"),
        ot(ut)) : (et.consume(ut),
        st)
    }
    function lt(ut) {
        return et.exit("codeIndented"),
        $(ut)
    }
}
function tokenizeIndentedContent(et, $, tt) {
    const nt = this;
    return rt;
    function rt(ot) {
        return nt.parser.lazy[nt.now().line] ? tt(ot) : markdownLineEnding(ot) ? (et.enter("lineEnding"),
        et.consume(ot),
        et.exit("lineEnding"),
        rt) : factorySpace(et, it, "linePrefix", 4 + 1)(ot)
    }
    function it(ot) {
        const st = nt.events[nt.events.length - 1];
        return st && st[1].type === "linePrefix" && st[2].sliceSerialize(st[1], !0).length >= 4 ? $(ot) : markdownLineEnding(ot) ? rt(ot) : tt(ot)
    }
}
const codeText = {
    name: "codeText",
    tokenize: tokenizeCodeText,
    resolve: resolveCodeText,
    previous
};
function resolveCodeText(et) {
    let $ = et.length - 4, tt = 3, nt, rt;
    if ((et[tt][1].type === "lineEnding" || et[tt][1].type === "space") && (et[$][1].type === "lineEnding" || et[$][1].type === "space")) {
        for (nt = tt; ++nt < $; )
            if (et[nt][1].type === "codeTextData") {
                et[tt][1].type = "codeTextPadding",
                et[$][1].type = "codeTextPadding",
                tt += 2,
                $ -= 2;
                break
            }
    }
    for (nt = tt - 1,
    $++; ++nt <= $; )
        rt === void 0 ? nt !== $ && et[nt][1].type !== "lineEnding" && (rt = nt) : (nt === $ || et[nt][1].type === "lineEnding") && (et[rt][1].type = "codeTextData",
        nt !== rt + 2 && (et[rt][1].end = et[nt - 1][1].end,
        et.splice(rt + 2, nt - rt - 2),
        $ -= nt - rt - 2,
        nt = rt + 2),
        rt = void 0);
    return et
}
function previous(et) {
    return et !== 96 || this.events[this.events.length - 1][1].type === "characterEscape"
}
function tokenizeCodeText(et, $, tt) {
    let nt = 0, rt, it;
    return ot;
    function ot(ht) {
        return et.enter("codeText"),
        et.enter("codeTextSequence"),
        st(ht)
    }
    function st(ht) {
        return ht === 96 ? (et.consume(ht),
        nt++,
        st) : (et.exit("codeTextSequence"),
        lt(ht))
    }
    function lt(ht) {
        return ht === null ? tt(ht) : ht === 96 ? (it = et.enter("codeTextSequence"),
        rt = 0,
        ct(ht)) : ht === 32 ? (et.enter("space"),
        et.consume(ht),
        et.exit("space"),
        lt) : markdownLineEnding(ht) ? (et.enter("lineEnding"),
        et.consume(ht),
        et.exit("lineEnding"),
        lt) : (et.enter("codeTextData"),
        ut(ht))
    }
    function ut(ht) {
        return ht === null || ht === 32 || ht === 96 || markdownLineEnding(ht) ? (et.exit("codeTextData"),
        lt(ht)) : (et.consume(ht),
        ut)
    }
    function ct(ht) {
        return ht === 96 ? (et.consume(ht),
        rt++,
        ct) : rt === nt ? (et.exit("codeTextSequence"),
        et.exit("codeText"),
        $(ht)) : (it.type = "codeTextData",
        ut(ht))
    }
}
function subtokenize(et) {
    const $ = {};
    let tt = -1, nt, rt, it, ot, st, lt, ut;
    for (; ++tt < et.length; ) {
        for (; tt in $; )
            tt = $[tt];
        if (nt = et[tt],
        tt && nt[1].type === "chunkFlow" && et[tt - 1][1].type === "listItemPrefix" && (lt = nt[1]._tokenizer.events,
        it = 0,
        it < lt.length && lt[it][1].type === "lineEndingBlank" && (it += 2),
        it < lt.length && lt[it][1].type === "content"))
            for (; ++it < lt.length && lt[it][1].type !== "content"; )
                lt[it][1].type === "chunkText" && (lt[it][1]._isInFirstContentOfListItem = !0,
                it++);
        if (nt[0] === "enter")
            nt[1].contentType && (Object.assign($, subcontent(et, tt)),
            tt = $[tt],
            ut = !0);
        else if (nt[1]._container) {
            for (it = tt,
            rt = void 0; it-- && (ot = et[it],
            ot[1].type === "lineEnding" || ot[1].type === "lineEndingBlank"); )
                ot[0] === "enter" && (rt && (et[rt][1].type = "lineEndingBlank"),
                ot[1].type = "lineEnding",
                rt = it);
            rt && (nt[1].end = Object.assign({}, et[rt][1].start),
            st = et.slice(rt, tt),
            st.unshift(nt),
            splice(et, rt, tt - rt + 1, st))
        }
    }
    return !ut
}
function subcontent(et, $) {
    const tt = et[$][1]
      , nt = et[$][2];
    let rt = $ - 1;
    const it = []
      , ot = tt._tokenizer || nt.parser[tt.contentType](tt.start)
      , st = ot.events
      , lt = []
      , ut = {};
    let ct, ht, ft = -1, gt = tt, vt = 0, yt = 0;
    const wt = [yt];
    for (; gt; ) {
        for (; et[++rt][1] !== gt; )
            ;
        it.push(rt),
        gt._tokenizer || (ct = nt.sliceStream(gt),
        gt.next || ct.push(null),
        ht && ot.defineSkip(gt.start),
        gt._isInFirstContentOfListItem && (ot._gfmTasklistFirstContentOfListItem = !0),
        ot.write(ct),
        gt._isInFirstContentOfListItem && (ot._gfmTasklistFirstContentOfListItem = void 0)),
        ht = gt,
        gt = gt.next
    }
    for (gt = tt; ++ft < st.length; )
        st[ft][0] === "exit" && st[ft - 1][0] === "enter" && st[ft][1].type === st[ft - 1][1].type && st[ft][1].start.line !== st[ft][1].end.line && (yt = ft + 1,
        wt.push(yt),
        gt._tokenizer = void 0,
        gt.previous = void 0,
        gt = gt.next);
    for (ot.events = [],
    gt ? (gt._tokenizer = void 0,
    gt.previous = void 0) : wt.pop(),
    ft = wt.length; ft--; ) {
        const mt = st.slice(wt[ft], wt[ft + 1])
          , _t = it.pop();
        lt.unshift([_t, _t + mt.length - 1]),
        splice(et, _t, 2, mt)
    }
    for (ft = -1; ++ft < lt.length; )
        ut[vt + lt[ft][0]] = vt + lt[ft][1],
        vt += lt[ft][1] - lt[ft][0] - 1;
    return ut
}
const content = {
    tokenize: tokenizeContent,
    resolve: resolveContent
}
  , continuationConstruct = {
    tokenize: tokenizeContinuation,
    partial: !0
};
function resolveContent(et) {
    return subtokenize(et),
    et
}
function tokenizeContent(et, $) {
    let tt;
    return nt;
    function nt(st) {
        return et.enter("content"),
        tt = et.enter("chunkContent", {
            contentType: "content"
        }),
        rt(st)
    }
    function rt(st) {
        return st === null ? it(st) : markdownLineEnding(st) ? et.check(continuationConstruct, ot, it)(st) : (et.consume(st),
        rt)
    }
    function it(st) {
        return et.exit("chunkContent"),
        et.exit("content"),
        $(st)
    }
    function ot(st) {
        return et.consume(st),
        et.exit("chunkContent"),
        tt.next = et.enter("chunkContent", {
            contentType: "content",
            previous: tt
        }),
        tt = tt.next,
        rt
    }
}
function tokenizeContinuation(et, $, tt) {
    const nt = this;
    return rt;
    function rt(ot) {
        return et.exit("chunkContent"),
        et.enter("lineEnding"),
        et.consume(ot),
        et.exit("lineEnding"),
        factorySpace(et, it, "linePrefix")
    }
    function it(ot) {
        if (ot === null || markdownLineEnding(ot))
            return tt(ot);
        const st = nt.events[nt.events.length - 1];
        return !nt.parser.constructs.disable.null.includes("codeIndented") && st && st[1].type === "linePrefix" && st[2].sliceSerialize(st[1], !0).length >= 4 ? $(ot) : et.interrupt(nt.parser.constructs.flow, tt, $)(ot)
    }
}
function factoryDestination(et, $, tt, nt, rt, it, ot, st, lt) {
    const ut = lt || Number.POSITIVE_INFINITY;
    let ct = 0;
    return ht;
    function ht(mt) {
        return mt === 60 ? (et.enter(nt),
        et.enter(rt),
        et.enter(it),
        et.consume(mt),
        et.exit(it),
        ft) : mt === null || mt === 41 || asciiControl(mt) ? tt(mt) : (et.enter(nt),
        et.enter(ot),
        et.enter(st),
        et.enter("chunkString", {
            contentType: "string"
        }),
        yt(mt))
    }
    function ft(mt) {
        return mt === 62 ? (et.enter(it),
        et.consume(mt),
        et.exit(it),
        et.exit(rt),
        et.exit(nt),
        $) : (et.enter(st),
        et.enter("chunkString", {
            contentType: "string"
        }),
        gt(mt))
    }
    function gt(mt) {
        return mt === 62 ? (et.exit("chunkString"),
        et.exit(st),
        ft(mt)) : mt === null || mt === 60 || markdownLineEnding(mt) ? tt(mt) : (et.consume(mt),
        mt === 92 ? vt : gt)
    }
    function vt(mt) {
        return mt === 60 || mt === 62 || mt === 92 ? (et.consume(mt),
        gt) : gt(mt)
    }
    function yt(mt) {
        return mt === 40 ? ++ct > ut ? tt(mt) : (et.consume(mt),
        yt) : mt === 41 ? ct-- ? (et.consume(mt),
        yt) : (et.exit("chunkString"),
        et.exit(st),
        et.exit(ot),
        et.exit(nt),
        $(mt)) : mt === null || markdownLineEndingOrSpace(mt) ? ct ? tt(mt) : (et.exit("chunkString"),
        et.exit(st),
        et.exit(ot),
        et.exit(nt),
        $(mt)) : asciiControl(mt) ? tt(mt) : (et.consume(mt),
        mt === 92 ? wt : yt)
    }
    function wt(mt) {
        return mt === 40 || mt === 41 || mt === 92 ? (et.consume(mt),
        yt) : yt(mt)
    }
}
function factoryLabel(et, $, tt, nt, rt, it) {
    const ot = this;
    let st = 0, lt;
    return ut;
    function ut(gt) {
        return et.enter(nt),
        et.enter(rt),
        et.consume(gt),
        et.exit(rt),
        et.enter(it),
        ct
    }
    function ct(gt) {
        return gt === null || gt === 91 || gt === 93 && !lt || gt === 94 && !st && "_hiddenFootnoteSupport"in ot.parser.constructs || st > 999 ? tt(gt) : gt === 93 ? (et.exit(it),
        et.enter(rt),
        et.consume(gt),
        et.exit(rt),
        et.exit(nt),
        $) : markdownLineEnding(gt) ? (et.enter("lineEnding"),
        et.consume(gt),
        et.exit("lineEnding"),
        ct) : (et.enter("chunkString", {
            contentType: "string"
        }),
        ht(gt))
    }
    function ht(gt) {
        return gt === null || gt === 91 || gt === 93 || markdownLineEnding(gt) || st++ > 999 ? (et.exit("chunkString"),
        ct(gt)) : (et.consume(gt),
        lt = lt || !markdownSpace(gt),
        gt === 92 ? ft : ht)
    }
    function ft(gt) {
        return gt === 91 || gt === 92 || gt === 93 ? (et.consume(gt),
        st++,
        ht) : ht(gt)
    }
}
function factoryTitle(et, $, tt, nt, rt, it) {
    let ot;
    return st;
    function st(ft) {
        return et.enter(nt),
        et.enter(rt),
        et.consume(ft),
        et.exit(rt),
        ot = ft === 40 ? 41 : ft,
        lt
    }
    function lt(ft) {
        return ft === ot ? (et.enter(rt),
        et.consume(ft),
        et.exit(rt),
        et.exit(nt),
        $) : (et.enter(it),
        ut(ft))
    }
    function ut(ft) {
        return ft === ot ? (et.exit(it),
        lt(ot)) : ft === null ? tt(ft) : markdownLineEnding(ft) ? (et.enter("lineEnding"),
        et.consume(ft),
        et.exit("lineEnding"),
        factorySpace(et, ut, "linePrefix")) : (et.enter("chunkString", {
            contentType: "string"
        }),
        ct(ft))
    }
    function ct(ft) {
        return ft === ot || ft === null || markdownLineEnding(ft) ? (et.exit("chunkString"),
        ut(ft)) : (et.consume(ft),
        ft === 92 ? ht : ct)
    }
    function ht(ft) {
        return ft === ot || ft === 92 ? (et.consume(ft),
        ct) : ct(ft)
    }
}
function factoryWhitespace(et, $) {
    let tt;
    return nt;
    function nt(rt) {
        return markdownLineEnding(rt) ? (et.enter("lineEnding"),
        et.consume(rt),
        et.exit("lineEnding"),
        tt = !0,
        nt) : markdownSpace(rt) ? factorySpace(et, nt, tt ? "linePrefix" : "lineSuffix")(rt) : $(rt)
    }
}
function normalizeIdentifier(et) {
    return et.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase()
}
const definition = {
    name: "definition",
    tokenize: tokenizeDefinition
}
  , titleConstruct = {
    tokenize: tokenizeTitle,
    partial: !0
};
function tokenizeDefinition(et, $, tt) {
    const nt = this;
    let rt;
    return it;
    function it(lt) {
        return et.enter("definition"),
        factoryLabel.call(nt, et, ot, tt, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(lt)
    }
    function ot(lt) {
        return rt = normalizeIdentifier(nt.sliceSerialize(nt.events[nt.events.length - 1][1]).slice(1, -1)),
        lt === 58 ? (et.enter("definitionMarker"),
        et.consume(lt),
        et.exit("definitionMarker"),
        factoryWhitespace(et, factoryDestination(et, et.attempt(titleConstruct, factorySpace(et, st, "whitespace"), factorySpace(et, st, "whitespace")), tt, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString"))) : tt(lt)
    }
    function st(lt) {
        return lt === null || markdownLineEnding(lt) ? (et.exit("definition"),
        nt.parser.defined.includes(rt) || nt.parser.defined.push(rt),
        $(lt)) : tt(lt)
    }
}
function tokenizeTitle(et, $, tt) {
    return nt;
    function nt(ot) {
        return markdownLineEndingOrSpace(ot) ? factoryWhitespace(et, rt)(ot) : tt(ot)
    }
    function rt(ot) {
        return ot === 34 || ot === 39 || ot === 40 ? factoryTitle(et, factorySpace(et, it, "whitespace"), tt, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(ot) : tt(ot)
    }
    function it(ot) {
        return ot === null || markdownLineEnding(ot) ? $(ot) : tt(ot)
    }
}
const hardBreakEscape = {
    name: "hardBreakEscape",
    tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(et, $, tt) {
    return nt;
    function nt(it) {
        return et.enter("hardBreakEscape"),
        et.enter("escapeMarker"),
        et.consume(it),
        rt
    }
    function rt(it) {
        return markdownLineEnding(it) ? (et.exit("escapeMarker"),
        et.exit("hardBreakEscape"),
        $(it)) : tt(it)
    }
}
const headingAtx = {
    name: "headingAtx",
    tokenize: tokenizeHeadingAtx,
    resolve: resolveHeadingAtx
};
function resolveHeadingAtx(et, $) {
    let tt = et.length - 2, nt = 3, rt, it;
    return et[nt][1].type === "whitespace" && (nt += 2),
    tt - 2 > nt && et[tt][1].type === "whitespace" && (tt -= 2),
    et[tt][1].type === "atxHeadingSequence" && (nt === tt - 1 || tt - 4 > nt && et[tt - 2][1].type === "whitespace") && (tt -= nt + 1 === tt ? 2 : 4),
    tt > nt && (rt = {
        type: "atxHeadingText",
        start: et[nt][1].start,
        end: et[tt][1].end
    },
    it = {
        type: "chunkText",
        start: et[nt][1].start,
        end: et[tt][1].end,
        contentType: "text"
    },
    splice(et, nt, tt - nt + 1, [["enter", rt, $], ["enter", it, $], ["exit", it, $], ["exit", rt, $]])),
    et
}
function tokenizeHeadingAtx(et, $, tt) {
    const nt = this;
    let rt = 0;
    return it;
    function it(ct) {
        return et.enter("atxHeading"),
        et.enter("atxHeadingSequence"),
        ot(ct)
    }
    function ot(ct) {
        return ct === 35 && rt++ < 6 ? (et.consume(ct),
        ot) : ct === null || markdownLineEndingOrSpace(ct) ? (et.exit("atxHeadingSequence"),
        nt.interrupt ? $(ct) : st(ct)) : tt(ct)
    }
    function st(ct) {
        return ct === 35 ? (et.enter("atxHeadingSequence"),
        lt(ct)) : ct === null || markdownLineEnding(ct) ? (et.exit("atxHeading"),
        $(ct)) : markdownSpace(ct) ? factorySpace(et, st, "whitespace")(ct) : (et.enter("atxHeadingText"),
        ut(ct))
    }
    function lt(ct) {
        return ct === 35 ? (et.consume(ct),
        lt) : (et.exit("atxHeadingSequence"),
        st(ct))
    }
    function ut(ct) {
        return ct === null || ct === 35 || markdownLineEndingOrSpace(ct) ? (et.exit("atxHeadingText"),
        st(ct)) : (et.consume(ct),
        ut)
    }
}
const htmlBlockNames = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"]
  , htmlRawNames = ["pre", "script", "style", "textarea"]
  , htmlFlow = {
    name: "htmlFlow",
    tokenize: tokenizeHtmlFlow,
    resolveTo: resolveToHtmlFlow,
    concrete: !0
}
  , nextBlankConstruct = {
    tokenize: tokenizeNextBlank,
    partial: !0
};
function resolveToHtmlFlow(et) {
    let $ = et.length;
    for (; $-- && !(et[$][0] === "enter" && et[$][1].type === "htmlFlow"); )
        ;
    return $ > 1 && et[$ - 2][1].type === "linePrefix" && (et[$][1].start = et[$ - 2][1].start,
    et[$ + 1][1].start = et[$ - 2][1].start,
    et.splice($ - 2, 2)),
    et
}
function tokenizeHtmlFlow(et, $, tt) {
    const nt = this;
    let rt, it, ot, st, lt;
    return ut;
    function ut(Rt) {
        return et.enter("htmlFlow"),
        et.enter("htmlFlowData"),
        et.consume(Rt),
        ct
    }
    function ct(Rt) {
        return Rt === 33 ? (et.consume(Rt),
        ht) : Rt === 47 ? (et.consume(Rt),
        vt) : Rt === 63 ? (et.consume(Rt),
        rt = 3,
        nt.interrupt ? $ : Xt) : asciiAlpha(Rt) ? (et.consume(Rt),
        ot = String.fromCharCode(Rt),
        it = !0,
        yt) : tt(Rt)
    }
    function ht(Rt) {
        return Rt === 45 ? (et.consume(Rt),
        rt = 2,
        ft) : Rt === 91 ? (et.consume(Rt),
        rt = 5,
        ot = "CDATA[",
        st = 0,
        gt) : asciiAlpha(Rt) ? (et.consume(Rt),
        rt = 4,
        nt.interrupt ? $ : Xt) : tt(Rt)
    }
    function ft(Rt) {
        return Rt === 45 ? (et.consume(Rt),
        nt.interrupt ? $ : Xt) : tt(Rt)
    }
    function gt(Rt) {
        return Rt === ot.charCodeAt(st++) ? (et.consume(Rt),
        st === ot.length ? nt.interrupt ? $ : Tt : gt) : tt(Rt)
    }
    function vt(Rt) {
        return asciiAlpha(Rt) ? (et.consume(Rt),
        ot = String.fromCharCode(Rt),
        yt) : tt(Rt)
    }
    function yt(Rt) {
        return Rt === null || Rt === 47 || Rt === 62 || markdownLineEndingOrSpace(Rt) ? Rt !== 47 && it && htmlRawNames.includes(ot.toLowerCase()) ? (rt = 1,
        nt.interrupt ? $(Rt) : Tt(Rt)) : htmlBlockNames.includes(ot.toLowerCase()) ? (rt = 6,
        Rt === 47 ? (et.consume(Rt),
        wt) : nt.interrupt ? $(Rt) : Tt(Rt)) : (rt = 7,
        nt.interrupt && !nt.parser.lazy[nt.now().line] ? tt(Rt) : it ? _t(Rt) : mt(Rt)) : Rt === 45 || asciiAlphanumeric(Rt) ? (et.consume(Rt),
        ot += String.fromCharCode(Rt),
        yt) : tt(Rt)
    }
    function wt(Rt) {
        return Rt === 62 ? (et.consume(Rt),
        nt.interrupt ? $ : Tt) : tt(Rt)
    }
    function mt(Rt) {
        return markdownSpace(Rt) ? (et.consume(Rt),
        mt) : Zt(Rt)
    }
    function _t(Rt) {
        return Rt === 47 ? (et.consume(Rt),
        Zt) : Rt === 58 || Rt === 95 || asciiAlpha(Rt) ? (et.consume(Rt),
        bt) : markdownSpace(Rt) ? (et.consume(Rt),
        _t) : Zt(Rt)
    }
    function bt(Rt) {
        return Rt === 45 || Rt === 46 || Rt === 58 || Rt === 95 || asciiAlphanumeric(Rt) ? (et.consume(Rt),
        bt) : Mt(Rt)
    }
    function Mt(Rt) {
        return Rt === 61 ? (et.consume(Rt),
        St) : markdownSpace(Rt) ? (et.consume(Rt),
        Mt) : _t(Rt)
    }
    function St(Rt) {
        return Rt === null || Rt === 60 || Rt === 61 || Rt === 62 || Rt === 96 ? tt(Rt) : Rt === 34 || Rt === 39 ? (et.consume(Rt),
        lt = Rt,
        At) : markdownSpace(Rt) ? (et.consume(Rt),
        St) : (lt = null,
        Pt(Rt))
    }
    function At(Rt) {
        return Rt === null || markdownLineEnding(Rt) ? tt(Rt) : Rt === lt ? (et.consume(Rt),
        Ot) : (et.consume(Rt),
        At)
    }
    function Pt(Rt) {
        return Rt === null || Rt === 34 || Rt === 39 || Rt === 60 || Rt === 61 || Rt === 62 || Rt === 96 || markdownLineEndingOrSpace(Rt) ? Mt(Rt) : (et.consume(Rt),
        Pt)
    }
    function Ot(Rt) {
        return Rt === 47 || Rt === 62 || markdownSpace(Rt) ? _t(Rt) : tt(Rt)
    }
    function Zt(Rt) {
        return Rt === 62 ? (et.consume(Rt),
        Nt) : tt(Rt)
    }
    function Nt(Rt) {
        return markdownSpace(Rt) ? (et.consume(Rt),
        Nt) : Rt === null || markdownLineEnding(Rt) ? Tt(Rt) : tt(Rt)
    }
    function Tt(Rt) {
        return Rt === 45 && rt === 2 ? (et.consume(Rt),
        Kt) : Rt === 60 && rt === 1 ? (et.consume(Rt),
        qt) : Rt === 62 && rt === 4 ? (et.consume(Rt),
        Jt) : Rt === 63 && rt === 3 ? (et.consume(Rt),
        Xt) : Rt === 93 && rt === 5 ? (et.consume(Rt),
        Bt) : markdownLineEnding(Rt) && (rt === 6 || rt === 7) ? et.check(nextBlankConstruct, Jt, Ft)(Rt) : Rt === null || markdownLineEnding(Rt) ? Ft(Rt) : (et.consume(Rt),
        Tt)
    }
    function Ft(Rt) {
        return et.exit("htmlFlowData"),
        $t(Rt)
    }
    function $t(Rt) {
        return Rt === null ? Lt(Rt) : markdownLineEnding(Rt) ? et.attempt({
            tokenize: Wt,
            partial: !0
        }, $t, Lt)(Rt) : (et.enter("htmlFlowData"),
        Tt(Rt))
    }
    function Wt(Rt, _n, Fn) {
        return Vn;
        function Vn(Un) {
            return Rt.enter("lineEnding"),
            Rt.consume(Un),
            Rt.exit("lineEnding"),
            sn
        }
        function sn(Un) {
            return nt.parser.lazy[nt.now().line] ? Fn(Un) : _n(Un)
        }
    }
    function Kt(Rt) {
        return Rt === 45 ? (et.consume(Rt),
        Xt) : Tt(Rt)
    }
    function qt(Rt) {
        return Rt === 47 ? (et.consume(Rt),
        ot = "",
        jt) : Tt(Rt)
    }
    function jt(Rt) {
        return Rt === 62 && htmlRawNames.includes(ot.toLowerCase()) ? (et.consume(Rt),
        Jt) : asciiAlpha(Rt) && ot.length < 8 ? (et.consume(Rt),
        ot += String.fromCharCode(Rt),
        jt) : Tt(Rt)
    }
    function Bt(Rt) {
        return Rt === 93 ? (et.consume(Rt),
        Xt) : Tt(Rt)
    }
    function Xt(Rt) {
        return Rt === 62 ? (et.consume(Rt),
        Jt) : Rt === 45 && rt === 2 ? (et.consume(Rt),
        Xt) : Tt(Rt)
    }
    function Jt(Rt) {
        return Rt === null || markdownLineEnding(Rt) ? (et.exit("htmlFlowData"),
        Lt(Rt)) : (et.consume(Rt),
        Jt)
    }
    function Lt(Rt) {
        return et.exit("htmlFlow"),
        $(Rt)
    }
}
function tokenizeNextBlank(et, $, tt) {
    return nt;
    function nt(rt) {
        return et.exit("htmlFlowData"),
        et.enter("lineEndingBlank"),
        et.consume(rt),
        et.exit("lineEndingBlank"),
        et.attempt(blankLine, $, tt)
    }
}
const htmlText = {
    name: "htmlText",
    tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(et, $, tt) {
    const nt = this;
    let rt, it, ot, st;
    return lt;
    function lt(Lt) {
        return et.enter("htmlText"),
        et.enter("htmlTextData"),
        et.consume(Lt),
        ut
    }
    function ut(Lt) {
        return Lt === 33 ? (et.consume(Lt),
        ct) : Lt === 47 ? (et.consume(Lt),
        Pt) : Lt === 63 ? (et.consume(Lt),
        St) : asciiAlpha(Lt) ? (et.consume(Lt),
        Nt) : tt(Lt)
    }
    function ct(Lt) {
        return Lt === 45 ? (et.consume(Lt),
        ht) : Lt === 91 ? (et.consume(Lt),
        it = "CDATA[",
        ot = 0,
        wt) : asciiAlpha(Lt) ? (et.consume(Lt),
        Mt) : tt(Lt)
    }
    function ht(Lt) {
        return Lt === 45 ? (et.consume(Lt),
        ft) : tt(Lt)
    }
    function ft(Lt) {
        return Lt === null || Lt === 62 ? tt(Lt) : Lt === 45 ? (et.consume(Lt),
        gt) : vt(Lt)
    }
    function gt(Lt) {
        return Lt === null || Lt === 62 ? tt(Lt) : vt(Lt)
    }
    function vt(Lt) {
        return Lt === null ? tt(Lt) : Lt === 45 ? (et.consume(Lt),
        yt) : markdownLineEnding(Lt) ? (st = vt,
        Bt(Lt)) : (et.consume(Lt),
        vt)
    }
    function yt(Lt) {
        return Lt === 45 ? (et.consume(Lt),
        Jt) : vt(Lt)
    }
    function wt(Lt) {
        return Lt === it.charCodeAt(ot++) ? (et.consume(Lt),
        ot === it.length ? mt : wt) : tt(Lt)
    }
    function mt(Lt) {
        return Lt === null ? tt(Lt) : Lt === 93 ? (et.consume(Lt),
        _t) : markdownLineEnding(Lt) ? (st = mt,
        Bt(Lt)) : (et.consume(Lt),
        mt)
    }
    function _t(Lt) {
        return Lt === 93 ? (et.consume(Lt),
        bt) : mt(Lt)
    }
    function bt(Lt) {
        return Lt === 62 ? Jt(Lt) : Lt === 93 ? (et.consume(Lt),
        bt) : mt(Lt)
    }
    function Mt(Lt) {
        return Lt === null || Lt === 62 ? Jt(Lt) : markdownLineEnding(Lt) ? (st = Mt,
        Bt(Lt)) : (et.consume(Lt),
        Mt)
    }
    function St(Lt) {
        return Lt === null ? tt(Lt) : Lt === 63 ? (et.consume(Lt),
        At) : markdownLineEnding(Lt) ? (st = St,
        Bt(Lt)) : (et.consume(Lt),
        St)
    }
    function At(Lt) {
        return Lt === 62 ? Jt(Lt) : St(Lt)
    }
    function Pt(Lt) {
        return asciiAlpha(Lt) ? (et.consume(Lt),
        Ot) : tt(Lt)
    }
    function Ot(Lt) {
        return Lt === 45 || asciiAlphanumeric(Lt) ? (et.consume(Lt),
        Ot) : Zt(Lt)
    }
    function Zt(Lt) {
        return markdownLineEnding(Lt) ? (st = Zt,
        Bt(Lt)) : markdownSpace(Lt) ? (et.consume(Lt),
        Zt) : Jt(Lt)
    }
    function Nt(Lt) {
        return Lt === 45 || asciiAlphanumeric(Lt) ? (et.consume(Lt),
        Nt) : Lt === 47 || Lt === 62 || markdownLineEndingOrSpace(Lt) ? Tt(Lt) : tt(Lt)
    }
    function Tt(Lt) {
        return Lt === 47 ? (et.consume(Lt),
        Jt) : Lt === 58 || Lt === 95 || asciiAlpha(Lt) ? (et.consume(Lt),
        Ft) : markdownLineEnding(Lt) ? (st = Tt,
        Bt(Lt)) : markdownSpace(Lt) ? (et.consume(Lt),
        Tt) : Jt(Lt)
    }
    function Ft(Lt) {
        return Lt === 45 || Lt === 46 || Lt === 58 || Lt === 95 || asciiAlphanumeric(Lt) ? (et.consume(Lt),
        Ft) : $t(Lt)
    }
    function $t(Lt) {
        return Lt === 61 ? (et.consume(Lt),
        Wt) : markdownLineEnding(Lt) ? (st = $t,
        Bt(Lt)) : markdownSpace(Lt) ? (et.consume(Lt),
        $t) : Tt(Lt)
    }
    function Wt(Lt) {
        return Lt === null || Lt === 60 || Lt === 61 || Lt === 62 || Lt === 96 ? tt(Lt) : Lt === 34 || Lt === 39 ? (et.consume(Lt),
        rt = Lt,
        Kt) : markdownLineEnding(Lt) ? (st = Wt,
        Bt(Lt)) : markdownSpace(Lt) ? (et.consume(Lt),
        Wt) : (et.consume(Lt),
        rt = void 0,
        jt)
    }
    function Kt(Lt) {
        return Lt === rt ? (et.consume(Lt),
        qt) : Lt === null ? tt(Lt) : markdownLineEnding(Lt) ? (st = Kt,
        Bt(Lt)) : (et.consume(Lt),
        Kt)
    }
    function qt(Lt) {
        return Lt === 62 || Lt === 47 || markdownLineEndingOrSpace(Lt) ? Tt(Lt) : tt(Lt)
    }
    function jt(Lt) {
        return Lt === null || Lt === 34 || Lt === 39 || Lt === 60 || Lt === 61 || Lt === 96 ? tt(Lt) : Lt === 62 || markdownLineEndingOrSpace(Lt) ? Tt(Lt) : (et.consume(Lt),
        jt)
    }
    function Bt(Lt) {
        return et.exit("htmlTextData"),
        et.enter("lineEnding"),
        et.consume(Lt),
        et.exit("lineEnding"),
        factorySpace(et, Xt, "linePrefix", nt.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)
    }
    function Xt(Lt) {
        return et.enter("htmlTextData"),
        st(Lt)
    }
    function Jt(Lt) {
        return Lt === 62 ? (et.consume(Lt),
        et.exit("htmlTextData"),
        et.exit("htmlText"),
        $) : tt(Lt)
    }
}
const labelEnd = {
    name: "labelEnd",
    tokenize: tokenizeLabelEnd,
    resolveTo: resolveToLabelEnd,
    resolveAll: resolveAllLabelEnd
}
  , resourceConstruct = {
    tokenize: tokenizeResource
}
  , fullReferenceConstruct = {
    tokenize: tokenizeFullReference
}
  , collapsedReferenceConstruct = {
    tokenize: tokenizeCollapsedReference
};
function resolveAllLabelEnd(et) {
    let $ = -1, tt;
    for (; ++$ < et.length; )
        tt = et[$][1],
        (tt.type === "labelImage" || tt.type === "labelLink" || tt.type === "labelEnd") && (et.splice($ + 1, tt.type === "labelImage" ? 4 : 2),
        tt.type = "data",
        $++);
    return et
}
function resolveToLabelEnd(et, $) {
    let tt = et.length, nt = 0, rt, it, ot, st;
    for (; tt--; )
        if (rt = et[tt][1],
        it) {
            if (rt.type === "link" || rt.type === "labelLink" && rt._inactive)
                break;
            et[tt][0] === "enter" && rt.type === "labelLink" && (rt._inactive = !0)
        } else if (ot) {
            if (et[tt][0] === "enter" && (rt.type === "labelImage" || rt.type === "labelLink") && !rt._balanced && (it = tt,
            rt.type !== "labelLink")) {
                nt = 2;
                break
            }
        } else
            rt.type === "labelEnd" && (ot = tt);
    const lt = {
        type: et[it][1].type === "labelLink" ? "link" : "image",
        start: Object.assign({}, et[it][1].start),
        end: Object.assign({}, et[et.length - 1][1].end)
    }
      , ut = {
        type: "label",
        start: Object.assign({}, et[it][1].start),
        end: Object.assign({}, et[ot][1].end)
    }
      , ct = {
        type: "labelText",
        start: Object.assign({}, et[it + nt + 2][1].end),
        end: Object.assign({}, et[ot - 2][1].start)
    };
    return st = [["enter", lt, $], ["enter", ut, $]],
    st = push(st, et.slice(it + 1, it + nt + 3)),
    st = push(st, [["enter", ct, $]]),
    st = push(st, resolveAll($.parser.constructs.insideSpan.null, et.slice(it + nt + 4, ot - 3), $)),
    st = push(st, [["exit", ct, $], et[ot - 2], et[ot - 1], ["exit", ut, $]]),
    st = push(st, et.slice(ot + 1)),
    st = push(st, [["exit", lt, $]]),
    splice(et, it, et.length, st),
    et
}
function tokenizeLabelEnd(et, $, tt) {
    const nt = this;
    let rt = nt.events.length, it, ot;
    for (; rt--; )
        if ((nt.events[rt][1].type === "labelImage" || nt.events[rt][1].type === "labelLink") && !nt.events[rt][1]._balanced) {
            it = nt.events[rt][1];
            break
        }
    return st;
    function st(ct) {
        return it ? it._inactive ? ut(ct) : (ot = nt.parser.defined.includes(normalizeIdentifier(nt.sliceSerialize({
            start: it.end,
            end: nt.now()
        }))),
        et.enter("labelEnd"),
        et.enter("labelMarker"),
        et.consume(ct),
        et.exit("labelMarker"),
        et.exit("labelEnd"),
        lt) : tt(ct)
    }
    function lt(ct) {
        return ct === 40 ? et.attempt(resourceConstruct, $, ot ? $ : ut)(ct) : ct === 91 ? et.attempt(fullReferenceConstruct, $, ot ? et.attempt(collapsedReferenceConstruct, $, ut) : ut)(ct) : ot ? $(ct) : ut(ct)
    }
    function ut(ct) {
        return it._balanced = !0,
        tt(ct)
    }
}
function tokenizeResource(et, $, tt) {
    return nt;
    function nt(lt) {
        return et.enter("resource"),
        et.enter("resourceMarker"),
        et.consume(lt),
        et.exit("resourceMarker"),
        factoryWhitespace(et, rt)
    }
    function rt(lt) {
        return lt === 41 ? st(lt) : factoryDestination(et, it, tt, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(lt)
    }
    function it(lt) {
        return markdownLineEndingOrSpace(lt) ? factoryWhitespace(et, ot)(lt) : st(lt)
    }
    function ot(lt) {
        return lt === 34 || lt === 39 || lt === 40 ? factoryTitle(et, factoryWhitespace(et, st), tt, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(lt) : st(lt)
    }
    function st(lt) {
        return lt === 41 ? (et.enter("resourceMarker"),
        et.consume(lt),
        et.exit("resourceMarker"),
        et.exit("resource"),
        $) : tt(lt)
    }
}
function tokenizeFullReference(et, $, tt) {
    const nt = this;
    return rt;
    function rt(ot) {
        return factoryLabel.call(nt, et, it, tt, "reference", "referenceMarker", "referenceString")(ot)
    }
    function it(ot) {
        return nt.parser.defined.includes(normalizeIdentifier(nt.sliceSerialize(nt.events[nt.events.length - 1][1]).slice(1, -1))) ? $(ot) : tt(ot)
    }
}
function tokenizeCollapsedReference(et, $, tt) {
    return nt;
    function nt(it) {
        return et.enter("reference"),
        et.enter("referenceMarker"),
        et.consume(it),
        et.exit("referenceMarker"),
        rt
    }
    function rt(it) {
        return it === 93 ? (et.enter("referenceMarker"),
        et.consume(it),
        et.exit("referenceMarker"),
        et.exit("reference"),
        $) : tt(it)
    }
}
const labelStartImage = {
    name: "labelStartImage",
    tokenize: tokenizeLabelStartImage,
    resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(et, $, tt) {
    const nt = this;
    return rt;
    function rt(st) {
        return et.enter("labelImage"),
        et.enter("labelImageMarker"),
        et.consume(st),
        et.exit("labelImageMarker"),
        it
    }
    function it(st) {
        return st === 91 ? (et.enter("labelMarker"),
        et.consume(st),
        et.exit("labelMarker"),
        et.exit("labelImage"),
        ot) : tt(st)
    }
    function ot(st) {
        return st === 94 && "_hiddenFootnoteSupport"in nt.parser.constructs ? tt(st) : $(st)
    }
}
const labelStartLink = {
    name: "labelStartLink",
    tokenize: tokenizeLabelStartLink,
    resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(et, $, tt) {
    const nt = this;
    return rt;
    function rt(ot) {
        return et.enter("labelLink"),
        et.enter("labelMarker"),
        et.consume(ot),
        et.exit("labelMarker"),
        et.exit("labelLink"),
        it
    }
    function it(ot) {
        return ot === 94 && "_hiddenFootnoteSupport"in nt.parser.constructs ? tt(ot) : $(ot)
    }
}
const lineEnding = {
    name: "lineEnding",
    tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(et, $) {
    return tt;
    function tt(nt) {
        return et.enter("lineEnding"),
        et.consume(nt),
        et.exit("lineEnding"),
        factorySpace(et, $, "linePrefix")
    }
}
const thematicBreak$1 = {
    name: "thematicBreak",
    tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(et, $, tt) {
    let nt = 0, rt;
    return it;
    function it(lt) {
        return et.enter("thematicBreak"),
        rt = lt,
        ot(lt)
    }
    function ot(lt) {
        return lt === rt ? (et.enter("thematicBreakSequence"),
        st(lt)) : markdownSpace(lt) ? factorySpace(et, ot, "whitespace")(lt) : nt < 3 || lt !== null && !markdownLineEnding(lt) ? tt(lt) : (et.exit("thematicBreak"),
        $(lt))
    }
    function st(lt) {
        return lt === rt ? (et.consume(lt),
        nt++,
        st) : (et.exit("thematicBreakSequence"),
        ot(lt))
    }
}
const list$1 = {
    name: "list",
    tokenize: tokenizeListStart,
    continuation: {
        tokenize: tokenizeListContinuation
    },
    exit: tokenizeListEnd
}
  , listItemPrefixWhitespaceConstruct = {
    tokenize: tokenizeListItemPrefixWhitespace,
    partial: !0
}
  , indentConstruct = {
    tokenize: tokenizeIndent,
    partial: !0
};
function tokenizeListStart(et, $, tt) {
    const nt = this
      , rt = nt.events[nt.events.length - 1];
    let it = rt && rt[1].type === "linePrefix" ? rt[2].sliceSerialize(rt[1], !0).length : 0
      , ot = 0;
    return st;
    function st(gt) {
        const vt = nt.containerState.type || (gt === 42 || gt === 43 || gt === 45 ? "listUnordered" : "listOrdered");
        if (vt === "listUnordered" ? !nt.containerState.marker || gt === nt.containerState.marker : asciiDigit(gt)) {
            if (nt.containerState.type || (nt.containerState.type = vt,
            et.enter(vt, {
                _container: !0
            })),
            vt === "listUnordered")
                return et.enter("listItemPrefix"),
                gt === 42 || gt === 45 ? et.check(thematicBreak$1, tt, ut)(gt) : ut(gt);
            if (!nt.interrupt || gt === 49)
                return et.enter("listItemPrefix"),
                et.enter("listItemValue"),
                lt(gt)
        }
        return tt(gt)
    }
    function lt(gt) {
        return asciiDigit(gt) && ++ot < 10 ? (et.consume(gt),
        lt) : (!nt.interrupt || ot < 2) && (nt.containerState.marker ? gt === nt.containerState.marker : gt === 41 || gt === 46) ? (et.exit("listItemValue"),
        ut(gt)) : tt(gt)
    }
    function ut(gt) {
        return et.enter("listItemMarker"),
        et.consume(gt),
        et.exit("listItemMarker"),
        nt.containerState.marker = nt.containerState.marker || gt,
        et.check(blankLine, nt.interrupt ? tt : ct, et.attempt(listItemPrefixWhitespaceConstruct, ft, ht))
    }
    function ct(gt) {
        return nt.containerState.initialBlankLine = !0,
        it++,
        ft(gt)
    }
    function ht(gt) {
        return markdownSpace(gt) ? (et.enter("listItemPrefixWhitespace"),
        et.consume(gt),
        et.exit("listItemPrefixWhitespace"),
        ft) : tt(gt)
    }
    function ft(gt) {
        return nt.containerState.size = it + nt.sliceSerialize(et.exit("listItemPrefix"), !0).length,
        $(gt)
    }
}
function tokenizeListContinuation(et, $, tt) {
    const nt = this;
    return nt.containerState._closeFlow = void 0,
    et.check(blankLine, rt, it);
    function rt(st) {
        return nt.containerState.furtherBlankLines = nt.containerState.furtherBlankLines || nt.containerState.initialBlankLine,
        factorySpace(et, $, "listItemIndent", nt.containerState.size + 1)(st)
    }
    function it(st) {
        return nt.containerState.furtherBlankLines || !markdownSpace(st) ? (nt.containerState.furtherBlankLines = void 0,
        nt.containerState.initialBlankLine = void 0,
        ot(st)) : (nt.containerState.furtherBlankLines = void 0,
        nt.containerState.initialBlankLine = void 0,
        et.attempt(indentConstruct, $, ot)(st))
    }
    function ot(st) {
        return nt.containerState._closeFlow = !0,
        nt.interrupt = void 0,
        factorySpace(et, et.attempt(list$1, $, tt), "linePrefix", nt.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(st)
    }
}
function tokenizeIndent(et, $, tt) {
    const nt = this;
    return factorySpace(et, rt, "listItemIndent", nt.containerState.size + 1);
    function rt(it) {
        const ot = nt.events[nt.events.length - 1];
        return ot && ot[1].type === "listItemIndent" && ot[2].sliceSerialize(ot[1], !0).length === nt.containerState.size ? $(it) : tt(it)
    }
}
function tokenizeListEnd(et) {
    et.exit(this.containerState.type)
}
function tokenizeListItemPrefixWhitespace(et, $, tt) {
    const nt = this;
    return factorySpace(et, rt, "listItemPrefixWhitespace", nt.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
    function rt(it) {
        const ot = nt.events[nt.events.length - 1];
        return !markdownSpace(it) && ot && ot[1].type === "listItemPrefixWhitespace" ? $(it) : tt(it)
    }
}
const setextUnderline = {
    name: "setextUnderline",
    tokenize: tokenizeSetextUnderline,
    resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(et, $) {
    let tt = et.length, nt, rt, it;
    for (; tt--; )
        if (et[tt][0] === "enter") {
            if (et[tt][1].type === "content") {
                nt = tt;
                break
            }
            et[tt][1].type === "paragraph" && (rt = tt)
        } else
            et[tt][1].type === "content" && et.splice(tt, 1),
            !it && et[tt][1].type === "definition" && (it = tt);
    const ot = {
        type: "setextHeading",
        start: Object.assign({}, et[rt][1].start),
        end: Object.assign({}, et[et.length - 1][1].end)
    };
    return et[rt][1].type = "setextHeadingText",
    it ? (et.splice(rt, 0, ["enter", ot, $]),
    et.splice(it + 1, 0, ["exit", et[nt][1], $]),
    et[nt][1].end = Object.assign({}, et[it][1].end)) : et[nt][1] = ot,
    et.push(["exit", ot, $]),
    et
}
function tokenizeSetextUnderline(et, $, tt) {
    const nt = this;
    let rt = nt.events.length, it, ot;
    for (; rt--; )
        if (nt.events[rt][1].type !== "lineEnding" && nt.events[rt][1].type !== "linePrefix" && nt.events[rt][1].type !== "content") {
            ot = nt.events[rt][1].type === "paragraph";
            break
        }
    return st;
    function st(ct) {
        return !nt.parser.lazy[nt.now().line] && (nt.interrupt || ot) ? (et.enter("setextHeadingLine"),
        et.enter("setextHeadingLineSequence"),
        it = ct,
        lt(ct)) : tt(ct)
    }
    function lt(ct) {
        return ct === it ? (et.consume(ct),
        lt) : (et.exit("setextHeadingLineSequence"),
        factorySpace(et, ut, "lineSuffix")(ct))
    }
    function ut(ct) {
        return ct === null || markdownLineEnding(ct) ? (et.exit("setextHeadingLine"),
        $(ct)) : tt(ct)
    }
}
const flow$1 = {
    tokenize: initializeFlow
};
function initializeFlow(et) {
    const $ = this
      , tt = et.attempt(blankLine, nt, et.attempt(this.parser.constructs.flowInitial, rt, factorySpace(et, et.attempt(this.parser.constructs.flow, rt, et.attempt(content, rt)), "linePrefix")));
    return tt;
    function nt(it) {
        if (it === null) {
            et.consume(it);
            return
        }
        return et.enter("lineEndingBlank"),
        et.consume(it),
        et.exit("lineEndingBlank"),
        $.currentConstruct = void 0,
        tt
    }
    function rt(it) {
        if (it === null) {
            et.consume(it);
            return
        }
        return et.enter("lineEnding"),
        et.consume(it),
        et.exit("lineEnding"),
        $.currentConstruct = void 0,
        tt
    }
}
const resolver = {
    resolveAll: createResolver()
}
  , string$1 = initializeFactory("string")
  , text$2 = initializeFactory("text");
function initializeFactory(et) {
    return {
        tokenize: $,
        resolveAll: createResolver(et === "text" ? resolveAllLineSuffixes : void 0)
    };
    function $(tt) {
        const nt = this
          , rt = this.parser.constructs[et]
          , it = tt.attempt(rt, ot, st);
        return ot;
        function ot(ct) {
            return ut(ct) ? it(ct) : st(ct)
        }
        function st(ct) {
            if (ct === null) {
                tt.consume(ct);
                return
            }
            return tt.enter("data"),
            tt.consume(ct),
            lt
        }
        function lt(ct) {
            return ut(ct) ? (tt.exit("data"),
            it(ct)) : (tt.consume(ct),
            lt)
        }
        function ut(ct) {
            if (ct === null)
                return !0;
            const ht = rt[ct];
            let ft = -1;
            if (ht)
                for (; ++ft < ht.length; ) {
                    const gt = ht[ft];
                    if (!gt.previous || gt.previous.call(nt, nt.previous))
                        return !0
                }
            return !1
        }
    }
}
function createResolver(et) {
    return $;
    function $(tt, nt) {
        let rt = -1, it;
        for (; ++rt <= tt.length; )
            it === void 0 ? tt[rt] && tt[rt][1].type === "data" && (it = rt,
            rt++) : (!tt[rt] || tt[rt][1].type !== "data") && (rt !== it + 2 && (tt[it][1].end = tt[rt - 1][1].end,
            tt.splice(it + 2, rt - it - 2),
            rt = it + 2),
            it = void 0);
        return et ? et(tt, nt) : tt
    }
}
function resolveAllLineSuffixes(et, $) {
    let tt = 0;
    for (; ++tt <= et.length; )
        if ((tt === et.length || et[tt][1].type === "lineEnding") && et[tt - 1][1].type === "data") {
            const nt = et[tt - 1][1]
              , rt = $.sliceStream(nt);
            let it = rt.length, ot = -1, st = 0, lt;
            for (; it--; ) {
                const ut = rt[it];
                if (typeof ut == "string") {
                    for (ot = ut.length; ut.charCodeAt(ot - 1) === 32; )
                        st++,
                        ot--;
                    if (ot)
                        break;
                    ot = -1
                } else if (ut === -2)
                    lt = !0,
                    st++;
                else if (ut !== -1) {
                    it++;
                    break
                }
            }
            if (st) {
                const ut = {
                    type: tt === et.length || lt || st < 2 ? "lineSuffix" : "hardBreakTrailing",
                    start: {
                        line: nt.end.line,
                        column: nt.end.column - st,
                        offset: nt.end.offset - st,
                        _index: nt.start._index + it,
                        _bufferIndex: it ? ot : nt.start._bufferIndex + ot
                    },
                    end: Object.assign({}, nt.end)
                };
                nt.end = Object.assign({}, ut.start),
                nt.start.offset === nt.end.offset ? Object.assign(nt, ut) : (et.splice(tt, 0, ["enter", ut, $], ["exit", ut, $]),
                tt += 2)
            }
            tt++
        }
    return et
}
function createTokenizer(et, $, tt) {
    let nt = Object.assign(tt ? Object.assign({}, tt) : {
        line: 1,
        column: 1,
        offset: 0
    }, {
        _index: 0,
        _bufferIndex: -1
    });
    const rt = {}
      , it = [];
    let ot = []
      , st = [];
    const lt = {
        consume: _t,
        enter: bt,
        exit: Mt,
        attempt: Pt(St),
        check: Pt(At),
        interrupt: Pt(At, {
            interrupt: !0
        })
    }
      , ut = {
        previous: null,
        code: null,
        containerState: {},
        events: [],
        parser: et,
        sliceStream: gt,
        sliceSerialize: ft,
        now: vt,
        defineSkip: yt,
        write: ht
    };
    let ct = $.tokenize.call(ut, lt);
    return $.resolveAll && it.push($),
    ut;
    function ht(Tt) {
        return ot = push(ot, Tt),
        wt(),
        ot[ot.length - 1] !== null ? [] : (Ot($, 0),
        ut.events = resolveAll(it, ut.events, ut),
        ut.events)
    }
    function ft(Tt, Ft) {
        return serializeChunks(gt(Tt), Ft)
    }
    function gt(Tt) {
        return sliceChunks(ot, Tt)
    }
    function vt() {
        return Object.assign({}, nt)
    }
    function yt(Tt) {
        rt[Tt.line] = Tt.column,
        Nt()
    }
    function wt() {
        let Tt;
        for (; nt._index < ot.length; ) {
            const Ft = ot[nt._index];
            if (typeof Ft == "string")
                for (Tt = nt._index,
                nt._bufferIndex < 0 && (nt._bufferIndex = 0); nt._index === Tt && nt._bufferIndex < Ft.length; )
                    mt(Ft.charCodeAt(nt._bufferIndex));
            else
                mt(Ft)
        }
    }
    function mt(Tt) {
        ct = ct(Tt)
    }
    function _t(Tt) {
        markdownLineEnding(Tt) ? (nt.line++,
        nt.column = 1,
        nt.offset += Tt === -3 ? 2 : 1,
        Nt()) : Tt !== -1 && (nt.column++,
        nt.offset++),
        nt._bufferIndex < 0 ? nt._index++ : (nt._bufferIndex++,
        nt._bufferIndex === ot[nt._index].length && (nt._bufferIndex = -1,
        nt._index++)),
        ut.previous = Tt
    }
    function bt(Tt, Ft) {
        const $t = Ft || {};
        return $t.type = Tt,
        $t.start = vt(),
        ut.events.push(["enter", $t, ut]),
        st.push($t),
        $t
    }
    function Mt(Tt) {
        const Ft = st.pop();
        return Ft.end = vt(),
        ut.events.push(["exit", Ft, ut]),
        Ft
    }
    function St(Tt, Ft) {
        Ot(Tt, Ft.from)
    }
    function At(Tt, Ft) {
        Ft.restore()
    }
    function Pt(Tt, Ft) {
        return $t;
        function $t(Wt, Kt, qt) {
            let jt, Bt, Xt, Jt;
            return Array.isArray(Wt) ? Rt(Wt) : "tokenize"in Wt ? Rt([Wt]) : Lt(Wt);
            function Lt(sn) {
                return Un;
                function Un(zn) {
                    const Rn = zn !== null && sn[zn]
                      , Ln = zn !== null && sn.null
                      , Gn = [...Array.isArray(Rn) ? Rn : Rn ? [Rn] : [], ...Array.isArray(Ln) ? Ln : Ln ? [Ln] : []];
                    return Rt(Gn)(zn)
                }
            }
            function Rt(sn) {
                return jt = sn,
                Bt = 0,
                sn.length === 0 ? qt : _n(sn[Bt])
            }
            function _n(sn) {
                return Un;
                function Un(zn) {
                    return Jt = Zt(),
                    Xt = sn,
                    sn.partial || (ut.currentConstruct = sn),
                    sn.name && ut.parser.constructs.disable.null.includes(sn.name) ? Vn() : sn.tokenize.call(Ft ? Object.assign(Object.create(ut), Ft) : ut, lt, Fn, Vn)(zn)
                }
            }
            function Fn(sn) {
                return Tt(Xt, Jt),
                Kt
            }
            function Vn(sn) {
                return Jt.restore(),
                ++Bt < jt.length ? _n(jt[Bt]) : qt
            }
        }
    }
    function Ot(Tt, Ft) {
        Tt.resolveAll && !it.includes(Tt) && it.push(Tt),
        Tt.resolve && splice(ut.events, Ft, ut.events.length - Ft, Tt.resolve(ut.events.slice(Ft), ut)),
        Tt.resolveTo && (ut.events = Tt.resolveTo(ut.events, ut))
    }
    function Zt() {
        const Tt = vt()
          , Ft = ut.previous
          , $t = ut.currentConstruct
          , Wt = ut.events.length
          , Kt = Array.from(st);
        return {
            restore: qt,
            from: Wt
        };
        function qt() {
            nt = Tt,
            ut.previous = Ft,
            ut.currentConstruct = $t,
            ut.events.length = Wt,
            st = Kt,
            Nt()
        }
    }
    function Nt() {
        nt.line in rt && nt.column < 2 && (nt.column = rt[nt.line],
        nt.offset += rt[nt.line] - 1)
    }
}
function sliceChunks(et, $) {
    const tt = $.start._index
      , nt = $.start._bufferIndex
      , rt = $.end._index
      , it = $.end._bufferIndex;
    let ot;
    return tt === rt ? ot = [et[tt].slice(nt, it)] : (ot = et.slice(tt, rt),
    nt > -1 && (ot[0] = ot[0].slice(nt)),
    it > 0 && ot.push(et[rt].slice(0, it))),
    ot
}
function serializeChunks(et, $) {
    let tt = -1;
    const nt = [];
    let rt;
    for (; ++tt < et.length; ) {
        const it = et[tt];
        let ot;
        if (typeof it == "string")
            ot = it;
        else
            switch (it) {
            case -5:
                {
                    ot = "\r";
                    break
                }
            case -4:
                {
                    ot = `
`;
                    break
                }
            case -3:
                {
                    ot = `\r
`;
                    break
                }
            case -2:
                {
                    ot = $ ? " " : "	";
                    break
                }
            case -1:
                {
                    if (!$ && rt)
                        continue;
                    ot = " ";
                    break
                }
            default:
                ot = String.fromCharCode(it)
            }
        rt = it === -2,
        nt.push(ot)
    }
    return nt.join("")
}
const document$1 = {
    [42]: list$1,
    [43]: list$1,
    [45]: list$1,
    [48]: list$1,
    [49]: list$1,
    [50]: list$1,
    [51]: list$1,
    [52]: list$1,
    [53]: list$1,
    [54]: list$1,
    [55]: list$1,
    [56]: list$1,
    [57]: list$1,
    [62]: blockQuote
}
  , contentInitial = {
    [91]: definition
}
  , flowInitial = {
    [-2]: codeIndented,
    [-1]: codeIndented,
    [32]: codeIndented
}
  , flow = {
    [35]: headingAtx,
    [42]: thematicBreak$1,
    [45]: [setextUnderline, thematicBreak$1],
    [60]: htmlFlow,
    [61]: setextUnderline,
    [95]: thematicBreak$1,
    [96]: codeFenced,
    [126]: codeFenced
}
  , string = {
    [38]: characterReference,
    [92]: characterEscape
}
  , text$1 = {
    [-5]: lineEnding,
    [-4]: lineEnding,
    [-3]: lineEnding,
    [33]: labelStartImage,
    [38]: characterReference,
    [42]: attention,
    [60]: [autolink, htmlText],
    [91]: labelStartLink,
    [92]: [hardBreakEscape, characterEscape],
    [93]: labelEnd,
    [95]: attention,
    [96]: codeText
}
  , insideSpan = {
    null: [attention, resolver]
}
  , attentionMarkers = {
    null: [42, 95]
}
  , disable = {
    null: []
};
var defaultConstructs = Object.freeze(Object.defineProperty({
    __proto__: null,
    document: document$1,
    contentInitial,
    flowInitial,
    flow,
    string,
    text: text$1,
    insideSpan,
    attentionMarkers,
    disable
}, Symbol.toStringTag, {
    value: "Module"
}));
function parse$1(et={}) {
    const $ = combineExtensions([defaultConstructs].concat(et.extensions || []))
      , tt = {
        defined: [],
        lazy: {},
        constructs: $,
        content: nt(content$1),
        document: nt(document$2),
        flow: nt(flow$1),
        string: nt(string$1),
        text: nt(text$2)
    };
    return tt;
    function nt(rt) {
        return it;
        function it(ot) {
            return createTokenizer(tt, rt, ot)
        }
    }
}
const search = /[\0\t\n\r]/g;
function preprocess() {
    let et = 1, $ = "", tt = !0, nt;
    return rt;
    function rt(it, ot, st) {
        const lt = [];
        let ut, ct, ht, ft, gt;
        for (it = $ + it.toString(ot),
        ht = 0,
        $ = "",
        tt && (it.charCodeAt(0) === 65279 && ht++,
        tt = void 0); ht < it.length; ) {
            if (search.lastIndex = ht,
            ut = search.exec(it),
            ft = ut && ut.index !== void 0 ? ut.index : it.length,
            gt = it.charCodeAt(ft),
            !ut) {
                $ = it.slice(ht);
                break
            }
            if (gt === 10 && ht === ft && nt)
                lt.push(-3),
                nt = void 0;
            else
                switch (nt && (lt.push(-5),
                nt = void 0),
                ht < ft && (lt.push(it.slice(ht, ft)),
                et += ft - ht),
                gt) {
                case 0:
                    {
                        lt.push(65533),
                        et++;
                        break
                    }
                case 9:
                    {
                        for (ct = Math.ceil(et / 4) * 4,
                        lt.push(-2); et++ < ct; )
                            lt.push(-1);
                        break
                    }
                case 10:
                    {
                        lt.push(-4),
                        et = 1;
                        break
                    }
                default:
                    nt = !0,
                    et = 1
                }
            ht = ft + 1
        }
        return st && (nt && lt.push(-5),
        $ && lt.push($),
        lt.push(null)),
        lt
    }
}
function postprocess(et) {
    for (; !subtokenize(et); )
        ;
    return et
}
function decodeNumericCharacterReference(et, $) {
    const tt = Number.parseInt(et, $);
    return tt < 9 || tt === 11 || tt > 13 && tt < 32 || tt > 126 && tt < 160 || tt > 55295 && tt < 57344 || tt > 64975 && tt < 65008 || (tt & 65535) === 65535 || (tt & 65535) === 65534 || tt > 1114111 ? "\uFFFD" : String.fromCharCode(tt)
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(et) {
    return et.replace(characterEscapeOrReference, decode)
}
function decode(et, $, tt) {
    if ($)
        return $;
    if (tt.charCodeAt(0) === 35) {
        const rt = tt.charCodeAt(1)
          , it = rt === 120 || rt === 88;
        return decodeNumericCharacterReference(tt.slice(it ? 2 : 1), it ? 16 : 10)
    }
    return decodeNamedCharacterReference(tt) || et
}
const own$5 = {}.hasOwnProperty
  , fromMarkdown = function(et, $, tt) {
    return typeof $ != "string" && (tt = $,
    $ = void 0),
    compiler(tt)(postprocess(parse$1(tt).document().write(preprocess()(et, $, !0))))
};
function compiler(et) {
    const $ = {
        transforms: [],
        canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
        enter: {
            autolink: st(rr),
            autolinkProtocol: Tt,
            autolinkEmail: Tt,
            atxHeading: st(Pn),
            blockQuote: st(Gn),
            characterEscape: Tt,
            characterReference: Tt,
            codeFenced: st(cn),
            codeFencedFenceInfo: lt,
            codeFencedFenceMeta: lt,
            codeIndented: st(cn, lt),
            codeText: st(bn, lt),
            codeTextData: Tt,
            data: Tt,
            codeFlowValue: Tt,
            definition: st(Mn),
            definitionDestinationString: lt,
            definitionLabelString: lt,
            definitionTitleString: lt,
            emphasis: st(Dn),
            hardBreakEscape: st($n),
            hardBreakTrailing: st($n),
            htmlFlow: st(On, lt),
            htmlFlowData: Tt,
            htmlText: st(On, lt),
            htmlTextData: Tt,
            image: st(Wn),
            label: lt,
            link: st(rr),
            listItem: st(kt),
            listItemValue: vt,
            listOrdered: st(Dt, gt),
            listUnordered: st(Dt),
            paragraph: st(pn),
            reference: Vn,
            referenceString: lt,
            resourceDestinationString: lt,
            resourceTitleString: lt,
            setextHeading: st(Pn),
            strong: st(mn),
            thematicBreak: st(In)
        },
        exit: {
            atxHeading: ct(),
            atxHeadingSequence: Pt,
            autolink: ct(),
            autolinkEmail: Ln,
            autolinkProtocol: Rn,
            blockQuote: ct(),
            characterEscapeValue: Ft,
            characterReferenceMarkerHexadecimal: Un,
            characterReferenceMarkerNumeric: Un,
            characterReferenceValue: zn,
            codeFenced: ct(_t),
            codeFencedFence: mt,
            codeFencedFenceInfo: yt,
            codeFencedFenceMeta: wt,
            codeFlowValue: Ft,
            codeIndented: ct(bt),
            codeText: ct(jt),
            codeTextData: Ft,
            data: Ft,
            definition: ct(),
            definitionDestinationString: At,
            definitionLabelString: Mt,
            definitionTitleString: St,
            emphasis: ct(),
            hardBreakEscape: ct(Wt),
            hardBreakTrailing: ct(Wt),
            htmlFlow: ct(Kt),
            htmlFlowData: Ft,
            htmlText: ct(qt),
            htmlTextData: Ft,
            image: ct(Xt),
            label: Lt,
            labelText: Jt,
            lineEnding: $t,
            link: ct(Bt),
            listItem: ct(),
            listOrdered: ct(),
            listUnordered: ct(),
            paragraph: ct(),
            referenceString: sn,
            resourceDestinationString: Rt,
            resourceTitleString: _n,
            resource: Fn,
            setextHeading: ct(Nt),
            setextHeadingLineSequence: Zt,
            setextHeadingText: Ot,
            strong: ct(),
            thematicBreak: ct()
        }
    };
    configure($, (et || {}).mdastExtensions || []);
    const tt = {};
    return nt;
    function nt(Gt) {
        let Ht = {
            type: "root",
            children: []
        };
        const Vt = {
            stack: [Ht],
            tokenStack: [],
            config: $,
            enter: ut,
            exit: ht,
            buffer: lt,
            resume: ft,
            setData: it,
            getData: ot
        }
          , hn = [];
        let vn = -1;
        for (; ++vn < Gt.length; )
            if (Gt[vn][1].type === "listOrdered" || Gt[vn][1].type === "listUnordered")
                if (Gt[vn][0] === "enter")
                    hn.push(vn);
                else {
                    const En = hn.pop();
                    vn = rt(Gt, En, vn)
                }
        for (vn = -1; ++vn < Gt.length; ) {
            const En = $[Gt[vn][0]];
            own$5.call(En, Gt[vn][1].type) && En[Gt[vn][1].type].call(Object.assign({
                sliceSerialize: Gt[vn][2].sliceSerialize
            }, Vt), Gt[vn][1])
        }
        if (Vt.tokenStack.length > 0) {
            const En = Vt.tokenStack[Vt.tokenStack.length - 1];
            (En[1] || defaultOnError).call(Vt, void 0, En[0])
        }
        for (Ht.position = {
            start: point$1(Gt.length > 0 ? Gt[0][1].start : {
                line: 1,
                column: 1,
                offset: 0
            }),
            end: point$1(Gt.length > 0 ? Gt[Gt.length - 2][1].end : {
                line: 1,
                column: 1,
                offset: 0
            })
        },
        vn = -1; ++vn < $.transforms.length; )
            Ht = $.transforms[vn](Ht) || Ht;
        return Ht
    }
    function rt(Gt, Ht, Vt) {
        let hn = Ht - 1, vn = -1, En = !1, Ut, Cn, Tn, Hn;
        for (; ++hn <= Vt; ) {
            const yn = Gt[hn];
            if (yn[1].type === "listUnordered" || yn[1].type === "listOrdered" || yn[1].type === "blockQuote" ? (yn[0] === "enter" ? vn++ : vn--,
            Hn = void 0) : yn[1].type === "lineEndingBlank" ? yn[0] === "enter" && (Ut && !Hn && !vn && !Tn && (Tn = hn),
            Hn = void 0) : yn[1].type === "linePrefix" || yn[1].type === "listItemValue" || yn[1].type === "listItemMarker" || yn[1].type === "listItemPrefix" || yn[1].type === "listItemPrefixWhitespace" || (Hn = void 0),
            !vn && yn[0] === "enter" && yn[1].type === "listItemPrefix" || vn === -1 && yn[0] === "exit" && (yn[1].type === "listUnordered" || yn[1].type === "listOrdered")) {
                if (Ut) {
                    let xn = hn;
                    for (Cn = void 0; xn--; ) {
                        const Nn = Gt[xn];
                        if (Nn[1].type === "lineEnding" || Nn[1].type === "lineEndingBlank") {
                            if (Nn[0] === "exit")
                                continue;
                            Cn && (Gt[Cn][1].type = "lineEndingBlank",
                            En = !0),
                            Nn[1].type = "lineEnding",
                            Cn = xn
                        } else if (!(Nn[1].type === "linePrefix" || Nn[1].type === "blockQuotePrefix" || Nn[1].type === "blockQuotePrefixWhitespace" || Nn[1].type === "blockQuoteMarker" || Nn[1].type === "listItemIndent"))
                            break
                    }
                    Tn && (!Cn || Tn < Cn) && (Ut._spread = !0),
                    Ut.end = Object.assign({}, Cn ? Gt[Cn][1].start : yn[1].end),
                    Gt.splice(Cn || hn, 0, ["exit", Ut, yn[2]]),
                    hn++,
                    Vt++
                }
                yn[1].type === "listItemPrefix" && (Ut = {
                    type: "listItem",
                    _spread: !1,
                    start: Object.assign({}, yn[1].start)
                },
                Gt.splice(hn, 0, ["enter", Ut, yn[2]]),
                hn++,
                Vt++,
                Tn = void 0,
                Hn = !0)
            }
        }
        return Gt[Ht][1]._spread = En,
        Vt
    }
    function it(Gt, Ht) {
        tt[Gt] = Ht
    }
    function ot(Gt) {
        return tt[Gt]
    }
    function st(Gt, Ht) {
        return Vt;
        function Vt(hn) {
            ut.call(this, Gt(hn), hn),
            Ht && Ht.call(this, hn)
        }
    }
    function lt() {
        this.stack.push({
            type: "fragment",
            children: []
        })
    }
    function ut(Gt, Ht, Vt) {
        return this.stack[this.stack.length - 1].children.push(Gt),
        this.stack.push(Gt),
        this.tokenStack.push([Ht, Vt]),
        Gt.position = {
            start: point$1(Ht.start)
        },
        Gt
    }
    function ct(Gt) {
        return Ht;
        function Ht(Vt) {
            Gt && Gt.call(this, Vt),
            ht.call(this, Vt)
        }
    }
    function ht(Gt, Ht) {
        const Vt = this.stack.pop()
          , hn = this.tokenStack.pop();
        if (hn)
            hn[0].type !== Gt.type && (Ht ? Ht.call(this, Gt, hn[0]) : (hn[1] || defaultOnError).call(this, Gt, hn[0]));
        else
            throw new Error("Cannot close `" + Gt.type + "` (" + stringifyPosition({
                start: Gt.start,
                end: Gt.end
            }) + "): it\u2019s not open");
        return Vt.position.end = point$1(Gt.end),
        Vt
    }
    function ft() {
        return toString(this.stack.pop())
    }
    function gt() {
        it("expectingFirstListItemValue", !0)
    }
    function vt(Gt) {
        if (ot("expectingFirstListItemValue")) {
            const Ht = this.stack[this.stack.length - 2];
            Ht.start = Number.parseInt(this.sliceSerialize(Gt), 10),
            it("expectingFirstListItemValue")
        }
    }
    function yt() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.lang = Gt
    }
    function wt() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.meta = Gt
    }
    function mt() {
        ot("flowCodeInside") || (this.buffer(),
        it("flowCodeInside", !0))
    }
    function _t() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.value = Gt.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""),
        it("flowCodeInside")
    }
    function bt() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.value = Gt.replace(/(\r?\n|\r)$/g, "")
    }
    function Mt(Gt) {
        const Ht = this.resume()
          , Vt = this.stack[this.stack.length - 1];
        Vt.label = Ht,
        Vt.identifier = normalizeIdentifier(this.sliceSerialize(Gt)).toLowerCase()
    }
    function St() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.title = Gt
    }
    function At() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.url = Gt
    }
    function Pt(Gt) {
        const Ht = this.stack[this.stack.length - 1];
        if (!Ht.depth) {
            const Vt = this.sliceSerialize(Gt).length;
            Ht.depth = Vt
        }
    }
    function Ot() {
        it("setextHeadingSlurpLineEnding", !0)
    }
    function Zt(Gt) {
        const Ht = this.stack[this.stack.length - 1];
        Ht.depth = this.sliceSerialize(Gt).charCodeAt(0) === 61 ? 1 : 2
    }
    function Nt() {
        it("setextHeadingSlurpLineEnding")
    }
    function Tt(Gt) {
        const Ht = this.stack[this.stack.length - 1];
        let Vt = Ht.children[Ht.children.length - 1];
        (!Vt || Vt.type !== "text") && (Vt = An(),
        Vt.position = {
            start: point$1(Gt.start)
        },
        Ht.children.push(Vt)),
        this.stack.push(Vt)
    }
    function Ft(Gt) {
        const Ht = this.stack.pop();
        Ht.value += this.sliceSerialize(Gt),
        Ht.position.end = point$1(Gt.end)
    }
    function $t(Gt) {
        const Ht = this.stack[this.stack.length - 1];
        if (ot("atHardBreak")) {
            const Vt = Ht.children[Ht.children.length - 1];
            Vt.position.end = point$1(Gt.end),
            it("atHardBreak");
            return
        }
        !ot("setextHeadingSlurpLineEnding") && $.canContainEols.includes(Ht.type) && (Tt.call(this, Gt),
        Ft.call(this, Gt))
    }
    function Wt() {
        it("atHardBreak", !0)
    }
    function Kt() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.value = Gt
    }
    function qt() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.value = Gt
    }
    function jt() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.value = Gt
    }
    function Bt() {
        const Gt = this.stack[this.stack.length - 1];
        if (ot("inReference")) {
            const Ht = ot("referenceType") || "shortcut";
            Gt.type += "Reference",
            Gt.referenceType = Ht,
            delete Gt.url,
            delete Gt.title
        } else
            delete Gt.identifier,
            delete Gt.label;
        it("referenceType")
    }
    function Xt() {
        const Gt = this.stack[this.stack.length - 1];
        if (ot("inReference")) {
            const Ht = ot("referenceType") || "shortcut";
            Gt.type += "Reference",
            Gt.referenceType = Ht,
            delete Gt.url,
            delete Gt.title
        } else
            delete Gt.identifier,
            delete Gt.label;
        it("referenceType")
    }
    function Jt(Gt) {
        const Ht = this.sliceSerialize(Gt)
          , Vt = this.stack[this.stack.length - 2];
        Vt.label = decodeString(Ht),
        Vt.identifier = normalizeIdentifier(Ht).toLowerCase()
    }
    function Lt() {
        const Gt = this.stack[this.stack.length - 1]
          , Ht = this.resume()
          , Vt = this.stack[this.stack.length - 1];
        if (it("inReference", !0),
        Vt.type === "link") {
            const hn = Gt.children;
            Vt.children = hn
        } else
            Vt.alt = Ht
    }
    function Rt() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.url = Gt
    }
    function _n() {
        const Gt = this.resume()
          , Ht = this.stack[this.stack.length - 1];
        Ht.title = Gt
    }
    function Fn() {
        it("inReference")
    }
    function Vn() {
        it("referenceType", "collapsed")
    }
    function sn(Gt) {
        const Ht = this.resume()
          , Vt = this.stack[this.stack.length - 1];
        Vt.label = Ht,
        Vt.identifier = normalizeIdentifier(this.sliceSerialize(Gt)).toLowerCase(),
        it("referenceType", "full")
    }
    function Un(Gt) {
        it("characterReferenceType", Gt.type)
    }
    function zn(Gt) {
        const Ht = this.sliceSerialize(Gt)
          , Vt = ot("characterReferenceType");
        let hn;
        Vt ? (hn = decodeNumericCharacterReference(Ht, Vt === "characterReferenceMarkerNumeric" ? 10 : 16),
        it("characterReferenceType")) : hn = decodeNamedCharacterReference(Ht);
        const vn = this.stack.pop();
        vn.value += hn,
        vn.position.end = point$1(Gt.end)
    }
    function Rn(Gt) {
        Ft.call(this, Gt);
        const Ht = this.stack[this.stack.length - 1];
        Ht.url = this.sliceSerialize(Gt)
    }
    function Ln(Gt) {
        Ft.call(this, Gt);
        const Ht = this.stack[this.stack.length - 1];
        Ht.url = "mailto:" + this.sliceSerialize(Gt)
    }
    function Gn() {
        return {
            type: "blockquote",
            children: []
        }
    }
    function cn() {
        return {
            type: "code",
            lang: null,
            meta: null,
            value: ""
        }
    }
    function bn() {
        return {
            type: "inlineCode",
            value: ""
        }
    }
    function Mn() {
        return {
            type: "definition",
            identifier: "",
            label: null,
            title: null,
            url: ""
        }
    }
    function Dn() {
        return {
            type: "emphasis",
            children: []
        }
    }
    function Pn() {
        return {
            type: "heading",
            depth: void 0,
            children: []
        }
    }
    function $n() {
        return {
            type: "break"
        }
    }
    function On() {
        return {
            type: "html",
            value: ""
        }
    }
    function Wn() {
        return {
            type: "image",
            title: null,
            url: "",
            alt: null
        }
    }
    function rr() {
        return {
            type: "link",
            title: null,
            url: "",
            children: []
        }
    }
    function Dt(Gt) {
        return {
            type: "list",
            ordered: Gt.type === "listOrdered",
            start: null,
            spread: Gt._spread,
            children: []
        }
    }
    function kt(Gt) {
        return {
            type: "listItem",
            spread: Gt._spread,
            checked: null,
            children: []
        }
    }
    function pn() {
        return {
            type: "paragraph",
            children: []
        }
    }
    function mn() {
        return {
            type: "strong",
            children: []
        }
    }
    function An() {
        return {
            type: "text",
            value: ""
        }
    }
    function In() {
        return {
            type: "thematicBreak"
        }
    }
}
function point$1(et) {
    return {
        line: et.line,
        column: et.column,
        offset: et.offset
    }
}
function configure(et, $) {
    let tt = -1;
    for (; ++tt < $.length; ) {
        const nt = $[tt];
        Array.isArray(nt) ? configure(et, nt) : extension(et, nt)
    }
}
function extension(et, $) {
    let tt;
    for (tt in $)
        if (own$5.call($, tt)) {
            if (tt === "canContainEols") {
                const nt = $[tt];
                nt && et[tt].push(...nt)
            } else if (tt === "transforms") {
                const nt = $[tt];
                nt && et[tt].push(...nt)
            } else if (tt === "enter" || tt === "exit") {
                const nt = $[tt];
                nt && Object.assign(et[tt], nt)
            }
        }
}
function defaultOnError(et, $) {
    throw et ? new Error("Cannot close `" + et.type + "` (" + stringifyPosition({
        start: et.start,
        end: et.end
    }) + "): a different token (`" + $.type + "`, " + stringifyPosition({
        start: $.start,
        end: $.end
    }) + ") is open") : new Error("Cannot close document, a token (`" + $.type + "`, " + stringifyPosition({
        start: $.start,
        end: $.end
    }) + ") is still open")
}
function remarkParse(et) {
    Object.assign(this, {
        Parser: tt=>{
            const nt = this.data("settings");
            return fromMarkdown(tt, Object.assign({}, nt, et, {
                extensions: this.data("micromarkExtensions") || [],
                mdastExtensions: this.data("fromMarkdownExtensions") || []
            }))
        }
    })
}
function blockquote(et, $) {
    const tt = {
        type: "element",
        tagName: "blockquote",
        properties: {},
        children: et.wrap(et.all($), !0)
    };
    return et.patch($, tt),
    et.applyData($, tt)
}
function hardBreak(et, $) {
    const tt = {
        type: "element",
        tagName: "br",
        properties: {},
        children: []
    };
    return et.patch($, tt),
    [et.applyData($, tt), {
        type: "text",
        value: `
`
    }]
}
function code(et, $) {
    const tt = $.value ? $.value + `
` : ""
      , nt = $.lang ? $.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null
      , rt = {};
    nt && (rt.className = ["language-" + nt]);
    let it = {
        type: "element",
        tagName: "code",
        properties: rt,
        children: [{
            type: "text",
            value: tt
        }]
    };
    return $.meta && (it.data = {
        meta: $.meta
    }),
    et.patch($, it),
    it = et.applyData($, it),
    it = {
        type: "element",
        tagName: "pre",
        properties: {},
        children: [it]
    },
    et.patch($, it),
    it
}
function strikethrough(et, $) {
    const tt = {
        type: "element",
        tagName: "del",
        properties: {},
        children: et.all($)
    };
    return et.patch($, tt),
    et.applyData($, tt)
}
function emphasis(et, $) {
    const tt = {
        type: "element",
        tagName: "em",
        properties: {},
        children: et.all($)
    };
    return et.patch($, tt),
    et.applyData($, tt)
}
function normalizeUri(et) {
    const $ = [];
    let tt = -1
      , nt = 0
      , rt = 0;
    for (; ++tt < et.length; ) {
        const it = et.charCodeAt(tt);
        let ot = "";
        if (it === 37 && asciiAlphanumeric(et.charCodeAt(tt + 1)) && asciiAlphanumeric(et.charCodeAt(tt + 2)))
            rt = 2;
        else if (it < 128)
            /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(it)) || (ot = String.fromCharCode(it));
        else if (it > 55295 && it < 57344) {
            const st = et.charCodeAt(tt + 1);
            it < 56320 && st > 56319 && st < 57344 ? (ot = String.fromCharCode(it, st),
            rt = 1) : ot = "\uFFFD"
        } else
            ot = String.fromCharCode(it);
        ot && ($.push(et.slice(nt, tt), encodeURIComponent(ot)),
        nt = tt + rt + 1,
        ot = ""),
        rt && (tt += rt,
        rt = 0)
    }
    return $.join("") + et.slice(nt)
}
function footnoteReference(et, $) {
    const tt = String($.identifier).toUpperCase()
      , nt = normalizeUri(tt.toLowerCase())
      , rt = et.footnoteOrder.indexOf(tt);
    let it;
    rt === -1 ? (et.footnoteOrder.push(tt),
    et.footnoteCounts[tt] = 1,
    it = et.footnoteOrder.length) : (et.footnoteCounts[tt]++,
    it = rt + 1);
    const ot = et.footnoteCounts[tt]
      , st = {
        type: "element",
        tagName: "a",
        properties: {
            href: "#" + et.clobberPrefix + "fn-" + nt,
            id: et.clobberPrefix + "fnref-" + nt + (ot > 1 ? "-" + ot : ""),
            dataFootnoteRef: !0,
            ariaDescribedBy: ["footnote-label"]
        },
        children: [{
            type: "text",
            value: String(it)
        }]
    };
    et.patch($, st);
    const lt = {
        type: "element",
        tagName: "sup",
        properties: {},
        children: [st]
    };
    return et.patch($, lt),
    et.applyData($, lt)
}
function footnote(et, $) {
    const tt = et.footnoteById;
    let nt = 1;
    for (; nt in tt; )
        nt++;
    const rt = String(nt);
    return tt[rt] = {
        type: "footnoteDefinition",
        identifier: rt,
        children: [{
            type: "paragraph",
            children: $.children
        }],
        position: $.position
    },
    footnoteReference(et, {
        type: "footnoteReference",
        identifier: rt,
        position: $.position
    })
}
function heading(et, $) {
    const tt = {
        type: "element",
        tagName: "h" + $.depth,
        properties: {},
        children: et.all($)
    };
    return et.patch($, tt),
    et.applyData($, tt)
}
function html$2(et, $) {
    if (et.dangerous) {
        const tt = {
            type: "raw",
            value: $.value
        };
        return et.patch($, tt),
        et.applyData($, tt)
    }
    return null
}
function revert(et, $) {
    const tt = $.referenceType;
    let nt = "]";
    if (tt === "collapsed" ? nt += "[]" : tt === "full" && (nt += "[" + ($.label || $.identifier) + "]"),
    $.type === "imageReference")
        return {
            type: "text",
            value: "![" + $.alt + nt
        };
    const rt = et.all($)
      , it = rt[0];
    it && it.type === "text" ? it.value = "[" + it.value : rt.unshift({
        type: "text",
        value: "["
    });
    const ot = rt[rt.length - 1];
    return ot && ot.type === "text" ? ot.value += nt : rt.push({
        type: "text",
        value: nt
    }),
    rt
}
function imageReference(et, $) {
    const tt = et.definition($.identifier);
    if (!tt)
        return revert(et, $);
    const nt = {
        src: normalizeUri(tt.url || ""),
        alt: $.alt
    };
    tt.title !== null && tt.title !== void 0 && (nt.title = tt.title);
    const rt = {
        type: "element",
        tagName: "img",
        properties: nt,
        children: []
    };
    return et.patch($, rt),
    et.applyData($, rt)
}
function image(et, $) {
    const tt = {
        src: normalizeUri($.url)
    };
    $.alt !== null && $.alt !== void 0 && (tt.alt = $.alt),
    $.title !== null && $.title !== void 0 && (tt.title = $.title);
    const nt = {
        type: "element",
        tagName: "img",
        properties: tt,
        children: []
    };
    return et.patch($, nt),
    et.applyData($, nt)
}
function inlineCode(et, $) {
    const tt = {
        type: "text",
        value: $.value.replace(/\r?\n|\r/g, " ")
    };
    et.patch($, tt);
    const nt = {
        type: "element",
        tagName: "code",
        properties: {},
        children: [tt]
    };
    return et.patch($, nt),
    et.applyData($, nt)
}
function linkReference(et, $) {
    const tt = et.definition($.identifier);
    if (!tt)
        return revert(et, $);
    const nt = {
        href: normalizeUri(tt.url || "")
    };
    tt.title !== null && tt.title !== void 0 && (nt.title = tt.title);
    const rt = {
        type: "element",
        tagName: "a",
        properties: nt,
        children: et.all($)
    };
    return et.patch($, rt),
    et.applyData($, rt)
}
function link(et, $) {
    const tt = {
        href: normalizeUri($.url)
    };
    $.title !== null && $.title !== void 0 && (tt.title = $.title);
    const nt = {
        type: "element",
        tagName: "a",
        properties: tt,
        children: et.all($)
    };
    return et.patch($, nt),
    et.applyData($, nt)
}
function listItem(et, $, tt) {
    const nt = et.all($)
      , rt = tt ? listLoose(tt) : listItemLoose($)
      , it = {}
      , ot = [];
    if (typeof $.checked == "boolean") {
        const ct = nt[0];
        let ht;
        ct && ct.type === "element" && ct.tagName === "p" ? ht = ct : (ht = {
            type: "element",
            tagName: "p",
            properties: {},
            children: []
        },
        nt.unshift(ht)),
        ht.children.length > 0 && ht.children.unshift({
            type: "text",
            value: " "
        }),
        ht.children.unshift({
            type: "element",
            tagName: "input",
            properties: {
                type: "checkbox",
                checked: $.checked,
                disabled: !0
            },
            children: []
        }),
        it.className = ["task-list-item"]
    }
    let st = -1;
    for (; ++st < nt.length; ) {
        const ct = nt[st];
        (rt || st !== 0 || ct.type !== "element" || ct.tagName !== "p") && ot.push({
            type: "text",
            value: `
`
        }),
        ct.type === "element" && ct.tagName === "p" && !rt ? ot.push(...ct.children) : ot.push(ct)
    }
    const lt = nt[nt.length - 1];
    lt && (rt || lt.type !== "element" || lt.tagName !== "p") && ot.push({
        type: "text",
        value: `
`
    });
    const ut = {
        type: "element",
        tagName: "li",
        properties: it,
        children: ot
    };
    return et.patch($, ut),
    et.applyData($, ut)
}
function listLoose(et) {
    let $ = !1;
    if (et.type === "list") {
        $ = et.spread || !1;
        const tt = et.children;
        let nt = -1;
        for (; !$ && ++nt < tt.length; )
            $ = listItemLoose(tt[nt])
    }
    return $
}
function listItemLoose(et) {
    const $ = et.spread;
    return $ == null ? et.children.length > 1 : $
}
function list(et, $) {
    const tt = {}
      , nt = et.all($);
    let rt = -1;
    for (typeof $.start == "number" && $.start !== 1 && (tt.start = $.start); ++rt < nt.length; ) {
        const ot = nt[rt];
        if (ot.type === "element" && ot.tagName === "li" && ot.properties && Array.isArray(ot.properties.className) && ot.properties.className.includes("task-list-item")) {
            tt.className = ["contains-task-list"];
            break
        }
    }
    const it = {
        type: "element",
        tagName: $.ordered ? "ol" : "ul",
        properties: tt,
        children: et.wrap(nt, !0)
    };
    return et.patch($, it),
    et.applyData($, it)
}
function paragraph(et, $) {
    const tt = {
        type: "element",
        tagName: "p",
        properties: {},
        children: et.all($)
    };
    return et.patch($, tt),
    et.applyData($, tt)
}
function root(et, $) {
    const tt = {
        type: "root",
        children: et.wrap(et.all($))
    };
    return et.patch($, tt),
    et.applyData($, tt)
}
function strong(et, $) {
    const tt = {
        type: "element",
        tagName: "strong",
        properties: {},
        children: et.all($)
    };
    return et.patch($, tt),
    et.applyData($, tt)
}
const pointStart = point("start")
  , pointEnd = point("end");
function position(et) {
    return {
        start: pointStart(et),
        end: pointEnd(et)
    }
}
function point(et) {
    return $;
    function $(tt) {
        const nt = tt && tt.position && tt.position[et] || {};
        return {
            line: nt.line || null,
            column: nt.column || null,
            offset: nt.offset > -1 ? nt.offset : null
        }
    }
}
function table(et, $) {
    const tt = et.all($)
      , nt = tt.shift()
      , rt = [];
    if (nt) {
        const ot = {
            type: "element",
            tagName: "thead",
            properties: {},
            children: et.wrap([nt], !0)
        };
        et.patch($.children[0], ot),
        rt.push(ot)
    }
    if (tt.length > 0) {
        const ot = {
            type: "element",
            tagName: "tbody",
            properties: {},
            children: et.wrap(tt, !0)
        }
          , st = pointStart($.children[1])
          , lt = pointEnd($.children[$.children.length - 1]);
        st.line && lt.line && (ot.position = {
            start: st,
            end: lt
        }),
        rt.push(ot)
    }
    const it = {
        type: "element",
        tagName: "table",
        properties: {},
        children: et.wrap(rt, !0)
    };
    return et.patch($, it),
    et.applyData($, it)
}
function tableRow(et, $, tt) {
    const nt = tt ? tt.children : void 0
      , it = (nt ? nt.indexOf($) : 1) === 0 ? "th" : "td"
      , ot = tt && tt.type === "table" ? tt.align : void 0
      , st = ot ? ot.length : $.children.length;
    let lt = -1;
    const ut = [];
    for (; ++lt < st; ) {
        const ht = $.children[lt]
          , ft = {}
          , gt = ot ? ot[lt] : void 0;
        gt && (ft.align = gt);
        let vt = {
            type: "element",
            tagName: it,
            properties: ft,
            children: []
        };
        ht && (vt.children = et.all(ht),
        et.patch(ht, vt),
        vt = et.applyData($, vt)),
        ut.push(vt)
    }
    const ct = {
        type: "element",
        tagName: "tr",
        properties: {},
        children: et.wrap(ut, !0)
    };
    return et.patch($, ct),
    et.applyData($, ct)
}
function tableCell(et, $) {
    const tt = {
        type: "element",
        tagName: "td",
        properties: {},
        children: et.all($)
    };
    return et.patch($, tt),
    et.applyData($, tt)
}
const tab = 9
  , space = 32;
function trimLines(et) {
    const $ = String(et)
      , tt = /\r?\n|\r/g;
    let nt = tt.exec($)
      , rt = 0;
    const it = [];
    for (; nt; )
        it.push(trimLine($.slice(rt, nt.index), rt > 0, !0), nt[0]),
        rt = nt.index + nt[0].length,
        nt = tt.exec($);
    return it.push(trimLine($.slice(rt), rt > 0, !1)),
    it.join("")
}
function trimLine(et, $, tt) {
    let nt = 0
      , rt = et.length;
    if ($) {
        let it = et.codePointAt(nt);
        for (; it === tab || it === space; )
            nt++,
            it = et.codePointAt(nt)
    }
    if (tt) {
        let it = et.codePointAt(rt - 1);
        for (; it === tab || it === space; )
            rt--,
            it = et.codePointAt(rt - 1)
    }
    return rt > nt ? et.slice(nt, rt) : ""
}
function text(et, $) {
    const tt = {
        type: "text",
        value: trimLines(String($.value))
    };
    return et.patch($, tt),
    et.applyData($, tt)
}
function thematicBreak(et, $) {
    const tt = {
        type: "element",
        tagName: "hr",
        properties: {},
        children: []
    };
    return et.patch($, tt),
    et.applyData($, tt)
}
const handlers = {
    blockquote,
    break: hardBreak,
    code,
    delete: strikethrough,
    emphasis,
    footnoteReference,
    footnote,
    heading,
    html: html$2,
    imageReference,
    image,
    inlineCode,
    linkReference,
    link,
    listItem,
    list,
    paragraph,
    root,
    strong,
    table,
    tableCell,
    tableRow,
    text,
    thematicBreak,
    toml: ignore,
    yaml: ignore,
    definition: ignore,
    footnoteDefinition: ignore
};
function ignore() {
    return null
}
const convert = function(et) {
    if (et == null)
        return ok;
    if (typeof et == "string")
        return typeFactory(et);
    if (typeof et == "object")
        return Array.isArray(et) ? anyFactory(et) : propsFactory(et);
    if (typeof et == "function")
        return castFactory(et);
    throw new Error("Expected function, string, or object as test")
};
function anyFactory(et) {
    const $ = [];
    let tt = -1;
    for (; ++tt < et.length; )
        $[tt] = convert(et[tt]);
    return castFactory(nt);
    function nt(...rt) {
        let it = -1;
        for (; ++it < $.length; )
            if ($[it].call(this, ...rt))
                return !0;
        return !1
    }
}
function propsFactory(et) {
    return castFactory($);
    function $(tt) {
        let nt;
        for (nt in et)
            if (tt[nt] !== et[nt])
                return !1;
        return !0
    }
}
function typeFactory(et) {
    return castFactory($);
    function $(tt) {
        return tt && tt.type === et
    }
}
function castFactory(et) {
    return $;
    function $(tt, ...nt) {
        return Boolean(tt && typeof tt == "object" && "type"in tt && Boolean(et.call(this, tt, ...nt)))
    }
}
function ok() {
    return !0
}
function color(et) {
    return et
}
const CONTINUE = !0
  , EXIT = !1
  , SKIP = "skip"
  , visitParents = function(et, $, tt, nt) {
    typeof $ == "function" && typeof tt != "function" && (nt = tt,
    tt = $,
    $ = null);
    const rt = convert($)
      , it = nt ? -1 : 1;
    ot(et, void 0, [])();
    function ot(st, lt, ut) {
        const ct = st && typeof st == "object" ? st : {};
        if (typeof ct.type == "string") {
            const ft = typeof ct.tagName == "string" ? ct.tagName : typeof ct.name == "string" ? ct.name : void 0;
            Object.defineProperty(ht, "name", {
                value: "node (" + (st.type + (ft ? "<" + ft + ">" : "")) + ")"
            })
        }
        return ht;
        function ht() {
            let ft = [], gt, vt, yt;
            if ((!$ || rt(st, lt, ut[ut.length - 1] || null)) && (ft = toResult(tt(st, ut)),
            ft[0] === EXIT))
                return ft;
            if (st.children && ft[0] !== SKIP)
                for (vt = (nt ? st.children.length : -1) + it,
                yt = ut.concat(st); vt > -1 && vt < st.children.length; ) {
                    if (gt = ot(st.children[vt], vt, yt)(),
                    gt[0] === EXIT)
                        return gt;
                    vt = typeof gt[1] == "number" ? gt[1] : vt + it
                }
            return ft
        }
    }
};
function toResult(et) {
    return Array.isArray(et) ? et : typeof et == "number" ? [CONTINUE, et] : [et]
}
const visit = function(et, $, tt, nt) {
    typeof $ == "function" && typeof tt != "function" && (nt = tt,
    tt = $,
    $ = null),
    visitParents(et, $, rt, nt);
    function rt(it, ot) {
        const st = ot[ot.length - 1];
        return tt(it, st ? st.children.indexOf(it) : null, st)
    }
};
function generated(et) {
    return !et || !et.position || !et.position.start || !et.position.start.line || !et.position.start.column || !et.position.end || !et.position.end.line || !et.position.end.column
}
const own$4 = {}.hasOwnProperty;
function definitions(et) {
    const $ = Object.create(null);
    if (!et || !et.type)
        throw new Error("mdast-util-definitions expected node");
    return visit(et, "definition", nt=>{
        const rt = clean(nt.identifier);
        rt && !own$4.call($, rt) && ($[rt] = nt)
    }
    ),
    tt;
    function tt(nt) {
        const rt = clean(nt);
        return rt && own$4.call($, rt) ? $[rt] : null
    }
}
function clean(et) {
    return String(et || "").toUpperCase()
}
const own$3 = {}.hasOwnProperty;
function createState(et, $) {
    const tt = $ || {}
      , nt = tt.allowDangerousHtml || !1
      , rt = {};
    return ot.dangerous = nt,
    ot.clobberPrefix = tt.clobberPrefix === void 0 || tt.clobberPrefix === null ? "user-content-" : tt.clobberPrefix,
    ot.footnoteLabel = tt.footnoteLabel || "Footnotes",
    ot.footnoteLabelTagName = tt.footnoteLabelTagName || "h2",
    ot.footnoteLabelProperties = tt.footnoteLabelProperties || {
        className: ["sr-only"]
    },
    ot.footnoteBackLabel = tt.footnoteBackLabel || "Back to content",
    ot.unknownHandler = tt.unknownHandler,
    ot.passThrough = tt.passThrough,
    ot.handlers = wn(wn({}, handlers), tt.handlers),
    ot.definition = definitions(et),
    ot.footnoteById = rt,
    ot.footnoteOrder = [],
    ot.footnoteCounts = {},
    ot.patch = patch,
    ot.applyData = applyData,
    ot.one = st,
    ot.all = lt,
    ot.wrap = wrap,
    ot.augment = it,
    visit(et, "footnoteDefinition", ut=>{
        const ct = String(ut.identifier).toUpperCase();
        own$3.call(rt, ct) || (rt[ct] = ut)
    }
    ),
    ot;
    function it(ut, ct) {
        if (ut && "data"in ut && ut.data) {
            const ht = ut.data;
            ht.hName && (ct.type !== "element" && (ct = {
                type: "element",
                tagName: "",
                properties: {},
                children: []
            }),
            ct.tagName = ht.hName),
            ct.type === "element" && ht.hProperties && (ct.properties = wn(wn({}, ct.properties), ht.hProperties)),
            "children"in ct && ct.children && ht.hChildren && (ct.children = ht.hChildren)
        }
        if (ut) {
            const ht = "type"in ut ? ut : {
                position: ut
            };
            generated(ht) || (ct.position = {
                start: pointStart(ht),
                end: pointEnd(ht)
            })
        }
        return ct
    }
    function ot(ut, ct, ht, ft) {
        return Array.isArray(ht) && (ft = ht,
        ht = {}),
        it(ut, {
            type: "element",
            tagName: ct,
            properties: ht || {},
            children: ft || []
        })
    }
    function st(ut, ct) {
        return one(ot, ut, ct)
    }
    function lt(ut) {
        return all(ot, ut)
    }
}
function patch(et, $) {
    et.position && ($.position = position(et))
}
function applyData(et, $) {
    let tt = $;
    if (et && et.data) {
        const nt = et.data.hName
          , rt = et.data.hChildren
          , it = et.data.hProperties;
        typeof nt == "string" && (tt.type === "element" ? tt.tagName = nt : tt = {
            type: "element",
            tagName: nt,
            properties: {},
            children: []
        }),
        tt.type === "element" && it && (tt.properties = wn(wn({}, tt.properties), it)),
        "children"in tt && tt.children && rt !== null && rt !== void 0 && (tt.children = rt)
    }
    return tt
}
function one(et, $, tt) {
    const nt = $ && $.type;
    if (!nt)
        throw new Error("Expected node, got `" + $ + "`");
    return own$3.call(et.handlers, nt) ? et.handlers[nt](et, $, tt) : et.passThrough && et.passThrough.includes(nt) ? "children"in $ ? kn(wn({}, $), {
        children: all(et, $)
    }) : $ : et.unknownHandler ? et.unknownHandler(et, $, tt) : defaultUnknownHandler(et, $)
}
function all(et, $) {
    const tt = [];
    if ("children"in $) {
        const nt = $.children;
        let rt = -1;
        for (; ++rt < nt.length; ) {
            const it = one(et, nt[rt], $);
            if (it) {
                if (rt && nt[rt - 1].type === "break" && (!Array.isArray(it) && it.type === "text" && (it.value = it.value.replace(/^\s+/, "")),
                !Array.isArray(it) && it.type === "element")) {
                    const ot = it.children[0];
                    ot && ot.type === "text" && (ot.value = ot.value.replace(/^\s+/, ""))
                }
                Array.isArray(it) ? tt.push(...it) : tt.push(it)
            }
        }
    }
    return tt
}
function defaultUnknownHandler(et, $) {
    const tt = $.data || {}
      , nt = "value"in $ && !(own$3.call(tt, "hProperties") || own$3.call(tt, "hChildren")) ? {
        type: "text",
        value: $.value
    } : {
        type: "element",
        tagName: "div",
        properties: {},
        children: all(et, $)
    };
    return et.patch($, nt),
    et.applyData($, nt)
}
function wrap(et, $) {
    const tt = [];
    let nt = -1;
    for ($ && tt.push({
        type: "text",
        value: `
`
    }); ++nt < et.length; )
        nt && tt.push({
            type: "text",
            value: `
`
        }),
        tt.push(et[nt]);
    return $ && et.length > 0 && tt.push({
        type: "text",
        value: `
`
    }),
    tt
}
function footer(et) {
    const $ = [];
    let tt = -1;
    for (; ++tt < et.footnoteOrder.length; ) {
        const nt = et.footnoteById[et.footnoteOrder[tt]];
        if (!nt)
            continue;
        const rt = et.all(nt)
          , it = String(nt.identifier).toUpperCase()
          , ot = normalizeUri(it.toLowerCase());
        let st = 0;
        const lt = [];
        for (; ++st <= et.footnoteCounts[it]; ) {
            const ht = {
                type: "element",
                tagName: "a",
                properties: {
                    href: "#" + et.clobberPrefix + "fnref-" + ot + (st > 1 ? "-" + st : ""),
                    dataFootnoteBackref: !0,
                    className: ["data-footnote-backref"],
                    ariaLabel: et.footnoteBackLabel
                },
                children: [{
                    type: "text",
                    value: "\u21A9"
                }]
            };
            st > 1 && ht.children.push({
                type: "element",
                tagName: "sup",
                children: [{
                    type: "text",
                    value: String(st)
                }]
            }),
            lt.length > 0 && lt.push({
                type: "text",
                value: " "
            }),
            lt.push(ht)
        }
        const ut = rt[rt.length - 1];
        if (ut && ut.type === "element" && ut.tagName === "p") {
            const ht = ut.children[ut.children.length - 1];
            ht && ht.type === "text" ? ht.value += " " : ut.children.push({
                type: "text",
                value: " "
            }),
            ut.children.push(...lt)
        } else
            rt.push(...lt);
        const ct = {
            type: "element",
            tagName: "li",
            properties: {
                id: et.clobberPrefix + "fn-" + ot
            },
            children: et.wrap(rt, !0)
        };
        et.patch(nt, ct),
        $.push(ct)
    }
    if ($.length !== 0)
        return {
            type: "element",
            tagName: "section",
            properties: {
                dataFootnotes: !0,
                className: ["footnotes"]
            },
            children: [{
                type: "element",
                tagName: et.footnoteLabelTagName,
                properties: kn(wn({}, JSON.parse(JSON.stringify(et.footnoteLabelProperties))), {
                    id: "footnote-label"
                }),
                children: [{
                    type: "text",
                    value: et.footnoteLabel
                }]
            }, {
                type: "text",
                value: `
`
            }, {
                type: "element",
                tagName: "ol",
                properties: {},
                children: et.wrap($, !0)
            }, {
                type: "text",
                value: `
`
            }]
        }
}
function toHast(et, $) {
    const tt = createState(et, $)
      , nt = tt.one(et, null)
      , rt = footer(tt);
    return rt && nt.children.push({
        type: "text",
        value: `
`
    }, rt),
    Array.isArray(nt) ? {
        type: "root",
        children: nt
    } : nt
}
const remarkRehype = function(et, $) {
    return et && "run"in et ? bridge(et, $) : mutate(et || $)
};
var remarkRehype$1 = remarkRehype;
function bridge(et, $) {
    return (tt,nt,rt)=>{
        et.run(toHast(tt, $), nt, it=>{
            rt(it)
        }
        )
    }
}
function mutate(et) {
    return $=>toHast($, et)
}
class Schema {
    constructor($, tt, nt) {
        this.property = $,
        this.normal = tt,
        nt && (this.space = nt)
    }
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(et, $) {
    const tt = {}
      , nt = {};
    let rt = -1;
    for (; ++rt < et.length; )
        Object.assign(tt, et[rt].property),
        Object.assign(nt, et[rt].normal);
    return new Schema(tt,nt,$)
}
function normalize(et) {
    return et.toLowerCase()
}
class Info {
    constructor($, tt) {
        this.property = $,
        this.attribute = tt
    }
}
Info.prototype.space = null;
Info.prototype.boolean = !1;
Info.prototype.booleanish = !1;
Info.prototype.overloadedBoolean = !1;
Info.prototype.number = !1;
Info.prototype.commaSeparated = !1;
Info.prototype.spaceSeparated = !1;
Info.prototype.commaOrSpaceSeparated = !1;
Info.prototype.mustUseProperty = !1;
Info.prototype.defined = !1;
let powers = 0;
const boolean = increment()
  , booleanish = increment()
  , overloadedBoolean = increment()
  , number = increment()
  , spaceSeparated = increment()
  , commaSeparated = increment()
  , commaOrSpaceSeparated = increment();
function increment() {
    return 2 ** ++powers
}
var types = Object.freeze(Object.defineProperty({
    __proto__: null,
    boolean,
    booleanish,
    overloadedBoolean,
    number,
    spaceSeparated,
    commaSeparated,
    commaOrSpaceSeparated
}, Symbol.toStringTag, {
    value: "Module"
}));
const checks = Object.keys(types);
class DefinedInfo extends Info {
    constructor($, tt, nt, rt) {
        let it = -1;
        if (super($, tt),
        mark(this, "space", rt),
        typeof nt == "number")
            for (; ++it < checks.length; ) {
                const ot = checks[it];
                mark(this, checks[it], (nt & types[ot]) === types[ot])
            }
    }
}
DefinedInfo.prototype.defined = !0;
function mark(et, $, tt) {
    tt && (et[$] = tt)
}
const own$2 = {}.hasOwnProperty;
function create(et) {
    const $ = {}
      , tt = {};
    let nt;
    for (nt in et.properties)
        if (own$2.call(et.properties, nt)) {
            const rt = et.properties[nt]
              , it = new DefinedInfo(nt,et.transform(et.attributes || {}, nt),rt,et.space);
            et.mustUseProperty && et.mustUseProperty.includes(nt) && (it.mustUseProperty = !0),
            $[nt] = it,
            tt[normalize(nt)] = nt,
            tt[normalize(it.attribute)] = nt
        }
    return new Schema($,tt,et.space)
}
const xlink = create({
    space: "xlink",
    transform(et, $) {
        return "xlink:" + $.slice(5).toLowerCase()
    },
    properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
    }
})
  , xml = create({
    space: "xml",
    transform(et, $) {
        return "xml:" + $.slice(3).toLowerCase()
    },
    properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
    }
});
function caseSensitiveTransform(et, $) {
    return $ in et ? et[$] : $
}
function caseInsensitiveTransform(et, $) {
    return caseSensitiveTransform(et, $.toLowerCase())
}
const xmlns = create({
    space: "xmlns",
    attributes: {
        xmlnsxlink: "xmlns:xlink"
    },
    transform: caseInsensitiveTransform,
    properties: {
        xmlns: null,
        xmlnsXLink: null
    }
})
  , aria = create({
    transform(et, $) {
        return $ === "role" ? $ : "aria-" + $.slice(4).toLowerCase()
    },
    properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish,
        ariaAutoComplete: null,
        ariaBusy: booleanish,
        ariaChecked: booleanish,
        ariaColCount: number,
        ariaColIndex: number,
        ariaColSpan: number,
        ariaControls: spaceSeparated,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated,
        ariaDetails: null,
        ariaDisabled: booleanish,
        ariaDropEffect: spaceSeparated,
        ariaErrorMessage: null,
        ariaExpanded: booleanish,
        ariaFlowTo: spaceSeparated,
        ariaGrabbed: booleanish,
        ariaHasPopup: null,
        ariaHidden: booleanish,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated,
        ariaLevel: number,
        ariaLive: null,
        ariaModal: booleanish,
        ariaMultiLine: booleanish,
        ariaMultiSelectable: booleanish,
        ariaOrientation: null,
        ariaOwns: spaceSeparated,
        ariaPlaceholder: null,
        ariaPosInSet: number,
        ariaPressed: booleanish,
        ariaReadOnly: booleanish,
        ariaRelevant: null,
        ariaRequired: booleanish,
        ariaRoleDescription: spaceSeparated,
        ariaRowCount: number,
        ariaRowIndex: number,
        ariaRowSpan: number,
        ariaSelected: booleanish,
        ariaSetSize: number,
        ariaSort: null,
        ariaValueMax: number,
        ariaValueMin: number,
        ariaValueNow: number,
        ariaValueText: null,
        role: null
    }
})
  , html$1 = create({
    space: "html",
    attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
    },
    transform: caseInsensitiveTransform,
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
        abbr: null,
        accept: commaSeparated,
        acceptCharset: spaceSeparated,
        accessKey: spaceSeparated,
        action: null,
        allow: null,
        allowFullScreen: boolean,
        allowPaymentRequest: boolean,
        allowUserMedia: boolean,
        alt: null,
        as: null,
        async: boolean,
        autoCapitalize: null,
        autoComplete: spaceSeparated,
        autoFocus: boolean,
        autoPlay: boolean,
        capture: boolean,
        charSet: null,
        checked: boolean,
        cite: null,
        className: spaceSeparated,
        cols: number,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean,
        controlsList: spaceSeparated,
        coords: number | commaSeparated,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean,
        defer: boolean,
        dir: null,
        dirName: null,
        disabled: boolean,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean,
        formTarget: null,
        headers: spaceSeparated,
        height: number,
        hidden: boolean,
        high: number,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated,
        httpEquiv: spaceSeparated,
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean,
        itemId: null,
        itemProp: spaceSeparated,
        itemRef: spaceSeparated,
        itemScope: boolean,
        itemType: spaceSeparated,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean,
        low: number,
        manifest: null,
        max: null,
        maxLength: number,
        media: null,
        method: null,
        min: null,
        minLength: number,
        multiple: boolean,
        muted: boolean,
        name: null,
        nonce: null,
        noModule: boolean,
        noValidate: boolean,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean,
        optimum: number,
        pattern: null,
        ping: spaceSeparated,
        placeholder: null,
        playsInline: boolean,
        poster: null,
        preload: null,
        readOnly: boolean,
        referrerPolicy: null,
        rel: spaceSeparated,
        required: boolean,
        reversed: boolean,
        rows: number,
        rowSpan: number,
        sandbox: spaceSeparated,
        scope: null,
        scoped: boolean,
        seamless: boolean,
        selected: boolean,
        shape: null,
        size: number,
        sizes: null,
        slot: null,
        span: number,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: number,
        step: null,
        style: null,
        tabIndex: number,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean,
        useMap: null,
        value: booleanish,
        width: number,
        wrap: null,
        align: null,
        aLink: null,
        archive: spaceSeparated,
        axis: null,
        background: null,
        bgColor: null,
        border: number,
        borderColor: null,
        bottomMargin: number,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: boolean,
        declare: boolean,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: number,
        leftMargin: number,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: number,
        marginWidth: number,
        noResize: boolean,
        noHref: boolean,
        noShade: boolean,
        noWrap: boolean,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: number,
        rules: null,
        scheme: null,
        scrolling: booleanish,
        standby: null,
        summary: null,
        text: null,
        topMargin: number,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: number,
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean,
        disableRemotePlayback: boolean,
        prefix: null,
        property: null,
        results: number,
        security: null,
        unselectable: null
    }
})
  , svg$1 = create({
    space: "svg",
    attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
    },
    transform: caseSensitiveTransform,
    properties: {
        about: commaOrSpaceSeparated,
        accentHeight: number,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: number,
        amplitude: number,
        arabicForm: null,
        ascent: number,
        attributeName: null,
        attributeType: null,
        azimuth: number,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: number,
        by: null,
        calcMode: null,
        capHeight: number,
        className: spaceSeparated,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: number,
        diffuseConstant: number,
        direction: null,
        display: null,
        dur: null,
        divisor: number,
        dominantBaseline: null,
        download: boolean,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: number,
        enableBackground: null,
        end: null,
        event: null,
        exponent: number,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: number,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: commaSeparated,
        g2: commaSeparated,
        glyphName: commaSeparated,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: number,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: number,
        horizOriginX: number,
        horizOriginY: number,
        id: null,
        ideographic: number,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: number,
        k: number,
        k1: number,
        k2: number,
        k3: number,
        k4: number,
        kernelMatrix: commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: number,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: number,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: number,
        overlineThickness: number,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: number,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: spaceSeparated,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: number,
        pointsAtY: number,
        pointsAtZ: number,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: commaOrSpaceSeparated,
        rev: commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: commaOrSpaceSeparated,
        requiredFeatures: commaOrSpaceSeparated,
        requiredFonts: commaOrSpaceSeparated,
        requiredFormats: commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: number,
        specularExponent: number,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: number,
        strikethroughThickness: number,
        string: null,
        stroke: null,
        strokeDashArray: commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: number,
        strokeOpacity: number,
        strokeWidth: null,
        style: null,
        surfaceScale: number,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: commaOrSpaceSeparated,
        tabIndex: number,
        tableValues: null,
        target: null,
        targetX: number,
        targetY: number,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: commaOrSpaceSeparated,
        to: null,
        transform: null,
        u1: null,
        u2: null,
        underlinePosition: number,
        underlineThickness: number,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: number,
        values: null,
        vAlphabetic: number,
        vMathematical: number,
        vectorEffect: null,
        vHanging: number,
        vIdeographic: number,
        version: null,
        vertAdvY: number,
        vertOriginX: number,
        vertOriginY: number,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: number,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
    }
})
  , valid = /^data[-\w.:]+$/i
  , dash = /-[a-z]/g
  , cap = /[A-Z]/g;
function find(et, $) {
    const tt = normalize($);
    let nt = $
      , rt = Info;
    if (tt in et.normal)
        return et.property[et.normal[tt]];
    if (tt.length > 4 && tt.slice(0, 4) === "data" && valid.test($)) {
        if ($.charAt(4) === "-") {
            const it = $.slice(5).replace(dash, camelcase);
            nt = "data" + it.charAt(0).toUpperCase() + it.slice(1)
        } else {
            const it = $.slice(4);
            if (!dash.test(it)) {
                let ot = it.replace(cap, kebab);
                ot.charAt(0) !== "-" && (ot = "-" + ot),
                $ = "data" + ot
            }
        }
        rt = DefinedInfo
    }
    return new rt(nt,$)
}
function kebab(et) {
    return "-" + et.toLowerCase()
}
function camelcase(et) {
    return et.charAt(1).toUpperCase()
}
const hastToReact = {
    classId: "classID",
    dataType: "datatype",
    itemId: "itemID",
    strokeDashArray: "strokeDasharray",
    strokeDashOffset: "strokeDashoffset",
    strokeLineCap: "strokeLinecap",
    strokeLineJoin: "strokeLinejoin",
    strokeMiterLimit: "strokeMiterlimit",
    typeOf: "typeof",
    xLinkActuate: "xlinkActuate",
    xLinkArcRole: "xlinkArcrole",
    xLinkHref: "xlinkHref",
    xLinkRole: "xlinkRole",
    xLinkShow: "xlinkShow",
    xLinkTitle: "xlinkTitle",
    xLinkType: "xlinkType",
    xmlnsXLink: "xmlnsXlink"
}
  , html = merge([xml, xlink, xmlns, aria, html$1], "html")
  , svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
function rehypeFilter(et) {
    if (et.allowedElements && et.disallowedElements)
        throw new TypeError("Only one of `allowedElements` and `disallowedElements` should be defined");
    if (et.allowedElements || et.disallowedElements || et.allowElement)
        return $=>{
            visit($, "element", (tt,nt,rt)=>{
                const it = rt;
                let ot;
                if (et.allowedElements ? ot = !et.allowedElements.includes(tt.tagName) : et.disallowedElements && (ot = et.disallowedElements.includes(tt.tagName)),
                !ot && et.allowElement && typeof nt == "number" && (ot = !et.allowElement(tt, nt, it)),
                ot && typeof nt == "number")
                    return et.unwrapDisallowed && tt.children ? it.children.splice(nt, 1, ...tt.children) : it.children.splice(nt, 1),
                    nt
            }
            )
        }
}
var reactIs = {
    exports: {}
}
  , reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
u = Symbol.for("react.module.reference");
function v(et) {
    if (typeof et == "object" && et !== null) {
        var $ = et.$$typeof;
        switch ($) {
        case b:
            switch (et = et.type,
            et) {
            case d:
            case f:
            case e:
            case m:
            case n:
                return et;
            default:
                switch (et = et && et.$$typeof,
                et) {
                case k:
                case h:
                case l:
                case q:
                case p:
                case g:
                    return et;
                default:
                    return $
                }
            }
        case c:
            return $
        }
    }
}
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = g;
reactIs_production_min.Element = b;
reactIs_production_min.ForwardRef = l;
reactIs_production_min.Fragment = d;
reactIs_production_min.Lazy = q;
reactIs_production_min.Memo = p;
reactIs_production_min.Portal = c;
reactIs_production_min.Profiler = f;
reactIs_production_min.StrictMode = e;
reactIs_production_min.Suspense = m;
reactIs_production_min.SuspenseList = n;
reactIs_production_min.isAsyncMode = function() {
    return !1
}
;
reactIs_production_min.isConcurrentMode = function() {
    return !1
}
;
reactIs_production_min.isContextConsumer = function(et) {
    return v(et) === h
}
;
reactIs_production_min.isContextProvider = function(et) {
    return v(et) === g
}
;
reactIs_production_min.isElement = function(et) {
    return typeof et == "object" && et !== null && et.$$typeof === b
}
;
reactIs_production_min.isForwardRef = function(et) {
    return v(et) === l
}
;
reactIs_production_min.isFragment = function(et) {
    return v(et) === d
}
;
reactIs_production_min.isLazy = function(et) {
    return v(et) === q
}
;
reactIs_production_min.isMemo = function(et) {
    return v(et) === p
}
;
reactIs_production_min.isPortal = function(et) {
    return v(et) === c
}
;
reactIs_production_min.isProfiler = function(et) {
    return v(et) === f
}
;
reactIs_production_min.isStrictMode = function(et) {
    return v(et) === e
}
;
reactIs_production_min.isSuspense = function(et) {
    return v(et) === m
}
;
reactIs_production_min.isSuspenseList = function(et) {
    return v(et) === n
}
;
reactIs_production_min.isValidElementType = function(et) {
    return typeof et == "string" || typeof et == "function" || et === d || et === f || et === e || et === m || et === n || et === t || typeof et == "object" && et !== null && (et.$$typeof === q || et.$$typeof === p || et.$$typeof === g || et.$$typeof === h || et.$$typeof === l || et.$$typeof === u || et.getModuleId !== void 0)
}
;
reactIs_production_min.typeOf = v;
reactIs.exports = reactIs_production_min;
var ReactIs = reactIs.exports;
function whitespace(et) {
    const $ = et && typeof et == "object" && et.type === "text" ? et.value || "" : et;
    return typeof $ == "string" && $.replace(/[ \t\n\f\r]/g, "") === ""
}
function stringify$1(et) {
    return et.join(" ").trim()
}
function stringify(et, $) {
    const tt = $ || {};
    return (et[et.length - 1] === "" ? [...et, ""] : et).join((tt.padRight ? " " : "") + "," + (tt.padLeft === !1 ? "" : " ")).trim()
}
var styleToObject = {
    exports: {}
}
  , COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g
  , NEWLINE_REGEX = /\n/g
  , WHITESPACE_REGEX = /^\s*/
  , PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/
  , COLON_REGEX = /^:\s*/
  , VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/
  , SEMICOLON_REGEX = /^[;\s]*/
  , TRIM_REGEX = /^\s+|\s+$/g
  , NEWLINE = `
`
  , FORWARD_SLASH = "/"
  , ASTERISK = "*"
  , EMPTY_STRING = ""
  , TYPE_COMMENT = "comment"
  , TYPE_DECLARATION = "declaration"
  , inlineStyleParser = function(et, $) {
    if (typeof et != "string")
        throw new TypeError("First argument must be a string");
    if (!et)
        return [];
    $ = $ || {};
    var tt = 1
      , nt = 1;
    function rt(vt) {
        var yt = vt.match(NEWLINE_REGEX);
        yt && (tt += yt.length);
        var wt = vt.lastIndexOf(NEWLINE);
        nt = ~wt ? vt.length - wt : nt + vt.length
    }
    function it() {
        var vt = {
            line: tt,
            column: nt
        };
        return function(yt) {
            return yt.position = new ot(vt),
            ut(),
            yt
        }
    }
    function ot(vt) {
        this.start = vt,
        this.end = {
            line: tt,
            column: nt
        },
        this.source = $.source
    }
    ot.prototype.content = et;
    function st(vt) {
        var yt = new Error($.source + ":" + tt + ":" + nt + ": " + vt);
        if (yt.reason = vt,
        yt.filename = $.source,
        yt.line = tt,
        yt.column = nt,
        yt.source = et,
        !$.silent)
            throw yt
    }
    function lt(vt) {
        var yt = vt.exec(et);
        if (!!yt) {
            var wt = yt[0];
            return rt(wt),
            et = et.slice(wt.length),
            yt
        }
    }
    function ut() {
        lt(WHITESPACE_REGEX)
    }
    function ct(vt) {
        var yt;
        for (vt = vt || []; yt = ht(); )
            yt !== !1 && vt.push(yt);
        return vt
    }
    function ht() {
        var vt = it();
        if (!(FORWARD_SLASH != et.charAt(0) || ASTERISK != et.charAt(1))) {
            for (var yt = 2; EMPTY_STRING != et.charAt(yt) && (ASTERISK != et.charAt(yt) || FORWARD_SLASH != et.charAt(yt + 1)); )
                ++yt;
            if (yt += 2,
            EMPTY_STRING === et.charAt(yt - 1))
                return st("End of comment missing");
            var wt = et.slice(2, yt - 2);
            return nt += 2,
            rt(wt),
            et = et.slice(yt),
            nt += 2,
            vt({
                type: TYPE_COMMENT,
                comment: wt
            })
        }
    }
    function ft() {
        var vt = it()
          , yt = lt(PROPERTY_REGEX);
        if (!!yt) {
            if (ht(),
            !lt(COLON_REGEX))
                return st("property missing ':'");
            var wt = lt(VALUE_REGEX)
              , mt = vt({
                type: TYPE_DECLARATION,
                property: trim(yt[0].replace(COMMENT_REGEX, EMPTY_STRING)),
                value: wt ? trim(wt[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
            });
            return lt(SEMICOLON_REGEX),
            mt
        }
    }
    function gt() {
        var vt = [];
        ct(vt);
        for (var yt; yt = ft(); )
            yt !== !1 && (vt.push(yt),
            ct(vt));
        return vt
    }
    return ut(),
    gt()
};
function trim(et) {
    return et ? et.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING
}
var parse = inlineStyleParser;
function StyleToObject(et, $) {
    var tt = null;
    if (!et || typeof et != "string")
        return tt;
    for (var nt, rt = parse(et), it = typeof $ == "function", ot, st, lt = 0, ut = rt.length; lt < ut; lt++)
        nt = rt[lt],
        ot = nt.property,
        st = nt.value,
        it ? $(ot, st, nt) : st && (tt || (tt = {}),
        tt[ot] = st);
    return tt
}
styleToObject.exports = StyleToObject;
styleToObject.exports.default = StyleToObject;
var StyleToObject$1 = styleToObject.exports;
const protocols = ["http", "https", "mailto", "tel"];
function uriTransformer(et) {
    const $ = (et || "").trim()
      , tt = $.charAt(0);
    if (tt === "#" || tt === "/")
        return $;
    const nt = $.indexOf(":");
    if (nt === -1)
        return $;
    let rt = -1;
    for (; ++rt < protocols.length; ) {
        const it = protocols[rt];
        if (nt === it.length && $.slice(0, it.length).toLowerCase() === it)
            return $
    }
    return rt = $.indexOf("?"),
    rt !== -1 && nt > rt || (rt = $.indexOf("#"),
    rt !== -1 && nt > rt) ? $ : "javascript:void(0)"
}
const own$1 = {}.hasOwnProperty
  , tableElements = new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function childrenToReact(et, $) {
    const tt = [];
    let nt = -1, rt;
    for (; ++nt < $.children.length; )
        rt = $.children[nt],
        rt.type === "element" ? tt.push(toReact(et, rt, nt, $)) : rt.type === "text" ? ($.type !== "element" || !tableElements.has($.tagName) || !whitespace(rt)) && tt.push(rt.value) : rt.type === "raw" && !et.options.skipHtml && tt.push(rt.value);
    return tt
}
function toReact(et, $, tt, nt) {
    const rt = et.options
      , it = rt.transformLinkUri === void 0 ? uriTransformer : rt.transformLinkUri
      , ot = et.schema
      , st = $.tagName
      , lt = {};
    let ut = ot, ct;
    if (ot.space === "html" && st === "svg" && (ut = svg,
    et.schema = ut),
    $.properties)
        for (ct in $.properties)
            own$1.call($.properties, ct) && addProperty(lt, ct, $.properties[ct], et);
    (st === "ol" || st === "ul") && et.listDepth++;
    const ht = childrenToReact(et, $);
    (st === "ol" || st === "ul") && et.listDepth--,
    et.schema = ot;
    const ft = $.position || {
        start: {
            line: null,
            column: null,
            offset: null
        },
        end: {
            line: null,
            column: null,
            offset: null
        }
    }
      , gt = rt.components && own$1.call(rt.components, st) ? rt.components[st] : st
      , vt = typeof gt == "string" || gt === React.Fragment;
    if (!ReactIs.isValidElementType(gt))
        throw new TypeError(`Component for name \`${st}\` not defined or is not renderable`);
    if (lt.key = [st, ft.start.line, ft.start.column, tt].join("-"),
    st === "a" && rt.linkTarget && (lt.target = typeof rt.linkTarget == "function" ? rt.linkTarget(String(lt.href || ""), $.children, typeof lt.title == "string" ? lt.title : null) : rt.linkTarget),
    st === "a" && it && (lt.href = it(String(lt.href || ""), $.children, typeof lt.title == "string" ? lt.title : null)),
    !vt && st === "code" && nt.type === "element" && nt.tagName !== "pre" && (lt.inline = !0),
    !vt && (st === "h1" || st === "h2" || st === "h3" || st === "h4" || st === "h5" || st === "h6") && (lt.level = Number.parseInt(st.charAt(1), 10)),
    st === "img" && rt.transformImageUri && (lt.src = rt.transformImageUri(String(lt.src || ""), String(lt.alt || ""), typeof lt.title == "string" ? lt.title : null)),
    !vt && st === "li" && nt.type === "element") {
        const yt = getInputElement($);
        lt.checked = yt && yt.properties ? Boolean(yt.properties.checked) : null,
        lt.index = getElementsBeforeCount(nt, $),
        lt.ordered = nt.tagName === "ol"
    }
    return !vt && (st === "ol" || st === "ul") && (lt.ordered = st === "ol",
    lt.depth = et.listDepth),
    (st === "td" || st === "th") && (lt.align && (lt.style || (lt.style = {}),
    lt.style.textAlign = lt.align,
    delete lt.align),
    vt || (lt.isHeader = st === "th")),
    !vt && st === "tr" && nt.type === "element" && (lt.isHeader = Boolean(nt.tagName === "thead")),
    rt.sourcePos && (lt["data-sourcepos"] = flattenPosition(ft)),
    !vt && rt.rawSourcePos && (lt.sourcePosition = $.position),
    !vt && rt.includeElementIndex && (lt.index = getElementsBeforeCount(nt, $),
    lt.siblingCount = getElementsBeforeCount(nt)),
    vt || (lt.node = $),
    ht.length > 0 ? React.createElement(gt, lt, ht) : React.createElement(gt, lt)
}
function getInputElement(et) {
    let $ = -1;
    for (; ++$ < et.children.length; ) {
        const tt = et.children[$];
        if (tt.type === "element" && tt.tagName === "input")
            return tt
    }
    return null
}
function getElementsBeforeCount(et, $) {
    let tt = -1
      , nt = 0;
    for (; ++tt < et.children.length && et.children[tt] !== $; )
        et.children[tt].type === "element" && nt++;
    return nt
}
function addProperty(et, $, tt, nt) {
    const rt = find(nt.schema, $);
    let it = tt;
    it == null || it !== it || (Array.isArray(it) && (it = rt.commaSeparated ? stringify(it) : stringify$1(it)),
    rt.property === "style" && typeof it == "string" && (it = parseStyle(it)),
    rt.space && rt.property ? et[own$1.call(hastToReact, rt.property) ? hastToReact[rt.property] : rt.property] = it : rt.attribute && (et[rt.attribute] = it))
}
function parseStyle(et) {
    const $ = {};
    try {
        StyleToObject$1(et, tt)
    } catch {}
    return $;
    function tt(nt, rt) {
        const it = nt.slice(0, 4) === "-ms-" ? `ms-${nt.slice(4)}` : nt;
        $[it.replace(/-([a-z])/g, styleReplacer)] = rt
    }
}
function styleReplacer(et, $) {
    return $.toUpperCase()
}
function flattenPosition(et) {
    return [et.start.line, ":", et.start.column, "-", et.end.line, ":", et.end.column].map(String).join("")
}
const own = {}.hasOwnProperty
  , changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md"
  , deprecated = {
    plugins: {
        to: "remarkPlugins",
        id: "change-plugins-to-remarkplugins"
    },
    renderers: {
        to: "components",
        id: "change-renderers-to-components"
    },
    astPlugins: {
        id: "remove-buggy-html-in-markdown-parser"
    },
    allowDangerousHtml: {
        id: "remove-buggy-html-in-markdown-parser"
    },
    escapeHtml: {
        id: "remove-buggy-html-in-markdown-parser"
    },
    source: {
        to: "children",
        id: "change-source-to-children"
    },
    allowNode: {
        to: "allowElement",
        id: "replace-allownode-allowedtypes-and-disallowedtypes"
    },
    allowedTypes: {
        to: "allowedElements",
        id: "replace-allownode-allowedtypes-and-disallowedtypes"
    },
    disallowedTypes: {
        to: "disallowedElements",
        id: "replace-allownode-allowedtypes-and-disallowedtypes"
    },
    includeNodeIndex: {
        to: "includeElementIndex",
        id: "change-includenodeindex-to-includeelementindex"
    }
};
function ReactMarkdown(et) {
    for (const it in deprecated)
        if (own.call(deprecated, it) && own.call(et, it)) {
            const ot = deprecated[it];
            console.warn(`[react-markdown] Warning: please ${ot.to ? `use \`${ot.to}\` instead of` : "remove"} \`${it}\` (see <${changelog}#${ot.id}> for more info)`),
            delete deprecated[it]
        }
    const $ = unified().use(remarkParse).use(et.remarkPlugins || []).use(remarkRehype$1, kn(wn({}, et.remarkRehypeOptions), {
        allowDangerousHtml: !0
    })).use(et.rehypePlugins || []).use(rehypeFilter, et)
      , tt = new VFile;
    typeof et.children == "string" ? tt.value = et.children : et.children !== void 0 && et.children !== null && console.warn(`[react-markdown] Warning: please pass a string as \`children\` (not: \`${et.children}\`)`);
    const nt = $.runSync($.parse(tt), tt);
    if (nt.type !== "root")
        throw new TypeError("Expected a `root` node");
    let rt = React.createElement(React.Fragment, {}, childrenToReact({
        options: et,
        schema: html,
        listDepth: 0
    }, nt));
    return et.className && (rt = React.createElement("div", {
        className: et.className
    }, rt)),
    rt
}
ReactMarkdown.propTypes = {
    children: PropTypes.string,
    className: PropTypes.string,
    allowElement: PropTypes.func,
    allowedElements: PropTypes.arrayOf(PropTypes.string),
    disallowedElements: PropTypes.arrayOf(PropTypes.string),
    unwrapDisallowed: PropTypes.bool,
    remarkPlugins: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.object, PropTypes.func, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.bool, PropTypes.string, PropTypes.object, PropTypes.func, PropTypes.arrayOf(PropTypes.any)]))])),
    rehypePlugins: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.object, PropTypes.func, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.bool, PropTypes.string, PropTypes.object, PropTypes.func, PropTypes.arrayOf(PropTypes.any)]))])),
    sourcePos: PropTypes.bool,
    rawSourcePos: PropTypes.bool,
    skipHtml: PropTypes.bool,
    includeElementIndex: PropTypes.bool,
    transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
    linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
    transformImageUri: PropTypes.func,
    components: PropTypes.object
};
function Like(et) {
    const nt = et
      , {fill: $="black"} = nt
      , tt = nr(nt, ["fill"]);
    return jsx("svg", kn(wn({
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, tt), {
        children: jsx("path", {
            d: "M2.13302 3.08991C0.621027 4.54441 0.621023 6.90264 2.13302 8.35715L2.52394 8.73321L2.52185 8.73522L7.99727 14.0025L7.99935 14.0005L8.00136 14.0024L13.4768 8.73514L13.4748 8.73321L13.8656 8.35723C15.3776 6.90272 15.3776 4.5445 13.8656 3.08999C12.3536 1.63548 9.90219 1.63548 8.39019 3.08998L7.99935 3.46597L7.60843 3.0899C6.09644 1.6354 3.64501 1.6354 2.13302 3.08991Z",
            fill: $,
            stroke: "black"
        })
    }))
}
const BUTTON_TYPE = {
    DEFAULT: "default",
    EXT_LINK: "extLink",
    LINK: "link",
    LIKE: "like"
}
  , BUTTON_ICON = {
    [BUTTON_TYPE.DEFAULT]: [Dot, Dot],
    [BUTTON_TYPE.EXT_LINK]: [Dot, ArrowTopRight16],
    [BUTTON_TYPE.LINK]: [ArrowRight16, ArrowRight16],
    [BUTTON_TYPE.LIKE]: [Like, Like]
};
function IconWrapper(et) {
    const {Default: $, Hover: tt} = et;
    return jsxs("div", {
        className: "button__icon-wrapper",
        children: [jsx($, {
            className: "button__icon"
        }), jsx(tt, {
            className: clsx("button__icon", "button__icon--hover")
        })]
    })
}
const SPRING_CONFIG = {
    mass: 1,
    tension: 320,
    friction: 40
};
function Button(et) {
    const yt = et
      , {children: $, type: tt=BUTTON_TYPE.DEFAULT, flipped: nt, inverse: rt} = yt
      , it = nr(yt, ["children", "type", "flipped", "inverse"])
      , ot = tt === BUTTON_TYPE.LINK || tt === BUTTON_TYPE.EXT_LINK
      , st = BUTTON_ICON[tt][0]
      , lt = BUTTON_ICON[tt][1]
      , ut = ot ? "a" : "button"
      , [ct,ht] = react.exports.useState(!1)
      , ft = react.exports.useCallback(wt=>{
        const mt = wt.type === "mouseenter";
        ht(mt)
    }
    , [])
      , gt = useSpring({
        showOpacity: ct ? 1 : 0,
        hideOpacity: ct ? 0 : 1,
        t: ct ? 1 : 0,
        config: SPRING_CONFIG
    })
      , vt = useSpring({
        y: ct ? "0" : "100%",
        delay: ct ? 200 : 0,
        config: {
            duration: 240,
            easing: easings.easeOutQuart
        }
    });
    return jsxs(ut, kn(wn({}, it), {
        className: clsx("button", nt && "button--flipped", rt && "button--inverse", ct && "button--hovering"),
        onMouseEnter: ft,
        onMouseLeave: ft,
        children: [!nt && jsx(IconWrapper, {
            Default: st,
            Hover: lt
        }), jsxs("div", {
            className: "button__text-wrapper",
            children: [jsx(animated.div, {
                className: "button__text",
                children: $
            }), jsx(animated.div, {
                style: {
                    y: vt.y
                },
                className: "button__hover-text",
                children: $
            })]
        }), nt && jsx(IconWrapper, {
            Default: st,
            Hover: lt
        }), jsx("div", {
            className: "button__mask__container",
            children: jsx(animated.div, {
                style: {
                    scale: gt.t.to(wt=>wt * 40)
                },
                className: clsx("button__mask")
            })
        })]
    }))
}
const Card = et=>{
    const {data: $} = et
      , [tt,nt] = useLocation()
      , {nId: rt, slug: it, projectName: ot, projectLink: st, releaseDate: lt, tags: ut, darkModeTop: ct, darkModeBottom: ht, smallImg: ft} = $ || {}
      , gt = react.exports.useRef()
      , vt = react.exports.useRef(0)
      , [yt,wt] = react.exports.useState(!1);
    return useAnimationFrame(mt=>{
        !gt.current || (vt.current = math.saturate(vt.current + mt * (yt ? 1 : -1)),
        gt.current.style.transform = `translate(-50%, -50%) scale(${1 + .075 * ease.quintInOut(vt.current)})`)
    }
    ),
    $ ? jsxs("button", {
        className: "card card--fixed",
        onPointerEnter: ()=>{
            updateLucyEmote("random"),
            wt(!0),
            useGlobalStore.setState(mt=>{
                mt.isCursorHovering = !0
            }
            )
        }
        ,
        onPointerLeave: ()=>{
            updateLucyEmote(),
            wt(!1),
            useGlobalStore.setState(mt=>{
                mt.isCursorHovering = !1
            }
            )
        }
        ,
        onClick: mt=>{
            mt.preventDefault(),
            nt(`/exp/${it}${window.location.search}`)
        }
        ,
        children: [jsx("div", {
            className: "card__img",
            children: jsx("img", {
                ref: gt,
                src: ft
            })
        }), jsxs("div", {
            className: "card__text",
            children: [jsxs("div", {
                className: clsx("card__top", ct && "card--dark"),
                children: [jsx("div", {
                    children: jsx(ExpInfo, {
                        id: rt,
                        releaseDate: lt
                    })
                }), jsx("a", {
                    href: st,
                    target: "_blank",
                    className: "card__ext-link",
                    onClick: mt=>mt.stopPropagation(),
                    style: {
                        pointerEvents: "all"
                    },
                    children: jsx(CardButton, {
                        isHovering: yt,
                        darkMode: ct
                    })
                })]
            }), jsxs("div", {
                className: clsx("card__bottom", ht && "card--dark"),
                children: [jsx("div", {
                    className: "card__title",
                    style: {
                        lineHeight: "120%"
                    },
                    children: ot
                }), jsx(Tags, {
                    tags: ut
                })]
            })]
        })]
    }) : null
}
;
function ExploreMore(et) {
    const {id: $} = et
      , tt = useDataStore(it=>it.hasLoaded, shallow)
      , nt = useDataStore(it=>it.experimentsFlatList, shallow)
      , rt = react.exports.useMemo(()=>{
        const it = nt.filter(lt=>lt.id !== $)
          , ot = []
          , st = [];
        for (; ot.length < 3; ) {
            const lt = Math.floor(Math.random() * it.length);
            ot.indexOf(lt) === -1 && (ot.push(lt),
            st.push(it[lt]))
        }
        return st
    }
    , [$, tt]);
    return jsxs("div", {
        className: "explore-more",
        children: [jsxs("div", {
            className: "explore-more__title-wrapper",
            children: [jsx("div", {
                className: "explore-more__title",
                children: "Explore more"
            }), jsx("div", {
                className: "explore-more__subtitle",
                children: "(discover what you've been missing)"
            })]
        }), jsx("div", {
            className: "explore-more__cards",
            children: rt.map(it=>jsx(Card, {
                data: it
            }, it.id))
        })]
    })
}
const methodName = "createTweet";
function TwitterTweetEmbed(et) {
    const $ = React.useRef(null)
      , tt = React.useRef(null)
      , nt = React.useRef(null)
      , rt = React.useRef(!1)
      , [it,ot] = React.useState(!0)
      , st = useGlobalStore(lt=>lt.width, shallow);
    return React.useEffect(()=>{
        if (nt.current && tt.current) {
            const ct = nt.current.getBoundingClientRect();
            console.log(ct),
            tt.current.style.width = `${ct.width}px`,
            tt.current.style.height = `${ct.height}px`
        }
        if (rt.current)
            return;
        let lt = !0
          , ut = {};
        if (st < 768 && (ut = {
            cards: "hidden",
            conversation: "none"
        }),
        !window.twttr) {
            console.error("Failure to load window.twttr, aborting load");
            return
        }
        if (lt) {
            if (!window.twttr.widgets[methodName]) {
                console.error(`Method ${methodName} is not present anymore in twttr.widget api`);
                return
            }
            rt.current = !0,
            window.twttr.widgets[methodName](et.tweetId, $ == null ? void 0 : $.current, ut).then(ct=>{
                if (ot(!1),
                et.onLoad && et.onLoad(ct),
                nt.current = $.current.querySelector("iframe"),
                nt.current && tt.current) {
                    const ht = nt.current.getBoundingClientRect();
                    tt.current.style.width = `${ht.width}px`,
                    tt.current.style.height = `${ht.height}px`
                }
            }
            )
        }
        return ()=>{
            lt = !1
        }
    }
    , [st]),
    jsxs(Fragment, {
        children: [it && jsx("div", {
            style: {},
            children: "Loading Twitter widget..."
        }), jsx("div", {
            ref: $,
            style: {
                position: "relative"
            },
            children: !browser$1.isDesktop && jsx("a", {
                ref: tt,
                href: `https://twitter.com/lusionltd/status/${et.tweetId}`,
                target: "_blank",
                style: {
                    position: "absolute",
                    top: 0,
                    left: 0
                }
            })
        })]
    })
}
function objectToGetParams(et) {
    var $ = Object.entries(et).filter(function(tt) {
        var nt = tt[1];
        return nt != null
    }).map(function(tt) {
        var nt = tt[0]
          , rt = tt[1];
        return encodeURIComponent(nt) + "=" + encodeURIComponent(String(rt))
    });
    return $.length > 0 ? "?" + $.join("&") : ""
}
var classnames = {
    exports: {}
};
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(et) {
    (function() {
        var $ = {}.hasOwnProperty;
        function tt() {
            for (var nt = [], rt = 0; rt < arguments.length; rt++) {
                var it = arguments[rt];
                if (!!it) {
                    var ot = typeof it;
                    if (ot === "string" || ot === "number")
                        nt.push(it);
                    else if (Array.isArray(it)) {
                        if (it.length) {
                            var st = tt.apply(null, it);
                            st && nt.push(st)
                        }
                    } else if (ot === "object")
                        if (it.toString === Object.prototype.toString)
                            for (var lt in it)
                                $.call(it, lt) && it[lt] && nt.push(lt);
                        else
                            nt.push(it.toString())
                }
            }
            return nt.join(" ")
        }
        et.exports ? (tt.default = tt,
        et.exports = tt) : window.classNames = tt
    }
    )()
}
)(classnames);
var cx = classnames.exports
  , __extends$2 = globalThis && globalThis.__extends || function() {
    var et = function($, tt) {
        return et = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(nt, rt) {
            nt.__proto__ = rt
        }
        || function(nt, rt) {
            for (var it in rt)
                Object.prototype.hasOwnProperty.call(rt, it) && (nt[it] = rt[it])
        }
        ,
        et($, tt)
    };
    return function($, tt) {
        et($, tt);
        function nt() {
            this.constructor = $
        }
        $.prototype = tt === null ? Object.create(tt) : (nt.prototype = tt.prototype,
        new nt)
    }
}()
  , __assign$2 = globalThis && globalThis.__assign || function() {
    return __assign$2 = Object.assign || function(et) {
        for (var $, tt = 1, nt = arguments.length; tt < nt; tt++) {
            $ = arguments[tt];
            for (var rt in $)
                Object.prototype.hasOwnProperty.call($, rt) && (et[rt] = $[rt])
        }
        return et
    }
    ,
    __assign$2.apply(this, arguments)
}
  , __awaiter = globalThis && globalThis.__awaiter || function(et, $, tt, nt) {
    function rt(it) {
        return it instanceof tt ? it : new tt(function(ot) {
            ot(it)
        }
        )
    }
    return new (tt || (tt = Promise))(function(it, ot) {
        function st(ct) {
            try {
                ut(nt.next(ct))
            } catch (ht) {
                ot(ht)
            }
        }
        function lt(ct) {
            try {
                ut(nt.throw(ct))
            } catch (ht) {
                ot(ht)
            }
        }
        function ut(ct) {
            ct.done ? it(ct.value) : rt(ct.value).then(st, lt)
        }
        ut((nt = nt.apply(et, $ || [])).next())
    }
    )
}
  , __generator = globalThis && globalThis.__generator || function(et, $) {
    var tt = {
        label: 0,
        sent: function() {
            if (it[0] & 1)
                throw it[1];
            return it[1]
        },
        trys: [],
        ops: []
    }, nt, rt, it, ot;
    return ot = {
        next: st(0),
        throw: st(1),
        return: st(2)
    },
    typeof Symbol == "function" && (ot[Symbol.iterator] = function() {
        return this
    }
    ),
    ot;
    function st(ut) {
        return function(ct) {
            return lt([ut, ct])
        }
    }
    function lt(ut) {
        if (nt)
            throw new TypeError("Generator is already executing.");
        for (; tt; )
            try {
                if (nt = 1,
                rt && (it = ut[0] & 2 ? rt.return : ut[0] ? rt.throw || ((it = rt.return) && it.call(rt),
                0) : rt.next) && !(it = it.call(rt, ut[1])).done)
                    return it;
                switch (rt = 0,
                it && (ut = [ut[0] & 2, it.value]),
                ut[0]) {
                case 0:
                case 1:
                    it = ut;
                    break;
                case 4:
                    return tt.label++,
                    {
                        value: ut[1],
                        done: !1
                    };
                case 5:
                    tt.label++,
                    rt = ut[1],
                    ut = [0];
                    continue;
                case 7:
                    ut = tt.ops.pop(),
                    tt.trys.pop();
                    continue;
                default:
                    if (it = tt.trys,
                    !(it = it.length > 0 && it[it.length - 1]) && (ut[0] === 6 || ut[0] === 2)) {
                        tt = 0;
                        continue
                    }
                    if (ut[0] === 3 && (!it || ut[1] > it[0] && ut[1] < it[3])) {
                        tt.label = ut[1];
                        break
                    }
                    if (ut[0] === 6 && tt.label < it[1]) {
                        tt.label = it[1],
                        it = ut;
                        break
                    }
                    if (it && tt.label < it[2]) {
                        tt.label = it[2],
                        tt.ops.push(ut);
                        break
                    }
                    it[2] && tt.ops.pop(),
                    tt.trys.pop();
                    continue
                }
                ut = $.call(et, tt)
            } catch (ct) {
                ut = [6, ct],
                rt = 0
            } finally {
                nt = it = 0
            }
        if (ut[0] & 5)
            throw ut[1];
        return {
            value: ut[0] ? ut[1] : void 0,
            done: !0
        }
    }
}
  , __rest$1 = globalThis && globalThis.__rest || function(et, $) {
    var tt = {};
    for (var nt in et)
        Object.prototype.hasOwnProperty.call(et, nt) && $.indexOf(nt) < 0 && (tt[nt] = et[nt]);
    if (et != null && typeof Object.getOwnPropertySymbols == "function")
        for (var rt = 0, nt = Object.getOwnPropertySymbols(et); rt < nt.length; rt++)
            $.indexOf(nt[rt]) < 0 && Object.prototype.propertyIsEnumerable.call(et, nt[rt]) && (tt[nt[rt]] = et[nt[rt]]);
    return tt
}
  , isPromise = function(et) {
    return !!et && (typeof et == "object" || typeof et == "function") && typeof et.then == "function"
}
  , getBoxPositionOnWindowCenter = function(et, $) {
    return {
        left: window.outerWidth / 2 + (window.screenX || window.screenLeft || 0) - et / 2,
        top: window.outerHeight / 2 + (window.screenY || window.screenTop || 0) - $ / 2
    }
}
  , getBoxPositionOnScreenCenter = function(et, $) {
    return {
        top: (window.screen.height - $) / 2,
        left: (window.screen.width - et) / 2
    }
};
function windowOpen(et, $, tt) {
    var nt = $.height
      , rt = $.width
      , it = __rest$1($, ["height", "width"])
      , ot = __assign$2({
        height: nt,
        width: rt,
        location: "no",
        toolbar: "no",
        status: "no",
        directories: "no",
        menubar: "no",
        scrollbars: "yes",
        resizable: "no",
        centerscreen: "yes",
        chrome: "yes"
    }, it)
      , st = window.open(et, "", Object.keys(ot).map(function(ut) {
        return ut + "=" + ot[ut]
    }).join(", "));
    if (tt)
        var lt = window.setInterval(function() {
            try {
                (st === null || st.closed) && (window.clearInterval(lt),
                tt(st))
            } catch (ut) {
                console.error(ut)
            }
        }, 1e3);
    return st
}
var ShareButton = function(et) {
    __extends$2($, et);
    function $() {
        var tt = et !== null && et.apply(this, arguments) || this;
        return tt.openShareDialog = function(nt) {
            var rt = tt.props
              , it = rt.onShareWindowClose
              , ot = rt.windowHeight
              , st = ot === void 0 ? 400 : ot
              , lt = rt.windowPosition
              , ut = lt === void 0 ? "windowCenter" : lt
              , ct = rt.windowWidth
              , ht = ct === void 0 ? 550 : ct
              , ft = __assign$2({
                height: st,
                width: ht
            }, ut === "windowCenter" ? getBoxPositionOnWindowCenter(ht, st) : getBoxPositionOnScreenCenter(ht, st));
            windowOpen(nt, ft, it)
        }
        ,
        tt.handleClick = function(nt) {
            return __awaiter(tt, void 0, void 0, function() {
                var rt, it, ot, st, lt, ut, ct, ht, ft, gt;
                return __generator(this, function(vt) {
                    switch (vt.label) {
                    case 0:
                        return rt = this.props,
                        it = rt.beforeOnClick,
                        ot = rt.disabled,
                        st = rt.networkLink,
                        lt = rt.onClick,
                        ut = rt.url,
                        ct = rt.openShareDialogOnClick,
                        ht = rt.opts,
                        ft = st(ut, ht),
                        ot ? [2] : (nt.preventDefault(),
                        it ? (gt = it(),
                        isPromise(gt) ? [4, gt] : [3, 2]) : [3, 2]);
                    case 1:
                        vt.sent(),
                        vt.label = 2;
                    case 2:
                        return ct && this.openShareDialog(ft),
                        lt && lt(nt, ft),
                        [2]
                    }
                })
            })
        }
        ,
        tt
    }
    return $.prototype.render = function() {
        var tt = this.props;
        tt.beforeOnClick;
        var nt = tt.children
          , rt = tt.className
          , it = tt.disabled
          , ot = tt.disabledStyle
          , st = tt.forwardedRef;
        tt.networkLink;
        var lt = tt.networkName;
        tt.onShareWindowClose,
        tt.openShareDialogOnClick,
        tt.opts;
        var ut = tt.resetButtonStyle
          , ct = tt.style;
        tt.url,
        tt.windowHeight,
        tt.windowPosition,
        tt.windowWidth;
        var ht = __rest$1(tt, ["beforeOnClick", "children", "className", "disabled", "disabledStyle", "forwardedRef", "networkLink", "networkName", "onShareWindowClose", "openShareDialogOnClick", "opts", "resetButtonStyle", "style", "url", "windowHeight", "windowPosition", "windowWidth"])
          , ft = cx("react-share__ShareButton", {
            "react-share__ShareButton--disabled": !!it,
            disabled: !!it
        }, rt)
          , gt = __assign$2(__assign$2(ut ? {
            backgroundColor: "transparent",
            border: "none",
            padding: 0,
            font: "inherit",
            color: "inherit",
            cursor: "pointer"
        } : {}, ct), it && ot);
        return jsx("button", kn(wn({}, __assign$2({}, ht, {
            "aria-label": ht["aria-label"] || lt,
            className: ft,
            onClick: this.handleClick,
            ref: st,
            style: gt
        })), {
            children: nt
        }))
    }
    ,
    $.defaultProps = {
        disabledStyle: {
            opacity: .6
        },
        openShareDialogOnClick: !0,
        resetButtonStyle: !0
    },
    $
}(react.exports.Component)
  , ShareButton$1 = ShareButton
  , __assign$1 = globalThis && globalThis.__assign || function() {
    return __assign$1 = Object.assign || function(et) {
        for (var $, tt = 1, nt = arguments.length; tt < nt; tt++) {
            $ = arguments[tt];
            for (var rt in $)
                Object.prototype.hasOwnProperty.call($, rt) && (et[rt] = $[rt])
        }
        return et
    }
    ,
    __assign$1.apply(this, arguments)
}
;
function createShareButton(et, $, tt, nt) {
    function rt(it, ot) {
        var st = tt(it)
          , lt = __assign$1({}, it)
          , ut = Object.keys(st);
        return ut.forEach(function(ct) {
            delete lt[ct]
        }),
        jsx(ShareButton$1, wn({}, __assign$1({}, nt, lt, {
            forwardedRef: ot,
            networkName: et,
            networkLink: $,
            opts: tt(it)
        })))
    }
    return rt.displayName = "ShareButton-" + et,
    react.exports.forwardRef(rt)
}
var __extends$1 = globalThis && globalThis.__extends || function() {
    var et = function($, tt) {
        return et = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(nt, rt) {
            nt.__proto__ = rt
        }
        || function(nt, rt) {
            for (var it in rt)
                Object.prototype.hasOwnProperty.call(rt, it) && (nt[it] = rt[it])
        }
        ,
        et($, tt)
    };
    return function($, tt) {
        et($, tt);
        function nt() {
            this.constructor = $
        }
        $.prototype = tt === null ? Object.create(tt) : (nt.prototype = tt.prototype,
        new nt)
    }
}()
  , AssertionError = function(et) {
    __extends$1($, et);
    function $(tt) {
        var nt = et.call(this, tt) || this;
        return nt.name = "AssertionError",
        nt
    }
    return $
}(Error);
function assert(et, $) {
    if (!et)
        throw new AssertionError($)
}
function facebookLink(et, $) {
    var tt = $.quote
      , nt = $.hashtag;
    return assert(et, "facebook.url"),
    "https://www.facebook.com/sharer/sharer.php" + objectToGetParams({
        u: et,
        quote: tt,
        hashtag: nt
    })
}
var FacebookShareButton = createShareButton("facebook", facebookLink, function(et) {
    return {
        quote: et.quote,
        hashtag: et.hashtag
    }
}, {
    windowWidth: 550,
    windowHeight: 400
})
  , FacebookShareButton$1 = FacebookShareButton
  , __extends = globalThis && globalThis.__extends || function() {
    var et = function($, tt) {
        return et = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(nt, rt) {
            nt.__proto__ = rt
        }
        || function(nt, rt) {
            for (var it in rt)
                Object.prototype.hasOwnProperty.call(rt, it) && (nt[it] = rt[it])
        }
        ,
        et($, tt)
    };
    return function($, tt) {
        et($, tt);
        function nt() {
            this.constructor = $
        }
        $.prototype = tt === null ? Object.create(tt) : (nt.prototype = tt.prototype,
        new nt)
    }
}()
  , __assign = globalThis && globalThis.__assign || function() {
    return __assign = Object.assign || function(et) {
        for (var $, tt = 1, nt = arguments.length; tt < nt; tt++) {
            $ = arguments[tt];
            for (var rt in $)
                Object.prototype.hasOwnProperty.call($, rt) && (et[rt] = $[rt])
        }
        return et
    }
    ,
    __assign.apply(this, arguments)
}
  , __rest = globalThis && globalThis.__rest || function(et, $) {
    var tt = {};
    for (var nt in et)
        Object.prototype.hasOwnProperty.call(et, nt) && $.indexOf(nt) < 0 && (tt[nt] = et[nt]);
    if (et != null && typeof Object.getOwnPropertySymbols == "function")
        for (var rt = 0, nt = Object.getOwnPropertySymbols(et); rt < nt.length; rt++)
            $.indexOf(nt[rt]) < 0 && Object.prototype.propertyIsEnumerable.call(et, nt[rt]) && (tt[nt[rt]] = et[nt[rt]]);
    return tt
}
  , defaultChildren = function(et) {
    return et
}
  , SocialMediaShareCount = function(et) {
    __extends($, et);
    function $(tt) {
        var nt = et.call(this, tt) || this;
        return nt._isMounted = !1,
        nt.state = {
            count: 0,
            isLoading: !1
        },
        nt
    }
    return $.prototype.componentDidMount = function() {
        this._isMounted = !0,
        this.updateCount(this.props.url)
    }
    ,
    $.prototype.componentDidUpdate = function(tt) {
        this.props.url !== tt.url && this.updateCount(this.props.url)
    }
    ,
    $.prototype.componentWillUnmount = function() {
        this._isMounted = !1
    }
    ,
    $.prototype.updateCount = function(tt) {
        var nt = this;
        this.setState({
            isLoading: !0
        }),
        this.props.getCount(tt, function(rt) {
            nt._isMounted && nt.setState({
                count: rt,
                isLoading: !1
            })
        })
    }
    ,
    $.prototype.render = function() {
        var tt = this.state
          , nt = tt.count
          , rt = tt.isLoading
          , it = this.props
          , ot = it.children
          , st = ot === void 0 ? defaultChildren : ot
          , lt = it.className;
        it.getCount;
        var ut = __rest(it, ["children", "className", "getCount"]);
        return jsx("span", kn(wn({}, __assign({
            className: cx("react-share__ShareCount", lt)
        }, ut)), {
            children: !rt && nt !== void 0 && st(nt)
        }))
    }
    ,
    $
}(react.exports.Component);
function createShareCount(et) {
    var $ = function(tt) {
        return jsx(SocialMediaShareCount, wn({}, __assign({
            getCount: et
        }, tt)))
    };
    return $.displayName = "ShareCount(" + et.name + ")",
    $
}
function getFacebookShareCount(et, $) {
    var tt = "https://graph.facebook.com/?id=" + et + "&fields=og_object{engagement}";
    jsonp_1(tt, function(nt, rt) {
        $(!nt && rt && rt.og_object && rt.og_object.engagement ? rt.og_object.engagement.count : void 0)
    })
}
var FacebookShareCount = createShareCount(getFacebookShareCount);
function linkedinLink(et, $) {
    var tt = $.title
      , nt = $.summary
      , rt = $.source;
    return assert(et, "linkedin.url"),
    "https://linkedin.com/shareArticle" + objectToGetParams({
        url: et,
        mini: "true",
        title: tt,
        summary: nt,
        source: rt
    })
}
var LinkedinShareButton = createShareButton("linkedin", linkedinLink, function(et) {
    var $ = et.title
      , tt = et.summary
      , nt = et.source;
    return {
        title: $,
        summary: tt,
        source: nt
    }
}, {
    windowWidth: 750,
    windowHeight: 600
})
  , LinkedinShareButton$1 = LinkedinShareButton;
function twitterLink(et, $) {
    var tt = $.title
      , nt = $.via
      , rt = $.hashtags
      , it = rt === void 0 ? [] : rt
      , ot = $.related
      , st = ot === void 0 ? [] : ot;
    return assert(et, "twitter.url"),
    assert(Array.isArray(it), "twitter.hashtags is not an array"),
    assert(Array.isArray(st), "twitter.related is not an array"),
    "https://twitter.com/share" + objectToGetParams({
        url: et,
        text: tt,
        via: nt,
        hashtags: it.length > 0 ? it.join(",") : void 0,
        related: st.length > 0 ? st.join(",") : void 0
    })
}
var TwitterShareButton = createShareButton("twitter", twitterLink, function(et) {
    return {
        hashtags: et.hashtags,
        title: et.title,
        via: et.via,
        related: et.related
    }
}, {
    windowWidth: 550,
    windowHeight: 400
})
  , TwitterShareButton$1 = TwitterShareButton;
function Facebook() {
    return jsx("svg", {
        width: "20",
        height: "20",
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: jsx("path", {
            d: "M18.3334 10.0504C18.3334 5.41984 14.6029 1.6665 10.0001 1.6665C5.3973 1.6665 1.66675 5.41984 1.66675 10.0504C1.66675 14.2359 4.71342 17.7043 8.69786 18.3332V12.4743H6.5823V10.0498H8.69786V8.20317C8.69786 6.10206 9.94175 4.94095 11.8456 4.94095C12.7567 4.94095 13.7112 5.10484 13.7112 5.10484V7.16817H12.6595C11.6245 7.16817 11.3023 7.81484 11.3023 8.47817V10.0504H13.6134L13.244 12.4737H11.3023V18.3332C15.2867 17.7043 18.3334 14.2359 18.3334 10.0504Z",
            fill: "currentColor"
        })
    })
}
function Linkedin() {
    return jsx("svg", {
        width: "20",
        height: "20",
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: jsx("path", {
            d: "M17.0992 1.6665H2.89673C2.21639 1.6665 1.66626 2.20361 1.66626 2.86768V17.1287C1.66626 17.7928 2.21639 18.3332 2.89673 18.3332H17.0992C17.7795 18.3332 18.3329 17.7928 18.3329 17.132V2.86768C18.3329 2.20361 17.7795 1.6665 17.0992 1.6665ZM6.61092 15.869H4.13696V7.91325H6.61092V15.869ZM5.37394 6.82926C4.57967 6.82926 3.9384 6.18799 3.9384 5.39697C3.9384 4.60596 4.57967 3.96468 5.37394 3.96468C6.16496 3.96468 6.80623 4.60596 6.80623 5.39697C6.80623 6.18473 6.16496 6.82926 5.37394 6.82926ZM15.8687 15.869H13.398V12.0018C13.398 11.0806 13.3818 9.89242 12.1122 9.89242C10.8264 9.89242 10.6311 10.8983 10.6311 11.9367V15.869H8.16366V7.91325H10.5334V9.00049H10.566C10.8948 8.37549 11.7021 7.71468 12.9032 7.71468C15.4065 7.71468 15.8687 9.36182 15.8687 11.5037V15.869Z",
            fill: "currentColor"
        })
    })
}
function Twitter() {
    return jsx("svg", {
        width: "20",
        height: "20",
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: jsx("path", {
            d: "M16.6271 6.59994C16.6373 6.74687 16.6373 6.8938 16.6373 7.04209C16.6373 11.5603 13.1977 16.7712 6.90813 16.7712V16.7685C5.05019 16.7712 3.23084 16.2391 1.66675 15.2356C1.93691 15.2681 2.20842 15.2843 2.48062 15.285C4.02033 15.2864 5.51603 14.7698 6.72735 13.8184C5.26415 13.7907 3.98106 12.8367 3.53282 11.4439C4.04538 11.5427 4.57351 11.5224 5.07659 11.385C3.48136 11.0627 2.33369 9.66109 2.33369 8.03335C2.33369 8.01846 2.33369 8.00424 2.33369 7.99002C2.80901 8.25476 3.3412 8.40169 3.88558 8.41794C2.38311 7.41381 1.91998 5.41503 2.82729 3.8523C4.56336 5.98853 7.1248 7.28719 9.87448 7.42464C9.5989 6.23702 9.97537 4.99252 10.8637 4.15767C12.2409 2.86306 14.4069 2.92942 15.7016 4.30595C16.4673 4.15496 17.2013 3.87396 17.873 3.47583C17.6177 4.26736 17.0835 4.93971 16.3698 5.36696C17.0476 5.28706 17.7098 5.1056 18.3334 4.82867C17.8743 5.51659 17.2961 6.11582 16.6271 6.59994Z",
            fill: "currentColor"
        })
    })
}
function ShareButtons(et) {
    const {projectName: $, socialMessage: tt, projectLink: nt, hashTags: rt, className: it, animProps: ot} = et;
    return jsxs("div", {
        className: clsx("detail__share", it),
        children: [jsxs(ClipRevealAnim, kn(wn({}, ot), {
            children: [jsx(FacebookShareButton$1, {
                url: nt,
                quote: tt,
                children: jsx("div", {
                    className: "detail__share-btn",
                    children: jsx(Facebook, {})
                })
            }), jsx(FacebookShareCount, {
                url: nt,
                children: st=>st
            })]
        })), jsx(ClipRevealAnim, kn(wn({}, ot), {
            children: jsx(LinkedinShareButton$1, {
                url: nt,
                source: encodeURIComponent($),
                title: encodeURIComponent($),
                summary: encodeURIComponent(tt),
                children: jsx("div", {
                    className: "detail__share-btn",
                    children: jsx(Linkedin, {})
                })
            })
        })), jsx(ClipRevealAnim, kn(wn({}, ot), {
            children: jsx(TwitterShareButton$1, {
                title: `${tt}

@lusionltd

`,
                url: `${nt}

`,
                hashtags: rt,
                children: jsx("div", {
                    className: "detail__share-btn",
                    children: jsx(Twitter, {})
                })
            })
        }))]
    })
}
const PAGE_DELAY$1 = 450
  , STAGGER = 120;
function ExpDetailContent({data: et}) {
    const {isLoading: $, data: tt} = useFetch(et != null && et.id ? `/assets/data/${et.id}/${et.id}.md` : null)
      , nt = PAGE_DELAY$1
      , it = useGlobalStore(mt=>mt.width, shallow) <= 1024
      , ot = react.exports.useRef()
      , st = react.exports.useRef(0)
      , lt = react.exports.useRef()
      , ut = react.exports.useRef(0)
      , ct = react.exports.useRef(0)
      , ht = react.exports.useRef()
      , ft = react.exports.useRef(0)
      , gt = react.exports.useRef(0)
      , vt = react.exports.useRef(0)
      , yt = react.exports.useRef(0)
      , wt = react.exports.useRef(0);
    return react.exports.useEffect(()=>{
        if (!ot.current || !ht.current || !lt.current)
            return;
        const mt = new ResizeObserver(_t=>{
            var Mt;
            const bt = window.innerHeight;
            for (let St of _t) {
                const At = St.contentRect
                  , Pt = St.target.id;
                Pt === "detail-info" && (st.current = At.height),
                Pt === "detail-content" && (gt.current = At.height - (bt - (((Mt = ht.current) == null ? void 0 : Mt.offsetTop) || 0)),
                gt.current = Math.max(0, gt.current),
                ft.current = gt.current + bt * .28),
                Pt === "detail-exploremore" && (ut.current = At.height)
            }
        }
        );
        return mt.observe(ot.current),
        mt.observe(ht.current),
        mt.observe(lt.current),
        ()=>{
            !mt || mt.disconnect()
        }
    }
    , []),
    useAnimationFrame(mt=>{
        !ot.current || !ht.current || !lt.current || (disableAbsScroll.current = !1,
        disableScroll.current = !1,
        yt.current += input.deltaScroll,
        yt.current = math.clamp(yt.current, 0, ft.current + ut.current),
        wt.current = math.mix(wt.current, yt.current, .05),
        vt.current = Math.min(wt.current, gt.current) / gt.current,
        ct.current = Math.max(0, wt.current - ft.current) / ut.current,
        ht.current.style.transform = `translateY(${-wt.current}px)`,
        lt.current.style.transform = `translateY(${it ? -wt.current : -ct.current * ut.current}px)`,
        ot.current.style.transform = `translateY(${it ? -wt.current : -ct.current * ut.current}px)`)
    }
    ),
    et ? jsxs("div", {
        className: "page-wrapper",
        children: [jsxs("div", {
            className: "detail detail--first",
            children: [jsxs("div", {
                ref: ot,
                id: "detail-info",
                className: "detail__left",
                children: [jsxs("div", {
                    className: "detail__left-top",
                    children: [jsx(ExpInfoId, {
                        id: et.nId
                    }), jsx("h1", {
                        className: "detail__hero",
                        children: et.projectName
                    })]
                }), jsx("img", {
                    src: et.detailImg,
                    className: clsx("detail__img", "o-hide-desktop", "detail__img--show")
                }), jsxs("div", {
                    className: "detail__left-bottom",
                    children: [jsx("div", {
                        className: "detail__cta o-hide-desktop",
                        children: et.projectLink && jsx(ClipRevealAnim, {
                            delay: nt,
                            stagger: STAGGER,
                            staggerOrder: 1,
                            children: jsx(Button, {
                                href: et.projectLink,
                                target: "_blank",
                                type: BUTTON_TYPE.EXT_LINK,
                                children: "view live"
                            })
                        })
                    }), (et == null ? void 0 : et.recognitions.length) > 0 && jsxs("div", {
                        children: [jsx("h3", {
                            children: jsx(ClipRevealAnim, {
                                delay: nt,
                                stagger: STAGGER,
                                staggerOrder: 1,
                                type: "clip-right",
                                children: "RECOGNITION"
                            })
                        }), jsx("div", {
                            className: "detail__recognitions",
                            children: et.recognitions.map((mt,_t)=>jsx(ClipRevealAnim, {
                                stagger: STAGGER * .5,
                                staggerOrder: _t + 2,
                                delay: nt,
                                type: "clip-right",
                                children: RECOGNITIONS[mt]
                            }, mt))
                        })]
                    }), jsx(ShareButtons, kn(wn({
                        className: "o-hide-tablet-and-below"
                    }, et), {
                        animProps: {
                            stagger: STAGGER,
                            staggerOrder: 2,
                            delay: nt
                        }
                    })), jsx("div", {
                        className: "detail__cta o-hide-tablet-and-below",
                        children: et.projectLink && jsx(ClipRevealAnim, {
                            stagger: STAGGER,
                            staggerOrder: 3,
                            delay: nt,
                            children: jsx(Button, {
                                href: et.projectLink,
                                target: "_blank",
                                type: BUTTON_TYPE.EXT_LINK,
                                children: "view live"
                            })
                        })
                    })]
                })]
            }), jsxs("div", {
                ref: ht,
                id: "detail-content",
                className: "detail__right",
                children: [jsx("img", {
                    src: et.detailImg,
                    className: clsx("detail__img", "o-hide-tablet-and-below", "detail__img--show")
                }), jsxs("div", {
                    children: [jsx("h3", {
                        children: jsx(ClipRevealAnim, {
                            stagger: STAGGER,
                            staggerOrder: 0,
                            type: "clip-right",
                            children: "Technology"
                        })
                    }), jsx(ClipRevealAnim, {
                        stagger: STAGGER,
                        staggerOrder: 1,
                        children: jsx(Tags, {
                            tags: et.tags
                        })
                    })]
                }), jsx("div", {
                    children: jsx("div", {
                        className: "detail__description",
                        children: $ ? "" : jsx(ReactMarkdown, {
                            transformImageUri: (mt,_t,bt)=>mt.indexOf("://") == -1 ? "/assets/data/" + et.id + "/" + mt : mt,
                            children: tt
                        })
                    })
                }), jsx(ShareButtons, kn(wn({
                    className: "o-hide-desktop"
                }, et), {
                    animProps: {
                        stagger: STAGGER
                    }
                })), jsxs("div", {
                    children: [jsx("h3", {
                        children: "PROJECT INSIGHT & DISCUSSION"
                    }), jsx(TwitterTweetEmbed, {
                        tweetId: et.twitterId
                    })]
                })]
            })]
        }), jsx("div", {
            ref: lt,
            id: "detail-exploremore",
            className: "detail detail--override",
            children: jsx("div", {
                className: "detail__bottom",
                children: jsx(ExploreMore, {
                    id: et.id
                })
            })
        })]
    }) : null
}
function ExpDetail(et) {
    const {active: $, location: tt} = et
      , [nt,rt] = react.exports.useState()
      , it = useDataStore(ot=>ot.hasLoaded, shallow);
    return react.exports.useEffect(()=>{
        var lt, ut;
        if (!$)
            return;
        const ot = (lt = tt.split("/")) == null ? void 0 : lt[2]
          , {experimentsFlatList: st} = useDataStore.getState();
        ot && it && st && rt((ut = st.filter(ct=>ct.slug === ot)) == null ? void 0 : ut[0])
    }
    , [$, tt, it]),
    jsx(Fragment, {
        children: $ && nt ? jsx(ExpDetailContent, wn({
            data: nt
        }, et)) : null
    })
}
var ABOUT_COPY = {
    categories: ["immersive experiences", "installations", "creative coding", "new media"],
    faqs: [{
        question: "Why do we invest in R&D?",
        answer: "By investing in R&D, we unlock new possibilities and push the boundaries of what's currently achievable. R&D is at the heart of what we do at Lusion allows us to continusously elevate our expertise and deliver cutting-edge solutions that blow people's minds!"
    }, {
        question: "What is your approach?",
        answer: "We approach our work at Lusion with curiosity and a commitment to excellence. We foster a collaborative environment at Lusion, where our team combines their expertise in research, design and development and together we push the limits of what's possible. Our approach involves creating our own brief, from concept to implementation. This process allows us to refine our process and develop smart, innovative solutions to bridge gap between an idea and a reality."
    }, {
        question: "Why these experiments?",
        answer: "At Lusion, we believe dedicating time to these lab experiments is essential for exploring new possibilities, test emerging technologies and gain valuable insights to stay at the forefront of our field. By breaking free from traditional constraints, we discover unique solutions, allowing our team to be adaptable to challenges, while also enabling us to tailor unique, custom solutions to our clients. But let's also be honest, it's also really fun for us as a team to play together and try something new!"
    }]
};
const HEADER_STAGGER = 150
  , PAGE_DELAY = 450
  , STYLES = {
    paddingBottom: "2rem",
    lineHeight: .7
}
  , X_OFFSETS = [16, 30, 72, 5];
function AboutContent(et) {
    const tt = useGlobalStore(ut=>ut.isInitialLoad, shallow) ? PAGE_DELAY * .6 : PAGE_DELAY
      , nt = react.exports.useRef()
      , rt = react.exports.useRef(0)
      , it = react.exports.useRef(0)
      , ot = react.exports.useRef(0)
      , st = react.exports.useRef(0)
      , lt = useGlobalStore(ut=>ut.width, shallow);
    return react.exports.useEffect(()=>{
        if (!nt.current)
            return;
        const ut = new ResizeObserver(ct=>{
            var ht;
            for (let ft of ct) {
                const gt = ft.contentRect;
                rt.current = gt.height - (window.innerHeight - (((ht = nt.current) == null ? void 0 : ht.offsetTop) || 0)),
                rt.current = Math.abs(rt.current)
            }
        }
        );
        return ut.observe(nt.current),
        ()=>{
            !ut || ut.disconnect()
        }
    }
    , []),
    useAnimationFrame(ut=>{
        !nt.current || (disableAbsScroll.current = !1,
        disableScroll.current = !1,
        ot.current += input.deltaScroll,
        ot.current = math.clamp(ot.current, 0, rt.current),
        st.current = math.mix(st.current, ot.current, .05),
        it.current = st.current / rt.current,
        nt.current.style.transform = `translateY(${-st.current}px)`)
    }
    ),
    jsxs("div", kn(wn({
        ref: nt,
        className: "page-wrapper about",
        id: "about-page"
    }, et), {
        children: [jsx("div", {
            className: "about__hero-wrapper",
            children: lt > 1024 ? jsxs("div", {
                className: "about__hero about__hero--desktop",
                children: [jsx("div", {
                    className: "about__hero-text--small",
                    children: jsx(ClipRevealAnim, {
                        delay: tt,
                        stagger: HEADER_STAGGER,
                        staggerOrder: 1,
                        active: !0,
                        type: "clip-right",
                        children: "(WE ARE)"
                    })
                }), jsx("div", {
                    children: jsxs(ClipRevealAnim, {
                        delay: tt,
                        stagger: HEADER_STAGGER,
                        staggerOrder: 1,
                        active: !0,
                        type: "about",
                        animProps: {
                            secondary: !0,
                            xOffset: X_OFFSETS[0]
                        },
                        style: STYLES,
                        children: ["The ", jsx("i", {
                            children: "R&D"
                        })]
                    })
                }), jsx("div", {
                    children: jsx(ClipRevealAnim, {
                        delay: tt,
                        stagger: HEADER_STAGGER,
                        staggerOrder: 2,
                        active: !0,
                        type: "about",
                        animProps: {
                            secondary: !0,
                            xOffset: X_OFFSETS[1]
                        },
                        style: STYLES,
                        children: "division of a"
                    })
                }), jsx("div", {
                    children: jsx(ClipRevealAnim, {
                        delay: tt,
                        stagger: HEADER_STAGGER,
                        staggerOrder: 3,
                        active: !0,
                        type: "about",
                        animProps: {
                            secondary: !0,
                            xOffset: X_OFFSETS[2]
                        },
                        style: STYLES,
                        children: "digital"
                    })
                }), jsx("div", {
                    className: "about__hero-text--small",
                    children: jsx(AboutCategories, {
                        categories: ABOUT_COPY.categories,
                        staggerOrder: 7,
                        delay: tt
                    })
                }), jsxs("div", {
                    children: [jsx(ClipRevealAnim, {
                        delay: tt,
                        stagger: HEADER_STAGGER,
                        staggerOrder: 4,
                        active: !0,
                        type: "about",
                        animProps: {
                            secondary: !0,
                            xOffset: X_OFFSETS[3]
                        },
                        style: STYLES,
                        children: "creative studio "
                    }), jsx("a", {
                        href: "https://lusion.co",
                        target: "_blank",
                        rel: "noreferrer noopener",
                        className: "about__hero-text--small",
                        children: jsxs(ClipRevealAnim, {
                            delay: tt,
                            stagger: HEADER_STAGGER,
                            staggerOrder: 5,
                            active: !0,
                            type: "clip-right",
                            children: ["(", jsx(ArrowTopRight16, {
                                style: {
                                    marginBottom: -2,
                                    marginRight: 4
                                }
                            }), "LUSION)"]
                        })
                    })]
                })]
            }) : jsxs("div", {
                className: "about__hero about__hero--mobile",
                children: [jsx("div", {
                    className: "about__hero-text--small",
                    children: jsx(ClipRevealAnim, {
                        stagger: HEADER_STAGGER,
                        active: !0,
                        type: "clip-right",
                        children: "(WE ARE)"
                    })
                }), jsx("div", {
                    children: jsx(SplitLines, {
                        LineWrapper: ClipRevealAnim,
                        activeOnReveal: !0,
                        wrapperProps: ut=>({
                            delay: 0,
                            stagger: 100,
                            staggerOrder: ut
                        }),
                        children: "The R&D division of a digital creative studio"
                    })
                }), jsx("div", {
                    className: "about__hero-text--small",
                    children: jsx(AboutCategories, {
                        categories: ABOUT_COPY.categories
                    })
                })]
            })
        }), jsx("div", {
            className: "about__content",
            children: ABOUT_COPY.faqs.map((ut,ct)=>jsx(AboutFaq, kn(wn({}, ut), {
                large: ct === 0
            }), ut.question))
        }), jsx(AboutFooter, {})]
    }))
}
function About(et) {
    const nt = et
      , {active: $} = nt
      , tt = nr(nt, ["active"]);
    return jsx(Fragment, {
        children: $ ? jsx(AboutContent, wn({}, tt)) : null
    })
}
function AboutFaq(rt) {
    var it = rt
      , {question: et, answer: $, large: tt} = it
      , nt = nr(it, ["question", "answer", "large"]);
    return jsxs("div", kn(wn({
        className: clsx("about-faq", tt && "about-faq--large")
    }, nt), {
        children: [jsx(ClipRevealAnim, {
            activeOnReveal: !0,
            children: jsx("div", {
                className: "about-faq__question",
                children: et
            })
        }), jsx("div", {
            className: "about-faq__answer",
            children: jsx(SplitLines, {
                LineWrapper: ClipRevealAnim,
                wrapperProps: ot=>({
                    activeOnReveal: !0,
                    stagger: 100,
                    staggerOrder: ot
                }),
                children: $
            })
        })]
    }))
}
function AboutCategories(rt) {
    var it = rt
      , {categories: et, staggerOrder: $=4, delay: tt} = it
      , nt = nr(it, ["categories", "staggerOrder", "delay"]);
    return jsx("div", kn(wn({
        className: "about-categories"
    }, nt), {
        children: et.map((ot,st)=>jsxs(ClipRevealAnim, {
            delay: tt,
            stagger: HEADER_STAGGER / 2,
            staggerOrder: $ + st,
            active: !0,
            type: "clip-right",
            children: [jsx(ArrowRight12, {}), ot]
        }, ot))
    }))
}
function AboutFooter(et) {
    return jsx("div", kn(wn({
        className: "about__footer"
    }, et), {
        children: jsxs("div", {
            className: "about__footer-grid",
            children: [jsxs("div", {
                className: "about__footer-desc",
                children: [jsx("div", {
                    className: "about__footer-title t-title-mono",
                    children: "labs area"
                }), jsxs("div", {
                    className: "about__footer-content",
                    children: [jsx("span", {
                        children: "play ground"
                    }), jsx("span", {
                        children: "r&d collection"
                    }), jsx("span", {
                        children: "experiments"
                    })]
                })]
            }), jsxs("div", {
                className: "about__footer-socials",
                children: [jsx("div", {
                    className: "about__footer-title t-title-mono",
                    children: "follow"
                }), jsx(SocialLinks, {
                    className: "about__footer-content"
                })]
            }), jsxs("div", {
                className: "about__footer-contact",
                children: [jsxs("div", {
                    children: [jsx("div", {
                        className: "about__footer-title t-title-mono",
                        children: "contact"
                    }), jsx(ContactEmail, {
                        className: "link"
                    })]
                }), jsx(LusionLogo, {})]
            })]
        })
    }))
}
const MAIN = "/"
  , EXP_PATH = "/exp"
  , ABOUT = "/about";
function App() {
    useRouter();
    const [et] = useLocation()
      , [$,tt] = react.exports.useState(et)
      , [nt,rt] = useLocalStore(ft=>[ft.hasClosedSubscriptionModal, ft.hasSubmittedSubcriptionModal], shallow)
      , [it,ot,st,lt,ut] = useGlobalStore(ft=>[ft.isLoadingComplete, ft.isLoaderAnimationComplete, ft.showSubscribeModal, ft.height, ft.navbarHeight], shallow);
    react.exports.useEffect(()=>{
        useLocalStore.getState().fetchSubscriptionData(),
        useDataStore.getState().setData(experimentData)
    }
    , []),
    react.exports.useEffect(()=>{
        et.includes("about") && it ? properties.particleMode = 1 : properties.particleMode = 0,
        $ !== et && (disableScroll.current = !0,
        disableAbsScroll.current = !1,
        makeLucyJump(),
        useGlobalStore.setState(ft=>{
            ft.showSubscribeModal = !1,
            ft.showMobileMenuOverlay = !1,
            ft.showContactOverlay = !1,
            ft.isInitialLoad = !1
        }
        ))
    }
    , [et, $, it]),
    react.exports.useEffect(()=>{
        let ft = !1
          , gt = !1;
        const vt = ({scroll: wt})=>{
            let mt = wt / lt;
            mt > .2 && !gt && (gt = !0,
            toggleLucyMode(!0)),
            !rt && !nt && !ft && mt > 1 && (ft = !0,
            useGlobalStore.setState(_t=>_t.showSubscribeModal = !0))
        }
          , yt = useScrollStore.subscribe(vt);
        return ()=>void yt()
    }
    , [lt, nt, rt]);
    const ct = react.exports.useRef(0)
      , ht = react.exports.useRef();
    return useAnimationFrame(ft=>{
        ct.current = math.saturate(ct.current + ft * ($ === et ? 2 : -1)),
        ht.current.style.opacity = ease.cubicInOut(ct.current)
    }
    ),
    jsxs(Fragment, {
        children: [settings.ENABLE_GRID && jsx(TestGrid, {}), it && jsx(Navbar, {
            location: $
        }), jsx("div", {
            ref: ht,
            className: "app-wrapper",
            style: {
                marginTop: `${ut}px`
            },
            children: it && jsxs(Fragment, {
                children: [jsx(Main, {
                    active: $ === MAIN
                }), jsx(ExpDetail, {
                    active: $.includes(EXP_PATH),
                    location: $
                }, $), jsx(About, {
                    active: $ === ABOUT
                })]
            })
        }), jsx(TransitionCover, {
            active: et !== $,
            callback: ()=>{
                resetScrollSignal.dispatch(!0),
                tt(et)
            }
        }), !ot && jsx(Loader, {}), jsx(Contact, {}), jsx(MobileMenu, {
            location: $
        }), jsx(SubscribeModal, {
            active: st
        }), jsx(Cursor, {})]
    })
}
function ReactApp() {
    client.createRoot(document.getElementById("ui")).render(jsx(React.StrictMode, {
        children: jsx(App, {})
    }))
}
var blitVert = `#define GLSLIFY 1
attribute vec2 position;varying vec2 v_uv;void main(){v_uv=position*0.5+0.5;gl_Position=vec4(position,0.0,1.0);}`
  , blitFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_texture,v_uv);}`
  , copyAlpha = `#define GLSLIFY 1
uniform sampler2D u_textureFrom;uniform sampler2D u_textureTo;varying vec2 v_uv;void main(){vec4 from=texture2D(u_textureFrom,v_uv);vec4 to=texture2D(u_textureTo,v_uv);float alpha=from.a;gl_FragColor=vec4(to.rgb,alpha);}`
  , uvBlitVert = `#define GLSLIFY 1
attribute vec2 position;attribute vec2 uv;varying vec2 v_uv;void main(){v_uv=uv;gl_Position=vec4(position,0.0,1.0);}`
  , clearFrag = `#define GLSLIFY 1
uniform vec4 u_color;varying vec2 v_uv;void main(){gl_FragColor=u_color;}`
  , debugVert = `#define GLSLIFY 1
attribute vec3 position;attribute vec2 uv;uniform vec4 u_transform;varying vec2 v_uv;void main(){v_uv=uv;gl_Position=vec4(position.xy*u_transform.zw+u_transform.xy,0.0,1.0);}`;
class FboHelper {
    constructor() {
        Et(this, "isWebGL2");
        Et(this, "renderer");
        Et(this, "quadGeom");
        Et(this, "triGeom");
        Et(this, "floatType");
        Et(this, "precisionPrefix");
        Et(this, "precisionPrefix2");
        Et(this, "vertexShader");
        Et(this, "_scene");
        Et(this, "_camera");
        Et(this, "_tri");
        Et(this, "copyMaterial");
        Et(this, "uvCopyMaterial");
        Et(this, "clearMaterial");
        Et(this, "_debugScene");
        Et(this, "_debugMesh");
        Et(this, "_debugMaterial")
    }
    init($, tt) {
        this.renderer = $,
        this.floatType = tt,
        this.isWebGL2 = this.renderer.capabilities.isWebGL2,
        this._scene = new Scene,
        this._camera = new Camera,
        this._camera.position.z = 1,
        this.triGeom = new BufferGeometry,
        this.triGeom.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0, 4, -1, 0, -1, 4, 0]),3)),
        this.quadGeom = new PlaneGeometry(2,2),
        this._tri = new Mesh(this.triGeom),
        this._tri.frustumCulled = !1,
        this._scene.add(this._tri),
        this.precisionPrefix = `precision ${this.renderer.capabilities.precision} float;
`,
        this.precisionPrefix2 = `#version 300 es
			precision ${this.renderer.capabilities.precision} float;
			precision ${this.renderer.capabilities.precision} int;
			#define IS_WEBGL2 true
		`,
        this.isWebGL2 ? (this.vertexPrefix = `${this.precisionPrefix2}
				precision mediump sampler2DArray;
				#define attribute in
				#define varying out
				#define texture2D texture
			`,
        this.fragmentPrefix = `${this.precisionPrefix2}
				#define varying in
				out highp vec4 pc_fragColor;
				#define gl_FragColor pc_fragColor
				#define gl_FragDepthEXT gl_FragDepth
				#define texture2D texture
				#define textureCube texture
				#define texture2DProj textureProj
				#define texture2DLodEXT textureLod
				#define texture2DProjLodEXT textureProjLod
				#define textureCubeLodEXT textureLod
				#define texture2DGradEXT textureGrad
				#define texture2DProjGradEXT textureProjGrad
				#define textureCubeGradEXT textureGrad
			`) : (this.vertexPrefix = this.precisionPrefix,
        this.fragmentPrefix = this.precisionPrefix),
        this.renderer.getContext().getExtension("OES_standard_derivatives"),
        this.vertexShader = this.precisionPrefix + blitVert,
        this.copyMaterial = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                }
            },
            vertexShader: this.vertexShader,
            fragmentShader: this.precisionPrefix + blitFrag,
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending
        }),
        this.copyAlphaMaterial = new RawShaderMaterial({
            uniforms: Object.assign({
                u_texelSize: {
                    value: new Vector2
                },
                u_textureFrom: {
                    value: null
                },
                u_textureTo: {
                    value: null
                },
                u_bgTopLeft: {
                    value: new Color
                },
                u_bgTopRight: {
                    value: new Color
                },
                u_bgBottomLeft: {
                    value: new Color
                },
                u_bgBottomRight: {
                    value: new Color
                }
            }),
            vertexShader: this.vertexShader,
            fragmentShader: this.precisionPrefix + copyAlpha,
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending
        }),
        this.uvCopyMaterial = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                }
            },
            vertexShader: this.precisionPrefix + uvBlitVert,
            fragmentShader: this.precisionPrefix + blitFrag,
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending
        }),
        this.clearMaterial = new RawShaderMaterial({
            uniforms: {
                u_color: {
                    value: new Vector4(1,1,1,1)
                }
            },
            vertexShader: this.vertexShader,
            fragmentShader: this.precisionPrefix + clearFrag,
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending
        });
        const nt = new PlaneGeometry(1,1);
        nt.translate(.5, -.5, 0),
        this._debugMaterial = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_transform: {
                    value: new Vector4(0,0,1,1)
                }
            },
            vertexShader: this.precisionPrefix + debugVert,
            fragmentShader: this.precisionPrefix + blitFrag,
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending
        }),
        this._debugMesh = new Mesh(nt,this._debugMaterial),
        this._debugScene = new Scene,
        this._debugScene.frustumCulled = !1,
        this._debugScene.add(this._debugMesh)
    }
    copy($, tt) {
        const nt = this.copyMaterial;
        nt && (nt.uniforms.u_texture.value = $,
        this.render(nt, tt))
    }
    copyAlphaWithBg($, tt, nt) {
        const rt = this.copyAlphaMaterial;
        rt && (rt.uniforms.u_texelSize.value.set(properties.postprocessing.sharedUniforms.u_texelSize.value),
        rt.uniforms.u_textureFrom.value = $,
        rt.uniforms.u_textureTo.value = tt,
        this.render(rt, nt))
    }
    uvCopy($, tt) {
        const nt = this.uvCopyMaterial;
        nt && (nt.uniforms.u_texture.value = $,
        this.render(nt, tt))
    }
    render($, tt) {
        !(this._tri && this.renderer && this._scene && this._camera) || (this._tri.material = $,
        tt && this.renderer.setRenderTarget(tt),
        this.renderer.render(this._scene, this._camera),
        tt && this.renderer.setRenderTarget(null))
    }
    renderGeometry($, tt, nt) {
        !(this._tri && this.triGeom) || (this._tri.geometry = $,
        this.render(tt, nt),
        this._tri.geometry = this.triGeom)
    }
    renderMesh($, tt) {
        !(this._tri && this.renderer && this._scene && this._camera) || (this._tri.visible = !1,
        this._scene.add($),
        tt && this.renderer.setRenderTarget(tt || null),
        this.renderer.render(this._scene, this._camera),
        tt && this.renderer.setRenderTarget(null),
        this._scene.remove($),
        this._tri.visible = !0)
    }
    debugTo($, tt=200, nt=200, rt, it) {
        if (!(this.renderer && this._debugMaterial && this._debugScene && this._camera))
            return;
        tt = tt || $.width || $.image.width,
        nt = nt || $.height || $.image.height,
        rt = rt || 0,
        it = it || 0;
        const ot = this.renderer.getSize(new Vector2);
        rt = rt / ot.width * 2 - 1,
        it = 1 - it / ot.height * 2,
        tt = tt / ot.width * 2,
        nt = nt / ot.height * 2,
        this._debugMaterial.uniforms.u_texture.value = $,
        this._debugMaterial.uniforms.u_transform.value.set(rt, it, tt, nt);
        const st = this.getColorState();
        this.renderer.autoClearColor = !1,
        this.renderer.setRenderTarget(null),
        this.renderer.render(this._debugScene, this._camera),
        this.setColorState(st)
    }
    parseDefines($) {
        let tt = "";
        for (const nt in $) {
            const rt = $[nt];
            rt === !0 ? tt += `#define ${nt}
` : tt += `#define ${nt} ${rt}
`
        }
        return tt
    }
    clearColor($, tt, nt, rt, it) {
        !this.clearMaterial || (this.clearMaterial.uniforms.u_color.value.set($, tt, nt, rt),
        this.render(this.clearMaterial, it))
    }
    getColorState() {
        if (!this.renderer)
            return {
                autoClear: !0,
                autoClearColor: !0,
                autoClearStencil: !0,
                autoClearDepth: !0,
                clearColor: 0,
                clearAlpha: 1
            };
        const $ = new Color;
        return this.renderer.getClearColor($),
        {
            autoClear: this.renderer.autoClear,
            autoClearColor: this.renderer.autoClearColor,
            autoClearStencil: this.renderer.autoClearStencil,
            autoClearDepth: this.renderer.autoClearDepth,
            clearColor: $.getHex(),
            clearAlpha: this.renderer.getClearAlpha()
        }
    }
    setColorState($) {
        !this.renderer || (this.renderer.setClearColor($.clearColor, $.clearAlpha),
        this.renderer.autoClear = $.autoClear,
        this.renderer.autoClearColor = $.autoClearColor,
        this.renderer.autoClearStencil = $.autoClearStencil,
        this.renderer.autoClearDepth = $.autoClearDepth)
    }
    createDataTexture($, tt, nt, rt=!1, it=!0) {
        let ot = new DataTexture($,tt,nt,RGBAFormat,rt ? FloatType : UnsignedByteType,UVMapping,ClampToEdgeWrapping,ClampToEdgeWrapping,it ? NearestFilter : LinearFilter,it ? NearestFilter : LinearFilter,0);
        return ot.needsUpdate = !0,
        ot
    }
    createRenderTarget($, tt, nt=!1, rt=!1, it=0) {
        return new WebGLRenderTarget($,tt,{
            wrapS: ClampToEdgeWrapping,
            wrapT: ClampToEdgeWrapping,
            magFilter: nt ? NearestFilter : LinearFilter,
            minFilter: nt ? NearestFilter : LinearFilter,
            type: rt ? this.floatType : UnsignedByteType,
            anisotropy: 0,
            encoding: LinearEncoding,
            depthBuffer: !1,
            stencilBuffer: !1,
            samples: it
        })
    }
    createMultisampleRenderTarget($, tt, nt=!1, rt=!1, it=8) {
        return this.renderer && this.isWebGL2 ? new WebGLRenderTarget($,tt,{
            wrapS: ClampToEdgeWrapping,
            wrapT: ClampToEdgeWrapping,
            magFilter: nt ? NearestFilter : LinearFilter,
            minFilter: nt ? NearestFilter : LinearFilter,
            type: rt ? this.floatType : UnsignedByteType,
            anisotropy: 0,
            encoding: LinearEncoding,
            depthBuffer: !1,
            stencilBuffer: !1,
            samples: it
        }) : this.createRenderTarget($, tt, nt, rt)
    }
    clearMultisampleRenderTargetState($) {
        if ($ = $ || this.renderer.getRenderTarget(),
        $ && $.samples > 0) {
            let tt = this.renderer.getContext()
              , nt = this.renderer.state;
            const rt = $.width
              , it = $.height;
            let ot = tt.COLOR_BUFFER_BIT;
            const st = [tt.COLOR_ATTACHMENT0]
              , lt = $.stencilBuffer ? tt.DEPTH_STENCIL_ATTACHMENT : tt.DEPTH_ATTACHMENT;
            $.depthBuffer && st.push(lt);
            const ut = this.renderer.properties.get($)
              , ct = ut.__ignoreDepthValues !== void 0 ? ut.__ignoreDepthValues : !1;
            ct === !1 && ($.depthBuffer && (ot |= tt.DEPTH_BUFFER_BIT),
            $.stencilBuffer && (ot |= tt.STENCIL_BUFFER_BIT)),
            nt.bindFramebuffer(tt.READ_FRAMEBUFFER, ut.__webglMultisampledFramebuffer),
            nt.bindFramebuffer(tt.DRAW_FRAMEBUFFER, ut.__webglFramebuffer),
            ct === !0 && (tt.invalidateFramebuffer(tt.READ_FRAMEBUFFER, [lt]),
            tt.invalidateFramebuffer(tt.DRAW_FRAMEBUFFER, [lt])),
            tt.blitFramebuffer(0, 0, rt, it, 0, 0, rt, it, ot, tt.NEAREST),
            tt.invalidateFramebuffer(tt.READ_FRAMEBUFFER, st),
            nt.bindFramebuffer(tt.READ_FRAMEBUFFER, null),
            nt.bindFramebuffer(tt.DRAW_FRAMEBUFFER, ut.__webglMultisampledFramebuffer)
        }
    }
    createRawShaderMaterial($) {
        return $ = Object.assign({
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending,
            vertexShader: blitVert,
            fragmentShader: blitFrag
        }, $),
        $.vertexShader = ($.vertexShaderPrefix !== void 0 ? $.vertexShaderPrefix : this.precisionPrefix) + $.vertexShader,
        $.fragmentShader = ($.fragmentShaderPrefix !== void 0 ? $.fragmentShaderPrefix : this.precisionPrefix) + $.fragmentShader,
        delete $.vertexShaderPrefix,
        delete $.fragmentShaderPrefix,
        new RawShaderMaterial($)
    }
}
var fboHelper = new FboHelper;
let _geom;
class Postprocessing {
    constructor() {
        Et(this, "width", 1);
        Et(this, "height", 1);
        Et(this, "scene", null);
        Et(this, "camera", null);
        Et(this, "resolution", new Vector2(0,0));
        Et(this, "texelSize", new Vector2(0,0));
        Et(this, "texelSizeScaled", new Vector2(0,0));
        Et(this, "aspect", new Vector2(1,1));
        Et(this, "onBeforeSceneRendered", new MinSignal$2);
        Et(this, "onBeforeSceneRenderedSecondTime", new MinSignal$2);
        Et(this, "onAfterSceneRendered", new MinSignal$2);
        Et(this, "onAfterRendered", new MinSignal$2);
        Et(this, "sceneRenderTarget", null);
        Et(this, "tempSceneRenderTarget", null);
        Et(this, "fromRenderTarget", null);
        Et(this, "toRenderTarget", null);
        Et(this, "useDepthTexture", !0);
        Et(this, "depthTexture", null);
        Et(this, "fromTexture", null);
        Et(this, "toTexture", null);
        Et(this, "sceneTexture", null);
        Et(this, "mesh", null);
        Et(this, "queue", []);
        Et(this, "sharedUniforms", {});
        Et(this, "geom");
        Et(this, "hasSizeChanged", !0)
    }
    init($) {
        if (Object.assign(this, $),
        _geom ? this.geom = _geom : (this.geom = _geom = new BufferGeometry,
        this.geom.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0, 4, -1, 0, -1, 4, 0]),3)),
        this.geom.setAttribute("a_uvClamp", new BufferAttribute(new Float32Array([0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]),4))),
        this.sceneRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.sceneRenderTarget.depthBuffer = !0,
        this.tempSceneRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.fromRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.toRenderTarget = this.fromRenderTarget.clone(),
        this.useDepthTexture = !!this.useDepthTexture && fboHelper.renderer && (fboHelper.renderer.capabilities.isWebGL2 || fboHelper.renderer.extensions.get("WEBGL_depth_texture")),
        this.fromTexture = this.fromRenderTarget.texture,
        this.toTexture = this.toRenderTarget.texture,
        this.sceneTexture = this.sceneRenderTarget.texture,
        this.mesh = new Mesh,
        this.sharedUniforms = Object.assign(this.sharedUniforms, {
            u_sceneTexture: {
                value: this.sceneRenderTarget.texture
            },
            u_sceneDepthTexture: {
                value: null
            },
            u_cameraNear: {
                value: 0
            },
            u_cameraFar: {
                value: 1
            },
            u_cameraFovRad: {
                value: 1
            },
            u_resolution: {
                value: this.resolution
            },
            u_texelSize: {
                value: this.texelSize
            },
            u_texelSizeScaled: {
                value: this.texelSizeScaled
            },
            u_aspect: {
                value: this.aspect
            }
        }),
        this.useDepthTexture && fboHelper.renderer) {
            const tt = new DepthTexture(this.resolution.width,this.resolution.height);
            fboHelper.renderer.capabilities.isWebGL2 ? tt.type = UnsignedIntType : (tt.format = DepthStencilFormat,
            tt.type = UnsignedInt248Type),
            tt.minFilter = NearestFilter,
            tt.magFilter = NearestFilter,
            this.sceneRenderTarget.depthTexture = tt,
            this.depthTexture = this.sharedUniforms.u_sceneDepthTexture.value = tt
        }
    }
    swap() {
        const $ = this.fromRenderTarget;
        this.fromRenderTarget = this.toRenderTarget,
        this.toRenderTarget = $,
        this.fromTexture = this.fromRenderTarget.texture,
        this.toTexture = this.toRenderTarget.texture
    }
    setSize($, tt) {
        if (this.width !== $ || this.height !== tt) {
            this.hasSizeChanged = !0,
            this.width = $,
            this.height = tt,
            this.resolution.set($, tt),
            this.texelSize.set(1 / $, 1 / tt),
            this.texelSizeScaled.copy(this.texelSize).multiplyScalar(settings.UP_SCALE);
            const nt = tt / Math.sqrt($ * $ + tt * tt) * 2;
            this.aspect.set($ / tt * nt, nt),
            this.sceneRenderTarget.setSize(Math.ceil($ / settings.UP_SCALE), Math.ceil(tt / settings.UP_SCALE)),
            this.tempSceneRenderTarget.setSize(Math.ceil($ / settings.UP_SCALE), Math.ceil(tt / settings.UP_SCALE)),
            this.fromRenderTarget.setSize($, tt),
            this.toRenderTarget.setSize($, tt)
        }
    }
    dispose() {
        this.fromRenderTarget && this.fromRenderTarget.dispose(),
        this.toRenderTarget && this.toRenderTarget.dispose(),
        this.sceneRenderTarget && this.sceneRenderTarget.dispose(),
        this.tempSceneRenderTarget && this.tempSceneRenderTarget.dispose()
    }
    _filterQueue($) {
        return $.enabled && $.needsRender()
    }
    renderMaterial($, tt) {
        this.mesh.material = $,
        fboHelper.renderMesh(this.mesh, tt)
    }
    render($, tt, nt) {
        if (!fboHelper.renderer)
            return;
        this.scene = $,
        this.camera = tt,
        this.mesh.geometry = this.geom;
        const rt = this.queue.filter(this._filterQueue)
          , it = this.sharedUniforms;
        if (it.u_sceneTexture.value = this.sceneRenderTarget.texture,
        it.u_cameraNear.value = tt.near,
        it.u_cameraFar.value = tt.far,
        it.u_cameraFovRad.value = tt.fov / 180 * Math.PI,
        this.onBeforeSceneRendered.dispatch(),
        rt.length) {
            const ot = fboHelper.getColorState();
            fboHelper.renderer.setClearColor(16777215, 1),
            fboHelper.renderer.setRenderTarget(this.sceneRenderTarget),
            fboHelper.renderer.render($, tt),
            fboHelper.renderer.autoClearDepth = !1,
            this.onBeforeSceneRenderedSecondTime.dispatch(),
            fboHelper.renderer.render($, tt),
            fboHelper.renderer.autoClearDepth = !0,
            this.onAfterSceneRendered.dispatch(this.sceneRenderTarget),
            fboHelper.renderer.autoClear = !1;
            for (let st = 0, lt = rt.length; st < lt; st++) {
                const ut = st === lt - 1 && nt
                  , ct = rt[st];
                ct.setPostprocessing(this),
                ct.render(this, ut)
            }
            fboHelper.setColorState(ot)
        } else
            fboHelper.renderer.render($, tt),
            this.onAfterSceneRendered.dispatch();
        this.onAfterRendered.dispatch(),
        this.hasSizeChanged = !1
    }
}
class PostEffect {
    constructor() {
        Et(this, "sharedUniforms", {});
        Et(this, "enabled", !0);
        Et(this, "material", null);
        Et(this, "_hasShownWarning", !1)
    }
    init($) {
        Object.assign(this, $)
    }
    createRawShaderMaterial($) {
        return $ = Object.assign({
            depthTest: !1,
            depthWrite: !1,
            blending: NoBlending,
            vertexShader: blitVert,
            fragmentShader: blitFrag
        }, $),
        $.vertexShader = ($.vertexShaderPrefix !== void 0 ? $.vertexShaderPrefix : fboHelper.precisionPrefix) + $.vertexShader,
        $.fragmentShader = ($.fragmentShaderPrefix !== void 0 ? $.fragmentShaderPrefix : fboHelper.precisionPrefix) + $.fragmentShader,
        delete $.vertexShaderPrefix,
        delete $.fragmentShaderPrefix,
        new RawShaderMaterial($)
    }
    needsRender() {
        return !0
    }
    warn($) {
        this._hasShownWarning || (console.warn($),
        this._hasShownWarning = !0)
    }
    setPostprocessing($) {}
    render($, tt=!1) {
        this.material.uniforms.u_texture && (this.material.uniforms.u_texture.value = $.fromTexture),
        fboHelper.render(this.material, tt ? null : $.toRenderTarget),
        $.swap()
    }
}
var easuFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec2 u_inResolution;uniform vec2 u_outResolution;vec4 FsrEasuCF(vec2 p){return texture2D(u_texture,p);}void FsrEasuCon(out vec4 con0,out vec4 con1,out vec4 con2,out vec4 con3,vec2 inputViewportInPixels,vec2 inputSizeInPixels,vec2 outputSizeInPixels){con0=vec4(inputViewportInPixels.x/outputSizeInPixels.x,inputViewportInPixels.y/outputSizeInPixels.y,.5*inputViewportInPixels.x/outputSizeInPixels.x-.5,.5*inputViewportInPixels.y/outputSizeInPixels.y-.5);con1=vec4(1,1,1,-1)/inputSizeInPixels.xyxy;con2=vec4(-1,2,1,2)/inputSizeInPixels.xyxy;con3=vec4(0,4,0,0)/inputSizeInPixels.xyxy;}void FsrEasuTapF(inout vec4 aC,inout float aW,vec2 off,vec2 dir,vec2 len,float lob,float clp,vec4 c){vec2 v=vec2(dot(off,dir),dot(off,vec2(-dir.y,dir.x)));v*=len;float d2=min(dot(v,v),clp);float wB=.4*d2-1.;float wA=lob*d2-1.;wB*=wB;wA*=wA;wB=1.5625*wB-.5625;float w=wB*wA;aC+=c*w;aW+=w;}void FsrEasuSetF(inout vec2 dir,inout float len,float w,float lA,float lB,float lC,float lD,float lE){float lenX=max(abs(lD-lC),abs(lC-lB));float dirX=lD-lB;dir.x+=dirX*w;lenX=clamp(abs(dirX)/lenX,0.,1.);lenX*=lenX;len+=lenX*w;float lenY=max(abs(lE-lC),abs(lC-lA));float dirY=lE-lA;dir.y+=dirY*w;lenY=clamp(abs(dirY)/lenY,0.,1.);lenY*=lenY;len+=lenY*w;}void FsrEasuF(out vec4 pix,vec2 ip,vec4 con0,vec4 con1,vec4 con2,vec4 con3){vec2 pp=ip*con0.xy+con0.zw;vec2 fp=floor(pp);pp-=fp;vec2 p0=fp*con1.xy+con1.zw;vec2 p1=p0+con2.xy;vec2 p2=p0+con2.zw;vec2 p3=p0+con3.xy;vec4 off=vec4(-.5,.5,-.5,.5)*con1.xxyy;vec4 bC=FsrEasuCF(p0+off.xw);float bL=bC.g+0.5*(bC.r+bC.b);vec4 cC=FsrEasuCF(p0+off.yw);float cL=cC.g+0.5*(cC.r+cC.b);vec4 iC=FsrEasuCF(p1+off.xw);float iL=iC.g+0.5*(iC.r+iC.b);vec4 jC=FsrEasuCF(p1+off.yw);float jL=jC.g+0.5*(jC.r+jC.b);vec4 fC=FsrEasuCF(p1+off.yz);float fL=fC.g+0.5*(fC.r+fC.b);vec4 eC=FsrEasuCF(p1+off.xz);float eL=eC.g+0.5*(eC.r+eC.b);vec4 kC=FsrEasuCF(p2+off.xw);float kL=kC.g+0.5*(kC.r+kC.b);vec4 lC=FsrEasuCF(p2+off.yw);float lL=lC.g+0.5*(lC.r+lC.b);vec4 hC=FsrEasuCF(p2+off.yz);float hL=hC.g+0.5*(hC.r+hC.b);vec4 gC=FsrEasuCF(p2+off.xz);float gL=gC.g+0.5*(gC.r+gC.b);vec4 oC=FsrEasuCF(p3+off.yz);float oL=oC.g+0.5*(oC.r+oC.b);vec4 nC=FsrEasuCF(p3+off.xz);float nL=nC.g+0.5*(nC.r+nC.b);vec2 dir=vec2(0.);float len=0.;FsrEasuSetF(dir,len,(1.-pp.x)*(1.-pp.y),bL,eL,fL,gL,jL);FsrEasuSetF(dir,len,pp.x*(1.-pp.y),cL,fL,gL,hL,kL);FsrEasuSetF(dir,len,(1.-pp.x)*pp.y,fL,iL,jL,kL,nL);FsrEasuSetF(dir,len,pp.x*pp.y,gL,jL,kL,lL,oL);vec2 dir2=dir*dir;float dirR=dir2.x+dir2.y;bool zro=dirR<(1./32768.);dirR=inversesqrt(dirR);dirR=zro ? 1. : dirR;dir.x=zro ? 1. : dir.x;dir*=vec2(dirR);len=len*.5;len*=len;float stretch=dot(dir,dir)/(max(abs(dir.x),abs(dir.y)));vec2 len2=vec2(1.+(stretch-1.0)*len,1.-.5*len);float lob=.5-.29*len;float clp=1./lob;vec4 min4=min(min(fC,gC),min(jC,kC));vec4 max4=max(max(fC,gC),max(jC,kC));vec4 aC=vec4(0);float aW=0.;FsrEasuTapF(aC,aW,vec2(0.,-1.)-pp,dir,len2,lob,clp,bC);FsrEasuTapF(aC,aW,vec2(1.,-1.)-pp,dir,len2,lob,clp,cC);FsrEasuTapF(aC,aW,vec2(-1.,1.)-pp,dir,len2,lob,clp,iC);FsrEasuTapF(aC,aW,vec2(0.,1.)-pp,dir,len2,lob,clp,jC);FsrEasuTapF(aC,aW,vec2(0.,0.)-pp,dir,len2,lob,clp,fC);FsrEasuTapF(aC,aW,vec2(-1.,0.)-pp,dir,len2,lob,clp,eC);FsrEasuTapF(aC,aW,vec2(1.,1.)-pp,dir,len2,lob,clp,kC);FsrEasuTapF(aC,aW,vec2(2.,1.)-pp,dir,len2,lob,clp,lC);FsrEasuTapF(aC,aW,vec2(2.,0.)-pp,dir,len2,lob,clp,hC);FsrEasuTapF(aC,aW,vec2(1.,0.)-pp,dir,len2,lob,clp,gC);FsrEasuTapF(aC,aW,vec2(1.,2.)-pp,dir,len2,lob,clp,oC);FsrEasuTapF(aC,aW,vec2(0.,2.)-pp,dir,len2,lob,clp,nC);pix=min(max4,max(min4,aC/aW));}void main(){vec4 c;vec4 con0,con1,con2,con3;FsrEasuCon(con0,con1,con2,con3,u_inResolution,u_inResolution,u_outResolution);FsrEasuF(c,gl_FragCoord.xy,con0,con1,con2,con3);gl_FragColor=c;}`
  , frag$2 = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec2 u_outResolution;uniform float u_sharpness;
#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))
vec4 FsrRcasLoadF(vec2 p);void FsrRcasCon(out float con,float sharpness){con=exp2(-sharpness);}vec4 FsrRcasF(vec2 ip,float con){vec2 sp=vec2(ip);vec4 b=FsrRcasLoadF(sp+vec2(0,-1));vec4 d=FsrRcasLoadF(sp+vec2(-1,0));vec4 e=FsrRcasLoadF(sp);vec4 f=FsrRcasLoadF(sp+vec2(1,0));vec4 h=FsrRcasLoadF(sp+vec2(0,1));float bL=b.g+.5*(b.b+b.r);float dL=d.g+.5*(d.b+d.r);float eL=e.g+.5*(e.b+e.r);float fL=f.g+.5*(f.b+f.r);float hL=h.g+.5*(h.b+h.r);float nz=.25*(bL+dL+fL+hL)-eL;nz=clamp(abs(nz)/(max(max(bL,dL),max(eL,max(fL,hL)))-min(min(bL,dL),min(eL,min(fL,hL)))),0.,1.);nz=1.-.5*nz;vec4 mn4=min(b,min(f,h));vec4 mx4=max(b,max(f,h));vec2 peakC=vec2(1.,-4.);vec4 hitMin=mn4/(4.*mx4);vec4 hitMax=(peakC.x-mx4)/(4.*mn4+peakC.y);vec4 lobeRGB=max(-hitMin,hitMax);float lobe=max(-FSR_RCAS_LIMIT,min(max(lobeRGB.r,max(lobeRGB.g,lobeRGB.b)),0.))*con;
#ifdef FSR_RCAS_DENOISE
lobe*=nz;
#endif
return(lobe*(b+d+h+f)+e)/(4.*lobe+1.);}vec4 FsrRcasLoadF(vec2 p){return texture2D(u_texture,p/u_outResolution.xy);}void main(){vec2 uv=gl_FragCoord.xy/u_outResolution.xy;float con;FsrRcasCon(con,u_sharpness);vec4 col=FsrRcasF(gl_FragCoord.xy,con);gl_FragColor=col;}`;
class Fsr {
    constructor() {
        Et(this, "sharpness", 1);
        Et(this, "_easuMaterial");
        Et(this, "_material");
        Et(this, "_inResolution", new Vector2);
        Et(this, "_outResolution", new Vector2);
        Et(this, "_cacheRenderTarget", null);
        this._cacheRenderTarget = fboHelper.createRenderTarget(1, 1),
        this._easuMaterial = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_inResolution: {
                    value: this._inResolution
                },
                u_outResolution: {
                    value: this._outResolution
                }
            },
            fragmentShader: easuFrag
        }),
        this._material = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: this._cacheRenderTarget.texture
                },
                u_outResolution: this._easuMaterial.uniforms.u_outResolution,
                u_sharpness: {
                    value: 0
                }
            },
            fragmentShader: frag$2
        })
    }
    render($, tt) {
        let nt = $.image.width
          , rt = $.image.height;
        this._material.uniforms.u_sharpness.value = this.sharpness,
        (this._inResolution.width !== nt || this._inResolution.height !== rt) && this._inResolution.set(nt, rt);
        let it, ot;
        tt ? (it = tt.width,
        ot = tt.height) : (it = fboHelper.renderer.domElement.width,
        ot = fboHelper.renderer.domElement.height),
        (this._outResolution.width !== it || this._outResolution.height !== ot) && (this._outResolution.set(it, ot),
        this._cacheRenderTarget.setSize(it, ot)),
        this._easuMaterial.uniforms.u_texture.value = $,
        fboHelper.render(this._easuMaterial, this._cacheRenderTarget),
        tt || (fboHelper.renderer.setRenderTarget(null),
        fboHelper.renderer.setViewport(0, 0, this._outResolution.x, this._outResolution.y)),
        fboHelper.render(this._material, tt)
    }
}
var smaaBlendVert = `#define GLSLIFY 1
attribute vec3 position;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[2];void SMAANeighborhoodBlendingVS(vec2 texcoord){v_offsets[0]=texcoord.xyxy+u_texelSize.xyxy*vec4(-1.0,0.0,0.0,1.0);v_offsets[1]=texcoord.xyxy+u_texelSize.xyxy*vec4(1.0,0.0,0.0,-1.0);}void main(){v_uv=position.xy*0.5+0.5;SMAANeighborhoodBlendingVS(v_uv);gl_Position=vec4(position,1.0);}`
  , smaaBlendFrag = `#define GLSLIFY 1
uniform sampler2D u_weightsTexture;uniform sampler2D u_texture;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[2];vec4 SMAANeighborhoodBlendingPS(vec2 texcoord,vec4 offset[2],sampler2D colorTex,sampler2D blendTex){vec4 a;a.xz=texture2D(blendTex,texcoord).xz;a.y=texture2D(blendTex,offset[1].zw).g;a.w=texture2D(blendTex,offset[1].xy).a;if(dot(a,vec4(1.0,1.0,1.0,1.0))<1e-5){return texture2D(colorTex,texcoord,0.0);}else{vec2 offset;offset.x=a.a>a.b ? a.a :-a.b;offset.y=a.g>a.r ?-a.g : a.r;if(abs(offset.x)>abs(offset.y)){offset.y=0.0;}else{offset.x=0.0;}vec4 C=texture2D(colorTex,texcoord,0.0);texcoord+=sign(offset)*u_texelSize;vec4 Cop=texture2D(colorTex,texcoord,0.0);float s=abs(offset.x)>abs(offset.y)? abs(offset.x): abs(offset.y);C.xyz=pow(abs(C.xyz),vec3(2.2));Cop.xyz=pow(abs(Cop.xyz),vec3(2.2));vec4 mixed=mix(C,Cop,s);mixed.xyz=pow(abs(mixed.xyz),vec3(1.0/2.2));return mixed;}}void main(){gl_FragColor=SMAANeighborhoodBlendingPS(v_uv,v_offsets,u_texture,u_weightsTexture);}`
  , smaaEdgesVert = `#define GLSLIFY 1
attribute vec3 position;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[3];void SMAAEdgeDetectionVS(vec2 texcoord){v_offsets[0]=texcoord.xyxy+u_texelSize.xyxy*vec4(-1.0,0.0,0.0,1.0);v_offsets[1]=texcoord.xyxy+u_texelSize.xyxy*vec4(1.0,0.0,0.0,-1.0);v_offsets[2]=texcoord.xyxy+u_texelSize.xyxy*vec4(-2.0,0.0,0.0,2.0);}void main(){v_uv=position.xy*0.5+0.5;SMAAEdgeDetectionVS(v_uv);gl_Position=vec4(position,1.0);}`
  , smaaEdgesFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;varying vec2 v_uv;varying vec4 v_offsets[3];vec4 SMAAColorEdgeDetectionPS(vec2 texcoord,vec4 offset[3],sampler2D colorTex){vec2 threshold=vec2(SMAA_THRESHOLD,SMAA_THRESHOLD);vec4 delta;vec3 C=texture2D(colorTex,texcoord).rgb;vec3 Cleft=texture2D(colorTex,offset[0].xy).rgb;vec3 t=abs(C-Cleft);delta.x=max(max(t.r,t.g),t.b);vec3 Ctop=texture2D(colorTex,offset[0].zw).rgb;t=abs(C-Ctop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0,1.0))==0.0)discard;vec3 Cright=texture2D(colorTex,offset[1].xy).rgb;t=abs(C-Cright);delta.z=max(max(t.r,t.g),t.b);vec3 Cbottom=texture2D(colorTex,offset[1].zw).rgb;t=abs(C-Cbottom);delta.w=max(max(t.r,t.g),t.b);float maxDelta=max(max(max(delta.x,delta.y),delta.z),delta.w);vec3 Cleftleft=texture2D(colorTex,offset[2].xy).rgb;t=abs(C-Cleftleft);delta.z=max(max(t.r,t.g),t.b);vec3 Ctoptop=texture2D(colorTex,offset[2].zw).rgb;t=abs(C-Ctoptop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(max(maxDelta,delta.z),delta.w);edges.xy*=step(0.5*maxDelta,delta.xy);return vec4(edges,0.0,0.0);}void main(){gl_FragColor=SMAAColorEdgeDetectionPS(v_uv,v_offsets,u_texture);}`
  , smaaWeightsVert = `#define GLSLIFY 1
attribute vec3 position;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[3];varying vec2 v_pixcoord;void SMAABlendingWeightCalculationVS(vec2 texcoord){v_pixcoord=texcoord/u_texelSize;v_offsets[0]=texcoord.xyxy+u_texelSize.xyxy*vec4(-0.25,0.125,1.25,0.125);v_offsets[1]=texcoord.xyxy+u_texelSize.xyxy*vec4(-0.125,0.25,-0.125,-1.25);v_offsets[2]=vec4(v_offsets[0].xz,v_offsets[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*u_texelSize.xxyy*float(SMAA_MAX_SEARCH_STEPS);}void main(){v_uv=position.xy*0.5+0.5;SMAABlendingWeightCalculationVS(v_uv);gl_Position=vec4(position,1.0);}`
  , smaaWeightsFrag = `#define GLSLIFY 1
#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * u_texelSize, 0.0 )
uniform sampler2D u_edgesTexture;uniform sampler2D u_areaTexture;uniform sampler2D u_searchTexture;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[3];varying vec2 v_pixcoord;vec2 round(vec2 x){return sign(x)*floor(abs(x)+0.5);}float SMAASearchLength(sampler2D searchTex,vec2 e,float bias,float scale){e.r=bias+e.r*scale;return 255.0*texture2D(searchTex,e,0.0).r;}float SMAASearchXLeft(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord-=vec2(2.0,0.0)*u_texelSize;if(!(texcoord.x>end&&e.g>0.8281&&e.r==0.0))break;}texcoord.x+=0.25*u_texelSize.x;texcoord.x+=u_texelSize.x;texcoord.x+=2.0*u_texelSize.x;texcoord.x-=u_texelSize.x*SMAASearchLength(searchTex,e,0.0,0.5);return texcoord.x;}float SMAASearchXRight(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord+=vec2(2.0,0.0)*u_texelSize;if(!(texcoord.x<end&&e.g>0.8281&&e.r==0.0))break;}texcoord.x-=0.25*u_texelSize.x;texcoord.x-=u_texelSize.x;texcoord.x-=2.0*u_texelSize.x;texcoord.x+=u_texelSize.x*SMAASearchLength(searchTex,e,0.5,0.5);return texcoord.x;}float SMAASearchYUp(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord+=vec2(0.0,2.0)*u_texelSize;if(!(texcoord.y>end&&e.r>0.8281&&e.g==0.0))break;}texcoord.y-=0.25*u_texelSize.y;texcoord.y-=u_texelSize.y;texcoord.y-=2.0*u_texelSize.y;texcoord.y+=u_texelSize.y*SMAASearchLength(searchTex,e.gr,0.0,0.5);return texcoord.y;}float SMAASearchYDown(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord-=vec2(0.0,2.0)*u_texelSize;if(!(texcoord.y<end&&e.r>0.8281&&e.g==0.0))break;}texcoord.y+=0.25*u_texelSize.y;texcoord.y+=u_texelSize.y;texcoord.y+=2.0*u_texelSize.y;texcoord.y-=u_texelSize.y*SMAASearchLength(searchTex,e.gr,0.5,0.5);return texcoord.y;}vec2 SMAAArea(sampler2D areaTex,vec2 dist,float e1,float e2,float offset){vec2 texcoord=float(SMAA_AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texcoord=SMAA_AREATEX_PIXEL_SIZE*texcoord+(0.5*SMAA_AREATEX_PIXEL_SIZE);texcoord.y+=SMAA_AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTex,texcoord,0.0).rg;}vec4 SMAABlendingWeightCalculationPS(vec2 texcoord,vec2 pixcoord,vec4 offset[3],sampler2D edgesTex,sampler2D areaTex,sampler2D searchTex,ivec4 subsampleIndices){vec4 weights=vec4(0.0,0.0,0.0,0.0);vec2 e=texture2D(edgesTex,texcoord).rg;if(e.g>0.0){vec2 d;vec2 coords;coords.x=SMAASearchXLeft(edgesTex,searchTex,offset[0].xy,offset[2].x);coords.y=offset[1].y;d.x=coords.x;float e1=texture2D(edgesTex,coords,0.0).r;coords.x=SMAASearchXRight(edgesTex,searchTex,offset[0].zw,offset[2].y);d.y=coords.x;d=d/u_texelSize.x-pixcoord.x;vec2 sqrt_d=sqrt(abs(d));coords.y-=1.0*u_texelSize.y;float e2=SMAASampleLevelZeroOffset(edgesTex,coords,ivec2(1,0)).r;weights.rg=SMAAArea(areaTex,sqrt_d,e1,e2,float(subsampleIndices.y));}if(e.r>0.0){vec2 d;vec2 coords;coords.y=SMAASearchYUp(edgesTex,searchTex,offset[1].xy,offset[2].z);coords.x=offset[0].x;d.x=coords.y;float e1=texture2D(edgesTex,coords,0.0).g;coords.y=SMAASearchYDown(edgesTex,searchTex,offset[1].zw,offset[2].w);d.y=coords.y;d=d/u_texelSize.y-pixcoord.y;vec2 sqrt_d=sqrt(abs(d));coords.y-=1.0*u_texelSize.y;float e2=SMAASampleLevelZeroOffset(edgesTex,coords,ivec2(0,1)).g;weights.ba=SMAAArea(areaTex,sqrt_d,e1,e2,float(subsampleIndices.x));}return weights;}void main(){gl_FragColor=SMAABlendingWeightCalculationPS(v_uv,v_pixcoord,v_offsets,u_edgesTexture,u_areaTexture,u_searchTexture,ivec4(0.0));}`;
class Smaa extends PostEffect {
    constructor() {
        super(...arguments);
        Et(this, "edgesRenderTarget", null);
        Et(this, "weightsRenderTarget", null);
        Et(this, "edgesMaterial", null);
        Et(this, "weightsMaterial", null);
        Et(this, "fsr", !0)
    }
    init(tt) {
        Object.assign(this, {
            sharedUniforms: {
                u_areaTexture: {
                    value: null
                },
                u_searchTexture: {
                    value: null
                }
            }
        }, tt),
        super.init(),
        this.fsr = new Fsr,
        this.weightsRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.edgesRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.edgesMaterial = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_texelSize: null
            },
            vertexShader: fboHelper.precisionPrefix + smaaEdgesVert,
            fragmentShader: fboHelper.precisionPrefix + smaaEdgesFrag,
            defines: {
                SMAA_THRESHOLD: "0.1"
            },
            blending: NoBlending,
            depthTest: !1,
            depthWrite: !1
        }),
        this.weightsMaterial = new RawShaderMaterial({
            uniforms: {
                u_edgesTexture: {
                    value: this.edgesRenderTarget.texture
                },
                u_areaTexture: this.sharedUniforms.u_areaTexture,
                u_searchTexture: this.sharedUniforms.u_searchTexture,
                u_texelSize: null
            },
            vertexShader: fboHelper.precisionPrefix + smaaWeightsVert,
            fragmentShader: fboHelper.precisionPrefix + smaaWeightsFrag,
            defines: {
                SMAA_MAX_SEARCH_STEPS: "8",
                SMAA_AREATEX_MAX_DISTANCE: "16",
                SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
                SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
            },
            transparent: !0,
            blending: NoBlending,
            depthTest: !1,
            depthWrite: !1
        }),
        this.material = this.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_weightsTexture: {
                    value: this.weightsRenderTarget.texture
                },
                u_texelSize: null
            },
            vertexShader: fboHelper.precisionPrefix + smaaBlendVert,
            fragmentShader: fboHelper.precisionPrefix + smaaBlendFrag
        })
    }
    setTextures(tt, nt) {
        const rt = this.sharedUniforms.u_areaTexture.value = this._createTexture(tt);
        rt.format = RGBAFormat,
        rt.minFilter = LinearFilter;
        const it = this.sharedUniforms.u_searchTexture.value = this._createTexture(nt);
        it.magFilter = NearestFilter,
        it.minFilter = NearestFilter
    }
    updateTextures() {
        this.sharedUniforms.u_areaTexture.value.needsUpdate = !0,
        this.sharedUniforms.u_searchTexture.value.needsUpdate = !0
    }
    setPostprocessing(tt) {
        super.setPostprocessing(tt),
        this.edgesRenderTarget.setSize(tt.sceneRenderTarget.width, tt.sceneRenderTarget.height),
        this.weightsRenderTarget.setSize(tt.sceneRenderTarget.width, tt.sceneRenderTarget.height)
    }
    dispose() {
        this.edgesRenderTarget && this.edgesRenderTarget.dispose(),
        this.weightsRenderTarget && this.weightsRenderTarget.dispose()
    }
    needsRender() {
        return !this.sharedUniforms.u_areaTexture.value.needsUpdate
    }
    render(tt, nt) {
        const rt = fboHelper.getColorState();
        this.sharedUniforms.u_searchTexture.value || console.warn("You need to use Smaa.setImages() to set the smaa textures manually and assign to this class.");
        const it = fboHelper.renderer;
        it && (it.autoClear = !0,
        it.setClearColor(0, 0)),
        this.edgesMaterial.uniforms.u_texelSize = this.weightsMaterial.uniforms.u_texelSize = this.material.uniforms.u_texelSize = tt.sharedUniforms.u_texelSizeScaled,
        this.edgesMaterial.uniforms.u_texture.value = tt.sceneRenderTarget.texture,
        tt.renderMaterial(this.edgesMaterial, this.edgesRenderTarget),
        tt.renderMaterial(this.weightsMaterial, this.weightsRenderTarget),
        fboHelper.setColorState(rt),
        this.material.uniforms.u_texture.value = tt.sceneRenderTarget.texture,
        this.material.uniforms.u_texture && (this.material.uniforms.u_texture.value = tt.sceneRenderTarget.texture),
        fboHelper.render(this.material, tt.tempSceneRenderTarget),
        this.fsr.render(tt.tempSceneRenderTarget.texture, tt.fromRenderTarget)
    }
    _createTexture(tt) {
        const nt = new Texture(tt);
        return nt.generateMipmaps = !1,
        nt.flipY = !1,
        nt
    }
}
var fragmentShader$1 = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform sampler2D u_blurTexture0;
#if ITERATION > 1
uniform sampler2D u_blurTexture1;
#endif
#if ITERATION > 2
uniform sampler2D u_blurTexture2;
#endif
#if ITERATION > 3
uniform sampler2D u_blurTexture3;
#endif
#if ITERATION > 4
uniform sampler2D u_blurTexture4;
#endif
uniform float u_bloomWeights[ITERATION];
#include <common>
vec3 dithering(vec3 color){float grid_position=rand(gl_FragCoord.xy);vec3 dither_shift_RGB=vec3(0.25/255.0,-0.25/255.0,0.25/255.0);dither_shift_RGB=mix(2.0*dither_shift_RGB,-2.0*dither_shift_RGB,grid_position);return color+dither_shift_RGB;}void main(){vec4 c=texture2D(u_texture,v_uv);vec3 luma=vec3(0.299,0.587,0.114);float v=dot(c.xyz,luma);float a=1.0-v;gl_FragColor=c+(u_bloomWeights[0]*texture2D(u_blurTexture0,v_uv)
#if ITERATION > 1
+u_bloomWeights[1]*texture2D(u_blurTexture1,v_uv)
#endif
#if ITERATION > 2
+u_bloomWeights[2]*texture2D(u_blurTexture2,v_uv)
#endif
#if ITERATION > 3
+u_bloomWeights[3]*texture2D(u_blurTexture3,v_uv)
#endif
#if ITERATION > 4
+u_bloomWeights[4]*texture2D(u_blurTexture4,v_uv)
#endif
)*a;gl_FragColor.rgb=dithering(gl_FragColor.rgb);gl_FragColor.a=1.0;}`
  , highPassFragmentShader = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform float u_luminosityThreshold;uniform float u_smoothWidth;
#ifdef USE_HALO
uniform vec2 u_texelSize;uniform vec2 u_aspect;uniform float u_haloWidth;uniform float u_haloRGBShift;uniform float u_haloStrength;uniform float u_haloMaskInner;uniform float u_haloMaskOuter;
#endif
varying vec2 v_uv;void main(){vec4 texel=texture2D(u_texture,v_uv);vec3 luma=vec3(0.299,0.587,0.114);float v=dot(texel.xyz,luma);vec4 outputColor=vec4(0.0,0.0,0.0,1.0);float alpha=smoothstep(u_luminosityThreshold,u_luminosityThreshold+u_smoothWidth,v);outputColor=mix(outputColor,texel,alpha);gl_FragColor=vec4(outputColor.rgb,1.0);
#ifdef USE_HALO
vec2 toCenter=(v_uv-0.5)*u_aspect;vec2 ghostUv=1.0-(toCenter+0.5);vec2 ghostVec=(vec2(0.5)-ghostUv);vec2 direction=normalize(ghostVec);vec2 haloVec=direction*u_haloWidth;float weight=length(vec2(0.5)-fract(ghostUv+haloVec));weight=pow(1.0-weight,3.0);vec3 distortion=vec3(-u_texelSize.x,0.0,u_texelSize.x)*u_haloRGBShift;vec2 uv=ghostUv+haloVec;gl_FragColor.rgb+=vec3(texture2D(u_texture,uv+direction*distortion.r).r,texture2D(u_texture,uv+direction*distortion.g).g,texture2D(u_texture,uv+direction*distortion.b).b)*u_haloStrength*smoothstep(u_haloMaskInner,u_haloMaskOuter,length(toCenter));
#endif
}`
  , blurFragmentShader = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform vec2 u_resolution;uniform vec2 u_direction;float gaussianPdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}void main(){vec2 invSize=1.0/u_resolution;float fSigma=float(SIGMA);float weightSum=gaussianPdf(0.0,fSigma);vec3 diffuseSum=texture2D(u_texture,v_uv).rgb*weightSum;for(int i=1;i<KERNEL_RADIUS;i++){float x=float(i);float w=gaussianPdf(x,fSigma);vec2 uvOffset=u_direction*invSize*x;vec3 sample1=texture2D(u_texture,v_uv+uvOffset).rgb;vec3 sample2=texture2D(u_texture,v_uv-uvOffset).rgb;diffuseSum+=(sample1+sample2)*w;weightSum+=2.0*w;}gl_FragColor=vec4(diffuseSum/weightSum,1.0);}`;
class Bloom extends PostEffect {
    constructor() {
        super(...arguments);
        Et(this, "ITERATION", 5);
        Et(this, "amount", 1);
        Et(this, "radius", 0);
        Et(this, "threshold", .1);
        Et(this, "smoothWidth", 1);
        Et(this, "haloWidth", .8);
        Et(this, "haloRGBShift", .03);
        Et(this, "haloStrength", .21);
        Et(this, "haloMaskInner", .3);
        Et(this, "haloMaskOuter", .5);
        Et(this, "highPassMaterial");
        Et(this, "highPassRenderTarget");
        Et(this, "renderTargetsHorizontal", []);
        Et(this, "renderTargetsVertical", []);
        Et(this, "blurMaterials", []);
        Et(this, "directionX", new Vector2(1,0));
        Et(this, "directionY", new Vector2(0,1))
    }
    init(tt) {
        Object.assign(this, tt),
        super.init(),
        this.highPassRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.highPassMaterial = this.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_luminosityThreshold: {
                    value: 1
                },
                u_smoothWidth: {
                    value: 1
                },
                u_haloWidth: {
                    value: 1
                },
                u_haloRGBShift: {
                    value: 1
                },
                u_haloStrength: {
                    value: 1
                },
                u_haloMaskInner: {
                    value: 1
                },
                u_haloMaskOuter: {
                    value: 1
                },
                u_texelSize: null,
                u_aspect: null
            },
            fragmentShader: highPassFragmentShader
        });
        for (let nt = 0; nt < this.ITERATION; nt++) {
            this.renderTargetsHorizontal.push(this.highPassRenderTarget.clone()),
            this.renderTargetsVertical.push(this.highPassRenderTarget.clone());
            const rt = 3 + nt * 2;
            this.blurMaterials[nt] = this.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_resolution: {
                        value: new Vector2
                    },
                    u_direction: {
                        value: null
                    }
                },
                fragmentShader: blurFragmentShader,
                defines: {
                    KERNEL_RADIUS: rt,
                    SIGMA: rt
                }
            })
        }
        this.material = this.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_bloomStrength: {
                    value: 1
                },
                u_bloomWeights: {
                    value: []
                }
            },
            fragmentShader: fragmentShader$1,
            blending: NoBlending,
            defines: {
                ITERATION: this.ITERATION
            }
        });
        for (let nt = 0; nt < this.ITERATION; nt++)
            this.material.uniforms["u_blurTexture" + nt] = {
                value: this.renderTargetsVertical[nt].texture
            }
    }
    setPostprocessing(tt) {
        super.setPostprocessing(tt);
        const nt = tt.width
          , rt = tt.height;
        let it = Math.ceil(nt / 2)
          , ot = Math.ceil(rt / 2);
        this.highPassRenderTarget.setSize(it, ot);
        for (let st = 0; st < this.ITERATION; st++)
            this.renderTargetsHorizontal[st].setSize(it, ot),
            this.renderTargetsVertical[st].setSize(it, ot),
            this.blurMaterials[st].uniforms.u_resolution.value.set(it, ot),
            it = Math.ceil(it / 2),
            ot = Math.ceil(ot / 2)
    }
    dispose() {
        this.highPassRenderTarget && this.highPassRenderTarget.dispose();
        for (let tt = 0; tt < this.ITERATION; tt++)
            this.renderTargetsHorizontal[tt] && this.renderTargetsHorizontal[tt].dispose(),
            this.renderTargetsVertical[tt] && this.renderTargetsVertical[tt].dispose()
    }
    needsRender() {
        return !!this.amount
    }
    render(tt, nt=!1) {
        this.highPassMaterial.uniforms.u_texture.value = tt.fromTexture,
        this.highPassMaterial.uniforms.u_luminosityThreshold.value = this.threshold,
        this.highPassMaterial.uniforms.u_smoothWidth.value = this.smoothWidth,
        this.highPassMaterial.uniforms.u_haloWidth.value = this.haloWidth,
        this.highPassMaterial.uniforms.u_haloRGBShift.value = this.haloRGBShift * tt.width,
        this.highPassMaterial.uniforms.u_haloStrength.value = this.haloStrength,
        this.highPassMaterial.uniforms.u_haloMaskInner.value = this.haloMaskInner,
        this.highPassMaterial.uniforms.u_haloMaskOuter.value = this.haloMaskOuter,
        this.highPassMaterial.uniforms.u_texelSize = tt.sharedUniforms.u_texelSize,
        this.highPassMaterial.uniforms.u_aspect = tt.sharedUniforms.u_aspect;
        let rt = this.haloStrength > 0;
        this.highPassMaterial.defines.USE_HALO !== rt && (this.highPassMaterial.defines.USE_HALO = rt,
        this.highPassMaterial.needsUpdate = !0),
        tt.renderMaterial(this.highPassMaterial, this.highPassRenderTarget);
        let it = this.highPassRenderTarget;
        for (let ot = 0; ot < this.ITERATION; ot++) {
            const st = this.blurMaterials[ot];
            st.uniforms.u_texture.value = it.texture,
            st.uniforms.u_direction.value = this.directionX,
            tt.renderMaterial(st, this.renderTargetsHorizontal[ot]),
            st.uniforms.u_texture.value = this.renderTargetsHorizontal[ot].texture,
            st.uniforms.u_direction.value = this.directionY,
            tt.renderMaterial(st, this.renderTargetsVertical[ot]),
            it = this.renderTargetsVertical[ot]
        }
        this.material.uniforms.u_texture.value = tt.fromTexture;
        for (let ot = 0; ot < this.ITERATION; ot++) {
            const st = (this.ITERATION - ot) / this.ITERATION;
            this.material.uniforms.u_bloomWeights.value[ot] = this.amount * (st + (1.2 - st * 2) * this.radius) / Math.pow(2, this.ITERATION - ot - 1)
        }
        super.render(tt, nt)
    }
}
class ShaderHelper {
    glslifyStrip($) {
        return $.replace(/#define\sGLSLIFY\s./, "")
    }
    addChunk($, tt) {
        ShaderChunk[$] = this.glslifyStrip(tt)
    }
    _wrapInclude($) {
        return "#include <" + $ + ">"
    }
    insertBefore($, tt, nt, rt) {
        const it = rt ? this._wrapInclude(tt) : tt;
        return $.replace(tt, this.glslifyStrip(nt) + `
` + it)
    }
    insertAfter($, tt, nt, rt) {
        const it = rt ? this._wrapInclude(tt) : tt;
        return $.replace(it, it + `
` + this.glslifyStrip(nt) + `
`)
    }
    replace($, tt, nt, rt) {
        const it = rt ? this._wrapInclude(tt) : tt;
        return $.replace(it, `
` + this.glslifyStrip(nt) + `
`)
    }
}
var shaderHelper = new ShaderHelper
  , getBlueNoiseShader = `#define GLSLIFY 1
uniform sampler2D u_blueNoiseTexture;uniform vec2 u_blueNoiseTexelSize;uniform vec2 u_blueNoiseCoordOffset;vec3 getBlueNoise(vec2 coord){return texture2D(u_blueNoiseTexture,coord*u_blueNoiseTexelSize+u_blueNoiseCoordOffset).rgb;}vec3 getStaticBlueNoise(vec2 coord){return texture2D(u_blueNoiseTexture,coord*u_blueNoiseTexelSize).rgb;}`;
class BlueNoise {
    constructor() {
        Et(this, "sharedUniforms", {
            u_blueNoiseTexture: {
                value: null
            },
            u_blueNoiseLinearTexture: {
                value: null
            },
            u_blueNoiseTexelSize: {
                value: null
            },
            u_blueNoiseCoordOffset: {
                value: new Vector2
            }
        });
        Et(this, "TEXTURE_SIZE", 128)
    }
    preInit() {
        let $ = new Texture;
        $.generateMipmaps = !1,
        $.minFilter = $.magFilter = LinearFilter,
        $.wrapS = $.wrapT = RepeatWrapping;
        let tt = new Texture(properties.loader.add(settings.TEXTURE_PATH + "LDR_RGB1_0.png", {
            weight: 55,
            onLoad: function() {
                tt.needsUpdate = !0,
                $.needsUpdate = !0
            }
        }).content);
        $.image = tt.image,
        tt.generateMipmaps = !1,
        tt.minFilter = tt.magFilter = NearestFilter,
        tt.wrapS = tt.wrapT = RepeatWrapping,
        this.sharedUniforms.u_blueNoiseTexture.value = tt,
        this.sharedUniforms.u_blueNoiseLinearTexture.value = $,
        this.sharedUniforms.u_blueNoiseTexelSize.value = new Vector2(1 / this.TEXTURE_SIZE,1 / this.TEXTURE_SIZE),
        shaderHelper.addChunk("getBlueNoise", getBlueNoiseShader)
    }
    update($) {
        this.sharedUniforms.u_blueNoiseCoordOffset.value.set(Math.random(), Math.random())
    }
}
var blueNoise = new BlueNoise
  , frag$1 = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform sampler2D u_screenPaintTexture;uniform vec2 u_screenPaintTexelSize;uniform float u_amount;uniform float u_rgbShift;uniform float u_multiplier;uniform float u_colorMultiplier;uniform float u_shade;varying vec2 v_uv;
#include <getBlueNoise>
void main(){vec3 bnoise=getBlueNoise(gl_FragCoord.xy+vec2(17.,29.));vec4 data=texture2D(u_screenPaintTexture,v_uv);float weight=(data.z+data.w)*0.5;vec2 vel=(0.5-data.xy-0.001)*2.*weight;vec4 color=vec4(0.0);vec2 velocity=vel*u_amount/4.0*u_screenPaintTexelSize*u_multiplier;vec2 uv=v_uv+bnoise.xy*velocity;for(int i=0;i<4;i++){color+=texture2D(u_texture,uv);uv+=velocity;}color/=4.;color.rgb+=sin(vec3(vel.x+vel.y)*40.0+vec3(0.0,2.0,4.0)*u_rgbShift)*smoothstep(0.4,-0.9,weight)*u_shade*max(abs(vel.x),abs(vel.y))*u_colorMultiplier;gl_FragColor=color;}`;
class ScreenPaintDistortion extends PostEffect {
    constructor() {
        super(...arguments);
        Et(this, "screenPaint", null);
        Et(this, "amount", 20);
        Et(this, "rgbShift", 1);
        Et(this, "multiplier", 1.25);
        Et(this, "colorMultiplier", 1);
        Et(this, "shade", 1.25)
    }
    init(tt) {
        if (Object.assign(this, tt),
        super.init(),
        !this.screenPaint)
            throw new Error("screenPaint is required");
        this.material = fboHelper.createRawShaderMaterial({
            uniforms: Object.assign({
                u_texture: {
                    value: null
                },
                u_screenPaintTexture: this.screenPaint.sharedUniforms.u_currPaintTexture,
                u_screenPaintTexelSize: this.screenPaint.sharedUniforms.u_paintTexelSize,
                u_amount: {
                    value: 0
                },
                u_rgbShift: {
                    value: 0
                },
                u_multiplier: {
                    value: 0
                },
                u_colorMultiplier: {
                    value: 0
                },
                u_shade: {
                    value: 0
                }
            }, blueNoise.sharedUniforms),
            fragmentShader: frag$1
        })
    }
    needsRender(tt) {
        return this.amount > 0
    }
    syncCamera(tt) {
        this.needsSync = !0,
        tt && (tt.matrixWorldInverse.decompose(this._position, this._quaternion, this._scale),
        this.projectionViewMatrix.multiplyMatrices(tt.projectionMatrix, tt.matrixWorldInverse),
        this.projectionViewInverseMatrix.copy(this.projectionViewMatrix).invert()),
        this.prevProjectionViewMatrix.copy(this.projectionViewMatrix)
    }
    render(tt, nt=!1) {
        this.material.uniforms.u_amount.value = this.amount,
        this.material.uniforms.u_rgbShift.value = this.rgbShift,
        this.material.uniforms.u_multiplier.value = this.multiplier,
        this.material.uniforms.u_colorMultiplier.value = this.colorMultiplier,
        this.material.uniforms.u_shade.value = this.shade,
        super.render(tt, nt)
    }
}
var fragmentShader = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform vec3 u_bgColor;uniform float u_opacity;uniform float u_vignetteFrom;uniform float u_vignetteTo;uniform vec2 u_vignetteAspect;uniform vec3 u_vignetteColor;uniform float u_saturation;uniform float u_contrast;uniform float u_brightness;uniform float u_invert;uniform vec3 u_tintColor;uniform float u_tintOpacity;uniform float u_ditherSeed;float hash13(vec3 p3){p3=fract(p3*.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}vec3 screen(vec3 cb,vec3 cs){return cb+cs-(cb*cs);}vec3 colorDodge(vec3 cb,vec3 cs){return mix(min(vec3(1.0),cb/(1.0-cs)),vec3(1.0),step(vec3(1.0),cs));}void main(){vec2 uv=v_uv;vec3 color=texture2D(u_texture,uv).rgb;float luma=dot(color,vec3(0.299,0.587,0.114));color=mix(vec3(luma),color,1.0+u_saturation);color=0.5+(1.0+u_contrast)*(color-0.5);color+=u_brightness;color=mix(color,1.0-color,u_invert);color=mix(color,screen(colorDodge(color,u_tintColor),u_tintColor),u_tintOpacity);float d=length((uv-0.5)*u_vignetteAspect)*2.0;color=mix(color,u_vignetteColor,smoothstep(u_vignetteFrom,u_vignetteTo,d));gl_FragColor=vec4(mix(u_bgColor,color,u_opacity)+hash13(vec3(gl_FragCoord.xy,u_ditherSeed))/255.0,1.0);}`
  , transitionFragmentShader = `#define GLSLIFY 1
varying vec2 v_uv;uniform sampler2D u_texture;uniform sampler2D u_cacheTexture;uniform vec2 u_aspect;uniform float u_transitionRatio;void main(){vec2 uv=v_uv-0.5;float transitionRatioInverse=1.0-u_transitionRatio;uv*=u_aspect;float d=length(uv);float oriDist=d;float distortedDist=d*3.1415926*2.5*transitionRatioInverse;float distortion=cos(distortedDist*distortedDist);uv*=mix(1.0,distortion*distortion,u_transitionRatio);uv/=u_aspect;vec4 color=texture2D(u_texture,uv+0.5);vec4 sceneColor=texture2D(u_cacheTexture,uv*(1.0-u_transitionRatio*0.75)+0.5);float blend=smoothstep(0.4,0.6,transitionRatioInverse);color=mix(color,sceneColor,blend);gl_FragColor=color;}`;
class Final extends PostEffect {
    constructor() {
        super(...arguments);
        Et(this, "vignetteFrom", .6);
        Et(this, "vignetteTo", 1.6);
        Et(this, "vignetteAspect", new Vector2);
        Et(this, "vignetteColor", new Color);
        Et(this, "saturation", 1);
        Et(this, "contrast", 0);
        Et(this, "brightness", 1);
        Et(this, "tintColor", new Color);
        Et(this, "tintOpacity", 1);
        Et(this, "bgColor", new Color);
        Et(this, "opacity", 1);
        Et(this, "postInvert", 0);
        Et(this, "transitionRatio", 1);
        Et(this, "cacheRenderTarget", null)
    }
    init(tt) {
        Object.assign(this, tt),
        super.init(),
        this.material = this.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_vignetteFrom: {
                    value: 0
                },
                u_vignetteTo: {
                    value: 0
                },
                u_vignetteAspect: {
                    value: this.vignetteAspect
                },
                u_vignetteColor: {
                    value: this.vignetteColor
                },
                u_saturation: {
                    value: 0
                },
                u_contrast: {
                    value: 0
                },
                u_brightness: {
                    value: 0
                },
                u_invert: {
                    value: 0
                },
                u_tintColor: {
                    value: this.tintColor
                },
                u_tintOpacity: {
                    value: 0
                },
                u_bgColor: {
                    value: this.bgColor
                },
                u_opacity: {
                    value: 0
                },
                u_ditherSeed: {
                    value: 0
                }
            },
            fragmentShader
        }),
        this.cacheRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.transitionMaterial = this.createRawShaderMaterial({
            uniforms: Object.assign({
                u_texture: {
                    value: null
                },
                u_cacheTexture: {
                    value: this.cacheRenderTarget.texture
                },
                u_transitionRatio: {
                    value: 0
                },
                u_aspect: {
                    value: new Vector2
                }
            }, blueNoise.sharedUniforms),
            fragmentShader: transitionFragmentShader
        })
    }
    startTransition(tt) {
        let nt = tt.width
          , rt = tt.height;
        this.cacheRenderTarget.setSize(nt, rt),
        fboHelper.copy(tt.fromRenderTarget.texture, this.cacheRenderTarget),
        tt.swap(),
        this.transitionRatio = 0
    }
    render(tt, nt=!1) {
        const rt = tt.width
          , it = tt.height;
        let ot = this.material.uniforms;
        ot.u_vignetteFrom.value = this.vignetteFrom,
        ot.u_vignetteTo.value = this.vignetteTo;
        const st = it / Math.sqrt(rt * rt + it * it);
        this.vignetteAspect.set(rt / it * st, st),
        ot.u_saturation.value = this.saturation - 1,
        ot.u_contrast.value = this.contrast,
        ot.u_brightness.value = this.brightness - 1,
        ot.u_invert.value = this.postInvert,
        ot.u_tintOpacity.value = this.tintOpacity,
        ot.u_opacity.value = this.opacity,
        ot.u_ditherSeed.value = Math.random() * 1e3;
        let lt = this.transitionRatio
          , ut = lt < 1;
        this.material.uniforms.u_texture.value = tt.fromTexture,
        tt.renderMaterial(this.material, tt.toRenderTarget),
        ut && (tt.swap(),
        this.transitionMaterial.uniforms.u_texture.value = tt.fromTexture,
        this.transitionMaterial.uniforms.u_transitionRatio.value = lt,
        this.transitionMaterial.uniforms.u_aspect.value.copy(this.vignetteAspect),
        tt.renderMaterial(this.transitionMaterial, tt.toRenderTarget)),
        tt.swap(),
        fboHelper.copy(tt.fromTexture, nt ? null : tt.toRenderTarget)
    }
}
var channelMixerFrag = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec4 u_channelMixerR;uniform vec4 u_channelMixerG;uniform vec4 u_channelMixerB;uniform vec4 u_channelMixerA;varying vec2 v_uv;void main(){vec4 color=texture2D(u_texture,v_uv);gl_FragColor=vec4(dot(color,u_channelMixerR),dot(color,u_channelMixerG),dot(color,u_channelMixerB),dot(color,u_channelMixerA));}`;
class TextureHelper {
    constructor() {
        Et(this, "blackTexture");
        Et(this, "whiteTexture");
        Et(this, "transparentTexture");
        Et(this, "channelMixerMaterial")
    }
    init() {
        this.blackTexture = this._createPixelTexture([0, 0, 0, 255]),
        this.whiteTexture = this._createPixelTexture([255, 255, 255, 255]),
        this.transparentTexture = this._createPixelTexture([0, 0, 0, 0])
    }
    _createPixelTexture($) {
        return fboHelper.createDataTexture(new Uint8Array($), 1, 1, !1, !0)
    }
    mixChannels($, tt, nt=-1, rt=-1, it=-1, ot=-1) {
        this.channelMixerMaterial || (this.channelMixerMaterial = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_channelMixerR: {
                    value: new Vector4
                },
                u_channelMixerG: {
                    value: new Vector4
                },
                u_channelMixerB: {
                    value: new Vector4
                },
                u_channelMixerA: {
                    value: new Vector4
                }
            },
            vertexShader: fboHelper.vertexShader,
            fragmentShader: fboHelper.precisionPrefix + channelMixerFrag,
            blending: CustomBlending,
            blendEquation: AddEquation,
            blendDst: OneFactor,
            blendSrc: OneFactor,
            blendEquationAlpha: AddEquation,
            blendDstAlpha: OneFactor,
            blendSrcAlpha: OneFactor
        })),
        this.channelMixerMaterial.uniforms.u_texture.value = $,
        this.channelMixerMaterial.uniforms.u_channelMixerR.value.set(+(nt % 4 == 0), +(nt % 4 == 1), +(nt % 4 == 2), +(nt % 4 == 3)).multiplyScalar(nt < 0 ? 0 : 1),
        this.channelMixerMaterial.uniforms.u_channelMixerG.value.set(+(rt % 4 == 0), +(rt % 4 == 1), +(rt % 4 == 2), +(rt % 4 == 3)).multiplyScalar(rt < 0 ? 0 : 1),
        this.channelMixerMaterial.uniforms.u_channelMixerB.value.set(+(it % 4 == 0), +(it % 4 == 1), +(it % 4 == 2), +(it % 4 == 3)).multiplyScalar(it < 0 ? 0 : 1),
        this.channelMixerMaterial.uniforms.u_channelMixerA.value.set(+(ot % 4 == 0), +(ot % 4 == 1), +(ot % 4 == 2), +(ot % 4 == 3)).multiplyScalar(ot < 0 ? 0 : 1);
        let st = fboHelper.getColorState();
        fboHelper.renderer.autoClear = !1,
        fboHelper.render(this.channelMixerMaterial, tt),
        fboHelper.setColorState(st)
    }
}
var textureHelper = new TextureHelper;
const XHRItem = properties.loader.ITEM_CLASSES.xhr;
class BufItem extends XHRItem {
    constructor($, tt) {
        super($, kn(wn({}, tt), {
            responseType: "arraybuffer"
        }))
    }
    retrieve() {
        return !1
    }
    _onLoad() {
        if (!this.content) {
            const $ = this.xmlhttp.response
              , tt = new Uint32Array($,0,1)[0]
              , nt = JSON.parse(String.fromCharCode.apply(null, new Uint8Array($,4,tt)))
              , rt = nt.vertexCount
              , it = nt.indexCount;
            let ot = 4 + tt;
            const st = new BufferGeometry
              , lt = nt.attributes;
            for (let ut = 0, ct = lt.length; ut < ct; ut++) {
                const ht = lt[ut]
                  , ft = ht.id
                  , gt = ft === "indices" ? it : rt
                  , vt = ht.componentSize
                  , yt = window[ht.storageType]
                  , wt = new yt($,ot,gt * vt)
                  , mt = yt.BYTES_PER_ELEMENT;
                let _t;
                if (ht.needsPack) {
                    const bt = ht.packedComponents
                      , Mt = bt.length
                      , St = ht.storageType.indexOf("Int") === 0
                      , At = 1 << mt * 8
                      , Pt = St ? At * .5 : 0
                      , Ot = 1 / At;
                    _t = new Float32Array(gt * vt);
                    for (let Zt = 0, Nt = 0; Zt < gt; Zt++)
                        for (let Tt = 0; Tt < Mt; Tt++) {
                            const Ft = bt[Tt];
                            _t[Nt] = (wt[Nt] + Pt) * Ot * Ft.delta + Ft.from,
                            Nt++
                        }
                } else
                    _t = wt;
                ft === "indices" ? st.setIndex(new BufferAttribute(_t,1)) : st.setAttribute(ft, new BufferAttribute(_t,vt)),
                ot += gt * vt * mt
            }
            this.content = st
        }
        this.xmlhttp = void 0,
        super._onLoad(this)
    }
}
BufItem.type = "buf";
BufItem.extensions = ["buf"];
BufItem.responseType = "arraybuffer";
const ImageItem = properties.loader.ITEM_CLASSES.image;
class TextureItem extends ImageItem {
    constructor($, tt) {
        let nt = tt.content || new Texture(new Image);
        switch (tt.content = nt.image,
        nt.minFilter = tt.minFilter || LinearMipMapLinearFilter,
        nt.minFilter) {
        case NearestMipMapNearestFilter:
        case NearestMipMapLinearFilter:
        case LinearMipMapNearestFilter:
        case LinearMipMapLinearFilter:
            nt.generateMipmaps = !0,
            nt.anisotropy = tt.anisotropy || properties.renderer.capabilities.getMaxAnisotropy();
            break;
        default:
            nt.generateMipmaps = !1
        }
        nt.flipY = tt.flipY === void 0 ? !0 : tt.flipY,
        tt.wrap ? nt.wrapS = nt.wrapT = tt.wrap : (tt.wrapS && (nt.wrapS = tt.wrapS),
        tt.wrapT && (nt.wrapT = tt.wrapT)),
        super($, tt),
        this.content = nt
    }
    retrieve() {
        return !1
    }
    load() {
        this.isStartLoaded = !0;
        let $ = this.content.image;
        $.onload = this.boundOnLoad,
        $.src = this.url
    }
    _onLoad() {
        delete this.content.image.onload,
        this.width = this.content.image.width,
        this.height = this.content.image.height,
        this.content.needsUpdate = !0,
        this.onPost ? this.onPost.call(this, this.content, this.onPostLoadingSignal) : this._onLoadComplete()
    }
}
TextureItem.type = "texture";
TextureItem.extensions = [];
const AnyItem$1 = properties.loader.ITEM_CLASSES.any;
class ThreeLoaderItem extends AnyItem$1 {
    constructor($, tt) {
        tt.loadFunc = ()=>{}
        ,
        tt.hasLoading = tt.hasLoading === void 0 ? !0 : tt.hasLoading,
        super($, tt),
        !tt.loader && console && (console.error || console.log)("loader is required."),
        this.loadFunc = this._loadFunc.bind(this)
    }
    _loadFunc($, tt, nt) {
        this.loader.load($, this._onLoaderLoad.bind(this, tt), this._onLoaderLoading.bind(this, nt))
    }
    _onLoaderLoad($, tt) {
        this.content = tt,
        $(tt)
    }
    _onLoaderLoading($, tt) {
        $.dispatch(tt.loaded / tt.total)
    }
}
ThreeLoaderItem.type = "three-loader";
ThreeLoaderItem.extensions = [];
var shader = `#define GLSLIFY 1
uniform vec2 u_glPositionOffset;vec4 glPositionOffset(vec4 glPosition){return glPosition+vec4(u_glPositionOffset*glPosition.w,0.0,0.0);}`;
class GlPositionOffset {
    constructor() {
        Et(this, "offset", new Vector2);
        Et(this, "sharedUniforms", {
            u_glPositionOffset: {
                value: null
            }
        })
    }
    init() {
        this.sharedUniforms.u_glPositionOffset.value = this.offset,
        shaderHelper.addChunk("glPositionOffset", shader)
    }
    setOffset($, tt) {
        return this.offset.set($, tt)
    }
}
var glPositionOffset = new GlPositionOffset
  , frag = `#define GLSLIFY 1
uniform sampler2D u_lowPaintTexture;uniform sampler2D u_prevPaintTexture;uniform vec2 u_paintTexelSize;uniform vec4 u_drawFrom;uniform vec4 u_drawTo;uniform float u_pushStrength;uniform vec3 u_dissipations;uniform vec2 u_vel;varying vec2 v_uv;vec2 sdSegment(in vec2 p,in vec2 a,in vec2 b){vec2 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return vec2(length(pa-ba*h),h);}
#ifdef USE_NOISE
uniform float u_curlScale;uniform float u_curlStrength;vec2 hash(vec2 p){vec3 p3=fract(vec3(p.xyx)*vec3(.1031,.1030,.0973));p3+=dot(p3,p3.yzx+33.33);return fract((p3.xx+p3.yz)*p3.zy)*2.0-1.0;}vec3 noised(in vec2 p){vec2 i=floor(p);vec2 f=fract(p);vec2 u=f*f*f*(f*(f*6.0-15.0)+10.0);vec2 du=30.0*f*f*(f*(f-2.0)+1.0);vec2 ga=hash(i+vec2(0.0,0.0));vec2 gb=hash(i+vec2(1.0,0.0));vec2 gc=hash(i+vec2(0.0,1.0));vec2 gd=hash(i+vec2(1.0,1.0));float va=dot(ga,f-vec2(0.0,0.0));float vb=dot(gb,f-vec2(1.0,0.0));float vc=dot(gc,f-vec2(0.0,1.0));float vd=dot(gd,f-vec2(1.0,1.0));return vec3(va+u.x*(vb-va)+u.y*(vc-va)+u.x*u.y*(va-vb-vc+vd),ga+u.x*(gb-ga)+u.y*(gc-ga)+u.x*u.y*(ga-gb-gc+gd)+du*(u.yx*(va-vb-vc+vd)+vec2(vb,vc)-va));}
#endif
void main(){vec2 res=sdSegment(gl_FragCoord.xy,u_drawFrom.xy,u_drawTo.xy);vec2 radiusWeight=mix(u_drawFrom.zw,u_drawTo.zw,res.y);float d=1.0-smoothstep(-0.01,radiusWeight.x,res.x);vec4 lowData=texture2D(u_lowPaintTexture,v_uv);vec2 velInv=(0.5-lowData.xy)*u_pushStrength;
#ifdef USE_NOISE
vec3 noise3=noised(gl_FragCoord.xy*u_curlScale*(1.0-lowData.xy));vec2 noise=noised(gl_FragCoord.xy*u_curlScale*(2.0-lowData.xy*(0.5+noise3.x)+noise3.yz*0.1)).yz;velInv+=noise*(lowData.z+lowData.w)*u_curlStrength;
#endif
vec4 data=texture2D(u_prevPaintTexture,v_uv+velInv*u_paintTexelSize);data.xy-=0.5;vec4 delta=(u_dissipations.xxyz-1.0)*data;vec2 newVel=u_vel*d;delta+=vec4(newVel,radiusWeight.yy*d);delta.zw=sign(delta.zw)*max(vec2(0.004),abs(delta.zw));data+=delta;data.xy+=0.5;gl_FragColor=clamp(data,vec4(0.0),vec4(1.0));}`
  , blur9VaryingVertexShader = `#define GLSLIFY 1
attribute vec3 position;uniform vec2 u_delta;varying vec2 v_uv[9];void main(){vec2 uv=position.xy*0.5+0.5;v_uv[0]=uv;vec2 delta=u_delta;v_uv[1]=uv-delta;v_uv[2]=uv+delta;delta+=u_delta;v_uv[3]=uv-delta;v_uv[4]=uv+delta;delta+=u_delta;v_uv[5]=uv-delta;v_uv[6]=uv+delta;delta+=u_delta;v_uv[7]=uv-delta;v_uv[8]=uv+delta;gl_Position=vec4(position,1.0);}`
  , blur9VaryingFragmentShader = `#define GLSLIFY 1
uniform sampler2D u_texture;varying vec2 v_uv[9];void main(){vec4 color=texture2D(u_texture,v_uv[0])*0.1633;color+=texture2D(u_texture,v_uv[1])*0.1531;color+=texture2D(u_texture,v_uv[2])*0.1531;color+=texture2D(u_texture,v_uv[3])*0.12245;color+=texture2D(u_texture,v_uv[4])*0.12245;color+=texture2D(u_texture,v_uv[5])*0.0918;color+=texture2D(u_texture,v_uv[6])*0.0918;color+=texture2D(u_texture,v_uv[7])*0.051;color+=texture2D(u_texture,v_uv[8])*0.051;gl_FragColor=color;}`
  , blur9FragmentShader = `#define GLSLIFY 1
uniform sampler2D u_texture;uniform vec2 u_delta;varying vec2 v_uv;void main(){vec4 color=texture2D(u_texture,v_uv)*0.1633;vec2 delta=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.1531;color+=texture2D(u_texture,v_uv+delta)*0.1531;delta+=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.12245;color+=texture2D(u_texture,v_uv+delta)*0.12245;delta+=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.0918;color+=texture2D(u_texture,v_uv+delta)*0.0918;delta+=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.051;color+=texture2D(u_texture,v_uv+delta)*0.051;gl_FragColor=color;}`;
class Blur {
    constructor() {
        Et(this, "material", null);
        Et(this, "renderTarget", null)
    }
    getBlur9Material() {
        let $ = fboHelper.MAX_VARYING_VECTORS > 8;
        return this.blur9Material || (this.blur9Material = new RawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_delta: {
                    value: new Vector2
                }
            },
            vertexShader: $ ? fboHelper.precisionPrefix + blur9VaryingVertexShader : fboHelper.vertexShader,
            fragmentShader: fboHelper.precisionPrefix + ($ ? blur9VaryingFragmentShader : blur9FragmentShader)
        })),
        this.blur9Material
    }
    blur($, tt, nt, rt, it, ot) {
        let st = .25
          , lt = Math.ceil(nt.width * tt) || 0
          , ut = Math.ceil(nt.height * tt) || 0;
        this.material || (this.material = this.getBlur9Material()),
        rt || (this.renderTarget || (this.renderTarget = fboHelper.createRenderTarget(1, 1)),
        rt = this.renderTarget),
        rt.setSize(lt, ut),
        it ? ot || it.setSize(nt.width, nt.height) : it = nt,
        this.material.uniforms.u_texture.value = nt.texture || nt,
        this.material.uniforms.u_delta.value.set($ / lt * st, 0),
        fboHelper.render(this.material, rt),
        this.material.uniforms.u_texture.value = rt.texture || rt,
        this.material.uniforms.u_delta.value.set(0, $ / ut * st),
        fboHelper.render(this.material, it)
    }
}
var blur = new Blur;
let _v$1 = new Vector2;
class ScreenPaint {
    constructor() {
        Et(this, "_lowRenderTarget");
        Et(this, "_lowBlurRenderTarget");
        Et(this, "_prevPaintRenderTarget");
        Et(this, "_currPaintRenderTarget");
        Et(this, "_material");
        Et(this, "_distortionMaterial");
        Et(this, "_fromDrawData");
        Et(this, "_toDrawData");
        Et(this, "drawEnabled", !0);
        Et(this, "needsMouseDown", !1);
        Et(this, "enabled", !0);
        Et(this, "minRadius", 0);
        Et(this, "maxRadius", 100);
        Et(this, "radiusDistanceRange", 100);
        Et(this, "pushStrength", 25);
        Et(this, "accelerationDissipation", .8);
        Et(this, "velocityDissipation", .985);
        Et(this, "weight1Dissipation", .985);
        Et(this, "weight2Dissipation", .5);
        Et(this, "useNoise", !1);
        Et(this, "curlScale", .1);
        Et(this, "curlStrength", 5);
        Et(this, "_prevUseNoise", null);
        Et(this, "sharedUniforms", {
            u_paintTexelSize: {
                value: new Vector2
            },
            u_prevPaintTexture: {
                value: null
            },
            u_currPaintTexture: {
                value: null
            },
            u_lowPaintTexture: {
                value: null
            }
        });
        Et(this, "clear", ()=>{
            fboHelper.clearColor(.5, .5, 0, 0, this._lowRenderTarget),
            fboHelper.clearColor(.5, .5, 0, 0, this._lowBlurRenderTarget),
            fboHelper.clearColor(.5, .5, 0, 0, this._currPaintRenderTarget),
            this._material.uniforms.u_vel.value.set(0, 0)
        }
        )
    }
    init() {
        this._lowRenderTarget = fboHelper.createRenderTarget(1, 1),
        this._lowBlurRenderTarget = fboHelper.createRenderTarget(1, 1),
        this._prevPaintRenderTarget = fboHelper.createRenderTarget(1, 1),
        this._currPaintRenderTarget = fboHelper.createRenderTarget(1, 1),
        this.sharedUniforms.u_lowPaintTexture.value = this._lowRenderTarget.texture,
        this._material = new RawShaderMaterial({
            uniforms: {
                u_lowPaintTexture: {
                    value: this._lowRenderTarget.texture
                },
                u_prevPaintTexture: this.sharedUniforms.u_prevPaintTexture,
                u_paintTexelSize: this.sharedUniforms.u_paintTexelSize,
                u_drawFrom: {
                    value: this._fromDrawData = new Vector4(0,0,0,0)
                },
                u_drawTo: {
                    value: this._toDrawData = new Vector4(0,0,0,0)
                },
                u_pushStrength: {
                    value: 0
                },
                u_curlScale: {
                    value: 0
                },
                u_curlStrength: {
                    value: 0
                },
                u_vel: {
                    value: new Vector2
                },
                u_dissipations: {
                    value: new Vector3
                }
            },
            vertexShader: fboHelper.vertexShader,
            fragmentShader: fboHelper.precisionPrefix + frag
        })
    }
    resize($, tt) {
        let nt = $ >> 2
          , rt = tt >> 2
          , it = $ >> 4
          , ot = tt >> 4;
        (nt !== this._currPaintRenderTarget.width || rt !== this._currPaintRenderTarget.height) && (this._currPaintRenderTarget.setSize(nt, rt),
        this._prevPaintRenderTarget.setSize(nt, rt),
        this._lowRenderTarget.setSize(it, ot),
        this._lowBlurRenderTarget.setSize(it, ot),
        this.sharedUniforms.u_paintTexelSize.value.set(1 / nt, 1 / rt),
        this.clear())
    }
    update($) {
        if (!this.enabled)
            return;
        this.useNoise !== this._prevUseNoise && (this._material.defines.USE_NOISE = this.useNoise,
        this._material.needsUpdate = !0,
        this._prevUseNoise = this.useNoise);
        let tt = this._currPaintRenderTarget.width
          , nt = this._currPaintRenderTarget.height
          , rt = this._prevPaintRenderTarget;
        this._prevPaintRenderTarget = this._currPaintRenderTarget,
        this._currPaintRenderTarget = rt,
        this.sharedUniforms.u_prevPaintTexture.value = this._prevPaintRenderTarget.texture,
        this.sharedUniforms.u_currPaintTexture.value = this._currPaintRenderTarget.texture,
        this._material.uniforms.u_drawFrom.value.z = this._material.uniforms.u_drawTo.value.z;
        let it = input.mousePixelXY.distanceTo(input.prevMousePixelXY)
          , ot = math.fit(it, 0, this.radiusDistanceRange, this.minRadius, this.maxRadius);
        (!input.hadMoved || !this.drawEnabled || (this.needsMouseDown || browser$1.isMobile) && (!input.isDown || !input.wasDown)) && (ot = 0),
        ot = ot / properties.rawHeight * nt,
        this._material.uniforms.u_pushStrength.value = this.pushStrength,
        this._material.uniforms.u_curlScale.value = this.curlScale,
        this._material.uniforms.u_curlStrength.value = this.curlStrength,
        this._material.uniforms.u_dissipations.value.set(this.velocityDissipation, this.weight1Dissipation, this.weight2Dissipation),
        this._fromDrawData.copy(this._toDrawData),
        this._toDrawData.set((input.mouseXY.x + 1) * tt / 2, (input.mouseXY.y + 1) * nt / 2, ot, 1),
        _v$1.set(this._toDrawData.x - this._fromDrawData.x, this._toDrawData.y - this._fromDrawData.y).multiplyScalar($ * .8),
        this._material.uniforms.u_vel.value.multiplyScalar(this.accelerationDissipation).add(_v$1),
        fboHelper.render(this._material, this._currPaintRenderTarget),
        fboHelper.copy(this._currPaintRenderTarget.texture, this._lowRenderTarget),
        blur.blur(4, 1, this._lowRenderTarget, this._lowBlurRenderTarget)
    }
}
var screenPaint = new ScreenPaint;
class Support {
    isSupported() {
        properties._isSupportedDevice = !0,
        properties._isSupportedBrowser = (browser$1.isChrome || browser$1.isSafari || browser$1.isEdge || browser$1.isFirefox || browser$1.isOpera) && !browser$1.isIE,
        properties._isSupportedWebGL = this.checkSupportWebGL(),
        browser$1.isMobile && this.checkSupportMobileOrientation();
        let $;
        return settings.IS_API_MODE === !0 ? $ = properties._isSupportedWebGL : $ = properties._isSupportedDevice && properties._isSupportedBrowser && properties._isSupportedWebGL,
        $ === !1 && this.notSupported(),
        $
    }
    notSupported() {
        if (!properties._isSupportedDevice) {
            this._addNotSupported("device");
            return
        }
        if (!properties._isSupportedBrowser) {
            this._addNotSupported("browser");
            return
        }
        if (!properties._isSupportedWebGL) {
            this._addNotSupported("webgl");
            return
        }
    }
    checkSupportWebGL() {
        if (!(properties.canvas instanceof HTMLCanvasElement))
            return !1;
        if (settings.USE_WEBGL2 && window.WebGL2RenderingContext)
            try {
                return properties.gl = properties.canvas.getContext("webgl2", properties.webglOpts),
                settings.RENDER_TARGET_FLOAT_TYPE = FloatType,
                settings.DATA_FLOAT_TYPE = FloatType,
                !0
            } catch ($) {
                return console.error($),
                !1
            }
        if (settings.USE_WEBGL2 = !1,
        window.WebGLRenderingContext)
            try {
                let $ = properties.gl = properties.canvas.getContext("webgl", properties.webglOpts) || properties.canvas.getContext("experimental-webgl", properties.webglOpts);
                if (($.getExtension("OES_texture_float") || $.getExtension("OES_texture_half_float")) && $.getParameter($.MAX_VERTEX_TEXTURE_IMAGE_UNITS))
                    settings.RENDER_TARGET_FLOAT_TYPE = browser$1.isIOS || !$.getExtension("OES_texture_float") ? HalfFloatType : FloatType,
                    settings.DATA_FLOAT_TYPE = FloatType;
                else
                    return settings.USE_FLOAT_PACKING = !0,
                    settings.RENDER_TARGET_FLOAT_TYPE = settings.DATA_FLOAT_TYPE = UnsignedByteType,
                    !1;
                return !0
            } catch ($) {
                return console.error($),
                !1
            }
        return !1
    }
    checkSupportMobileOrientation() {
        const $ = window.matchMedia("(orientation: portrait)")
          , tt = nt=>{
            const rt = nt.matches ? "portrait" : "landscape";
            rt === "portrait" ? properties._isSupportedMobileOrientation = !0 : rt === "landscape" && (properties._isSupportedMobileOrientation = !1),
            properties._isSupported && !properties._isSupportedMobileOrientation ? this._addNotSupported("orientation") : this._removeNotSupported("orientation")
        }
        ;
        window.addEventListener("load", ()=>{
            tt($)
        }
        ),
        $.addEventListener("change", nt=>{
            tt(nt)
        }
        )
    }
    _removeNotSupported($) {
        properties._isSupported && document.documentElement.classList.remove("not-supported"),
        $ && document.documentElement.classList.remove(`not-supported--${$}`)
    }
    _addNotSupported($) {
        if (console.error(new Error(`[${settings.GLOBAL_ID}]: NOT SUPPORTED (${$.toUpperCase()})`)),
        settings.IS_API_MODE !== !0) {
            document.documentElement.classList.add("not-supported"),
            $ && document.documentElement.classList.add(`not-supported--${$}`);
            return
        }
    }
}
var support = new Support
  , tweakpane = {
    exports: {}
};
/*! Tweakpane 3.1.2 (c) 2016 cocopon, licensed under the MIT license. */
(function(et, $) {
    (function(tt, nt) {
        nt($)
    }
    )(commonjsGlobal, function(tt) {
        class nt {
            constructor(at) {
                const [dt,xt] = at.split("-")
                  , Ct = dt.split(".");
                this.major = parseInt(Ct[0], 10),
                this.minor = parseInt(Ct[1], 10),
                this.patch = parseInt(Ct[2], 10),
                this.prerelease = xt != null ? xt : null
            }
            toString() {
                const at = [this.major, this.minor, this.patch].join(".");
                return this.prerelease !== null ? [at, this.prerelease].join("-") : at
            }
        }
        class rt {
            constructor(at) {
                this.controller_ = at
            }
            get element() {
                return this.controller_.view.element
            }
            get disabled() {
                return this.controller_.viewProps.get("disabled")
            }
            set disabled(at) {
                this.controller_.viewProps.set("disabled", at)
            }
            get hidden() {
                return this.controller_.viewProps.get("hidden")
            }
            set hidden(at) {
                this.controller_.viewProps.set("hidden", at)
            }
            dispose() {
                this.controller_.viewProps.set("disposed", !0)
            }
        }
        class it {
            constructor(at) {
                this.target = at
            }
        }
        class ot extends it {
            constructor(at, dt, xt, Ct) {
                super(at),
                this.value = dt,
                this.presetKey = xt,
                this.last = Ct != null ? Ct : !0
            }
        }
        class st extends it {
            constructor(at, dt, xt) {
                super(at),
                this.value = dt,
                this.presetKey = xt
            }
        }
        class lt extends it {
            constructor(at, dt) {
                super(at),
                this.expanded = dt
            }
        }
        class ut extends it {
            constructor(at, dt) {
                super(at),
                this.index = dt
            }
        }
        function ct(pt) {
            return pt
        }
        function ht(pt) {
            return pt == null
        }
        function ft(pt, at) {
            if (pt.length !== at.length)
                return !1;
            for (let dt = 0; dt < pt.length; dt++)
                if (pt[dt] !== at[dt])
                    return !1;
            return !0
        }
        const gt = {
            alreadydisposed: ()=>"View has been already disposed",
            invalidparams: pt=>`Invalid parameters for '${pt.name}'`,
            nomatchingcontroller: pt=>`No matching controller for '${pt.key}'`,
            nomatchingview: pt=>`No matching view for '${JSON.stringify(pt.params)}'`,
            notbindable: ()=>"Value is not bindable",
            propertynotfound: pt=>`Property '${pt.name}' not found`,
            shouldneverhappen: ()=>"This error should never happen"
        };
        class vt {
            constructor(at) {
                var dt;
                this.message = (dt = gt[at.type](at.context)) !== null && dt !== void 0 ? dt : "Unexpected error",
                this.name = this.constructor.name,
                this.stack = new Error(this.message).stack,
                this.type = at.type
            }
            static alreadyDisposed() {
                return new vt({
                    type: "alreadydisposed"
                })
            }
            static notBindable() {
                return new vt({
                    type: "notbindable"
                })
            }
            static propertyNotFound(at) {
                return new vt({
                    type: "propertynotfound",
                    context: {
                        name: at
                    }
                })
            }
            static shouldNeverHappen() {
                return new vt({
                    type: "shouldneverhappen"
                })
            }
        }
        class yt {
            constructor(at, dt, xt) {
                this.obj_ = at,
                this.key_ = dt,
                this.presetKey_ = xt != null ? xt : dt
            }
            static isBindable(at) {
                return !(at === null || typeof at != "object")
            }
            get key() {
                return this.key_
            }
            get presetKey() {
                return this.presetKey_
            }
            read() {
                return this.obj_[this.key_]
            }
            write(at) {
                this.obj_[this.key_] = at
            }
            writeProperty(at, dt) {
                const xt = this.read();
                if (!yt.isBindable(xt))
                    throw vt.notBindable();
                if (!(at in xt))
                    throw vt.propertyNotFound(at);
                xt[at] = dt
            }
        }
        class wt extends rt {
            get label() {
                return this.controller_.props.get("label")
            }
            set label(at) {
                this.controller_.props.set("label", at)
            }
            get title() {
                var at;
                return (at = this.controller_.valueController.props.get("title")) !== null && at !== void 0 ? at : ""
            }
            set title(at) {
                this.controller_.valueController.props.set("title", at)
            }
            on(at, dt) {
                const xt = dt.bind(this);
                return this.controller_.valueController.emitter.on(at, ()=>{
                    xt(new it(this))
                }
                ),
                this
            }
        }
        class mt {
            constructor() {
                this.observers_ = {}
            }
            on(at, dt) {
                let xt = this.observers_[at];
                return xt || (xt = this.observers_[at] = []),
                xt.push({
                    handler: dt
                }),
                this
            }
            off(at, dt) {
                const xt = this.observers_[at];
                return xt && (this.observers_[at] = xt.filter(Ct=>Ct.handler !== dt)),
                this
            }
            emit(at, dt) {
                const xt = this.observers_[at];
                !xt || xt.forEach(Ct=>{
                    Ct.handler(dt)
                }
                )
            }
        }
        const _t = "tp";
        function bt(pt) {
            return (dt,xt)=>[_t, "-", pt, "v", dt ? `_ ${dt}` : "", xt ? `-${xt}` : ""].join("")
        }
        function Mt(pt, at) {
            return dt=>at(pt(dt))
        }
        function St(pt) {
            return pt.rawValue
        }
        function At(pt, at) {
            pt.emitter.on("change", Mt(St, at)),
            at(pt.rawValue)
        }
        function Pt(pt, at, dt) {
            At(pt.value(at), dt)
        }
        function Ot(pt, at, dt) {
            dt ? pt.classList.add(at) : pt.classList.remove(at)
        }
        function Zt(pt, at) {
            return dt=>{
                Ot(pt, at, dt)
            }
        }
        function Nt(pt, at) {
            At(pt, dt=>{
                at.textContent = dt != null ? dt : ""
            }
            )
        }
        const Tt = bt("btn");
        class Ft {
            constructor(at, dt) {
                this.element = at.createElement("div"),
                this.element.classList.add(Tt()),
                dt.viewProps.bindClassModifiers(this.element);
                const xt = at.createElement("button");
                xt.classList.add(Tt("b")),
                dt.viewProps.bindDisabled(xt),
                this.element.appendChild(xt),
                this.buttonElement = xt;
                const Ct = at.createElement("div");
                Ct.classList.add(Tt("t")),
                Nt(dt.props.value("title"), Ct),
                this.buttonElement.appendChild(Ct)
            }
        }
        class $t {
            constructor(at, dt) {
                this.emitter = new mt,
                this.onClick_ = this.onClick_.bind(this),
                this.props = dt.props,
                this.viewProps = dt.viewProps,
                this.view = new Ft(at,{
                    props: this.props,
                    viewProps: this.viewProps
                }),
                this.view.buttonElement.addEventListener("click", this.onClick_)
            }
            onClick_() {
                this.emitter.emit("click", {
                    sender: this
                })
            }
        }
        class Wt {
            constructor(at, dt) {
                var xt;
                this.constraint_ = dt == null ? void 0 : dt.constraint,
                this.equals_ = (xt = dt == null ? void 0 : dt.equals) !== null && xt !== void 0 ? xt : (Ct,zt)=>Ct === zt,
                this.emitter = new mt,
                this.rawValue_ = at
            }
            get constraint() {
                return this.constraint_
            }
            get rawValue() {
                return this.rawValue_
            }
            set rawValue(at) {
                this.setRawValue(at, {
                    forceEmit: !1,
                    last: !0
                })
            }
            setRawValue(at, dt) {
                const xt = dt != null ? dt : {
                    forceEmit: !1,
                    last: !0
                }
                  , Ct = this.constraint_ ? this.constraint_.constrain(at) : at;
                !!this.equals_(this.rawValue_, Ct) && !xt.forceEmit || (this.emitter.emit("beforechange", {
                    sender: this
                }),
                this.rawValue_ = Ct,
                this.emitter.emit("change", {
                    options: xt,
                    rawValue: Ct,
                    sender: this
                }))
            }
        }
        class Kt {
            constructor(at) {
                this.emitter = new mt,
                this.value_ = at
            }
            get rawValue() {
                return this.value_
            }
            set rawValue(at) {
                this.setRawValue(at, {
                    forceEmit: !1,
                    last: !0
                })
            }
            setRawValue(at, dt) {
                const xt = dt != null ? dt : {
                    forceEmit: !1,
                    last: !0
                };
                this.value_ === at && !xt.forceEmit || (this.emitter.emit("beforechange", {
                    sender: this
                }),
                this.value_ = at,
                this.emitter.emit("change", {
                    options: xt,
                    rawValue: this.value_,
                    sender: this
                }))
            }
        }
        function qt(pt, at) {
            const dt = at == null ? void 0 : at.constraint
              , xt = at == null ? void 0 : at.equals;
            return !dt && !xt ? new Kt(pt) : new Wt(pt,at)
        }
        class jt {
            constructor(at) {
                this.emitter = new mt,
                this.valMap_ = at;
                for (const dt in this.valMap_)
                    this.valMap_[dt].emitter.on("change", ()=>{
                        this.emitter.emit("change", {
                            key: dt,
                            sender: this
                        })
                    }
                    )
            }
            static createCore(at) {
                return Object.keys(at).reduce((xt,Ct)=>Object.assign(xt, {
                    [Ct]: qt(at[Ct])
                }), {})
            }
            static fromObject(at) {
                const dt = this.createCore(at);
                return new jt(dt)
            }
            get(at) {
                return this.valMap_[at].rawValue
            }
            set(at, dt) {
                this.valMap_[at].rawValue = dt
            }
            value(at) {
                return this.valMap_[at]
            }
        }
        function Bt(pt, at) {
            const xt = Object.keys(at).reduce((Ct,zt)=>{
                if (Ct === void 0)
                    return;
                const Sn = at[zt](pt[zt]);
                return Sn.succeeded ? Object.assign(Object.assign({}, Ct), {
                    [zt]: Sn.value
                }) : void 0
            }
            , {});
            return xt
        }
        function Xt(pt, at) {
            return pt.reduce((dt,xt)=>{
                if (dt === void 0)
                    return;
                const Ct = at(xt);
                if (!(!Ct.succeeded || Ct.value === void 0))
                    return [...dt, Ct.value]
            }
            , [])
        }
        function Jt(pt) {
            return pt === null ? !1 : typeof pt == "object"
        }
        function Lt(pt) {
            return at=>dt=>{
                if (!at && dt === void 0)
                    return {
                        succeeded: !1,
                        value: void 0
                    };
                if (at && dt === void 0)
                    return {
                        succeeded: !0,
                        value: void 0
                    };
                const xt = pt(dt);
                return xt !== void 0 ? {
                    succeeded: !0,
                    value: xt
                } : {
                    succeeded: !1,
                    value: void 0
                }
            }
        }
        function Rt(pt) {
            return {
                custom: at=>Lt(at)(pt),
                boolean: Lt(at=>typeof at == "boolean" ? at : void 0)(pt),
                number: Lt(at=>typeof at == "number" ? at : void 0)(pt),
                string: Lt(at=>typeof at == "string" ? at : void 0)(pt),
                function: Lt(at=>typeof at == "function" ? at : void 0)(pt),
                constant: at=>Lt(dt=>dt === at ? at : void 0)(pt),
                raw: Lt(at=>at)(pt),
                object: at=>Lt(dt=>{
                    if (!!Jt(dt))
                        return Bt(dt, at)
                }
                )(pt),
                array: at=>Lt(dt=>{
                    if (!!Array.isArray(dt))
                        return Xt(dt, at)
                }
                )(pt)
            }
        }
        const _n = {
            optional: Rt(!0),
            required: Rt(!1)
        };
        function Fn(pt, at) {
            const dt = _n.required.object(at)(pt);
            return dt.succeeded ? dt.value : void 0
        }
        function Vn(pt) {
            return pt && pt.parentElement && pt.parentElement.removeChild(pt),
            null
        }
        function sn() {
            return ["veryfirst", "first", "last", "verylast"]
        }
        const Un = bt("")
          , zn = {
            veryfirst: "vfst",
            first: "fst",
            last: "lst",
            verylast: "vlst"
        };
        class Rn {
            constructor(at) {
                this.parent_ = null,
                this.blade = at.blade,
                this.view = at.view,
                this.viewProps = at.viewProps;
                const dt = this.view.element;
                this.blade.value("positions").emitter.on("change", ()=>{
                    sn().forEach(xt=>{
                        dt.classList.remove(Un(void 0, zn[xt]))
                    }
                    ),
                    this.blade.get("positions").forEach(xt=>{
                        dt.classList.add(Un(void 0, zn[xt]))
                    }
                    )
                }
                ),
                this.viewProps.handleDispose(()=>{
                    Vn(dt)
                }
                )
            }
            get parent() {
                return this.parent_
            }
        }
        const Ln = "http://www.w3.org/2000/svg";
        function Gn(pt) {
            pt.offsetHeight
        }
        function cn(pt, at) {
            const dt = pt.style.transition;
            pt.style.transition = "none",
            at(),
            pt.style.transition = dt
        }
        function bn(pt) {
            return pt.ontouchstart !== void 0
        }
        function Mn() {
            return globalThis
        }
        function Dn() {
            return Mn().document
        }
        function Pn(pt) {
            const at = pt.ownerDocument.defaultView;
            return at && "document"in at ? pt.getContext("2d", {
                willReadFrequently: !0
            }) : null
        }
        const $n = {
            check: '<path d="M2 8l4 4l8 -8"/>',
            dropdown: '<path d="M5 7h6l-3 3 z"/>',
            p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
        };
        function On(pt, at) {
            const dt = pt.createElementNS(Ln, "svg");
            return dt.innerHTML = $n[at],
            dt
        }
        function Wn(pt, at, dt) {
            pt.insertBefore(at, pt.children[dt])
        }
        function rr(pt) {
            pt.parentElement && pt.parentElement.removeChild(pt)
        }
        function Dt(pt) {
            for (; pt.children.length > 0; )
                pt.removeChild(pt.children[0])
        }
        function kt(pt) {
            for (; pt.childNodes.length > 0; )
                pt.removeChild(pt.childNodes[0])
        }
        function pn(pt) {
            return pt.relatedTarget ? pt.relatedTarget : "explicitOriginalTarget"in pt ? pt.explicitOriginalTarget : null
        }
        const mn = bt("lbl");
        function An(pt, at) {
            const dt = pt.createDocumentFragment();
            return at.split(`
`).map(Ct=>pt.createTextNode(Ct)).forEach((Ct,zt)=>{
                zt > 0 && dt.appendChild(pt.createElement("br")),
                dt.appendChild(Ct)
            }
            ),
            dt
        }
        class In {
            constructor(at, dt) {
                this.element = at.createElement("div"),
                this.element.classList.add(mn()),
                dt.viewProps.bindClassModifiers(this.element);
                const xt = at.createElement("div");
                xt.classList.add(mn("l")),
                Pt(dt.props, "label", zt=>{
                    ht(zt) ? this.element.classList.add(mn(void 0, "nol")) : (this.element.classList.remove(mn(void 0, "nol")),
                    kt(xt),
                    xt.appendChild(An(at, zt)))
                }
                ),
                this.element.appendChild(xt),
                this.labelElement = xt;
                const Ct = at.createElement("div");
                Ct.classList.add(mn("v")),
                this.element.appendChild(Ct),
                this.valueElement = Ct
            }
        }
        class Gt extends Rn {
            constructor(at, dt) {
                const xt = dt.valueController.viewProps;
                super(Object.assign(Object.assign({}, dt), {
                    view: new In(at,{
                        props: dt.props,
                        viewProps: xt
                    }),
                    viewProps: xt
                })),
                this.props = dt.props,
                this.valueController = dt.valueController,
                this.view.valueElement.appendChild(this.valueController.view.element)
            }
        }
        const Ht = {
            id: "button",
            type: "blade",
            accept(pt) {
                const at = _n
                  , dt = Fn(pt, {
                    title: at.required.string,
                    view: at.required.constant("button"),
                    label: at.optional.string
                });
                return dt ? {
                    params: dt
                } : null
            },
            controller(pt) {
                return new Gt(pt.document,{
                    blade: pt.blade,
                    props: jt.fromObject({
                        label: pt.params.label
                    }),
                    valueController: new $t(pt.document,{
                        props: jt.fromObject({
                            title: pt.params.title
                        }),
                        viewProps: pt.viewProps
                    })
                })
            },
            api(pt) {
                return !(pt.controller instanceof Gt) || !(pt.controller.valueController instanceof $t) ? null : new wt(pt.controller)
            }
        };
        class Vt extends Rn {
            constructor(at) {
                super(at),
                this.value = at.value
            }
        }
        function hn() {
            return new jt({
                positions: qt([], {
                    equals: ft
                })
            })
        }
        class vn extends jt {
            constructor(at) {
                super(at)
            }
            static create(at) {
                const dt = {
                    completed: !0,
                    expanded: at,
                    expandedHeight: null,
                    shouldFixHeight: !1,
                    temporaryExpanded: null
                }
                  , xt = jt.createCore(dt);
                return new vn(xt)
            }
            get styleExpanded() {
                var at;
                return (at = this.get("temporaryExpanded")) !== null && at !== void 0 ? at : this.get("expanded")
            }
            get styleHeight() {
                if (!this.styleExpanded)
                    return "0";
                const at = this.get("expandedHeight");
                return this.get("shouldFixHeight") && !ht(at) ? `${at}px` : "auto"
            }
            bindExpandedClass(at, dt) {
                const xt = ()=>{
                    this.styleExpanded ? at.classList.add(dt) : at.classList.remove(dt)
                }
                ;
                Pt(this, "expanded", xt),
                Pt(this, "temporaryExpanded", xt)
            }
            cleanUpTransition() {
                this.set("shouldFixHeight", !1),
                this.set("expandedHeight", null),
                this.set("completed", !0)
            }
        }
        function En(pt, at) {
            let dt = 0;
            return cn(at, ()=>{
                pt.set("expandedHeight", null),
                pt.set("temporaryExpanded", !0),
                Gn(at),
                dt = at.clientHeight,
                pt.set("temporaryExpanded", null),
                Gn(at)
            }
            ),
            dt
        }
        function Ut(pt, at) {
            at.style.height = pt.styleHeight
        }
        function Cn(pt, at) {
            pt.value("expanded").emitter.on("beforechange", ()=>{
                pt.set("completed", !1),
                ht(pt.get("expandedHeight")) && pt.set("expandedHeight", En(pt, at)),
                pt.set("shouldFixHeight", !0),
                Gn(at)
            }
            ),
            pt.emitter.on("change", ()=>{
                Ut(pt, at)
            }
            ),
            Ut(pt, at),
            at.addEventListener("transitionend", dt=>{
                dt.propertyName === "height" && pt.cleanUpTransition()
            }
            )
        }
        class Tn extends rt {
            constructor(at, dt) {
                super(at),
                this.rackApi_ = dt
            }
        }
        function Hn(pt, at) {
            return pt.addBlade(Object.assign(Object.assign({}, at), {
                view: "button"
            }))
        }
        function yn(pt, at) {
            return pt.addBlade(Object.assign(Object.assign({}, at), {
                view: "folder"
            }))
        }
        function xn(pt, at) {
            const dt = at != null ? at : {};
            return pt.addBlade(Object.assign(Object.assign({}, dt), {
                view: "separator"
            }))
        }
        function Nn(pt, at) {
            return pt.addBlade(Object.assign(Object.assign({}, at), {
                view: "tab"
            }))
        }
        class Jn {
            constructor(at) {
                this.emitter = new mt,
                this.items_ = [],
                this.cache_ = new Set,
                this.onSubListAdd_ = this.onSubListAdd_.bind(this),
                this.onSubListRemove_ = this.onSubListRemove_.bind(this),
                this.extract_ = at
            }
            get items() {
                return this.items_
            }
            allItems() {
                return Array.from(this.cache_)
            }
            find(at) {
                for (const dt of this.allItems())
                    if (at(dt))
                        return dt;
                return null
            }
            includes(at) {
                return this.cache_.has(at)
            }
            add(at, dt) {
                if (this.includes(at))
                    throw vt.shouldNeverHappen();
                const xt = dt !== void 0 ? dt : this.items_.length;
                this.items_.splice(xt, 0, at),
                this.cache_.add(at);
                const Ct = this.extract_(at);
                Ct && (Ct.emitter.on("add", this.onSubListAdd_),
                Ct.emitter.on("remove", this.onSubListRemove_),
                Ct.allItems().forEach(zt=>{
                    this.cache_.add(zt)
                }
                )),
                this.emitter.emit("add", {
                    index: xt,
                    item: at,
                    root: this,
                    target: this
                })
            }
            remove(at) {
                const dt = this.items_.indexOf(at);
                if (dt < 0)
                    return;
                this.items_.splice(dt, 1),
                this.cache_.delete(at);
                const xt = this.extract_(at);
                xt && (xt.emitter.off("add", this.onSubListAdd_),
                xt.emitter.off("remove", this.onSubListRemove_)),
                this.emitter.emit("remove", {
                    index: dt,
                    item: at,
                    root: this,
                    target: this
                })
            }
            onSubListAdd_(at) {
                this.cache_.add(at.item),
                this.emitter.emit("add", {
                    index: at.index,
                    item: at.item,
                    root: this,
                    target: at.target
                })
            }
            onSubListRemove_(at) {
                this.cache_.delete(at.item),
                this.emitter.emit("remove", {
                    index: at.index,
                    item: at.item,
                    root: this,
                    target: at.target
                })
            }
        }
        class dr extends rt {
            constructor(at) {
                super(at),
                this.onBindingChange_ = this.onBindingChange_.bind(this),
                this.emitter_ = new mt,
                this.controller_.binding.emitter.on("change", this.onBindingChange_)
            }
            get label() {
                return this.controller_.props.get("label")
            }
            set label(at) {
                this.controller_.props.set("label", at)
            }
            on(at, dt) {
                const xt = dt.bind(this);
                return this.emitter_.on(at, Ct=>{
                    xt(Ct.event)
                }
                ),
                this
            }
            refresh() {
                this.controller_.binding.read()
            }
            onBindingChange_(at) {
                const dt = at.sender.target.read();
                this.emitter_.emit("change", {
                    event: new ot(this,dt,this.controller_.binding.target.presetKey,at.options.last)
                })
            }
        }
        class Qn extends Gt {
            constructor(at, dt) {
                super(at, dt),
                this.binding = dt.binding
            }
        }
        class _r extends rt {
            constructor(at) {
                super(at),
                this.onBindingUpdate_ = this.onBindingUpdate_.bind(this),
                this.emitter_ = new mt,
                this.controller_.binding.emitter.on("update", this.onBindingUpdate_)
            }
            get label() {
                return this.controller_.props.get("label")
            }
            set label(at) {
                this.controller_.props.set("label", at)
            }
            on(at, dt) {
                const xt = dt.bind(this);
                return this.emitter_.on(at, Ct=>{
                    xt(Ct.event)
                }
                ),
                this
            }
            refresh() {
                this.controller_.binding.read()
            }
            onBindingUpdate_(at) {
                const dt = at.sender.target.read();
                this.emitter_.emit("update", {
                    event: new st(this,dt,this.controller_.binding.target.presetKey)
                })
            }
        }
        class hr extends Gt {
            constructor(at, dt) {
                super(at, dt),
                this.binding = dt.binding,
                this.viewProps.bindDisabled(this.binding.ticker),
                this.viewProps.handleDispose(()=>{
                    this.binding.dispose()
                }
                )
            }
        }
        function Do(pt) {
            return pt instanceof Ir ? pt.apiSet_ : pt instanceof Tn ? pt.rackApi_.apiSet_ : null
        }
        function Mr(pt, at) {
            const dt = pt.find(xt=>xt.controller_ === at);
            if (!dt)
                throw vt.shouldNeverHappen();
            return dt
        }
        function wo(pt, at, dt) {
            if (!yt.isBindable(pt))
                throw vt.notBindable();
            return new yt(pt,at,dt)
        }
        class Ir extends rt {
            constructor(at, dt) {
                super(at),
                this.onRackAdd_ = this.onRackAdd_.bind(this),
                this.onRackRemove_ = this.onRackRemove_.bind(this),
                this.onRackInputChange_ = this.onRackInputChange_.bind(this),
                this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this),
                this.emitter_ = new mt,
                this.apiSet_ = new Jn(Do),
                this.pool_ = dt;
                const xt = this.controller_.rack;
                xt.emitter.on("add", this.onRackAdd_),
                xt.emitter.on("remove", this.onRackRemove_),
                xt.emitter.on("inputchange", this.onRackInputChange_),
                xt.emitter.on("monitorupdate", this.onRackMonitorUpdate_),
                xt.children.forEach(Ct=>{
                    this.setUpApi_(Ct)
                }
                )
            }
            get children() {
                return this.controller_.rack.children.map(at=>Mr(this.apiSet_, at))
            }
            addInput(at, dt, xt) {
                const Ct = xt != null ? xt : {}
                  , zt = this.controller_.view.element.ownerDocument
                  , Yt = this.pool_.createInput(zt, wo(at, dt, Ct.presetKey), Ct)
                  , Sn = new dr(Yt);
                return this.add(Sn, Ct.index)
            }
            addMonitor(at, dt, xt) {
                const Ct = xt != null ? xt : {}
                  , zt = this.controller_.view.element.ownerDocument
                  , Yt = this.pool_.createMonitor(zt, wo(at, dt), Ct)
                  , Sn = new _r(Yt);
                return this.add(Sn, Ct.index)
            }
            addFolder(at) {
                return yn(this, at)
            }
            addButton(at) {
                return Hn(this, at)
            }
            addSeparator(at) {
                return xn(this, at)
            }
            addTab(at) {
                return Nn(this, at)
            }
            add(at, dt) {
                this.controller_.rack.add(at.controller_, dt);
                const xt = this.apiSet_.find(Ct=>Ct.controller_ === at.controller_);
                return xt && this.apiSet_.remove(xt),
                this.apiSet_.add(at),
                at
            }
            remove(at) {
                this.controller_.rack.remove(at.controller_)
            }
            addBlade(at) {
                const dt = this.controller_.view.element.ownerDocument
                  , xt = this.pool_.createBlade(dt, at)
                  , Ct = this.pool_.createBladeApi(xt);
                return this.add(Ct, at.index)
            }
            on(at, dt) {
                const xt = dt.bind(this);
                return this.emitter_.on(at, Ct=>{
                    xt(Ct.event)
                }
                ),
                this
            }
            setUpApi_(at) {
                this.apiSet_.find(xt=>xt.controller_ === at) || this.apiSet_.add(this.pool_.createBladeApi(at))
            }
            onRackAdd_(at) {
                this.setUpApi_(at.bladeController)
            }
            onRackRemove_(at) {
                if (at.isRoot) {
                    const dt = Mr(this.apiSet_, at.bladeController);
                    this.apiSet_.remove(dt)
                }
            }
            onRackInputChange_(at) {
                const dt = at.bladeController;
                if (dt instanceof Qn) {
                    const xt = Mr(this.apiSet_, dt)
                      , Ct = dt.binding;
                    this.emitter_.emit("change", {
                        event: new ot(xt,Ct.target.read(),Ct.target.presetKey,at.options.last)
                    })
                } else if (dt instanceof Vt) {
                    const xt = Mr(this.apiSet_, dt);
                    this.emitter_.emit("change", {
                        event: new ot(xt,dt.value.rawValue,void 0,at.options.last)
                    })
                }
            }
            onRackMonitorUpdate_(at) {
                if (!(at.bladeController instanceof hr))
                    throw vt.shouldNeverHappen();
                const dt = Mr(this.apiSet_, at.bladeController)
                  , xt = at.bladeController.binding;
                this.emitter_.emit("update", {
                    event: new st(dt,xt.target.read(),xt.target.presetKey)
                })
            }
        }
        class Yr extends Tn {
            constructor(at, dt) {
                super(at, new Ir(at.rackController,dt)),
                this.emitter_ = new mt,
                this.controller_.foldable.value("expanded").emitter.on("change", xt=>{
                    this.emitter_.emit("fold", {
                        event: new lt(this,xt.sender.rawValue)
                    })
                }
                ),
                this.rackApi_.on("change", xt=>{
                    this.emitter_.emit("change", {
                        event: xt
                    })
                }
                ),
                this.rackApi_.on("update", xt=>{
                    this.emitter_.emit("update", {
                        event: xt
                    })
                }
                )
            }
            get expanded() {
                return this.controller_.foldable.get("expanded")
            }
            set expanded(at) {
                this.controller_.foldable.set("expanded", at)
            }
            get title() {
                return this.controller_.props.get("title")
            }
            set title(at) {
                this.controller_.props.set("title", at)
            }
            get children() {
                return this.rackApi_.children
            }
            addInput(at, dt, xt) {
                return this.rackApi_.addInput(at, dt, xt)
            }
            addMonitor(at, dt, xt) {
                return this.rackApi_.addMonitor(at, dt, xt)
            }
            addFolder(at) {
                return this.rackApi_.addFolder(at)
            }
            addButton(at) {
                return this.rackApi_.addButton(at)
            }
            addSeparator(at) {
                return this.rackApi_.addSeparator(at)
            }
            addTab(at) {
                return this.rackApi_.addTab(at)
            }
            add(at, dt) {
                return this.rackApi_.add(at, dt)
            }
            remove(at) {
                this.rackApi_.remove(at)
            }
            addBlade(at) {
                return this.rackApi_.addBlade(at)
            }
            on(at, dt) {
                const xt = dt.bind(this);
                return this.emitter_.on(at, Ct=>{
                    xt(Ct.event)
                }
                ),
                this
            }
        }
        class so extends Rn {
            constructor(at) {
                super({
                    blade: at.blade,
                    view: at.view,
                    viewProps: at.rackController.viewProps
                }),
                this.rackController = at.rackController
            }
        }
        class Fo {
            constructor(at, dt) {
                const xt = bt(dt.viewName);
                this.element = at.createElement("div"),
                this.element.classList.add(xt()),
                dt.viewProps.bindClassModifiers(this.element)
            }
        }
        function Oo(pt, at) {
            for (let dt = 0; dt < pt.length; dt++) {
                const xt = pt[dt];
                if (xt instanceof Qn && xt.binding === at)
                    return xt
            }
            return null
        }
        function It(pt, at) {
            for (let dt = 0; dt < pt.length; dt++) {
                const xt = pt[dt];
                if (xt instanceof hr && xt.binding === at)
                    return xt
            }
            return null
        }
        function Qt(pt, at) {
            for (let dt = 0; dt < pt.length; dt++) {
                const xt = pt[dt];
                if (xt instanceof Vt && xt.value === at)
                    return xt
            }
            return null
        }
        function dn(pt) {
            return pt instanceof jn ? pt.rack : pt instanceof so ? pt.rackController.rack : null
        }
        function ln(pt) {
            const at = dn(pt);
            return at ? at.bcSet_ : null
        }
        class gn {
            constructor(at) {
                var dt;
                this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this),
                this.onSetAdd_ = this.onSetAdd_.bind(this),
                this.onSetRemove_ = this.onSetRemove_.bind(this),
                this.onChildDispose_ = this.onChildDispose_.bind(this),
                this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this),
                this.onChildInputChange_ = this.onChildInputChange_.bind(this),
                this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this),
                this.onChildValueChange_ = this.onChildValueChange_.bind(this),
                this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this),
                this.onDescendantLayout_ = this.onDescendantLayout_.bind(this),
                this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this),
                this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this),
                this.emitter = new mt,
                this.blade_ = at != null ? at : null,
                (dt = this.blade_) === null || dt === void 0 || dt.value("positions").emitter.on("change", this.onBladePositionsChange_),
                this.bcSet_ = new Jn(ln),
                this.bcSet_.emitter.on("add", this.onSetAdd_),
                this.bcSet_.emitter.on("remove", this.onSetRemove_)
            }
            get children() {
                return this.bcSet_.items
            }
            add(at, dt) {
                at.parent && at.parent.remove(at),
                at.parent_ = this,
                this.bcSet_.add(at, dt)
            }
            remove(at) {
                at.parent_ = null,
                this.bcSet_.remove(at)
            }
            find(at) {
                return this.bcSet_.allItems().filter(dt=>dt instanceof at)
            }
            onSetAdd_(at) {
                this.updatePositions_();
                const dt = at.target === at.root;
                if (this.emitter.emit("add", {
                    bladeController: at.item,
                    index: at.index,
                    isRoot: dt,
                    sender: this
                }),
                !dt)
                    return;
                const xt = at.item;
                if (xt.viewProps.emitter.on("change", this.onChildViewPropsChange_),
                xt.blade.value("positions").emitter.on("change", this.onChildPositionsChange_),
                xt.viewProps.handleDispose(this.onChildDispose_),
                xt instanceof Qn)
                    xt.binding.emitter.on("change", this.onChildInputChange_);
                else if (xt instanceof hr)
                    xt.binding.emitter.on("update", this.onChildMonitorUpdate_);
                else if (xt instanceof Vt)
                    xt.value.emitter.on("change", this.onChildValueChange_);
                else {
                    const Ct = dn(xt);
                    if (Ct) {
                        const zt = Ct.emitter;
                        zt.on("layout", this.onDescendantLayout_),
                        zt.on("inputchange", this.onDescendantInputChange_),
                        zt.on("monitorupdate", this.onDescendantMonitorUpdate_)
                    }
                }
            }
            onSetRemove_(at) {
                this.updatePositions_();
                const dt = at.target === at.root;
                if (this.emitter.emit("remove", {
                    bladeController: at.item,
                    isRoot: dt,
                    sender: this
                }),
                !dt)
                    return;
                const xt = at.item;
                if (xt instanceof Qn)
                    xt.binding.emitter.off("change", this.onChildInputChange_);
                else if (xt instanceof hr)
                    xt.binding.emitter.off("update", this.onChildMonitorUpdate_);
                else if (xt instanceof Vt)
                    xt.value.emitter.off("change", this.onChildValueChange_);
                else {
                    const Ct = dn(xt);
                    if (Ct) {
                        const zt = Ct.emitter;
                        zt.off("layout", this.onDescendantLayout_),
                        zt.off("inputchange", this.onDescendantInputChange_),
                        zt.off("monitorupdate", this.onDescendantMonitorUpdate_)
                    }
                }
            }
            updatePositions_() {
                const at = this.bcSet_.items.filter(Ct=>!Ct.viewProps.get("hidden"))
                  , dt = at[0]
                  , xt = at[at.length - 1];
                this.bcSet_.items.forEach(Ct=>{
                    const zt = [];
                    Ct === dt && (zt.push("first"),
                    (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && zt.push("veryfirst")),
                    Ct === xt && (zt.push("last"),
                    (!this.blade_ || this.blade_.get("positions").includes("verylast")) && zt.push("verylast")),
                    Ct.blade.set("positions", zt)
                }
                )
            }
            onChildPositionsChange_() {
                this.updatePositions_(),
                this.emitter.emit("layout", {
                    sender: this
                })
            }
            onChildViewPropsChange_(at) {
                this.updatePositions_(),
                this.emitter.emit("layout", {
                    sender: this
                })
            }
            onChildDispose_() {
                this.bcSet_.items.filter(dt=>dt.viewProps.get("disposed")).forEach(dt=>{
                    this.bcSet_.remove(dt)
                }
                )
            }
            onChildInputChange_(at) {
                const dt = Oo(this.find(Qn), at.sender);
                if (!dt)
                    throw vt.alreadyDisposed();
                this.emitter.emit("inputchange", {
                    bladeController: dt,
                    options: at.options,
                    sender: this
                })
            }
            onChildMonitorUpdate_(at) {
                const dt = It(this.find(hr), at.sender);
                if (!dt)
                    throw vt.alreadyDisposed();
                this.emitter.emit("monitorupdate", {
                    bladeController: dt,
                    sender: this
                })
            }
            onChildValueChange_(at) {
                const dt = Qt(this.find(Vt), at.sender);
                if (!dt)
                    throw vt.alreadyDisposed();
                this.emitter.emit("inputchange", {
                    bladeController: dt,
                    options: at.options,
                    sender: this
                })
            }
            onDescendantLayout_(at) {
                this.updatePositions_(),
                this.emitter.emit("layout", {
                    sender: this
                })
            }
            onDescendantInputChange_(at) {
                this.emitter.emit("inputchange", {
                    bladeController: at.bladeController,
                    options: at.options,
                    sender: this
                })
            }
            onDescendantMonitorUpdate_(at) {
                this.emitter.emit("monitorupdate", {
                    bladeController: at.bladeController,
                    sender: this
                })
            }
            onBladePositionsChange_() {
                this.updatePositions_()
            }
        }
        class jn extends Rn {
            constructor(at, dt) {
                super(Object.assign(Object.assign({}, dt), {
                    view: new Fo(at,{
                        viewName: "brk",
                        viewProps: dt.viewProps
                    })
                })),
                this.onRackAdd_ = this.onRackAdd_.bind(this),
                this.onRackRemove_ = this.onRackRemove_.bind(this);
                const xt = new gn(dt.root ? void 0 : dt.blade);
                xt.emitter.on("add", this.onRackAdd_),
                xt.emitter.on("remove", this.onRackRemove_),
                this.rack = xt,
                this.viewProps.handleDispose(()=>{
                    for (let Ct = this.rack.children.length - 1; Ct >= 0; Ct--)
                        this.rack.children[Ct].viewProps.set("disposed", !0)
                }
                )
            }
            onRackAdd_(at) {
                !at.isRoot || Wn(this.view.element, at.bladeController.view.element, at.index)
            }
            onRackRemove_(at) {
                !at.isRoot || rr(at.bladeController.view.element)
            }
        }
        const Xn = bt("cnt");
        class Zn {
            constructor(at, dt) {
                var xt;
                this.className_ = bt((xt = dt.viewName) !== null && xt !== void 0 ? xt : "fld"),
                this.element = at.createElement("div"),
                this.element.classList.add(this.className_(), Xn()),
                dt.viewProps.bindClassModifiers(this.element),
                this.foldable_ = dt.foldable,
                this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")),
                Pt(this.foldable_, "completed", Zt(this.element, this.className_(void 0, "cpl")));
                const Ct = at.createElement("button");
                Ct.classList.add(this.className_("b")),
                Pt(dt.props, "title", Bn=>{
                    ht(Bn) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"))
                }
                ),
                dt.viewProps.bindDisabled(Ct),
                this.element.appendChild(Ct),
                this.buttonElement = Ct;
                const zt = at.createElement("div");
                zt.classList.add(this.className_("t")),
                Nt(dt.props.value("title"), zt),
                this.buttonElement.appendChild(zt),
                this.titleElement = zt;
                const Yt = at.createElement("div");
                Yt.classList.add(this.className_("m")),
                this.buttonElement.appendChild(Yt);
                const Sn = dt.containerElement;
                Sn.classList.add(this.className_("c")),
                this.element.appendChild(Sn),
                this.containerElement = Sn
            }
        }
        class Yn extends so {
            constructor(at, dt) {
                var xt;
                const Ct = vn.create((xt = dt.expanded) !== null && xt !== void 0 ? xt : !0)
                  , zt = new jn(at,{
                    blade: dt.blade,
                    root: dt.root,
                    viewProps: dt.viewProps
                });
                super(Object.assign(Object.assign({}, dt), {
                    rackController: zt,
                    view: new Zn(at,{
                        containerElement: zt.view.element,
                        foldable: Ct,
                        props: dt.props,
                        viewName: dt.root ? "rot" : void 0,
                        viewProps: dt.viewProps
                    })
                })),
                this.onTitleClick_ = this.onTitleClick_.bind(this),
                this.props = dt.props,
                this.foldable = Ct,
                Cn(this.foldable, this.view.containerElement),
                this.rackController.rack.emitter.on("add", ()=>{
                    this.foldable.cleanUpTransition()
                }
                ),
                this.rackController.rack.emitter.on("remove", ()=>{
                    this.foldable.cleanUpTransition()
                }
                ),
                this.view.buttonElement.addEventListener("click", this.onTitleClick_)
            }
            get document() {
                return this.view.element.ownerDocument
            }
            onTitleClick_() {
                this.foldable.set("expanded", !this.foldable.get("expanded"))
            }
        }
        const sr = {
            id: "folder",
            type: "blade",
            accept(pt) {
                const at = _n
                  , dt = Fn(pt, {
                    title: at.required.string,
                    view: at.required.constant("folder"),
                    expanded: at.optional.boolean
                });
                return dt ? {
                    params: dt
                } : null
            },
            controller(pt) {
                return new Yn(pt.document,{
                    blade: pt.blade,
                    expanded: pt.params.expanded,
                    props: jt.fromObject({
                        title: pt.params.title
                    }),
                    viewProps: pt.viewProps
                })
            },
            api(pt) {
                return pt.controller instanceof Yn ? new Yr(pt.controller,pt.pool) : null
            }
        };
        class Kn extends Vt {
            constructor(at, dt) {
                const xt = dt.valueController.viewProps;
                super(Object.assign(Object.assign({}, dt), {
                    value: dt.valueController.value,
                    view: new In(at,{
                        props: dt.props,
                        viewProps: xt
                    }),
                    viewProps: xt
                })),
                this.props = dt.props,
                this.valueController = dt.valueController,
                this.view.valueElement.appendChild(this.valueController.view.element)
            }
        }
        class tr extends rt {
        }
        const ur = bt("spr");
        class Cr {
            constructor(at, dt) {
                this.element = at.createElement("div"),
                this.element.classList.add(ur()),
                dt.viewProps.bindClassModifiers(this.element);
                const xt = at.createElement("hr");
                xt.classList.add(ur("r")),
                this.element.appendChild(xt)
            }
        }
        class Tr extends Rn {
            constructor(at, dt) {
                super(Object.assign(Object.assign({}, dt), {
                    view: new Cr(at,{
                        viewProps: dt.viewProps
                    })
                }))
            }
        }
        const Dr = {
            id: "separator",
            type: "blade",
            accept(pt) {
                const dt = Fn(pt, {
                    view: _n.required.constant("separator")
                });
                return dt ? {
                    params: dt
                } : null
            },
            controller(pt) {
                return new Tr(pt.document,{
                    blade: pt.blade,
                    viewProps: pt.viewProps
                })
            },
            api(pt) {
                return pt.controller instanceof Tr ? new tr(pt.controller) : null
            }
        }
          , yr = bt("");
        function ir(pt, at) {
            return Zt(pt, yr(void 0, at))
        }
        class vr extends jt {
            constructor(at) {
                super(at)
            }
            static create(at) {
                var dt, xt;
                const Ct = at != null ? at : {}
                  , zt = {
                    disabled: (dt = Ct.disabled) !== null && dt !== void 0 ? dt : !1,
                    disposed: !1,
                    hidden: (xt = Ct.hidden) !== null && xt !== void 0 ? xt : !1
                }
                  , Yt = jt.createCore(zt);
                return new vr(Yt)
            }
            bindClassModifiers(at) {
                Pt(this, "disabled", ir(at, "disabled")),
                Pt(this, "hidden", ir(at, "hidden"))
            }
            bindDisabled(at) {
                Pt(this, "disabled", dt=>{
                    at.disabled = dt
                }
                )
            }
            bindTabIndex(at) {
                Pt(this, "disabled", dt=>{
                    at.tabIndex = dt ? -1 : 0
                }
                )
            }
            handleDispose(at) {
                this.value("disposed").emitter.on("change", dt=>{
                    dt && at()
                }
                )
            }
        }
        const lr = bt("tbi");
        class br {
            constructor(at, dt) {
                this.element = at.createElement("div"),
                this.element.classList.add(lr()),
                dt.viewProps.bindClassModifiers(this.element),
                Pt(dt.props, "selected", zt=>{
                    zt ? this.element.classList.add(lr(void 0, "sel")) : this.element.classList.remove(lr(void 0, "sel"))
                }
                );
                const xt = at.createElement("button");
                xt.classList.add(lr("b")),
                dt.viewProps.bindDisabled(xt),
                this.element.appendChild(xt),
                this.buttonElement = xt;
                const Ct = at.createElement("div");
                Ct.classList.add(lr("t")),
                Nt(dt.props.value("title"), Ct),
                this.buttonElement.appendChild(Ct),
                this.titleElement = Ct
            }
        }
        class Er {
            constructor(at, dt) {
                this.emitter = new mt,
                this.onClick_ = this.onClick_.bind(this),
                this.props = dt.props,
                this.viewProps = dt.viewProps,
                this.view = new br(at,{
                    props: dt.props,
                    viewProps: dt.viewProps
                }),
                this.view.buttonElement.addEventListener("click", this.onClick_)
            }
            onClick_() {
                this.emitter.emit("click", {
                    sender: this
                })
            }
        }
        class Fr {
            constructor(at, dt) {
                this.onItemClick_ = this.onItemClick_.bind(this),
                this.ic_ = new Er(at,{
                    props: dt.itemProps,
                    viewProps: vr.create()
                }),
                this.ic_.emitter.on("click", this.onItemClick_),
                this.cc_ = new jn(at,{
                    blade: hn(),
                    viewProps: vr.create()
                }),
                this.props = dt.props,
                Pt(this.props, "selected", xt=>{
                    this.itemController.props.set("selected", xt),
                    this.contentController.viewProps.set("hidden", !xt)
                }
                )
            }
            get itemController() {
                return this.ic_
            }
            get contentController() {
                return this.cc_
            }
            onItemClick_() {
                this.props.set("selected", !0)
            }
        }
        class Zr {
            constructor(at, dt) {
                this.controller_ = at,
                this.rackApi_ = dt
            }
            get title() {
                var at;
                return (at = this.controller_.itemController.props.get("title")) !== null && at !== void 0 ? at : ""
            }
            set title(at) {
                this.controller_.itemController.props.set("title", at)
            }
            get selected() {
                return this.controller_.props.get("selected")
            }
            set selected(at) {
                this.controller_.props.set("selected", at)
            }
            get children() {
                return this.rackApi_.children
            }
            addButton(at) {
                return this.rackApi_.addButton(at)
            }
            addFolder(at) {
                return this.rackApi_.addFolder(at)
            }
            addSeparator(at) {
                return this.rackApi_.addSeparator(at)
            }
            addTab(at) {
                return this.rackApi_.addTab(at)
            }
            add(at, dt) {
                this.rackApi_.add(at, dt)
            }
            remove(at) {
                this.rackApi_.remove(at)
            }
            addInput(at, dt, xt) {
                return this.rackApi_.addInput(at, dt, xt)
            }
            addMonitor(at, dt, xt) {
                return this.rackApi_.addMonitor(at, dt, xt)
            }
            addBlade(at) {
                return this.rackApi_.addBlade(at)
            }
        }
        class pr extends Tn {
            constructor(at, dt) {
                super(at, new Ir(at.rackController,dt)),
                this.onPageAdd_ = this.onPageAdd_.bind(this),
                this.onPageRemove_ = this.onPageRemove_.bind(this),
                this.onSelect_ = this.onSelect_.bind(this),
                this.emitter_ = new mt,
                this.pageApiMap_ = new Map,
                this.rackApi_.on("change", xt=>{
                    this.emitter_.emit("change", {
                        event: xt
                    })
                }
                ),
                this.rackApi_.on("update", xt=>{
                    this.emitter_.emit("update", {
                        event: xt
                    })
                }
                ),
                this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_),
                this.controller_.pageSet.emitter.on("add", this.onPageAdd_),
                this.controller_.pageSet.emitter.on("remove", this.onPageRemove_),
                this.controller_.pageSet.items.forEach(xt=>{
                    this.setUpPageApi_(xt)
                }
                )
            }
            get pages() {
                return this.controller_.pageSet.items.map(at=>{
                    const dt = this.pageApiMap_.get(at);
                    if (!dt)
                        throw vt.shouldNeverHappen();
                    return dt
                }
                )
            }
            addPage(at) {
                const dt = this.controller_.view.element.ownerDocument
                  , xt = new Fr(dt,{
                    itemProps: jt.fromObject({
                        selected: !1,
                        title: at.title
                    }),
                    props: jt.fromObject({
                        selected: !1
                    })
                });
                this.controller_.add(xt, at.index);
                const Ct = this.pageApiMap_.get(xt);
                if (!Ct)
                    throw vt.shouldNeverHappen();
                return Ct
            }
            removePage(at) {
                this.controller_.remove(at)
            }
            on(at, dt) {
                const xt = dt.bind(this);
                return this.emitter_.on(at, Ct=>{
                    xt(Ct.event)
                }
                ),
                this
            }
            setUpPageApi_(at) {
                const dt = this.rackApi_.apiSet_.find(Ct=>Ct.controller_ === at.contentController);
                if (!dt)
                    throw vt.shouldNeverHappen();
                const xt = new Zr(at,dt);
                this.pageApiMap_.set(at, xt)
            }
            onPageAdd_(at) {
                this.setUpPageApi_(at.item)
            }
            onPageRemove_(at) {
                if (!this.pageApiMap_.get(at.item))
                    throw vt.shouldNeverHappen();
                this.pageApiMap_.delete(at.item)
            }
            onSelect_(at) {
                this.emitter_.emit("select", {
                    event: new ut(this,at.rawValue)
                })
            }
        }
        const Or = -1;
        class ao {
            constructor() {
                this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this),
                this.empty = qt(!0),
                this.selectedIndex = qt(Or),
                this.items_ = []
            }
            add(at, dt) {
                const xt = dt != null ? dt : this.items_.length;
                this.items_.splice(xt, 0, at),
                at.emitter.on("change", this.onItemSelectedChange_),
                this.keepSelection_()
            }
            remove(at) {
                const dt = this.items_.indexOf(at);
                dt < 0 || (this.items_.splice(dt, 1),
                at.emitter.off("change", this.onItemSelectedChange_),
                this.keepSelection_())
            }
            keepSelection_() {
                if (this.items_.length === 0) {
                    this.selectedIndex.rawValue = Or,
                    this.empty.rawValue = !0;
                    return
                }
                const at = this.items_.findIndex(dt=>dt.rawValue);
                at < 0 ? (this.items_.forEach((dt,xt)=>{
                    dt.rawValue = xt === 0
                }
                ),
                this.selectedIndex.rawValue = 0) : (this.items_.forEach((dt,xt)=>{
                    dt.rawValue = xt === at
                }
                ),
                this.selectedIndex.rawValue = at),
                this.empty.rawValue = !1
            }
            onItemSelectedChange_(at) {
                if (at.rawValue) {
                    const dt = this.items_.findIndex(xt=>xt === at.sender);
                    this.items_.forEach((xt,Ct)=>{
                        xt.rawValue = Ct === dt
                    }
                    ),
                    this.selectedIndex.rawValue = dt
                } else
                    this.keepSelection_()
            }
        }
        const gr = bt("tab");
        class Fl {
            constructor(at, dt) {
                this.element = at.createElement("div"),
                this.element.classList.add(gr(), Xn()),
                dt.viewProps.bindClassModifiers(this.element),
                At(dt.empty, Zt(this.element, gr(void 0, "nop")));
                const xt = at.createElement("div");
                xt.classList.add(gr("i")),
                this.element.appendChild(xt),
                this.itemsElement = xt;
                const Ct = dt.contentsElement;
                Ct.classList.add(gr("c")),
                this.element.appendChild(Ct),
                this.contentsElement = Ct
            }
        }
        class ds extends so {
            constructor(at, dt) {
                const xt = new jn(at,{
                    blade: dt.blade,
                    viewProps: dt.viewProps
                })
                  , Ct = new ao;
                super({
                    blade: dt.blade,
                    rackController: xt,
                    view: new Fl(at,{
                        contentsElement: xt.view.element,
                        empty: Ct.empty,
                        viewProps: dt.viewProps
                    })
                }),
                this.onPageAdd_ = this.onPageAdd_.bind(this),
                this.onPageRemove_ = this.onPageRemove_.bind(this),
                this.pageSet_ = new Jn(()=>null),
                this.pageSet_.emitter.on("add", this.onPageAdd_),
                this.pageSet_.emitter.on("remove", this.onPageRemove_),
                this.tab = Ct
            }
            get pageSet() {
                return this.pageSet_
            }
            add(at, dt) {
                this.pageSet_.add(at, dt)
            }
            remove(at) {
                this.pageSet_.remove(this.pageSet_.items[at])
            }
            onPageAdd_(at) {
                const dt = at.item;
                Wn(this.view.itemsElement, dt.itemController.view.element, at.index),
                this.rackController.rack.add(dt.contentController, at.index),
                this.tab.add(dt.props.value("selected"))
            }
            onPageRemove_(at) {
                const dt = at.item;
                rr(dt.itemController.view.element),
                this.rackController.rack.remove(dt.contentController),
                this.tab.remove(dt.props.value("selected"))
            }
        }
        const hs = {
            id: "tab",
            type: "blade",
            accept(pt) {
                const at = _n
                  , dt = Fn(pt, {
                    pages: at.required.array(at.required.object({
                        title: at.required.string
                    })),
                    view: at.required.constant("tab")
                });
                return !dt || dt.pages.length === 0 ? null : {
                    params: dt
                }
            },
            controller(pt) {
                const at = new ds(pt.document,{
                    blade: pt.blade,
                    viewProps: pt.viewProps
                });
                return pt.params.pages.forEach(dt=>{
                    const xt = new Fr(pt.document,{
                        itemProps: jt.fromObject({
                            selected: !1,
                            title: dt.title
                        }),
                        props: jt.fromObject({
                            selected: !1
                        })
                    });
                    at.add(xt)
                }
                ),
                at
            },
            api(pt) {
                return pt.controller instanceof ds ? new pr(pt.controller,pt.pool) : null
            }
        };
        function Ol(pt, at) {
            const dt = pt.accept(at.params);
            if (!dt)
                return null;
            const xt = _n.optional.boolean(at.params.disabled).value
              , Ct = _n.optional.boolean(at.params.hidden).value;
            return pt.controller({
                blade: hn(),
                document: at.document,
                params: Object.assign(Object.assign({}, dt.params), {
                    disabled: xt,
                    hidden: Ct
                }),
                viewProps: vr.create({
                    disabled: xt,
                    hidden: Ct
                })
            })
        }
        class Vl {
            constructor() {
                this.disabled = !1,
                this.emitter = new mt
            }
            dispose() {}
            tick() {
                this.disabled || this.emitter.emit("tick", {
                    sender: this
                })
            }
        }
        class Nl {
            constructor(at, dt) {
                this.disabled_ = !1,
                this.timerId_ = null,
                this.onTick_ = this.onTick_.bind(this),
                this.doc_ = at,
                this.emitter = new mt,
                this.interval_ = dt,
                this.setTimer_()
            }
            get disabled() {
                return this.disabled_
            }
            set disabled(at) {
                this.disabled_ = at,
                this.disabled_ ? this.clearTimer_() : this.setTimer_()
            }
            dispose() {
                this.clearTimer_()
            }
            clearTimer_() {
                if (this.timerId_ === null)
                    return;
                const at = this.doc_.defaultView;
                at && at.clearInterval(this.timerId_),
                this.timerId_ = null
            }
            setTimer_() {
                if (this.clearTimer_(),
                this.interval_ <= 0)
                    return;
                const at = this.doc_.defaultView;
                at && (this.timerId_ = at.setInterval(this.onTick_, this.interval_))
            }
            onTick_() {
                this.disabled_ || this.emitter.emit("tick", {
                    sender: this
                })
            }
        }
        class lo {
            constructor(at) {
                this.constraints = at
            }
            constrain(at) {
                return this.constraints.reduce((dt,xt)=>xt.constrain(dt), at)
            }
        }
        function Ar(pt, at) {
            if (pt instanceof at)
                return pt;
            if (pt instanceof lo) {
                const dt = pt.constraints.reduce((xt,Ct)=>xt || (Ct instanceof at ? Ct : null), null);
                if (dt)
                    return dt
            }
            return null
        }
        class Kr {
            constructor(at) {
                this.values = jt.fromObject({
                    max: at.max,
                    min: at.min
                })
            }
            constrain(at) {
                const dt = this.values.get("max")
                  , xt = this.values.get("min");
                return Math.min(Math.max(at, xt), dt)
            }
        }
        class uo {
            constructor(at) {
                this.values = jt.fromObject({
                    options: at
                })
            }
            get options() {
                return this.values.get("options")
            }
            constrain(at) {
                const dt = this.values.get("options");
                return dt.length === 0 || dt.filter(Ct=>Ct.value === at).length > 0 ? at : dt[0].value
            }
        }
        class ps {
            constructor(at) {
                this.values = jt.fromObject({
                    max: at.max,
                    min: at.min
                })
            }
            get maxValue() {
                return this.values.get("max")
            }
            get minValue() {
                return this.values.get("min")
            }
            constrain(at) {
                const dt = this.values.get("max")
                  , xt = this.values.get("min");
                let Ct = at;
                return ht(xt) || (Ct = Math.max(Ct, xt)),
                ht(dt) || (Ct = Math.min(Ct, dt)),
                Ct
            }
        }
        class So {
            constructor(at, dt=0) {
                this.step = at,
                this.origin = dt
            }
            constrain(at) {
                const dt = this.origin % this.step
                  , xt = Math.round((at - dt) / this.step);
                return dt + xt * this.step
            }
        }
        const Vo = bt("lst");
        class Bl {
            constructor(at, dt) {
                this.onValueChange_ = this.onValueChange_.bind(this),
                this.props_ = dt.props,
                this.element = at.createElement("div"),
                this.element.classList.add(Vo()),
                dt.viewProps.bindClassModifiers(this.element);
                const xt = at.createElement("select");
                xt.classList.add(Vo("s")),
                Pt(this.props_, "options", zt=>{
                    Dt(xt),
                    zt.forEach((Yt,Sn)=>{
                        const Bn = at.createElement("option");
                        Bn.dataset.index = String(Sn),
                        Bn.textContent = Yt.text,
                        Bn.value = String(Yt.value),
                        xt.appendChild(Bn)
                    }
                    )
                }
                ),
                dt.viewProps.bindDisabled(xt),
                this.element.appendChild(xt),
                this.selectElement = xt;
                const Ct = at.createElement("div");
                Ct.classList.add(Vo("m")),
                Ct.appendChild(On(at, "dropdown")),
                this.element.appendChild(Ct),
                dt.value.emitter.on("change", this.onValueChange_),
                this.value_ = dt.value,
                this.update_()
            }
            update_() {
                this.selectElement.value = String(this.value_.rawValue)
            }
            onValueChange_() {
                this.update_()
            }
        }
        class co {
            constructor(at, dt) {
                this.onSelectChange_ = this.onSelectChange_.bind(this),
                this.props = dt.props,
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.view = new Bl(at,{
                    props: this.props,
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.view.selectElement.addEventListener("change", this.onSelectChange_)
            }
            onSelectChange_(at) {
                const xt = at.currentTarget.selectedOptions.item(0);
                if (!xt)
                    return;
                const Ct = Number(xt.dataset.index);
                this.value.rawValue = this.props.get("options")[Ct].value
            }
        }
        const fs = bt("pop");
        class zl {
            constructor(at, dt) {
                this.element = at.createElement("div"),
                this.element.classList.add(fs()),
                dt.viewProps.bindClassModifiers(this.element),
                At(dt.shows, Zt(this.element, fs(void 0, "v")))
            }
        }
        class gs {
            constructor(at, dt) {
                this.shows = qt(!1),
                this.viewProps = dt.viewProps,
                this.view = new zl(at,{
                    shows: this.shows,
                    viewProps: this.viewProps
                })
            }
        }
        const vs = bt("txt");
        class $l {
            constructor(at, dt) {
                this.onChange_ = this.onChange_.bind(this),
                this.element = at.createElement("div"),
                this.element.classList.add(vs()),
                dt.viewProps.bindClassModifiers(this.element),
                this.props_ = dt.props,
                this.props_.emitter.on("change", this.onChange_);
                const xt = at.createElement("input");
                xt.classList.add(vs("i")),
                xt.type = "text",
                dt.viewProps.bindDisabled(xt),
                this.element.appendChild(xt),
                this.inputElement = xt,
                dt.value.emitter.on("change", this.onChange_),
                this.value_ = dt.value,
                this.refresh()
            }
            refresh() {
                const at = this.props_.get("formatter");
                this.inputElement.value = at(this.value_.rawValue)
            }
            onChange_() {
                this.refresh()
            }
        }
        class Mo {
            constructor(at, dt) {
                this.onInputChange_ = this.onInputChange_.bind(this),
                this.parser_ = dt.parser,
                this.props = dt.props,
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.view = new $l(at,{
                    props: dt.props,
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.view.inputElement.addEventListener("change", this.onInputChange_)
            }
            onInputChange_(at) {
                const xt = at.currentTarget.value
                  , Ct = this.parser_(xt);
                ht(Ct) || (this.value.rawValue = Ct),
                this.view.refresh()
            }
        }
        function Ul(pt) {
            return String(pt)
        }
        function _s(pt) {
            return pt === "false" ? !1 : !!pt
        }
        function xs(pt) {
            return Ul(pt)
        }
        class Hl {
            constructor(at) {
                this.text = at
            }
            evaluate() {
                return Number(this.text)
            }
            toString() {
                return this.text
            }
        }
        const Gl = {
            "**": (pt,at)=>Math.pow(pt, at),
            "*": (pt,at)=>pt * at,
            "/": (pt,at)=>pt / at,
            "%": (pt,at)=>pt % at,
            "+": (pt,at)=>pt + at,
            "-": (pt,at)=>pt - at,
            "<<": (pt,at)=>pt << at,
            ">>": (pt,at)=>pt >> at,
            ">>>": (pt,at)=>pt >>> at,
            "&": (pt,at)=>pt & at,
            "^": (pt,at)=>pt ^ at,
            "|": (pt,at)=>pt | at
        };
        class Wl {
            constructor(at, dt, xt) {
                this.left = dt,
                this.operator = at,
                this.right = xt
            }
            evaluate() {
                const at = Gl[this.operator];
                if (!at)
                    throw new Error(`unexpected binary operator: '${this.operator}`);
                return at(this.left.evaluate(), this.right.evaluate())
            }
            toString() {
                return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
            }
        }
        const Xl = {
            "+": pt=>pt,
            "-": pt=>-pt,
            "~": pt=>~pt
        };
        class Yl {
            constructor(at, dt) {
                this.operator = at,
                this.expression = dt
            }
            evaluate() {
                const at = Xl[this.operator];
                if (!at)
                    throw new Error(`unexpected unary operator: '${this.operator}`);
                return at(this.expression.evaluate())
            }
            toString() {
                return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
            }
        }
        function No(pt) {
            return (at,dt)=>{
                for (let xt = 0; xt < pt.length; xt++) {
                    const Ct = pt[xt](at, dt);
                    if (Ct !== "")
                        return Ct
                }
                return ""
            }
        }
        function ho(pt, at) {
            var dt;
            const xt = pt.substr(at).match(/^\s+/);
            return (dt = xt && xt[0]) !== null && dt !== void 0 ? dt : ""
        }
        function Zl(pt, at) {
            const dt = pt.substr(at, 1);
            return dt.match(/^[1-9]$/) ? dt : ""
        }
        function po(pt, at) {
            var dt;
            const xt = pt.substr(at).match(/^[0-9]+/);
            return (dt = xt && xt[0]) !== null && dt !== void 0 ? dt : ""
        }
        function Kl(pt, at) {
            const dt = po(pt, at);
            if (dt !== "")
                return dt;
            const xt = pt.substr(at, 1);
            if (at += 1,
            xt !== "-" && xt !== "+")
                return "";
            const Ct = po(pt, at);
            return Ct === "" ? "" : xt + Ct
        }
        function Bo(pt, at) {
            const dt = pt.substr(at, 1);
            if (at += 1,
            dt.toLowerCase() !== "e")
                return "";
            const xt = Kl(pt, at);
            return xt === "" ? "" : dt + xt
        }
        function ys(pt, at) {
            const dt = pt.substr(at, 1);
            if (dt === "0")
                return dt;
            const xt = Zl(pt, at);
            return at += xt.length,
            xt === "" ? "" : xt + po(pt, at)
        }
        function Ql(pt, at) {
            const dt = ys(pt, at);
            if (at += dt.length,
            dt === "")
                return "";
            const xt = pt.substr(at, 1);
            if (at += xt.length,
            xt !== ".")
                return "";
            const Ct = po(pt, at);
            return at += Ct.length,
            dt + xt + Ct + Bo(pt, at)
        }
        function Jl(pt, at) {
            const dt = pt.substr(at, 1);
            if (at += dt.length,
            dt !== ".")
                return "";
            const xt = po(pt, at);
            return at += xt.length,
            xt === "" ? "" : dt + xt + Bo(pt, at)
        }
        function eu(pt, at) {
            const dt = ys(pt, at);
            return at += dt.length,
            dt === "" ? "" : dt + Bo(pt, at)
        }
        const tu = No([Ql, Jl, eu]);
        function nu(pt, at) {
            var dt;
            const xt = pt.substr(at).match(/^[01]+/);
            return (dt = xt && xt[0]) !== null && dt !== void 0 ? dt : ""
        }
        function ru(pt, at) {
            const dt = pt.substr(at, 2);
            if (at += dt.length,
            dt.toLowerCase() !== "0b")
                return "";
            const xt = nu(pt, at);
            return xt === "" ? "" : dt + xt
        }
        function iu(pt, at) {
            var dt;
            const xt = pt.substr(at).match(/^[0-7]+/);
            return (dt = xt && xt[0]) !== null && dt !== void 0 ? dt : ""
        }
        function ou(pt, at) {
            const dt = pt.substr(at, 2);
            if (at += dt.length,
            dt.toLowerCase() !== "0o")
                return "";
            const xt = iu(pt, at);
            return xt === "" ? "" : dt + xt
        }
        function su(pt, at) {
            var dt;
            const xt = pt.substr(at).match(/^[0-9a-f]+/i);
            return (dt = xt && xt[0]) !== null && dt !== void 0 ? dt : ""
        }
        function au(pt, at) {
            const dt = pt.substr(at, 2);
            if (at += dt.length,
            dt.toLowerCase() !== "0x")
                return "";
            const xt = su(pt, at);
            return xt === "" ? "" : dt + xt
        }
        const lu = No([ru, ou, au])
          , uu = No([lu, tu]);
        function cu(pt, at) {
            const dt = uu(pt, at);
            return at += dt.length,
            dt === "" ? null : {
                evaluable: new Hl(dt),
                cursor: at
            }
        }
        function du(pt, at) {
            const dt = pt.substr(at, 1);
            if (at += dt.length,
            dt !== "(")
                return null;
            const xt = ws(pt, at);
            if (!xt)
                return null;
            at = xt.cursor,
            at += ho(pt, at).length;
            const Ct = pt.substr(at, 1);
            return at += Ct.length,
            Ct !== ")" ? null : {
                evaluable: xt.evaluable,
                cursor: at
            }
        }
        function hu(pt, at) {
            var dt;
            return (dt = cu(pt, at)) !== null && dt !== void 0 ? dt : du(pt, at)
        }
        function bs(pt, at) {
            const dt = hu(pt, at);
            if (dt)
                return dt;
            const xt = pt.substr(at, 1);
            if (at += xt.length,
            xt !== "+" && xt !== "-" && xt !== "~")
                return null;
            const Ct = bs(pt, at);
            return Ct ? (at = Ct.cursor,
            {
                cursor: at,
                evaluable: new Yl(xt,Ct.evaluable)
            }) : null
        }
        function pu(pt, at, dt) {
            dt += ho(at, dt).length;
            const xt = pt.filter(Ct=>at.startsWith(Ct, dt))[0];
            return xt ? (dt += xt.length,
            dt += ho(at, dt).length,
            {
                cursor: dt,
                operator: xt
            }) : null
        }
        function fu(pt, at) {
            return (dt,xt)=>{
                const Ct = pt(dt, xt);
                if (!Ct)
                    return null;
                xt = Ct.cursor;
                let zt = Ct.evaluable;
                for (; ; ) {
                    const Yt = pu(at, dt, xt);
                    if (!Yt)
                        break;
                    xt = Yt.cursor;
                    const Sn = pt(dt, xt);
                    if (!Sn)
                        return null;
                    xt = Sn.cursor,
                    zt = new Wl(Yt.operator,zt,Sn.evaluable)
                }
                return zt ? {
                    cursor: xt,
                    evaluable: zt
                } : null
            }
        }
        const mu = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce((pt,at)=>fu(pt, at), bs);
        function ws(pt, at) {
            return at += ho(pt, at).length,
            mu(pt, at)
        }
        function gu(pt) {
            const at = ws(pt, 0);
            return !at || at.cursor + ho(pt, at.cursor).length !== pt.length ? null : at.evaluable
        }
        function Lr(pt) {
            var at;
            const dt = gu(pt);
            return (at = dt == null ? void 0 : dt.evaluate()) !== null && at !== void 0 ? at : null
        }
        function Ss(pt) {
            if (typeof pt == "number")
                return pt;
            if (typeof pt == "string") {
                const at = Lr(pt);
                if (!ht(at))
                    return at
            }
            return 0
        }
        function vu(pt) {
            return String(pt)
        }
        function mr(pt) {
            return at=>at.toFixed(Math.max(Math.min(pt, 20), 0))
        }
        const _u = mr(0);
        function Eo(pt) {
            return _u(pt) + "%"
        }
        function Ms(pt) {
            return String(pt)
        }
        function zo(pt) {
            return pt
        }
        function Es(pt, at) {
            for (; pt.length < at; )
                pt.push(void 0)
        }
        function xu(pt) {
            const at = [];
            return Es(at, pt),
            qt(at)
        }
        function yu(pt) {
            const at = pt.indexOf(void 0);
            return at < 0 ? pt : pt.slice(0, at)
        }
        function bu(pt, at) {
            const dt = [...yu(pt), at];
            return dt.length > pt.length ? dt.splice(0, dt.length - pt.length) : Es(dt, pt.length),
            dt
        }
        function fo({primary: pt, secondary: at, forward: dt, backward: xt}) {
            let Ct = !1;
            function zt(Yt) {
                Ct || (Ct = !0,
                Yt(),
                Ct = !1)
            }
            pt.emitter.on("change", Yt=>{
                zt(()=>{
                    at.setRawValue(dt(pt, at), Yt.options)
                }
                )
            }
            ),
            at.emitter.on("change", Yt=>{
                zt(()=>{
                    pt.setRawValue(xt(pt, at), Yt.options)
                }
                ),
                zt(()=>{
                    at.setRawValue(dt(pt, at), Yt.options)
                }
                )
            }
            ),
            zt(()=>{
                at.setRawValue(dt(pt, at), {
                    forceEmit: !1,
                    last: !0
                })
            }
            )
        }
        function xr(pt, at) {
            const dt = pt * (at.altKey ? .1 : 1) * (at.shiftKey ? 10 : 1);
            return at.upKey ? +dt : at.downKey ? -dt : 0
        }
        function mo(pt) {
            return {
                altKey: pt.altKey,
                downKey: pt.key === "ArrowDown",
                shiftKey: pt.shiftKey,
                upKey: pt.key === "ArrowUp"
            }
        }
        function Pr(pt) {
            return {
                altKey: pt.altKey,
                downKey: pt.key === "ArrowLeft",
                shiftKey: pt.shiftKey,
                upKey: pt.key === "ArrowRight"
            }
        }
        function wu(pt) {
            return pt === "ArrowUp" || pt === "ArrowDown"
        }
        function Cs(pt) {
            return wu(pt) || pt === "ArrowLeft" || pt === "ArrowRight"
        }
        function $o(pt, at) {
            var dt, xt;
            const Ct = at.ownerDocument.defaultView
              , zt = at.getBoundingClientRect();
            return {
                x: pt.pageX - (((dt = Ct && Ct.scrollX) !== null && dt !== void 0 ? dt : 0) + zt.left),
                y: pt.pageY - (((xt = Ct && Ct.scrollY) !== null && xt !== void 0 ? xt : 0) + zt.top)
            }
        }
        class Hr {
            constructor(at) {
                this.lastTouch_ = null,
                this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this),
                this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this),
                this.onMouseDown_ = this.onMouseDown_.bind(this),
                this.onTouchEnd_ = this.onTouchEnd_.bind(this),
                this.onTouchMove_ = this.onTouchMove_.bind(this),
                this.onTouchStart_ = this.onTouchStart_.bind(this),
                this.elem_ = at,
                this.emitter = new mt,
                at.addEventListener("touchstart", this.onTouchStart_, {
                    passive: !1
                }),
                at.addEventListener("touchmove", this.onTouchMove_, {
                    passive: !0
                }),
                at.addEventListener("touchend", this.onTouchEnd_),
                at.addEventListener("mousedown", this.onMouseDown_)
            }
            computePosition_(at) {
                const dt = this.elem_.getBoundingClientRect();
                return {
                    bounds: {
                        width: dt.width,
                        height: dt.height
                    },
                    point: at ? {
                        x: at.x,
                        y: at.y
                    } : null
                }
            }
            onMouseDown_(at) {
                var dt;
                at.preventDefault(),
                (dt = at.currentTarget) === null || dt === void 0 || dt.focus();
                const xt = this.elem_.ownerDocument;
                xt.addEventListener("mousemove", this.onDocumentMouseMove_),
                xt.addEventListener("mouseup", this.onDocumentMouseUp_),
                this.emitter.emit("down", {
                    altKey: at.altKey,
                    data: this.computePosition_($o(at, this.elem_)),
                    sender: this,
                    shiftKey: at.shiftKey
                })
            }
            onDocumentMouseMove_(at) {
                this.emitter.emit("move", {
                    altKey: at.altKey,
                    data: this.computePosition_($o(at, this.elem_)),
                    sender: this,
                    shiftKey: at.shiftKey
                })
            }
            onDocumentMouseUp_(at) {
                const dt = this.elem_.ownerDocument;
                dt.removeEventListener("mousemove", this.onDocumentMouseMove_),
                dt.removeEventListener("mouseup", this.onDocumentMouseUp_),
                this.emitter.emit("up", {
                    altKey: at.altKey,
                    data: this.computePosition_($o(at, this.elem_)),
                    sender: this,
                    shiftKey: at.shiftKey
                })
            }
            onTouchStart_(at) {
                at.preventDefault();
                const dt = at.targetTouches.item(0)
                  , xt = this.elem_.getBoundingClientRect();
                this.emitter.emit("down", {
                    altKey: at.altKey,
                    data: this.computePosition_(dt ? {
                        x: dt.clientX - xt.left,
                        y: dt.clientY - xt.top
                    } : void 0),
                    sender: this,
                    shiftKey: at.shiftKey
                }),
                this.lastTouch_ = dt
            }
            onTouchMove_(at) {
                const dt = at.targetTouches.item(0)
                  , xt = this.elem_.getBoundingClientRect();
                this.emitter.emit("move", {
                    altKey: at.altKey,
                    data: this.computePosition_(dt ? {
                        x: dt.clientX - xt.left,
                        y: dt.clientY - xt.top
                    } : void 0),
                    sender: this,
                    shiftKey: at.shiftKey
                }),
                this.lastTouch_ = dt
            }
            onTouchEnd_(at) {
                var dt;
                const xt = (dt = at.targetTouches.item(0)) !== null && dt !== void 0 ? dt : this.lastTouch_
                  , Ct = this.elem_.getBoundingClientRect();
                this.emitter.emit("up", {
                    altKey: at.altKey,
                    data: this.computePosition_(xt ? {
                        x: xt.clientX - Ct.left,
                        y: xt.clientY - Ct.top
                    } : void 0),
                    sender: this,
                    shiftKey: at.shiftKey
                })
            }
        }
        function cr(pt, at, dt, xt, Ct) {
            const zt = (pt - at) / (dt - at);
            return xt + zt * (Ct - xt)
        }
        function Ts(pt) {
            return String(pt.toFixed(10)).split(".")[1].replace(/0+$/, "").length
        }
        function fr(pt, at, dt) {
            return Math.min(Math.max(pt, at), dt)
        }
        function As(pt, at) {
            return (pt % at + at) % at
        }
        const wr = bt("txt");
        class Su {
            constructor(at, dt) {
                this.onChange_ = this.onChange_.bind(this),
                this.props_ = dt.props,
                this.props_.emitter.on("change", this.onChange_),
                this.element = at.createElement("div"),
                this.element.classList.add(wr(), wr(void 0, "num")),
                dt.arrayPosition && this.element.classList.add(wr(void 0, dt.arrayPosition)),
                dt.viewProps.bindClassModifiers(this.element);
                const xt = at.createElement("input");
                xt.classList.add(wr("i")),
                xt.type = "text",
                dt.viewProps.bindDisabled(xt),
                this.element.appendChild(xt),
                this.inputElement = xt,
                this.onDraggingChange_ = this.onDraggingChange_.bind(this),
                this.dragging_ = dt.dragging,
                this.dragging_.emitter.on("change", this.onDraggingChange_),
                this.element.classList.add(wr()),
                this.inputElement.classList.add(wr("i"));
                const Ct = at.createElement("div");
                Ct.classList.add(wr("k")),
                this.element.appendChild(Ct),
                this.knobElement = Ct;
                const zt = at.createElementNS(Ln, "svg");
                zt.classList.add(wr("g")),
                this.knobElement.appendChild(zt);
                const Yt = at.createElementNS(Ln, "path");
                Yt.classList.add(wr("gb")),
                zt.appendChild(Yt),
                this.guideBodyElem_ = Yt;
                const Sn = at.createElementNS(Ln, "path");
                Sn.classList.add(wr("gh")),
                zt.appendChild(Sn),
                this.guideHeadElem_ = Sn;
                const Bn = at.createElement("div");
                Bn.classList.add(bt("tt")()),
                this.knobElement.appendChild(Bn),
                this.tooltipElem_ = Bn,
                dt.value.emitter.on("change", this.onChange_),
                this.value = dt.value,
                this.refresh()
            }
            onDraggingChange_(at) {
                if (at.rawValue === null) {
                    this.element.classList.remove(wr(void 0, "drg"));
                    return
                }
                this.element.classList.add(wr(void 0, "drg"));
                const dt = at.rawValue / this.props_.get("draggingScale")
                  , xt = dt + (dt > 0 ? -1 : dt < 0 ? 1 : 0)
                  , Ct = fr(-xt, -4, 4);
                this.guideHeadElem_.setAttributeNS(null, "d", [`M ${xt + Ct},0 L ${xt},4 L ${xt + Ct},8`, `M ${dt},-1 L ${dt},9`].join(" ")),
                this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L ${dt},4`);
                const zt = this.props_.get("formatter");
                this.tooltipElem_.textContent = zt(this.value.rawValue),
                this.tooltipElem_.style.left = `${dt}px`
            }
            refresh() {
                const at = this.props_.get("formatter");
                this.inputElement.value = at(this.value.rawValue)
            }
            onChange_() {
                this.refresh()
            }
        }
        class go {
            constructor(at, dt) {
                var xt;
                this.originRawValue_ = 0,
                this.onInputChange_ = this.onInputChange_.bind(this),
                this.onInputKeyDown_ = this.onInputKeyDown_.bind(this),
                this.onInputKeyUp_ = this.onInputKeyUp_.bind(this),
                this.onPointerDown_ = this.onPointerDown_.bind(this),
                this.onPointerMove_ = this.onPointerMove_.bind(this),
                this.onPointerUp_ = this.onPointerUp_.bind(this),
                this.baseStep_ = dt.baseStep,
                this.parser_ = dt.parser,
                this.props = dt.props,
                this.sliderProps_ = (xt = dt.sliderProps) !== null && xt !== void 0 ? xt : null,
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.dragging_ = qt(null),
                this.view = new Su(at,{
                    arrayPosition: dt.arrayPosition,
                    dragging: this.dragging_,
                    props: this.props,
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.view.inputElement.addEventListener("change", this.onInputChange_),
                this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_),
                this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
                const Ct = new Hr(this.view.knobElement);
                Ct.emitter.on("down", this.onPointerDown_),
                Ct.emitter.on("move", this.onPointerMove_),
                Ct.emitter.on("up", this.onPointerUp_)
            }
            constrainValue_(at) {
                var dt, xt;
                const Ct = (dt = this.sliderProps_) === null || dt === void 0 ? void 0 : dt.get("minValue")
                  , zt = (xt = this.sliderProps_) === null || xt === void 0 ? void 0 : xt.get("maxValue");
                let Yt = at;
                return Ct !== void 0 && (Yt = Math.max(Yt, Ct)),
                zt !== void 0 && (Yt = Math.min(Yt, zt)),
                Yt
            }
            onInputChange_(at) {
                const xt = at.currentTarget.value
                  , Ct = this.parser_(xt);
                ht(Ct) || (this.value.rawValue = this.constrainValue_(Ct)),
                this.view.refresh()
            }
            onInputKeyDown_(at) {
                const dt = xr(this.baseStep_, mo(at));
                dt !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + dt), {
                    forceEmit: !1,
                    last: !1
                })
            }
            onInputKeyUp_(at) {
                xr(this.baseStep_, mo(at)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0
                })
            }
            onPointerDown_() {
                this.originRawValue_ = this.value.rawValue,
                this.dragging_.rawValue = 0
            }
            computeDraggingValue_(at) {
                if (!at.point)
                    return null;
                const dt = at.point.x - at.bounds.width / 2;
                return this.constrainValue_(this.originRawValue_ + dt * this.props.get("draggingScale"))
            }
            onPointerMove_(at) {
                const dt = this.computeDraggingValue_(at.data);
                dt !== null && (this.value.setRawValue(dt, {
                    forceEmit: !1,
                    last: !1
                }),
                this.dragging_.rawValue = this.value.rawValue - this.originRawValue_)
            }
            onPointerUp_(at) {
                const dt = this.computeDraggingValue_(at.data);
                dt !== null && (this.value.setRawValue(dt, {
                    forceEmit: !0,
                    last: !0
                }),
                this.dragging_.rawValue = null)
            }
        }
        const Uo = bt("sld");
        class Mu {
            constructor(at, dt) {
                this.onChange_ = this.onChange_.bind(this),
                this.props_ = dt.props,
                this.props_.emitter.on("change", this.onChange_),
                this.element = at.createElement("div"),
                this.element.classList.add(Uo()),
                dt.viewProps.bindClassModifiers(this.element);
                const xt = at.createElement("div");
                xt.classList.add(Uo("t")),
                dt.viewProps.bindTabIndex(xt),
                this.element.appendChild(xt),
                this.trackElement = xt;
                const Ct = at.createElement("div");
                Ct.classList.add(Uo("k")),
                this.trackElement.appendChild(Ct),
                this.knobElement = Ct,
                dt.value.emitter.on("change", this.onChange_),
                this.value = dt.value,
                this.update_()
            }
            update_() {
                const at = fr(cr(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
                this.knobElement.style.width = `${at}%`
            }
            onChange_() {
                this.update_()
            }
        }
        class Eu {
            constructor(at, dt) {
                this.onKeyDown_ = this.onKeyDown_.bind(this),
                this.onKeyUp_ = this.onKeyUp_.bind(this),
                this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this),
                this.onPointerUp_ = this.onPointerUp_.bind(this),
                this.baseStep_ = dt.baseStep,
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.props = dt.props,
                this.view = new Mu(at,{
                    props: this.props,
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.ptHandler_ = new Hr(this.view.trackElement),
                this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_),
                this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_),
                this.ptHandler_.emitter.on("up", this.onPointerUp_),
                this.view.trackElement.addEventListener("keydown", this.onKeyDown_),
                this.view.trackElement.addEventListener("keyup", this.onKeyUp_)
            }
            handlePointerEvent_(at, dt) {
                !at.point || this.value.setRawValue(cr(fr(at.point.x, 0, at.bounds.width), 0, at.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), dt)
            }
            onPointerDownOrMove_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !1,
                    last: !1
                })
            }
            onPointerUp_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !0,
                    last: !0
                })
            }
            onKeyDown_(at) {
                const dt = xr(this.baseStep_, Pr(at));
                dt !== 0 && this.value.setRawValue(this.value.rawValue + dt, {
                    forceEmit: !1,
                    last: !1
                })
            }
            onKeyUp_(at) {
                xr(this.baseStep_, Pr(at)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0
                })
            }
        }
        const Ho = bt("sldtxt");
        class Cu {
            constructor(at, dt) {
                this.element = at.createElement("div"),
                this.element.classList.add(Ho());
                const xt = at.createElement("div");
                xt.classList.add(Ho("s")),
                this.sliderView_ = dt.sliderView,
                xt.appendChild(this.sliderView_.element),
                this.element.appendChild(xt);
                const Ct = at.createElement("div");
                Ct.classList.add(Ho("t")),
                this.textView_ = dt.textView,
                Ct.appendChild(this.textView_.element),
                this.element.appendChild(Ct)
            }
        }
        class jo {
            constructor(at, dt) {
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.sliderC_ = new Eu(at,{
                    baseStep: dt.baseStep,
                    props: dt.sliderProps,
                    value: dt.value,
                    viewProps: this.viewProps
                }),
                this.textC_ = new go(at,{
                    baseStep: dt.baseStep,
                    parser: dt.parser,
                    props: dt.textProps,
                    sliderProps: dt.sliderProps,
                    value: dt.value,
                    viewProps: dt.viewProps
                }),
                this.view = new Cu(at,{
                    sliderView: this.sliderC_.view,
                    textView: this.textC_.view
                })
            }
            get sliderController() {
                return this.sliderC_
            }
            get textController() {
                return this.textC_
            }
        }
        function vo(pt, at) {
            pt.write(at)
        }
        function Co(pt) {
            const at = _n;
            if (Array.isArray(pt))
                return at.required.array(at.required.object({
                    text: at.required.string,
                    value: at.required.raw
                }))(pt).value;
            if (typeof pt == "object")
                return at.required.raw(pt).value
        }
        function Ls(pt) {
            if (pt === "inline" || pt === "popup")
                return pt
        }
        function Vr(pt) {
            const at = _n;
            return at.required.object({
                max: at.optional.number,
                min: at.optional.number,
                step: at.optional.number
            })(pt).value
        }
        function Ps(pt) {
            if (Array.isArray(pt))
                return pt;
            const at = [];
            return Object.keys(pt).forEach(dt=>{
                at.push({
                    text: dt,
                    value: pt[dt]
                })
            }
            ),
            at
        }
        function Go(pt) {
            return ht(pt) ? null : new uo(Ps(pt))
        }
        function Tu(pt) {
            const at = pt ? Ar(pt, So) : null;
            return at ? at.step : null
        }
        function To(pt, at) {
            const dt = pt && Ar(pt, So);
            return dt ? Ts(dt.step) : Math.max(Ts(at), 2)
        }
        function Qr(pt) {
            const at = Tu(pt);
            return at != null ? at : 1
        }
        function Jr(pt, at) {
            var dt;
            const xt = pt && Ar(pt, So)
              , Ct = Math.abs((dt = xt == null ? void 0 : xt.step) !== null && dt !== void 0 ? dt : at);
            return Ct === 0 ? .1 : Math.pow(10, Math.floor(Math.log10(Ct)) - 1)
        }
        const Ao = bt("ckb");
        class Au {
            constructor(at, dt) {
                this.onValueChange_ = this.onValueChange_.bind(this),
                this.element = at.createElement("div"),
                this.element.classList.add(Ao()),
                dt.viewProps.bindClassModifiers(this.element);
                const xt = at.createElement("label");
                xt.classList.add(Ao("l")),
                this.element.appendChild(xt);
                const Ct = at.createElement("input");
                Ct.classList.add(Ao("i")),
                Ct.type = "checkbox",
                xt.appendChild(Ct),
                this.inputElement = Ct,
                dt.viewProps.bindDisabled(this.inputElement);
                const zt = at.createElement("div");
                zt.classList.add(Ao("w")),
                xt.appendChild(zt);
                const Yt = On(at, "check");
                zt.appendChild(Yt),
                dt.value.emitter.on("change", this.onValueChange_),
                this.value = dt.value,
                this.update_()
            }
            update_() {
                this.inputElement.checked = this.value.rawValue
            }
            onValueChange_() {
                this.update_()
            }
        }
        class Lu {
            constructor(at, dt) {
                this.onInputChange_ = this.onInputChange_.bind(this),
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.view = new Au(at,{
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.view.inputElement.addEventListener("change", this.onInputChange_)
            }
            onInputChange_(at) {
                const dt = at.currentTarget;
                this.value.rawValue = dt.checked
            }
        }
        function Pu(pt) {
            const at = []
              , dt = Go(pt.options);
            return dt && at.push(dt),
            new lo(at)
        }
        const Ru = {
            id: "input-bool",
            type: "input",
            accept: (pt,at)=>{
                if (typeof pt != "boolean")
                    return null;
                const xt = Fn(at, {
                    options: _n.optional.custom(Co)
                });
                return xt ? {
                    initialValue: pt,
                    params: xt
                } : null
            }
            ,
            binding: {
                reader: pt=>_s,
                constraint: pt=>Pu(pt.params),
                writer: pt=>vo
            },
            controller: pt=>{
                const at = pt.document
                  , dt = pt.value
                  , xt = pt.constraint
                  , Ct = xt && Ar(xt, uo);
                return Ct ? new co(at,{
                    props: new jt({
                        options: Ct.values.value("options")
                    }),
                    value: dt,
                    viewProps: pt.viewProps
                }) : new Lu(at,{
                    value: dt,
                    viewProps: pt.viewProps
                })
            }
        }
          , jr = bt("col");
        class ku {
            constructor(at, dt) {
                this.element = at.createElement("div"),
                this.element.classList.add(jr()),
                dt.foldable.bindExpandedClass(this.element, jr(void 0, "expanded")),
                Pt(dt.foldable, "completed", Zt(this.element, jr(void 0, "cpl")));
                const xt = at.createElement("div");
                xt.classList.add(jr("h")),
                this.element.appendChild(xt);
                const Ct = at.createElement("div");
                Ct.classList.add(jr("s")),
                xt.appendChild(Ct),
                this.swatchElement = Ct;
                const zt = at.createElement("div");
                if (zt.classList.add(jr("t")),
                xt.appendChild(zt),
                this.textElement = zt,
                dt.pickerLayout === "inline") {
                    const Yt = at.createElement("div");
                    Yt.classList.add(jr("p")),
                    this.element.appendChild(Yt),
                    this.pickerElement = Yt
                } else
                    this.pickerElement = null
            }
        }
        function Iu(pt, at, dt) {
            const xt = fr(pt / 255, 0, 1)
              , Ct = fr(at / 255, 0, 1)
              , zt = fr(dt / 255, 0, 1)
              , Yt = Math.max(xt, Ct, zt)
              , Sn = Math.min(xt, Ct, zt)
              , Bn = Yt - Sn;
            let qn = 0
              , or = 0;
            const ar = (Sn + Yt) / 2;
            return Bn !== 0 && (or = Bn / (1 - Math.abs(Yt + Sn - 1)),
            xt === Yt ? qn = (Ct - zt) / Bn : Ct === Yt ? qn = 2 + (zt - xt) / Bn : qn = 4 + (xt - Ct) / Bn,
            qn = qn / 6 + (qn < 0 ? 1 : 0)),
            [qn * 360, or * 100, ar * 100]
        }
        function Du(pt, at, dt) {
            const xt = (pt % 360 + 360) % 360
              , Ct = fr(at / 100, 0, 1)
              , zt = fr(dt / 100, 0, 1)
              , Yt = (1 - Math.abs(2 * zt - 1)) * Ct
              , Sn = Yt * (1 - Math.abs(xt / 60 % 2 - 1))
              , Bn = zt - Yt / 2;
            let qn, or, ar;
            return xt >= 0 && xt < 60 ? [qn,or,ar] = [Yt, Sn, 0] : xt >= 60 && xt < 120 ? [qn,or,ar] = [Sn, Yt, 0] : xt >= 120 && xt < 180 ? [qn,or,ar] = [0, Yt, Sn] : xt >= 180 && xt < 240 ? [qn,or,ar] = [0, Sn, Yt] : xt >= 240 && xt < 300 ? [qn,or,ar] = [Sn, 0, Yt] : [qn,or,ar] = [Yt, 0, Sn],
            [(qn + Bn) * 255, (or + Bn) * 255, (ar + Bn) * 255]
        }
        function Fu(pt, at, dt) {
            const xt = fr(pt / 255, 0, 1)
              , Ct = fr(at / 255, 0, 1)
              , zt = fr(dt / 255, 0, 1)
              , Yt = Math.max(xt, Ct, zt)
              , Sn = Math.min(xt, Ct, zt)
              , Bn = Yt - Sn;
            let qn;
            Bn === 0 ? qn = 0 : Yt === xt ? qn = 60 * (((Ct - zt) / Bn % 6 + 6) % 6) : Yt === Ct ? qn = 60 * ((zt - xt) / Bn + 2) : qn = 60 * ((xt - Ct) / Bn + 4);
            const or = Yt === 0 ? 0 : Bn / Yt
              , ar = Yt;
            return [qn, or * 100, ar * 100]
        }
        function Rs(pt, at, dt) {
            const xt = As(pt, 360)
              , Ct = fr(at / 100, 0, 1)
              , zt = fr(dt / 100, 0, 1)
              , Yt = zt * Ct
              , Sn = Yt * (1 - Math.abs(xt / 60 % 2 - 1))
              , Bn = zt - Yt;
            let qn, or, ar;
            return xt >= 0 && xt < 60 ? [qn,or,ar] = [Yt, Sn, 0] : xt >= 60 && xt < 120 ? [qn,or,ar] = [Sn, Yt, 0] : xt >= 120 && xt < 180 ? [qn,or,ar] = [0, Yt, Sn] : xt >= 180 && xt < 240 ? [qn,or,ar] = [0, Sn, Yt] : xt >= 240 && xt < 300 ? [qn,or,ar] = [Sn, 0, Yt] : [qn,or,ar] = [Yt, 0, Sn],
            [(qn + Bn) * 255, (or + Bn) * 255, (ar + Bn) * 255]
        }
        function Ou(pt, at, dt) {
            const xt = dt + at * (100 - Math.abs(2 * dt - 100)) / 200;
            return [pt, xt !== 0 ? at * (100 - Math.abs(2 * dt - 100)) / xt : 0, dt + at * (100 - Math.abs(2 * dt - 100)) / (2 * 100)]
        }
        function Vu(pt, at, dt) {
            const xt = 100 - Math.abs(dt * (200 - at) / 100 - 100);
            return [pt, xt !== 0 ? at * dt / xt : 0, dt * (200 - at) / (2 * 100)]
        }
        function Gr(pt) {
            return [pt[0], pt[1], pt[2]]
        }
        function ks(pt, at) {
            return [pt[0], pt[1], pt[2], at]
        }
        const Nu = {
            hsl: {
                hsl: (pt,at,dt)=>[pt, at, dt],
                hsv: Ou,
                rgb: Du
            },
            hsv: {
                hsl: Vu,
                hsv: (pt,at,dt)=>[pt, at, dt],
                rgb: Rs
            },
            rgb: {
                hsl: Iu,
                hsv: Fu,
                rgb: (pt,at,dt)=>[pt, at, dt]
            }
        };
        function Lo(pt, at) {
            return [at === "float" ? 1 : pt === "rgb" ? 255 : 360, at === "float" ? 1 : pt === "rgb" ? 255 : 100, at === "float" ? 1 : pt === "rgb" ? 255 : 100]
        }
        function Bu(pt, at) {
            return pt === at ? at : As(pt, at)
        }
        function zu(pt, at, dt) {
            var xt;
            const Ct = Lo(at, dt);
            return [at === "rgb" ? fr(pt[0], 0, Ct[0]) : Bu(pt[0], Ct[0]), fr(pt[1], 0, Ct[1]), fr(pt[2], 0, Ct[2]), fr((xt = pt[3]) !== null && xt !== void 0 ? xt : 1, 0, 1)]
        }
        function Is(pt, at, dt, xt) {
            const Ct = Lo(at, dt)
              , zt = Lo(at, xt);
            return pt.map((Yt,Sn)=>Yt / Ct[Sn] * zt[Sn])
        }
        function $u(pt, at, dt) {
            const xt = Is(pt, at.mode, at.type, "int")
              , Ct = Nu[at.mode][dt.mode](...xt);
            return Is(Ct, dt.mode, "int", dt.type)
        }
        function Po(pt, at) {
            return typeof pt != "object" || ht(pt) ? !1 : at in pt && typeof pt[at] == "number"
        }
        class er {
            constructor(at, dt, xt="int") {
                this.mode = dt,
                this.type = xt,
                this.comps_ = zu(at, dt, xt)
            }
            static black(at="int") {
                return new er([0, 0, 0],"rgb",at)
            }
            static fromObject(at, dt="int") {
                const xt = "a"in at ? [at.r, at.g, at.b, at.a] : [at.r, at.g, at.b];
                return new er(xt,"rgb",dt)
            }
            static toRgbaObject(at, dt="int") {
                return at.toRgbaObject(dt)
            }
            static isRgbColorObject(at) {
                return Po(at, "r") && Po(at, "g") && Po(at, "b")
            }
            static isRgbaColorObject(at) {
                return this.isRgbColorObject(at) && Po(at, "a")
            }
            static isColorObject(at) {
                return this.isRgbColorObject(at)
            }
            static equals(at, dt) {
                if (at.mode !== dt.mode)
                    return !1;
                const xt = at.comps_
                  , Ct = dt.comps_;
                for (let zt = 0; zt < xt.length; zt++)
                    if (xt[zt] !== Ct[zt])
                        return !1;
                return !0
            }
            getComponents(at, dt="int") {
                return ks($u(Gr(this.comps_), {
                    mode: this.mode,
                    type: this.type
                }, {
                    mode: at != null ? at : this.mode,
                    type: dt
                }), this.comps_[3])
            }
            toRgbaObject(at="int") {
                const dt = this.getComponents("rgb", at);
                return {
                    r: dt[0],
                    g: dt[1],
                    b: dt[2],
                    a: dt[3]
                }
            }
        }
        const Nr = bt("colp");
        class Uu {
            constructor(at, dt) {
                this.alphaViews_ = null,
                this.element = at.createElement("div"),
                this.element.classList.add(Nr());
                const xt = at.createElement("div");
                xt.classList.add(Nr("hsv"));
                const Ct = at.createElement("div");
                Ct.classList.add(Nr("sv")),
                this.svPaletteView_ = dt.svPaletteView,
                Ct.appendChild(this.svPaletteView_.element),
                xt.appendChild(Ct);
                const zt = at.createElement("div");
                zt.classList.add(Nr("h")),
                this.hPaletteView_ = dt.hPaletteView,
                zt.appendChild(this.hPaletteView_.element),
                xt.appendChild(zt),
                this.element.appendChild(xt);
                const Yt = at.createElement("div");
                if (Yt.classList.add(Nr("rgb")),
                this.textView_ = dt.textView,
                Yt.appendChild(this.textView_.element),
                this.element.appendChild(Yt),
                dt.alphaViews) {
                    this.alphaViews_ = {
                        palette: dt.alphaViews.palette,
                        text: dt.alphaViews.text
                    };
                    const Sn = at.createElement("div");
                    Sn.classList.add(Nr("a"));
                    const Bn = at.createElement("div");
                    Bn.classList.add(Nr("ap")),
                    Bn.appendChild(this.alphaViews_.palette.element),
                    Sn.appendChild(Bn);
                    const qn = at.createElement("div");
                    qn.classList.add(Nr("at")),
                    qn.appendChild(this.alphaViews_.text.element),
                    Sn.appendChild(qn),
                    this.element.appendChild(Sn)
                }
            }
            get allFocusableElements() {
                const at = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map(dt=>dt.inputElement)];
                return this.alphaViews_ && at.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement),
                at
            }
        }
        function Hu(pt) {
            return pt === "int" ? "int" : pt === "float" ? "float" : void 0
        }
        function Wo(pt) {
            const at = _n;
            return Fn(pt, {
                alpha: at.optional.boolean,
                color: at.optional.object({
                    alpha: at.optional.boolean,
                    type: at.optional.custom(Hu)
                }),
                expanded: at.optional.boolean,
                picker: at.optional.custom(Ls)
            })
        }
        function Wr(pt) {
            return pt ? .1 : 1
        }
        function qr(pt) {
            var at;
            return (at = pt.color) === null || at === void 0 ? void 0 : at.type
        }
        function ju(pt, at) {
            return pt.alpha === at.alpha && pt.mode === at.mode && pt.notation === at.notation && pt.type === at.type
        }
        function Sr(pt, at) {
            const dt = pt.match(/^(.+)%$/);
            return Math.min(dt ? parseFloat(dt[1]) * .01 * at : parseFloat(pt), at)
        }
        const Gu = {
            deg: pt=>pt,
            grad: pt=>pt * 360 / 400,
            rad: pt=>pt * 360 / (2 * Math.PI),
            turn: pt=>pt * 360
        };
        function Ds(pt) {
            const at = pt.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
            if (!at)
                return parseFloat(pt);
            const dt = parseFloat(at[1])
              , xt = at[2];
            return Gu[xt](dt)
        }
        function Fs(pt) {
            const at = pt.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!at)
                return null;
            const dt = [Sr(at[1], 255), Sr(at[2], 255), Sr(at[3], 255)];
            return isNaN(dt[0]) || isNaN(dt[1]) || isNaN(dt[2]) ? null : dt
        }
        function Os(pt) {
            return at=>{
                const dt = Fs(at);
                return dt ? new er(dt,"rgb",pt) : null
            }
        }
        function Vs(pt) {
            const at = pt.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!at)
                return null;
            const dt = [Sr(at[1], 255), Sr(at[2], 255), Sr(at[3], 255), Sr(at[4], 1)];
            return isNaN(dt[0]) || isNaN(dt[1]) || isNaN(dt[2]) || isNaN(dt[3]) ? null : dt
        }
        function Ns(pt) {
            return at=>{
                const dt = Vs(at);
                return dt ? new er(dt,"rgb",pt) : null
            }
        }
        function Bs(pt) {
            const at = pt.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!at)
                return null;
            const dt = [Ds(at[1]), Sr(at[2], 100), Sr(at[3], 100)];
            return isNaN(dt[0]) || isNaN(dt[1]) || isNaN(dt[2]) ? null : dt
        }
        function zs(pt) {
            return at=>{
                const dt = Bs(at);
                return dt ? new er(dt,"hsl",pt) : null
            }
        }
        function $s(pt) {
            const at = pt.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!at)
                return null;
            const dt = [Ds(at[1]), Sr(at[2], 100), Sr(at[3], 100), Sr(at[4], 1)];
            return isNaN(dt[0]) || isNaN(dt[1]) || isNaN(dt[2]) || isNaN(dt[3]) ? null : dt
        }
        function Us(pt) {
            return at=>{
                const dt = $s(at);
                return dt ? new er(dt,"hsl",pt) : null
            }
        }
        function Hs(pt) {
            const at = pt.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
            if (at)
                return [parseInt(at[1] + at[1], 16), parseInt(at[2] + at[2], 16), parseInt(at[3] + at[3], 16)];
            const dt = pt.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
            return dt ? [parseInt(dt[1], 16), parseInt(dt[2], 16), parseInt(dt[3], 16)] : null
        }
        function Wu(pt) {
            const at = Hs(pt);
            return at ? new er(at,"rgb","int") : null
        }
        function js(pt) {
            const at = pt.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
            if (at)
                return [parseInt(at[1] + at[1], 16), parseInt(at[2] + at[2], 16), parseInt(at[3] + at[3], 16), cr(parseInt(at[4] + at[4], 16), 0, 255, 0, 1)];
            const dt = pt.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
            return dt ? [parseInt(dt[1], 16), parseInt(dt[2], 16), parseInt(dt[3], 16), cr(parseInt(dt[4], 16), 0, 255, 0, 1)] : null
        }
        function qu(pt) {
            const at = js(pt);
            return at ? new er(at,"rgb","int") : null
        }
        function Gs(pt) {
            const at = pt.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
            if (!at)
                return null;
            const dt = [parseFloat(at[1]), parseFloat(at[2]), parseFloat(at[3])];
            return isNaN(dt[0]) || isNaN(dt[1]) || isNaN(dt[2]) ? null : dt
        }
        function Ws(pt) {
            return at=>{
                const dt = Gs(at);
                return dt ? new er(dt,"rgb",pt) : null
            }
        }
        function qs(pt) {
            const at = pt.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
            if (!at)
                return null;
            const dt = [parseFloat(at[1]), parseFloat(at[2]), parseFloat(at[3]), parseFloat(at[4])];
            return isNaN(dt[0]) || isNaN(dt[1]) || isNaN(dt[2]) || isNaN(dt[3]) ? null : dt
        }
        function Xs(pt) {
            return at=>{
                const dt = qs(at);
                return dt ? new er(dt,"rgb",pt) : null
            }
        }
        const Xu = [{
            parser: Hs,
            result: {
                alpha: !1,
                mode: "rgb",
                notation: "hex"
            }
        }, {
            parser: js,
            result: {
                alpha: !0,
                mode: "rgb",
                notation: "hex"
            }
        }, {
            parser: Fs,
            result: {
                alpha: !1,
                mode: "rgb",
                notation: "func"
            }
        }, {
            parser: Vs,
            result: {
                alpha: !0,
                mode: "rgb",
                notation: "func"
            }
        }, {
            parser: Bs,
            result: {
                alpha: !1,
                mode: "hsl",
                notation: "func"
            }
        }, {
            parser: $s,
            result: {
                alpha: !0,
                mode: "hsl",
                notation: "func"
            }
        }, {
            parser: Gs,
            result: {
                alpha: !1,
                mode: "rgb",
                notation: "object"
            }
        }, {
            parser: qs,
            result: {
                alpha: !0,
                mode: "rgb",
                notation: "object"
            }
        }];
        function Yu(pt) {
            return Xu.reduce((at,{parser: dt, result: xt})=>at || (dt(pt) ? xt : null), null)
        }
        function qo(pt, at="int") {
            const dt = Yu(pt);
            return dt ? dt.notation === "hex" && at !== "float" ? Object.assign(Object.assign({}, dt), {
                type: "int"
            }) : dt.notation === "func" ? Object.assign(Object.assign({}, dt), {
                type: at
            }) : null : null
        }
        const Ys = {
            int: [Wu, qu, Os("int"), Ns("int"), zs("int"), Us("int"), Ws("int"), Xs("int")],
            float: [Os("float"), Ns("float"), zs("float"), Us("float"), Ws("float"), Xs("float")]
        };
        function Zu(pt) {
            const at = Ys[pt];
            return dt=>{
                if (typeof dt != "string")
                    return er.black(pt);
                const xt = at.reduce((Ct,zt)=>Ct || zt(dt), null);
                return xt != null ? xt : er.black(pt)
            }
        }
        function Xo(pt) {
            const at = Ys[pt];
            return dt=>at.reduce((xt,Ct)=>xt || Ct(dt), null)
        }
        function Zs(pt) {
            const at = fr(Math.floor(pt), 0, 255).toString(16);
            return at.length === 1 ? `0 ${at}` : at
        }
        function Ks(pt, at="#") {
            const dt = Gr(pt.getComponents("rgb")).map(Zs).join("");
            return `${at}${dt}`
        }
        function Yo(pt, at="#") {
            const dt = pt.getComponents("rgb")
              , xt = [dt[0], dt[1], dt[2], dt[3] * 255].map(Zs).join("");
            return `${at}${xt}`
        }
        function Qs(pt, at) {
            const dt = mr(at === "float" ? 2 : 0);
            return `rgb(${Gr(pt.getComponents("rgb", at)).map(Ct=>dt(Ct)).join(", ")})`
        }
        function Ku(pt) {
            return at=>Qs(at, pt)
        }
        function Ro(pt, at) {
            const dt = mr(2)
              , xt = mr(at === "float" ? 2 : 0);
            return `rgba(${pt.getComponents("rgb", at).map((zt,Yt)=>(Yt === 3 ? dt : xt)(zt)).join(", ")})`
        }
        function Qu(pt) {
            return at=>Ro(at, pt)
        }
        function Ju(pt) {
            const at = [mr(0), Eo, Eo];
            return `hsl(${Gr(pt.getComponents("hsl")).map((xt,Ct)=>at[Ct](xt)).join(", ")})`
        }
        function _c(pt) {
            const at = [mr(0), Eo, Eo, mr(2)];
            return `hsla(${pt.getComponents("hsl").map((xt,Ct)=>at[Ct](xt)).join(", ")})`
        }
        function Js(pt, at) {
            const dt = mr(at === "float" ? 2 : 0)
              , xt = ["r", "g", "b"];
            return `{${Gr(pt.getComponents("rgb", at)).map((zt,Yt)=>`${xt[Yt]}: ${dt(zt)}`).join(", ")}}`
        }
        function _d(pt) {
            return at=>Js(at, pt)
        }
        function ca(pt, at) {
            const dt = mr(2)
              , xt = mr(at === "float" ? 2 : 0)
              , Ct = ["r", "g", "b", "a"];
            return `{${pt.getComponents("rgb", at).map((Yt,Sn)=>{
                const Bn = Sn === 3 ? dt : xt;
                return `${Ct[Sn]}: ${Bn(Yt)}`
            }
            ).join(", ")}}`
        }
        function _h(pt) {
            return at=>ca(at, pt)
        }
        const ep = [{
            format: {
                alpha: !1,
                mode: "rgb",
                notation: "hex",
                type: "int"
            },
            stringifier: Ks
        }, {
            format: {
                alpha: !0,
                mode: "rgb",
                notation: "hex",
                type: "int"
            },
            stringifier: Yo
        }, {
            format: {
                alpha: !1,
                mode: "hsl",
                notation: "func",
                type: "int"
            },
            stringifier: Ju
        }, {
            format: {
                alpha: !0,
                mode: "hsl",
                notation: "func",
                type: "int"
            },
            stringifier: _c
        }, ...["int", "float"].reduce((pt,at)=>[...pt, {
            format: {
                alpha: !1,
                mode: "rgb",
                notation: "func",
                type: at
            },
            stringifier: Ku(at)
        }, {
            format: {
                alpha: !0,
                mode: "rgb",
                notation: "func",
                type: at
            },
            stringifier: Qu(at)
        }, {
            format: {
                alpha: !1,
                mode: "rgb",
                notation: "object",
                type: at
            },
            stringifier: _d(at)
        }, {
            format: {
                alpha: !0,
                mode: "rgb",
                notation: "object",
                type: at
            },
            stringifier: _h(at)
        }], [])];
        function Zo(pt) {
            return ep.reduce((at,dt)=>at || (ju(dt.format, pt) ? dt.stringifier : null), null)
        }
        const _o = bt("apl");
        class tp {
            constructor(at, dt) {
                this.onValueChange_ = this.onValueChange_.bind(this),
                this.value = dt.value,
                this.value.emitter.on("change", this.onValueChange_),
                this.element = at.createElement("div"),
                this.element.classList.add(_o()),
                dt.viewProps.bindTabIndex(this.element);
                const xt = at.createElement("div");
                xt.classList.add(_o("b")),
                this.element.appendChild(xt);
                const Ct = at.createElement("div");
                Ct.classList.add(_o("c")),
                xt.appendChild(Ct),
                this.colorElem_ = Ct;
                const zt = at.createElement("div");
                zt.classList.add(_o("m")),
                this.element.appendChild(zt),
                this.markerElem_ = zt;
                const Yt = at.createElement("div");
                Yt.classList.add(_o("p")),
                this.markerElem_.appendChild(Yt),
                this.previewElem_ = Yt,
                this.update_()
            }
            update_() {
                const at = this.value.rawValue
                  , dt = at.getComponents("rgb")
                  , xt = new er([dt[0], dt[1], dt[2], 0],"rgb")
                  , Ct = new er([dt[0], dt[1], dt[2], 255],"rgb")
                  , zt = ["to right", Ro(xt), Ro(Ct)];
                this.colorElem_.style.background = `linear-gradient(${zt.join(",")})`,
                this.previewElem_.style.backgroundColor = Ro(at);
                const Yt = cr(dt[3], 0, 1, 0, 100);
                this.markerElem_.style.left = `${Yt}%`
            }
            onValueChange_() {
                this.update_()
            }
        }
        class np {
            constructor(at, dt) {
                this.onKeyDown_ = this.onKeyDown_.bind(this),
                this.onKeyUp_ = this.onKeyUp_.bind(this),
                this.onPointerDown_ = this.onPointerDown_.bind(this),
                this.onPointerMove_ = this.onPointerMove_.bind(this),
                this.onPointerUp_ = this.onPointerUp_.bind(this),
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.view = new tp(at,{
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.ptHandler_ = new Hr(this.view.element),
                this.ptHandler_.emitter.on("down", this.onPointerDown_),
                this.ptHandler_.emitter.on("move", this.onPointerMove_),
                this.ptHandler_.emitter.on("up", this.onPointerUp_),
                this.view.element.addEventListener("keydown", this.onKeyDown_),
                this.view.element.addEventListener("keyup", this.onKeyUp_)
            }
            handlePointerEvent_(at, dt) {
                if (!at.point)
                    return;
                const xt = at.point.x / at.bounds.width
                  , Ct = this.value.rawValue
                  , [zt,Yt,Sn] = Ct.getComponents("hsv");
                this.value.setRawValue(new er([zt, Yt, Sn, xt],"hsv"), dt)
            }
            onPointerDown_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !1,
                    last: !1
                })
            }
            onPointerMove_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !1,
                    last: !1
                })
            }
            onPointerUp_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !0,
                    last: !0
                })
            }
            onKeyDown_(at) {
                const dt = xr(Wr(!0), Pr(at));
                if (dt === 0)
                    return;
                const xt = this.value.rawValue
                  , [Ct,zt,Yt,Sn] = xt.getComponents("hsv");
                this.value.setRawValue(new er([Ct, zt, Yt, Sn + dt],"hsv"), {
                    forceEmit: !1,
                    last: !1
                })
            }
            onKeyUp_(at) {
                xr(Wr(!0), Pr(at)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0
                })
            }
        }
        const _i = bt("coltxt");
        function rp(pt) {
            const at = pt.createElement("select")
              , dt = [{
                text: "RGB",
                value: "rgb"
            }, {
                text: "HSL",
                value: "hsl"
            }, {
                text: "HSV",
                value: "hsv"
            }];
            return at.appendChild(dt.reduce((xt,Ct)=>{
                const zt = pt.createElement("option");
                return zt.textContent = Ct.text,
                zt.value = Ct.value,
                xt.appendChild(zt),
                xt
            }
            , pt.createDocumentFragment())),
            at
        }
        class ip {
            constructor(at, dt) {
                this.element = at.createElement("div"),
                this.element.classList.add(_i());
                const xt = at.createElement("div");
                xt.classList.add(_i("m")),
                this.modeElem_ = rp(at),
                this.modeElem_.classList.add(_i("ms")),
                xt.appendChild(this.modeSelectElement);
                const Ct = at.createElement("div");
                Ct.classList.add(_i("mm")),
                Ct.appendChild(On(at, "dropdown")),
                xt.appendChild(Ct),
                this.element.appendChild(xt);
                const zt = at.createElement("div");
                zt.classList.add(_i("w")),
                this.element.appendChild(zt),
                this.textsElem_ = zt,
                this.textViews_ = dt.textViews,
                this.applyTextViews_(),
                At(dt.colorMode, Yt=>{
                    this.modeElem_.value = Yt
                }
                )
            }
            get modeSelectElement() {
                return this.modeElem_
            }
            get textViews() {
                return this.textViews_
            }
            set textViews(at) {
                this.textViews_ = at,
                this.applyTextViews_()
            }
            applyTextViews_() {
                Dt(this.textsElem_);
                const at = this.element.ownerDocument;
                this.textViews_.forEach(dt=>{
                    const xt = at.createElement("div");
                    xt.classList.add(_i("c")),
                    xt.appendChild(dt.element),
                    this.textsElem_.appendChild(xt)
                }
                )
            }
        }
        function op(pt) {
            return mr(pt === "float" ? 2 : 0)
        }
        function sp(pt, at, dt) {
            const xt = Lo(pt, at)[dt];
            return new Kr({
                min: 0,
                max: xt
            })
        }
        function Ko(pt, at, dt) {
            return new go(pt,{
                arrayPosition: dt === 0 ? "fst" : dt === 3 - 1 ? "lst" : "mid",
                baseStep: Wr(!1),
                parser: at.parser,
                props: jt.fromObject({
                    draggingScale: at.colorType === "float" ? .01 : 1,
                    formatter: op(at.colorType)
                }),
                value: qt(0, {
                    constraint: sp(at.colorMode, at.colorType, dt)
                }),
                viewProps: at.viewProps
            })
        }
        class ap {
            constructor(at, dt) {
                this.onModeSelectChange_ = this.onModeSelectChange_.bind(this),
                this.colorType_ = dt.colorType,
                this.parser_ = dt.parser,
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.colorMode = qt(this.value.rawValue.mode),
                this.ccs_ = this.createComponentControllers_(at),
                this.view = new ip(at,{
                    colorMode: this.colorMode,
                    textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
                }),
                this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_)
            }
            createComponentControllers_(at) {
                const dt = {
                    colorMode: this.colorMode.rawValue,
                    colorType: this.colorType_,
                    parser: this.parser_,
                    viewProps: this.viewProps
                }
                  , xt = [Ko(at, dt, 0), Ko(at, dt, 1), Ko(at, dt, 2)];
                return xt.forEach((Ct,zt)=>{
                    fo({
                        primary: this.value,
                        secondary: Ct.value,
                        forward: Yt=>Yt.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[zt],
                        backward: (Yt,Sn)=>{
                            const Bn = this.colorMode.rawValue
                              , qn = Yt.rawValue.getComponents(Bn, this.colorType_);
                            return qn[zt] = Sn.rawValue,
                            new er(ks(Gr(qn), qn[3]),Bn,this.colorType_)
                        }
                    })
                }
                ),
                xt
            }
            onModeSelectChange_(at) {
                const dt = at.currentTarget;
                this.colorMode.rawValue = dt.value,
                this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument),
                this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
            }
        }
        const Qo = bt("hpl");
        class lp {
            constructor(at, dt) {
                this.onValueChange_ = this.onValueChange_.bind(this),
                this.value = dt.value,
                this.value.emitter.on("change", this.onValueChange_),
                this.element = at.createElement("div"),
                this.element.classList.add(Qo()),
                dt.viewProps.bindTabIndex(this.element);
                const xt = at.createElement("div");
                xt.classList.add(Qo("c")),
                this.element.appendChild(xt);
                const Ct = at.createElement("div");
                Ct.classList.add(Qo("m")),
                this.element.appendChild(Ct),
                this.markerElem_ = Ct,
                this.update_()
            }
            update_() {
                const at = this.value.rawValue
                  , [dt] = at.getComponents("hsv");
                this.markerElem_.style.backgroundColor = Qs(new er([dt, 100, 100],"hsv"));
                const xt = cr(dt, 0, 360, 0, 100);
                this.markerElem_.style.left = `${xt}%`
            }
            onValueChange_() {
                this.update_()
            }
        }
        class up {
            constructor(at, dt) {
                this.onKeyDown_ = this.onKeyDown_.bind(this),
                this.onKeyUp_ = this.onKeyUp_.bind(this),
                this.onPointerDown_ = this.onPointerDown_.bind(this),
                this.onPointerMove_ = this.onPointerMove_.bind(this),
                this.onPointerUp_ = this.onPointerUp_.bind(this),
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.view = new lp(at,{
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.ptHandler_ = new Hr(this.view.element),
                this.ptHandler_.emitter.on("down", this.onPointerDown_),
                this.ptHandler_.emitter.on("move", this.onPointerMove_),
                this.ptHandler_.emitter.on("up", this.onPointerUp_),
                this.view.element.addEventListener("keydown", this.onKeyDown_),
                this.view.element.addEventListener("keyup", this.onKeyUp_)
            }
            handlePointerEvent_(at, dt) {
                if (!at.point)
                    return;
                const xt = cr(fr(at.point.x, 0, at.bounds.width), 0, at.bounds.width, 0, 360)
                  , Ct = this.value.rawValue
                  , [,zt,Yt,Sn] = Ct.getComponents("hsv");
                this.value.setRawValue(new er([xt, zt, Yt, Sn],"hsv"), dt)
            }
            onPointerDown_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !1,
                    last: !1
                })
            }
            onPointerMove_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !1,
                    last: !1
                })
            }
            onPointerUp_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !0,
                    last: !0
                })
            }
            onKeyDown_(at) {
                const dt = xr(Wr(!1), Pr(at));
                if (dt === 0)
                    return;
                const xt = this.value.rawValue
                  , [Ct,zt,Yt,Sn] = xt.getComponents("hsv");
                this.value.setRawValue(new er([Ct + dt, zt, Yt, Sn],"hsv"), {
                    forceEmit: !1,
                    last: !1
                })
            }
            onKeyUp_(at) {
                xr(Wr(!1), Pr(at)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0
                })
            }
        }
        const Jo = bt("svp")
          , ga = 64;
        class cp {
            constructor(at, dt) {
                this.onValueChange_ = this.onValueChange_.bind(this),
                this.value = dt.value,
                this.value.emitter.on("change", this.onValueChange_),
                this.element = at.createElement("div"),
                this.element.classList.add(Jo()),
                dt.viewProps.bindTabIndex(this.element);
                const xt = at.createElement("canvas");
                xt.height = ga,
                xt.width = ga,
                xt.classList.add(Jo("c")),
                this.element.appendChild(xt),
                this.canvasElement = xt;
                const Ct = at.createElement("div");
                Ct.classList.add(Jo("m")),
                this.element.appendChild(Ct),
                this.markerElem_ = Ct,
                this.update_()
            }
            update_() {
                const at = Pn(this.canvasElement);
                if (!at)
                    return;
                const xt = this.value.rawValue.getComponents("hsv")
                  , Ct = this.canvasElement.width
                  , zt = this.canvasElement.height
                  , Yt = at.getImageData(0, 0, Ct, zt)
                  , Sn = Yt.data;
                for (let or = 0; or < zt; or++)
                    for (let ar = 0; ar < Ct; ar++) {
                        const kr = cr(ar, 0, Ct, 0, 100)
                          , yo = cr(or, 0, zt, 100, 0)
                          , bo = Rs(xt[0], kr, yo)
                          , io = (or * Ct + ar) * 4;
                        Sn[io] = bo[0],
                        Sn[io + 1] = bo[1],
                        Sn[io + 2] = bo[2],
                        Sn[io + 3] = 255
                    }
                at.putImageData(Yt, 0, 0);
                const Bn = cr(xt[1], 0, 100, 0, 100);
                this.markerElem_.style.left = `${Bn}%`;
                const qn = cr(xt[2], 0, 100, 100, 0);
                this.markerElem_.style.top = `${qn}%`
            }
            onValueChange_() {
                this.update_()
            }
        }
        class dp {
            constructor(at, dt) {
                this.onKeyDown_ = this.onKeyDown_.bind(this),
                this.onKeyUp_ = this.onKeyUp_.bind(this),
                this.onPointerDown_ = this.onPointerDown_.bind(this),
                this.onPointerMove_ = this.onPointerMove_.bind(this),
                this.onPointerUp_ = this.onPointerUp_.bind(this),
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.view = new cp(at,{
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.ptHandler_ = new Hr(this.view.element),
                this.ptHandler_.emitter.on("down", this.onPointerDown_),
                this.ptHandler_.emitter.on("move", this.onPointerMove_),
                this.ptHandler_.emitter.on("up", this.onPointerUp_),
                this.view.element.addEventListener("keydown", this.onKeyDown_),
                this.view.element.addEventListener("keyup", this.onKeyUp_)
            }
            handlePointerEvent_(at, dt) {
                if (!at.point)
                    return;
                const xt = cr(at.point.x, 0, at.bounds.width, 0, 100)
                  , Ct = cr(at.point.y, 0, at.bounds.height, 100, 0)
                  , [zt,,,Yt] = this.value.rawValue.getComponents("hsv");
                this.value.setRawValue(new er([zt, xt, Ct, Yt],"hsv"), dt)
            }
            onPointerDown_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !1,
                    last: !1
                })
            }
            onPointerMove_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !1,
                    last: !1
                })
            }
            onPointerUp_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !0,
                    last: !0
                })
            }
            onKeyDown_(at) {
                Cs(at.key) && at.preventDefault();
                const [dt,xt,Ct,zt] = this.value.rawValue.getComponents("hsv")
                  , Yt = Wr(!1)
                  , Sn = xr(Yt, Pr(at))
                  , Bn = xr(Yt, mo(at));
                Sn === 0 && Bn === 0 || this.value.setRawValue(new er([dt, xt + Sn, Ct + Bn, zt],"hsv"), {
                    forceEmit: !1,
                    last: !1
                })
            }
            onKeyUp_(at) {
                const dt = Wr(!1)
                  , xt = xr(dt, Pr(at))
                  , Ct = xr(dt, mo(at));
                xt === 0 && Ct === 0 || this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0
                })
            }
        }
        class hp {
            constructor(at, dt) {
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.hPaletteC_ = new up(at,{
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.svPaletteC_ = new dp(at,{
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.alphaIcs_ = dt.supportsAlpha ? {
                    palette: new np(at,{
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    text: new go(at,{
                        parser: Lr,
                        baseStep: .1,
                        props: jt.fromObject({
                            draggingScale: .01,
                            formatter: mr(2)
                        }),
                        value: qt(0, {
                            constraint: new Kr({
                                min: 0,
                                max: 1
                            })
                        }),
                        viewProps: this.viewProps
                    })
                } : null,
                this.alphaIcs_ && fo({
                    primary: this.value,
                    secondary: this.alphaIcs_.text.value,
                    forward: xt=>xt.rawValue.getComponents()[3],
                    backward: (xt,Ct)=>{
                        const zt = xt.rawValue.getComponents();
                        return zt[3] = Ct.rawValue,
                        new er(zt,xt.rawValue.mode)
                    }
                }),
                this.textC_ = new ap(at,{
                    colorType: dt.colorType,
                    parser: Lr,
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.view = new Uu(at,{
                    alphaViews: this.alphaIcs_ ? {
                        palette: this.alphaIcs_.palette.view,
                        text: this.alphaIcs_.text.view
                    } : null,
                    hPaletteView: this.hPaletteC_.view,
                    supportsAlpha: dt.supportsAlpha,
                    svPaletteView: this.svPaletteC_.view,
                    textView: this.textC_.view
                })
            }
            get textController() {
                return this.textC_
            }
        }
        const es = bt("colsw");
        class pp {
            constructor(at, dt) {
                this.onValueChange_ = this.onValueChange_.bind(this),
                dt.value.emitter.on("change", this.onValueChange_),
                this.value = dt.value,
                this.element = at.createElement("div"),
                this.element.classList.add(es()),
                dt.viewProps.bindClassModifiers(this.element);
                const xt = at.createElement("div");
                xt.classList.add(es("sw")),
                this.element.appendChild(xt),
                this.swatchElem_ = xt;
                const Ct = at.createElement("button");
                Ct.classList.add(es("b")),
                dt.viewProps.bindDisabled(Ct),
                this.element.appendChild(Ct),
                this.buttonElement = Ct,
                this.update_()
            }
            update_() {
                const at = this.value.rawValue;
                this.swatchElem_.style.backgroundColor = Yo(at)
            }
            onValueChange_() {
                this.update_()
            }
        }
        class fp {
            constructor(at, dt) {
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.view = new pp(at,{
                    value: this.value,
                    viewProps: this.viewProps
                })
            }
        }
        class ns {
            constructor(at, dt) {
                this.onButtonBlur_ = this.onButtonBlur_.bind(this),
                this.onButtonClick_ = this.onButtonClick_.bind(this),
                this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this),
                this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this),
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.foldable_ = vn.create(dt.expanded),
                this.swatchC_ = new fp(at,{
                    value: this.value,
                    viewProps: this.viewProps
                });
                const xt = this.swatchC_.view.buttonElement;
                xt.addEventListener("blur", this.onButtonBlur_),
                xt.addEventListener("click", this.onButtonClick_),
                this.textC_ = new Mo(at,{
                    parser: dt.parser,
                    props: jt.fromObject({
                        formatter: dt.formatter
                    }),
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.view = new ku(at,{
                    foldable: this.foldable_,
                    pickerLayout: dt.pickerLayout
                }),
                this.view.swatchElement.appendChild(this.swatchC_.view.element),
                this.view.textElement.appendChild(this.textC_.view.element),
                this.popC_ = dt.pickerLayout === "popup" ? new gs(at,{
                    viewProps: this.viewProps
                }) : null;
                const Ct = new hp(at,{
                    colorType: dt.colorType,
                    supportsAlpha: dt.supportsAlpha,
                    value: this.value,
                    viewProps: this.viewProps
                });
                Ct.view.allFocusableElements.forEach(zt=>{
                    zt.addEventListener("blur", this.onPopupChildBlur_),
                    zt.addEventListener("keydown", this.onPopupChildKeydown_)
                }
                ),
                this.pickerC_ = Ct,
                this.popC_ ? (this.view.element.appendChild(this.popC_.view.element),
                this.popC_.view.element.appendChild(Ct.view.element),
                fo({
                    primary: this.foldable_.value("expanded"),
                    secondary: this.popC_.shows,
                    forward: zt=>zt.rawValue,
                    backward: (zt,Yt)=>Yt.rawValue
                })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element),
                Cn(this.foldable_, this.view.pickerElement))
            }
            get textController() {
                return this.textC_
            }
            onButtonBlur_(at) {
                if (!this.popC_)
                    return;
                const dt = this.view.element
                  , xt = at.relatedTarget;
                (!xt || !dt.contains(xt)) && (this.popC_.shows.rawValue = !1)
            }
            onButtonClick_() {
                this.foldable_.set("expanded", !this.foldable_.get("expanded")),
                this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
            }
            onPopupChildBlur_(at) {
                if (!this.popC_)
                    return;
                const dt = this.popC_.view.element
                  , xt = pn(at);
                xt && dt.contains(xt) || xt && xt === this.swatchC_.view.buttonElement && !bn(dt.ownerDocument) || (this.popC_.shows.rawValue = !1)
            }
            onPopupChildKeydown_(at) {
                this.popC_ ? at.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && at.key === "Escape" && this.swatchC_.view.buttonElement.focus()
            }
        }
        function mp(pt, at) {
            return er.isColorObject(pt) ? er.fromObject(pt, at) : er.black(at)
        }
        function gp(pt) {
            return Gr(pt.getComponents("rgb")).reduce((at,dt)=>at << 8 | Math.floor(dt) & 255, 0)
        }
        function vp(pt) {
            return pt.getComponents("rgb").reduce((at,dt,xt)=>{
                const Ct = Math.floor(xt === 3 ? dt * 255 : dt) & 255;
                return at << 8 | Ct
            }
            , 0) >>> 0
        }
        function xp(pt) {
            return new er([pt >> 16 & 255, pt >> 8 & 255, pt & 255],"rgb")
        }
        function yp(pt) {
            return new er([pt >> 24 & 255, pt >> 16 & 255, pt >> 8 & 255, cr(pt & 255, 0, 255, 0, 1)],"rgb")
        }
        function bp(pt) {
            return typeof pt != "number" ? er.black() : xp(pt)
        }
        function wp(pt) {
            return typeof pt != "number" ? er.black() : yp(pt)
        }
        function Sp(pt) {
            const at = Zo(pt);
            return at ? (dt,xt)=>{
                vo(dt, at(xt))
            }
            : null
        }
        function Mp(pt) {
            const at = pt ? vp : gp;
            return (dt,xt)=>{
                vo(dt, at(xt))
            }
        }
        function Ep(pt, at, dt) {
            const xt = at.toRgbaObject(dt);
            pt.writeProperty("r", xt.r),
            pt.writeProperty("g", xt.g),
            pt.writeProperty("b", xt.b),
            pt.writeProperty("a", xt.a)
        }
        function Cp(pt, at, dt) {
            const xt = at.toRgbaObject(dt);
            pt.writeProperty("r", xt.r),
            pt.writeProperty("g", xt.g),
            pt.writeProperty("b", xt.b)
        }
        function Tp(pt, at) {
            return (dt,xt)=>{
                pt ? Ep(dt, xt, at) : Cp(dt, xt, at)
            }
        }
        function rs(pt) {
            var at;
            return !!((pt == null ? void 0 : pt.alpha) || ((at = pt == null ? void 0 : pt.color) === null || at === void 0 ? void 0 : at.alpha))
        }
        function Ap(pt) {
            return pt ? at=>Yo(at, "0x") : at=>Ks(at, "0x")
        }
        function Lp(pt) {
            return "color"in pt || "view"in pt && pt.view === "color"
        }
        const Pp = {
            id: "input-color-number",
            type: "input",
            accept: (pt,at)=>{
                if (typeof pt != "number" || !Lp(at))
                    return null;
                const dt = Wo(at);
                return dt ? {
                    initialValue: pt,
                    params: dt
                } : null
            }
            ,
            binding: {
                reader: pt=>rs(pt.params) ? wp : bp,
                equals: er.equals,
                writer: pt=>Mp(rs(pt.params))
            },
            controller: pt=>{
                const at = rs(pt.params)
                  , dt = "expanded"in pt.params ? pt.params.expanded : void 0
                  , xt = "picker"in pt.params ? pt.params.picker : void 0;
                return new ns(pt.document,{
                    colorType: "int",
                    expanded: dt != null ? dt : !1,
                    formatter: Ap(at),
                    parser: Xo("int"),
                    pickerLayout: xt != null ? xt : "popup",
                    supportsAlpha: at,
                    value: pt.value,
                    viewProps: pt.viewProps
                })
            }
        };
        function Rp(pt) {
            return er.isRgbaColorObject(pt)
        }
        function kp(pt) {
            return at=>mp(at, pt)
        }
        function Ip(pt, at) {
            return dt=>pt ? ca(dt, at) : Js(dt, at)
        }
        const Dp = {
            id: "input-color-object",
            type: "input",
            accept: (pt,at)=>{
                if (!er.isColorObject(pt))
                    return null;
                const dt = Wo(at);
                return dt ? {
                    initialValue: pt,
                    params: dt
                } : null
            }
            ,
            binding: {
                reader: pt=>kp(qr(pt.params)),
                equals: er.equals,
                writer: pt=>Tp(Rp(pt.initialValue), qr(pt.params))
            },
            controller: pt=>{
                var at;
                const dt = er.isRgbaColorObject(pt.initialValue)
                  , xt = "expanded"in pt.params ? pt.params.expanded : void 0
                  , Ct = "picker"in pt.params ? pt.params.picker : void 0
                  , zt = (at = qr(pt.params)) !== null && at !== void 0 ? at : "int";
                return new ns(pt.document,{
                    colorType: zt,
                    expanded: xt != null ? xt : !1,
                    formatter: Ip(dt, zt),
                    parser: Xo(zt),
                    pickerLayout: Ct != null ? Ct : "popup",
                    supportsAlpha: dt,
                    value: pt.value,
                    viewProps: pt.viewProps
                })
            }
        }
          , Fp = {
            id: "input-color-string",
            type: "input",
            accept: (pt,at)=>{
                if (typeof pt != "string" || "view"in at && at.view === "text")
                    return null;
                const dt = qo(pt, qr(at));
                if (!dt || !Zo(dt))
                    return null;
                const Ct = Wo(at);
                return Ct ? {
                    initialValue: pt,
                    params: Ct
                } : null
            }
            ,
            binding: {
                reader: pt=>{
                    var at;
                    return Zu((at = qr(pt.params)) !== null && at !== void 0 ? at : "int")
                }
                ,
                equals: er.equals,
                writer: pt=>{
                    const at = qo(pt.initialValue, qr(pt.params));
                    if (!at)
                        throw vt.shouldNeverHappen();
                    const dt = Sp(at);
                    if (!dt)
                        throw vt.notBindable();
                    return dt
                }
            },
            controller: pt=>{
                const at = qo(pt.initialValue, qr(pt.params));
                if (!at)
                    throw vt.shouldNeverHappen();
                const dt = Zo(at);
                if (!dt)
                    throw vt.shouldNeverHappen();
                const xt = "expanded"in pt.params ? pt.params.expanded : void 0
                  , Ct = "picker"in pt.params ? pt.params.picker : void 0;
                return new ns(pt.document,{
                    colorType: at.type,
                    expanded: xt != null ? xt : !1,
                    formatter: dt,
                    parser: Xo(at.type),
                    pickerLayout: Ct != null ? Ct : "popup",
                    supportsAlpha: at.alpha,
                    value: pt.value,
                    viewProps: pt.viewProps
                })
            }
        };
        class Br {
            constructor(at) {
                this.components = at.components,
                this.asm_ = at.assembly
            }
            constrain(at) {
                const dt = this.asm_.toComponents(at).map((xt,Ct)=>{
                    var zt, Yt;
                    return (Yt = (zt = this.components[Ct]) === null || zt === void 0 ? void 0 : zt.constrain(xt)) !== null && Yt !== void 0 ? Yt : xt
                }
                );
                return this.asm_.fromComponents(dt)
            }
        }
        const _a = bt("pndtxt");
        class Op {
            constructor(at, dt) {
                this.textViews = dt.textViews,
                this.element = at.createElement("div"),
                this.element.classList.add(_a()),
                this.textViews.forEach(xt=>{
                    const Ct = at.createElement("div");
                    Ct.classList.add(_a("a")),
                    Ct.appendChild(xt.element),
                    this.element.appendChild(Ct)
                }
                )
            }
        }
        function Vp(pt, at, dt) {
            return new go(pt,{
                arrayPosition: dt === 0 ? "fst" : dt === at.axes.length - 1 ? "lst" : "mid",
                baseStep: at.axes[dt].baseStep,
                parser: at.parser,
                props: at.axes[dt].textProps,
                value: qt(0, {
                    constraint: at.axes[dt].constraint
                }),
                viewProps: at.viewProps
            })
        }
        class os {
            constructor(at, dt) {
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.acs_ = dt.axes.map((xt,Ct)=>Vp(at, dt, Ct)),
                this.acs_.forEach((xt,Ct)=>{
                    fo({
                        primary: this.value,
                        secondary: xt.value,
                        forward: zt=>dt.assembly.toComponents(zt.rawValue)[Ct],
                        backward: (zt,Yt)=>{
                            const Sn = dt.assembly.toComponents(zt.rawValue);
                            return Sn[Ct] = Yt.rawValue,
                            dt.assembly.fromComponents(Sn)
                        }
                    })
                }
                ),
                this.view = new Op(at,{
                    textViews: this.acs_.map(xt=>xt.view)
                })
            }
        }
        function ya(pt, at) {
            return "step"in pt && !ht(pt.step) ? new So(pt.step,at) : null
        }
        function vl(pt) {
            return !ht(pt.max) && !ht(pt.min) ? new Kr({
                max: pt.max,
                min: pt.min
            }) : !ht(pt.max) || !ht(pt.min) ? new ps({
                max: pt.max,
                min: pt.min
            }) : null
        }
        function Np(pt) {
            const at = Ar(pt, Kr);
            if (at)
                return [at.values.get("min"), at.values.get("max")];
            const dt = Ar(pt, ps);
            return dt ? [dt.minValue, dt.maxValue] : [void 0, void 0]
        }
        function Bp(pt, at) {
            const dt = []
              , xt = ya(pt, at);
            xt && dt.push(xt);
            const Ct = vl(pt);
            Ct && dt.push(Ct);
            const zt = Go(pt.options);
            return zt && dt.push(zt),
            new lo(dt)
        }
        const zp = {
            id: "input-number",
            type: "input",
            accept: (pt,at)=>{
                if (typeof pt != "number")
                    return null;
                const dt = _n
                  , xt = Fn(at, {
                    format: dt.optional.function,
                    max: dt.optional.number,
                    min: dt.optional.number,
                    options: dt.optional.custom(Co),
                    step: dt.optional.number
                });
                return xt ? {
                    initialValue: pt,
                    params: xt
                } : null
            }
            ,
            binding: {
                reader: pt=>Ss,
                constraint: pt=>Bp(pt.params, pt.initialValue),
                writer: pt=>vo
            },
            controller: pt=>{
                var at;
                const dt = pt.value
                  , xt = pt.constraint
                  , Ct = xt && Ar(xt, uo);
                if (Ct)
                    return new co(pt.document,{
                        props: new jt({
                            options: Ct.values.value("options")
                        }),
                        value: dt,
                        viewProps: pt.viewProps
                    });
                const zt = (at = "format"in pt.params ? pt.params.format : void 0) !== null && at !== void 0 ? at : mr(To(xt, dt.rawValue))
                  , Yt = xt && Ar(xt, Kr);
                return Yt ? new jo(pt.document,{
                    baseStep: Qr(xt),
                    parser: Lr,
                    sliderProps: new jt({
                        maxValue: Yt.values.value("max"),
                        minValue: Yt.values.value("min")
                    }),
                    textProps: jt.fromObject({
                        draggingScale: Jr(xt, dt.rawValue),
                        formatter: zt
                    }),
                    value: dt,
                    viewProps: pt.viewProps
                }) : new go(pt.document,{
                    baseStep: Qr(xt),
                    parser: Lr,
                    props: jt.fromObject({
                        draggingScale: Jr(xt, dt.rawValue),
                        formatter: zt
                    }),
                    value: dt,
                    viewProps: pt.viewProps
                })
            }
        };
        class zr {
            constructor(at=0, dt=0) {
                this.x = at,
                this.y = dt
            }
            getComponents() {
                return [this.x, this.y]
            }
            static isObject(at) {
                if (ht(at))
                    return !1;
                const dt = at.x
                  , xt = at.y;
                return !(typeof dt != "number" || typeof xt != "number")
            }
            static equals(at, dt) {
                return at.x === dt.x && at.y === dt.y
            }
            toObject() {
                return {
                    x: this.x,
                    y: this.y
                }
            }
        }
        const _l = {
            toComponents: pt=>pt.getComponents(),
            fromComponents: pt=>new zr(...pt)
        }
          , eo = bt("p2d");
        class $p {
            constructor(at, dt) {
                this.element = at.createElement("div"),
                this.element.classList.add(eo()),
                dt.viewProps.bindClassModifiers(this.element),
                At(dt.expanded, Zt(this.element, eo(void 0, "expanded")));
                const xt = at.createElement("div");
                xt.classList.add(eo("h")),
                this.element.appendChild(xt);
                const Ct = at.createElement("button");
                Ct.classList.add(eo("b")),
                Ct.appendChild(On(at, "p2dpad")),
                dt.viewProps.bindDisabled(Ct),
                xt.appendChild(Ct),
                this.buttonElement = Ct;
                const zt = at.createElement("div");
                if (zt.classList.add(eo("t")),
                xt.appendChild(zt),
                this.textElement = zt,
                dt.pickerLayout === "inline") {
                    const Yt = at.createElement("div");
                    Yt.classList.add(eo("p")),
                    this.element.appendChild(Yt),
                    this.pickerElement = Yt
                } else
                    this.pickerElement = null
            }
        }
        const $r = bt("p2dp");
        class Up {
            constructor(at, dt) {
                this.onFoldableChange_ = this.onFoldableChange_.bind(this),
                this.onValueChange_ = this.onValueChange_.bind(this),
                this.invertsY_ = dt.invertsY,
                this.maxValue_ = dt.maxValue,
                this.element = at.createElement("div"),
                this.element.classList.add($r()),
                dt.layout === "popup" && this.element.classList.add($r(void 0, "p"));
                const xt = at.createElement("div");
                xt.classList.add($r("p")),
                dt.viewProps.bindTabIndex(xt),
                this.element.appendChild(xt),
                this.padElement = xt;
                const Ct = at.createElementNS(Ln, "svg");
                Ct.classList.add($r("g")),
                this.padElement.appendChild(Ct),
                this.svgElem_ = Ct;
                const zt = at.createElementNS(Ln, "line");
                zt.classList.add($r("ax")),
                zt.setAttributeNS(null, "x1", "0"),
                zt.setAttributeNS(null, "y1", "50%"),
                zt.setAttributeNS(null, "x2", "100%"),
                zt.setAttributeNS(null, "y2", "50%"),
                this.svgElem_.appendChild(zt);
                const Yt = at.createElementNS(Ln, "line");
                Yt.classList.add($r("ax")),
                Yt.setAttributeNS(null, "x1", "50%"),
                Yt.setAttributeNS(null, "y1", "0"),
                Yt.setAttributeNS(null, "x2", "50%"),
                Yt.setAttributeNS(null, "y2", "100%"),
                this.svgElem_.appendChild(Yt);
                const Sn = at.createElementNS(Ln, "line");
                Sn.classList.add($r("l")),
                Sn.setAttributeNS(null, "x1", "50%"),
                Sn.setAttributeNS(null, "y1", "50%"),
                this.svgElem_.appendChild(Sn),
                this.lineElem_ = Sn;
                const Bn = at.createElement("div");
                Bn.classList.add($r("m")),
                this.padElement.appendChild(Bn),
                this.markerElem_ = Bn,
                dt.value.emitter.on("change", this.onValueChange_),
                this.value = dt.value,
                this.update_()
            }
            get allFocusableElements() {
                return [this.padElement]
            }
            update_() {
                const [at,dt] = this.value.rawValue.getComponents()
                  , xt = this.maxValue_
                  , Ct = cr(at, -xt, +xt, 0, 100)
                  , zt = cr(dt, -xt, +xt, 0, 100)
                  , Yt = this.invertsY_ ? 100 - zt : zt;
                this.lineElem_.setAttributeNS(null, "x2", `${Ct}%`),
                this.lineElem_.setAttributeNS(null, "y2", `${Yt}%`),
                this.markerElem_.style.left = `${Ct}%`,
                this.markerElem_.style.top = `${Yt}%`
            }
            onValueChange_() {
                this.update_()
            }
            onFoldableChange_() {
                this.update_()
            }
        }
        function xl(pt, at, dt) {
            return [xr(at[0], Pr(pt)), xr(at[1], mo(pt)) * (dt ? 1 : -1)]
        }
        class Hp {
            constructor(at, dt) {
                this.onPadKeyDown_ = this.onPadKeyDown_.bind(this),
                this.onPadKeyUp_ = this.onPadKeyUp_.bind(this),
                this.onPointerDown_ = this.onPointerDown_.bind(this),
                this.onPointerMove_ = this.onPointerMove_.bind(this),
                this.onPointerUp_ = this.onPointerUp_.bind(this),
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.baseSteps_ = dt.baseSteps,
                this.maxValue_ = dt.maxValue,
                this.invertsY_ = dt.invertsY,
                this.view = new Up(at,{
                    invertsY: this.invertsY_,
                    layout: dt.layout,
                    maxValue: this.maxValue_,
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.ptHandler_ = new Hr(this.view.padElement),
                this.ptHandler_.emitter.on("down", this.onPointerDown_),
                this.ptHandler_.emitter.on("move", this.onPointerMove_),
                this.ptHandler_.emitter.on("up", this.onPointerUp_),
                this.view.padElement.addEventListener("keydown", this.onPadKeyDown_),
                this.view.padElement.addEventListener("keyup", this.onPadKeyUp_)
            }
            handlePointerEvent_(at, dt) {
                if (!at.point)
                    return;
                const xt = this.maxValue_
                  , Ct = cr(at.point.x, 0, at.bounds.width, -xt, +xt)
                  , zt = cr(this.invertsY_ ? at.bounds.height - at.point.y : at.point.y, 0, at.bounds.height, -xt, +xt);
                this.value.setRawValue(new zr(Ct,zt), dt)
            }
            onPointerDown_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !1,
                    last: !1
                })
            }
            onPointerMove_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !1,
                    last: !1
                })
            }
            onPointerUp_(at) {
                this.handlePointerEvent_(at.data, {
                    forceEmit: !0,
                    last: !0
                })
            }
            onPadKeyDown_(at) {
                Cs(at.key) && at.preventDefault();
                const [dt,xt] = xl(at, this.baseSteps_, this.invertsY_);
                dt === 0 && xt === 0 || this.value.setRawValue(new zr(this.value.rawValue.x + dt,this.value.rawValue.y + xt), {
                    forceEmit: !1,
                    last: !1
                })
            }
            onPadKeyUp_(at) {
                const [dt,xt] = xl(at, this.baseSteps_, this.invertsY_);
                dt === 0 && xt === 0 || this.value.setRawValue(this.value.rawValue, {
                    forceEmit: !0,
                    last: !0
                })
            }
        }
        class jp {
            constructor(at, dt) {
                var xt, Ct;
                this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this),
                this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this),
                this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this),
                this.onPadButtonClick_ = this.onPadButtonClick_.bind(this),
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.foldable_ = vn.create(dt.expanded),
                this.popC_ = dt.pickerLayout === "popup" ? new gs(at,{
                    viewProps: this.viewProps
                }) : null;
                const zt = new Hp(at,{
                    baseSteps: [dt.axes[0].baseStep, dt.axes[1].baseStep],
                    invertsY: dt.invertsY,
                    layout: dt.pickerLayout,
                    maxValue: dt.maxValue,
                    value: this.value,
                    viewProps: this.viewProps
                });
                zt.view.allFocusableElements.forEach(Yt=>{
                    Yt.addEventListener("blur", this.onPopupChildBlur_),
                    Yt.addEventListener("keydown", this.onPopupChildKeydown_)
                }
                ),
                this.pickerC_ = zt,
                this.textC_ = new os(at,{
                    assembly: _l,
                    axes: dt.axes,
                    parser: dt.parser,
                    value: this.value,
                    viewProps: this.viewProps
                }),
                this.view = new $p(at,{
                    expanded: this.foldable_.value("expanded"),
                    pickerLayout: dt.pickerLayout,
                    viewProps: this.viewProps
                }),
                this.view.textElement.appendChild(this.textC_.view.element),
                (xt = this.view.buttonElement) === null || xt === void 0 || xt.addEventListener("blur", this.onPadButtonBlur_),
                (Ct = this.view.buttonElement) === null || Ct === void 0 || Ct.addEventListener("click", this.onPadButtonClick_),
                this.popC_ ? (this.view.element.appendChild(this.popC_.view.element),
                this.popC_.view.element.appendChild(this.pickerC_.view.element),
                fo({
                    primary: this.foldable_.value("expanded"),
                    secondary: this.popC_.shows,
                    forward: Yt=>Yt.rawValue,
                    backward: (Yt,Sn)=>Sn.rawValue
                })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element),
                Cn(this.foldable_, this.view.pickerElement))
            }
            onPadButtonBlur_(at) {
                if (!this.popC_)
                    return;
                const dt = this.view.element
                  , xt = at.relatedTarget;
                (!xt || !dt.contains(xt)) && (this.popC_.shows.rawValue = !1)
            }
            onPadButtonClick_() {
                this.foldable_.set("expanded", !this.foldable_.get("expanded")),
                this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
            }
            onPopupChildBlur_(at) {
                if (!this.popC_)
                    return;
                const dt = this.popC_.view.element
                  , xt = pn(at);
                xt && dt.contains(xt) || xt && xt === this.view.buttonElement && !bn(dt.ownerDocument) || (this.popC_.shows.rawValue = !1)
            }
            onPopupChildKeydown_(at) {
                this.popC_ ? at.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && at.key === "Escape" && this.view.buttonElement.focus()
            }
        }
        class no {
            constructor(at=0, dt=0, xt=0) {
                this.x = at,
                this.y = dt,
                this.z = xt
            }
            getComponents() {
                return [this.x, this.y, this.z]
            }
            static isObject(at) {
                if (ht(at))
                    return !1;
                const dt = at.x
                  , xt = at.y
                  , Ct = at.z;
                return !(typeof dt != "number" || typeof xt != "number" || typeof Ct != "number")
            }
            static equals(at, dt) {
                return at.x === dt.x && at.y === dt.y && at.z === dt.z
            }
            toObject() {
                return {
                    x: this.x,
                    y: this.y,
                    z: this.z
                }
            }
        }
        const yl = {
            toComponents: pt=>pt.getComponents(),
            fromComponents: pt=>new no(...pt)
        };
        function Gp(pt) {
            return no.isObject(pt) ? new no(pt.x,pt.y,pt.z) : new no
        }
        function Wp(pt, at) {
            pt.writeProperty("x", at.x),
            pt.writeProperty("y", at.y),
            pt.writeProperty("z", at.z)
        }
        function qp(pt, at) {
            return new Br({
                assembly: yl,
                components: [Rr("x"in pt ? pt.x : void 0, at.x), Rr("y"in pt ? pt.y : void 0, at.y), Rr("z"in pt ? pt.z : void 0, at.z)]
            })
        }
        function ss(pt, at) {
            return {
                baseStep: Qr(at),
                constraint: at,
                textProps: jt.fromObject({
                    draggingScale: Jr(at, pt),
                    formatter: mr(To(at, pt))
                })
            }
        }
        const Xp = {
            id: "input-point3d",
            type: "input",
            accept: (pt,at)=>{
                if (!no.isObject(pt))
                    return null;
                const dt = _n
                  , xt = Fn(at, {
                    x: dt.optional.custom(Vr),
                    y: dt.optional.custom(Vr),
                    z: dt.optional.custom(Vr)
                });
                return xt ? {
                    initialValue: pt,
                    params: xt
                } : null
            }
            ,
            binding: {
                reader: pt=>Gp,
                constraint: pt=>qp(pt.params, pt.initialValue),
                equals: no.equals,
                writer: pt=>Wp
            },
            controller: pt=>{
                const at = pt.value
                  , dt = pt.constraint;
                if (!(dt instanceof Br))
                    throw vt.shouldNeverHappen();
                return new os(pt.document,{
                    assembly: yl,
                    axes: [ss(at.rawValue.x, dt.components[0]), ss(at.rawValue.y, dt.components[1]), ss(at.rawValue.z, dt.components[2])],
                    parser: Lr,
                    value: at,
                    viewProps: pt.viewProps
                })
            }
        };
        class ro {
            constructor(at=0, dt=0, xt=0, Ct=0) {
                this.x = at,
                this.y = dt,
                this.z = xt,
                this.w = Ct
            }
            getComponents() {
                return [this.x, this.y, this.z, this.w]
            }
            static isObject(at) {
                if (ht(at))
                    return !1;
                const dt = at.x
                  , xt = at.y
                  , Ct = at.z
                  , zt = at.w;
                return !(typeof dt != "number" || typeof xt != "number" || typeof Ct != "number" || typeof zt != "number")
            }
            static equals(at, dt) {
                return at.x === dt.x && at.y === dt.y && at.z === dt.z && at.w === dt.w
            }
            toObject() {
                return {
                    x: this.x,
                    y: this.y,
                    z: this.z,
                    w: this.w
                }
            }
        }
        const wl = {
            toComponents: pt=>pt.getComponents(),
            fromComponents: pt=>new ro(...pt)
        };
        function Yp(pt) {
            return ro.isObject(pt) ? new ro(pt.x,pt.y,pt.z,pt.w) : new ro
        }
        function Zp(pt, at) {
            pt.writeProperty("x", at.x),
            pt.writeProperty("y", at.y),
            pt.writeProperty("z", at.z),
            pt.writeProperty("w", at.w)
        }
        function Kp(pt, at) {
            return new Br({
                assembly: wl,
                components: [Rr("x"in pt ? pt.x : void 0, at.x), Rr("y"in pt ? pt.y : void 0, at.y), Rr("z"in pt ? pt.z : void 0, at.z), Rr("w"in pt ? pt.w : void 0, at.w)]
            })
        }
        function Qp(pt, at) {
            return {
                baseStep: Qr(at),
                constraint: at,
                textProps: jt.fromObject({
                    draggingScale: Jr(at, pt),
                    formatter: mr(To(at, pt))
                })
            }
        }
        const Jp = {
            id: "input-point4d",
            type: "input",
            accept: (pt,at)=>{
                if (!ro.isObject(pt))
                    return null;
                const dt = _n
                  , xt = Fn(at, {
                    x: dt.optional.custom(Vr),
                    y: dt.optional.custom(Vr),
                    z: dt.optional.custom(Vr),
                    w: dt.optional.custom(Vr)
                });
                return xt ? {
                    initialValue: pt,
                    params: xt
                } : null
            }
            ,
            binding: {
                reader: pt=>Yp,
                constraint: pt=>Kp(pt.params, pt.initialValue),
                equals: ro.equals,
                writer: pt=>Zp
            },
            controller: pt=>{
                const at = pt.value
                  , dt = pt.constraint;
                if (!(dt instanceof Br))
                    throw vt.shouldNeverHappen();
                return new os(pt.document,{
                    assembly: wl,
                    axes: at.rawValue.getComponents().map((xt,Ct)=>Qp(xt, dt.components[Ct])),
                    parser: Lr,
                    value: at,
                    viewProps: pt.viewProps
                })
            }
        };
        function _f(pt) {
            const at = []
              , dt = Go(pt.options);
            return dt && at.push(dt),
            new lo(at)
        }
        const em = {
            id: "input-string",
            type: "input",
            accept: (pt,at)=>{
                if (typeof pt != "string")
                    return null;
                const xt = Fn(at, {
                    options: _n.optional.custom(Co)
                });
                return xt ? {
                    initialValue: pt,
                    params: xt
                } : null
            }
            ,
            binding: {
                reader: pt=>Ms,
                constraint: pt=>_f(pt.params),
                writer: pt=>vo
            },
            controller: pt=>{
                const at = pt.document
                  , dt = pt.value
                  , xt = pt.constraint
                  , Ct = xt && Ar(xt, uo);
                return Ct ? new co(at,{
                    props: new jt({
                        options: Ct.values.value("options")
                    }),
                    value: dt,
                    viewProps: pt.viewProps
                }) : new Mo(at,{
                    parser: zt=>zt,
                    props: jt.fromObject({
                        formatter: zo
                    }),
                    value: dt,
                    viewProps: pt.viewProps
                })
            }
        }
          , xo = {
            monitor: {
                defaultInterval: 200,
                defaultLineCount: 3
            }
        }
          , Sl = bt("mll");
        class tm {
            constructor(at, dt) {
                this.onValueUpdate_ = this.onValueUpdate_.bind(this),
                this.formatter_ = dt.formatter,
                this.element = at.createElement("div"),
                this.element.classList.add(Sl()),
                dt.viewProps.bindClassModifiers(this.element);
                const xt = at.createElement("textarea");
                xt.classList.add(Sl("i")),
                xt.style.height = `calc(var(--bld-us) * ${dt.lineCount})`,
                xt.readOnly = !0,
                dt.viewProps.bindDisabled(xt),
                this.element.appendChild(xt),
                this.textareaElem_ = xt,
                dt.value.emitter.on("change", this.onValueUpdate_),
                this.value = dt.value,
                this.update_()
            }
            update_() {
                const at = this.textareaElem_
                  , dt = at.scrollTop === at.scrollHeight - at.clientHeight
                  , xt = [];
                this.value.rawValue.forEach(Ct=>{
                    Ct !== void 0 && xt.push(this.formatter_(Ct))
                }
                ),
                at.textContent = xt.join(`
`),
                dt && (at.scrollTop = at.scrollHeight)
            }
            onValueUpdate_() {
                this.update_()
            }
        }
        class as {
            constructor(at, dt) {
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.view = new tm(at,{
                    formatter: dt.formatter,
                    lineCount: dt.lineCount,
                    value: this.value,
                    viewProps: this.viewProps
                })
            }
        }
        const Ml = bt("sgl");
        class nm {
            constructor(at, dt) {
                this.onValueUpdate_ = this.onValueUpdate_.bind(this),
                this.formatter_ = dt.formatter,
                this.element = at.createElement("div"),
                this.element.classList.add(Ml()),
                dt.viewProps.bindClassModifiers(this.element);
                const xt = at.createElement("input");
                xt.classList.add(Ml("i")),
                xt.readOnly = !0,
                xt.type = "text",
                dt.viewProps.bindDisabled(xt),
                this.element.appendChild(xt),
                this.inputElement = xt,
                dt.value.emitter.on("change", this.onValueUpdate_),
                this.value = dt.value,
                this.update_()
            }
            update_() {
                const at = this.value.rawValue
                  , dt = at[at.length - 1];
                this.inputElement.value = dt !== void 0 ? this.formatter_(dt) : ""
            }
            onValueUpdate_() {
                this.update_()
            }
        }
        class ls {
            constructor(at, dt) {
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.view = new nm(at,{
                    formatter: dt.formatter,
                    value: this.value,
                    viewProps: this.viewProps
                })
            }
        }
        const rm = {
            id: "monitor-bool",
            type: "monitor",
            accept: (pt,at)=>{
                if (typeof pt != "boolean")
                    return null;
                const xt = Fn(at, {
                    lineCount: _n.optional.number
                });
                return xt ? {
                    initialValue: pt,
                    params: xt
                } : null
            }
            ,
            binding: {
                reader: pt=>_s
            },
            controller: pt=>{
                var at;
                return pt.value.rawValue.length === 1 ? new ls(pt.document,{
                    formatter: xs,
                    value: pt.value,
                    viewProps: pt.viewProps
                }) : new as(pt.document,{
                    formatter: xs,
                    lineCount: (at = pt.params.lineCount) !== null && at !== void 0 ? at : xo.monitor.defaultLineCount,
                    value: pt.value,
                    viewProps: pt.viewProps
                })
            }
        }
          , Ur = bt("grl");
        class im {
            constructor(at, dt) {
                this.onCursorChange_ = this.onCursorChange_.bind(this),
                this.onValueUpdate_ = this.onValueUpdate_.bind(this),
                this.element = at.createElement("div"),
                this.element.classList.add(Ur()),
                dt.viewProps.bindClassModifiers(this.element),
                this.formatter_ = dt.formatter,
                this.props_ = dt.props,
                this.cursor_ = dt.cursor,
                this.cursor_.emitter.on("change", this.onCursorChange_);
                const xt = at.createElementNS(Ln, "svg");
                xt.classList.add(Ur("g")),
                xt.style.height = `calc(var(--bld-us) * ${dt.lineCount})`,
                this.element.appendChild(xt),
                this.svgElem_ = xt;
                const Ct = at.createElementNS(Ln, "polyline");
                this.svgElem_.appendChild(Ct),
                this.lineElem_ = Ct;
                const zt = at.createElement("div");
                zt.classList.add(Ur("t"), bt("tt")()),
                this.element.appendChild(zt),
                this.tooltipElem_ = zt,
                dt.value.emitter.on("change", this.onValueUpdate_),
                this.value = dt.value,
                this.update_()
            }
            get graphElement() {
                return this.svgElem_
            }
            update_() {
                const at = this.svgElem_.getBoundingClientRect()
                  , dt = this.value.rawValue.length - 1
                  , xt = this.props_.get("minValue")
                  , Ct = this.props_.get("maxValue")
                  , zt = [];
                this.value.rawValue.forEach((or,ar)=>{
                    if (or === void 0)
                        return;
                    const kr = cr(ar, 0, dt, 0, at.width)
                      , yo = cr(or, xt, Ct, at.height, 0);
                    zt.push([kr, yo].join(","))
                }
                ),
                this.lineElem_.setAttributeNS(null, "points", zt.join(" "));
                const Yt = this.tooltipElem_
                  , Sn = this.value.rawValue[this.cursor_.rawValue];
                if (Sn === void 0) {
                    Yt.classList.remove(Ur("t", "a"));
                    return
                }
                const Bn = cr(this.cursor_.rawValue, 0, dt, 0, at.width)
                  , qn = cr(Sn, xt, Ct, at.height, 0);
                Yt.style.left = `${Bn}px`,
                Yt.style.top = `${qn}px`,
                Yt.textContent = `${this.formatter_(Sn)}`,
                Yt.classList.contains(Ur("t", "a")) || (Yt.classList.add(Ur("t", "a"), Ur("t", "in")),
                Gn(Yt),
                Yt.classList.remove(Ur("t", "in")))
            }
            onValueUpdate_() {
                this.update_()
            }
            onCursorChange_() {
                this.update_()
            }
        }
        class om {
            constructor(at, dt) {
                if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this),
                this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this),
                this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this),
                this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this),
                this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this),
                this.props_ = dt.props,
                this.value = dt.value,
                this.viewProps = dt.viewProps,
                this.cursor_ = qt(-1),
                this.view = new im(at,{
                    cursor: this.cursor_,
                    formatter: dt.formatter,
                    lineCount: dt.lineCount,
                    props: this.props_,
                    value: this.value,
                    viewProps: this.viewProps
                }),
                !bn(at))
                    this.view.element.addEventListener("mousemove", this.onGraphMouseMove_),
                    this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
                else {
                    const xt = new Hr(this.view.element);
                    xt.emitter.on("down", this.onGraphPointerDown_),
                    xt.emitter.on("move", this.onGraphPointerMove_),
                    xt.emitter.on("up", this.onGraphPointerUp_)
                }
            }
            onGraphMouseLeave_() {
                this.cursor_.rawValue = -1
            }
            onGraphMouseMove_(at) {
                const dt = this.view.element.getBoundingClientRect();
                this.cursor_.rawValue = Math.floor(cr(at.offsetX, 0, dt.width, 0, this.value.rawValue.length))
            }
            onGraphPointerDown_(at) {
                this.onGraphPointerMove_(at)
            }
            onGraphPointerMove_(at) {
                if (!at.data.point) {
                    this.cursor_.rawValue = -1;
                    return
                }
                this.cursor_.rawValue = Math.floor(cr(at.data.point.x, 0, at.data.bounds.width, 0, this.value.rawValue.length))
            }
            onGraphPointerUp_() {
                this.cursor_.rawValue = -1
            }
        }
        function us(pt) {
            return "format"in pt && !ht(pt.format) ? pt.format : mr(2)
        }
        function sm(pt) {
            var at;
            return pt.value.rawValue.length === 1 ? new ls(pt.document,{
                formatter: us(pt.params),
                value: pt.value,
                viewProps: pt.viewProps
            }) : new as(pt.document,{
                formatter: us(pt.params),
                lineCount: (at = pt.params.lineCount) !== null && at !== void 0 ? at : xo.monitor.defaultLineCount,
                value: pt.value,
                viewProps: pt.viewProps
            })
        }
        function am(pt) {
            var at, dt, xt;
            return new om(pt.document,{
                formatter: us(pt.params),
                lineCount: (at = pt.params.lineCount) !== null && at !== void 0 ? at : xo.monitor.defaultLineCount,
                props: jt.fromObject({
                    maxValue: (dt = "max"in pt.params ? pt.params.max : null) !== null && dt !== void 0 ? dt : 100,
                    minValue: (xt = "min"in pt.params ? pt.params.min : null) !== null && xt !== void 0 ? xt : 0
                }),
                value: pt.value,
                viewProps: pt.viewProps
            })
        }
        function El(pt) {
            return "view"in pt && pt.view === "graph"
        }
        const lm = {
            id: "monitor-number",
            type: "monitor",
            accept: (pt,at)=>{
                if (typeof pt != "number")
                    return null;
                const dt = _n
                  , xt = Fn(at, {
                    format: dt.optional.function,
                    lineCount: dt.optional.number,
                    max: dt.optional.number,
                    min: dt.optional.number,
                    view: dt.optional.string
                });
                return xt ? {
                    initialValue: pt,
                    params: xt
                } : null
            }
            ,
            binding: {
                defaultBufferSize: pt=>El(pt) ? 64 : 1,
                reader: pt=>Ss
            },
            controller: pt=>El(pt.params) ? am(pt) : sm(pt)
        }
          , um = {
            id: "monitor-string",
            type: "monitor",
            accept: (pt,at)=>{
                if (typeof pt != "string")
                    return null;
                const dt = _n
                  , xt = Fn(at, {
                    lineCount: dt.optional.number,
                    multiline: dt.optional.boolean
                });
                return xt ? {
                    initialValue: pt,
                    params: xt
                } : null
            }
            ,
            binding: {
                reader: pt=>Ms
            },
            controller: pt=>{
                var at;
                const dt = pt.value;
                return dt.rawValue.length > 1 || "multiline"in pt.params && pt.params.multiline ? new as(pt.document,{
                    formatter: zo,
                    lineCount: (at = pt.params.lineCount) !== null && at !== void 0 ? at : xo.monitor.defaultLineCount,
                    value: dt,
                    viewProps: pt.viewProps
                }) : new ls(pt.document,{
                    formatter: zo,
                    value: dt,
                    viewProps: pt.viewProps
                })
            }
        };
        class cm {
            constructor(at) {
                this.onValueChange_ = this.onValueChange_.bind(this),
                this.reader = at.reader,
                this.writer = at.writer,
                this.emitter = new mt,
                this.value = at.value,
                this.value.emitter.on("change", this.onValueChange_),
                this.target = at.target,
                this.read()
            }
            read() {
                const at = this.target.read();
                at !== void 0 && (this.value.rawValue = this.reader(at))
            }
            write_(at) {
                this.writer(this.target, at)
            }
            onValueChange_(at) {
                this.write_(at.rawValue),
                this.emitter.emit("change", {
                    options: at.options,
                    rawValue: at.rawValue,
                    sender: this
                })
            }
        }
        function dm(pt, at) {
            const dt = pt.accept(at.target.read(), at.params);
            if (ht(dt))
                return null;
            const xt = _n
              , Ct = {
                target: at.target,
                initialValue: dt.initialValue,
                params: dt.params
            }
              , zt = pt.binding.reader(Ct)
              , Yt = pt.binding.constraint ? pt.binding.constraint(Ct) : void 0
              , Sn = qt(zt(dt.initialValue), {
                constraint: Yt,
                equals: pt.binding.equals
            })
              , Bn = new cm({
                reader: zt,
                target: at.target,
                value: Sn,
                writer: pt.binding.writer(Ct)
            })
              , qn = xt.optional.boolean(at.params.disabled).value
              , or = xt.optional.boolean(at.params.hidden).value
              , ar = pt.controller({
                constraint: Yt,
                document: at.document,
                initialValue: dt.initialValue,
                params: dt.params,
                value: Bn.value,
                viewProps: vr.create({
                    disabled: qn,
                    hidden: or
                })
            })
              , kr = xt.optional.string(at.params.label).value;
            return new Qn(at.document,{
                binding: Bn,
                blade: hn(),
                props: jt.fromObject({
                    label: kr != null ? kr : at.target.key
                }),
                valueController: ar
            })
        }
        class hm {
            constructor(at) {
                this.onTick_ = this.onTick_.bind(this),
                this.reader_ = at.reader,
                this.target = at.target,
                this.emitter = new mt,
                this.value = at.value,
                this.ticker = at.ticker,
                this.ticker.emitter.on("tick", this.onTick_),
                this.read()
            }
            dispose() {
                this.ticker.dispose()
            }
            read() {
                const at = this.target.read();
                if (at === void 0)
                    return;
                const dt = this.value.rawValue
                  , xt = this.reader_(at);
                this.value.rawValue = bu(dt, xt),
                this.emitter.emit("update", {
                    rawValue: xt,
                    sender: this
                })
            }
            onTick_(at) {
                this.read()
            }
        }
        function pm(pt, at) {
            return at === 0 ? new Vl : new Nl(pt,at != null ? at : xo.monitor.defaultInterval)
        }
        function fm(pt, at) {
            var dt, xt, Ct;
            const zt = _n
              , Yt = pt.accept(at.target.read(), at.params);
            if (ht(Yt))
                return null;
            const Sn = {
                target: at.target,
                initialValue: Yt.initialValue,
                params: Yt.params
            }
              , Bn = pt.binding.reader(Sn)
              , qn = (xt = (dt = zt.optional.number(at.params.bufferSize).value) !== null && dt !== void 0 ? dt : pt.binding.defaultBufferSize && pt.binding.defaultBufferSize(Yt.params)) !== null && xt !== void 0 ? xt : 1
              , or = zt.optional.number(at.params.interval).value
              , ar = new hm({
                reader: Bn,
                target: at.target,
                ticker: pm(at.document, or),
                value: xu(qn)
            })
              , kr = zt.optional.boolean(at.params.disabled).value
              , yo = zt.optional.boolean(at.params.hidden).value
              , bo = pt.controller({
                document: at.document,
                params: Yt.params,
                value: ar.value,
                viewProps: vr.create({
                    disabled: kr,
                    hidden: yo
                })
            })
              , io = (Ct = zt.optional.string(at.params.label).value) !== null && Ct !== void 0 ? Ct : at.target.key;
            return new hr(at.document,{
                binding: ar,
                blade: hn(),
                props: jt.fromObject({
                    label: io
                }),
                valueController: bo
            })
        }
        class mm {
            constructor() {
                this.pluginsMap_ = {
                    blades: [],
                    inputs: [],
                    monitors: []
                }
            }
            getAll() {
                return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors]
            }
            register(at) {
                at.type === "blade" ? this.pluginsMap_.blades.unshift(at) : at.type === "input" ? this.pluginsMap_.inputs.unshift(at) : at.type === "monitor" && this.pluginsMap_.monitors.unshift(at)
            }
            createInput(at, dt, xt) {
                const Ct = dt.read();
                if (ht(Ct))
                    throw new vt({
                        context: {
                            key: dt.key
                        },
                        type: "nomatchingcontroller"
                    });
                const zt = this.pluginsMap_.inputs.reduce((Yt,Sn)=>Yt != null ? Yt : dm(Sn, {
                    document: at,
                    target: dt,
                    params: xt
                }), null);
                if (zt)
                    return zt;
                throw new vt({
                    context: {
                        key: dt.key
                    },
                    type: "nomatchingcontroller"
                })
            }
            createMonitor(at, dt, xt) {
                const Ct = this.pluginsMap_.monitors.reduce((zt,Yt)=>zt != null ? zt : fm(Yt, {
                    document: at,
                    params: xt,
                    target: dt
                }), null);
                if (Ct)
                    return Ct;
                throw new vt({
                    context: {
                        key: dt.key
                    },
                    type: "nomatchingcontroller"
                })
            }
            createBlade(at, dt) {
                const xt = this.pluginsMap_.blades.reduce((Ct,zt)=>Ct != null ? Ct : Ol(zt, {
                    document: at,
                    params: dt
                }), null);
                if (!xt)
                    throw new vt({
                        type: "nomatchingview",
                        context: {
                            params: dt
                        }
                    });
                return xt
            }
            createBladeApi(at) {
                if (at instanceof Qn)
                    return new dr(at);
                if (at instanceof hr)
                    return new _r(at);
                if (at instanceof jn)
                    return new Ir(at,this);
                const dt = this.pluginsMap_.blades.reduce((xt,Ct)=>xt != null ? xt : Ct.api({
                    controller: at,
                    pool: this
                }), null);
                if (!dt)
                    throw vt.shouldNeverHappen();
                return dt
            }
        }
        function gm() {
            const pt = new mm;
            return [wm, Xp, Jp, em, zp, Fp, Dp, Pp, Ru, rm, um, lm, Ht, sr, Dr, hs].forEach(at=>{
                pt.register(at)
            }
            ),
            pt
        }
        function vm(pt) {
            return zr.isObject(pt) ? new zr(pt.x,pt.y) : new zr
        }
        function _m(pt, at) {
            pt.writeProperty("x", at.x),
            pt.writeProperty("y", at.y)
        }
        function Rr(pt, at) {
            if (!pt)
                return;
            const dt = []
              , xt = ya(pt, at);
            xt && dt.push(xt);
            const Ct = vl(pt);
            return Ct && dt.push(Ct),
            new lo(dt)
        }
        function xm(pt, at) {
            return new Br({
                assembly: _l,
                components: [Rr("x"in pt ? pt.x : void 0, at.x), Rr("y"in pt ? pt.y : void 0, at.y)]
            })
        }
        function Cl(pt, at) {
            const [dt,xt] = pt ? Np(pt) : [];
            if (!ht(dt) || !ht(xt))
                return Math.max(Math.abs(dt != null ? dt : 0), Math.abs(xt != null ? xt : 0));
            const Ct = Qr(pt);
            return Math.max(Math.abs(Ct) * 10, Math.abs(at) * 10)
        }
        function ym(pt, at) {
            const dt = at instanceof Br ? at.components[0] : void 0
              , xt = at instanceof Br ? at.components[1] : void 0
              , Ct = Cl(dt, pt.x)
              , zt = Cl(xt, pt.y);
            return Math.max(Ct, zt)
        }
        function Tl(pt, at) {
            return {
                baseStep: Qr(at),
                constraint: at,
                textProps: jt.fromObject({
                    draggingScale: Jr(at, pt),
                    formatter: mr(To(at, pt))
                })
            }
        }
        function bm(pt) {
            if (!("y"in pt))
                return !1;
            const at = pt.y;
            return at && "inverted"in at ? !!at.inverted : !1
        }
        const wm = {
            id: "input-point2d",
            type: "input",
            accept: (pt,at)=>{
                if (!zr.isObject(pt))
                    return null;
                const dt = _n
                  , xt = Fn(at, {
                    expanded: dt.optional.boolean,
                    picker: dt.optional.custom(Ls),
                    x: dt.optional.custom(Vr),
                    y: dt.optional.object({
                        inverted: dt.optional.boolean,
                        max: dt.optional.number,
                        min: dt.optional.number,
                        step: dt.optional.number
                    })
                });
                return xt ? {
                    initialValue: pt,
                    params: xt
                } : null
            }
            ,
            binding: {
                reader: pt=>vm,
                constraint: pt=>xm(pt.params, pt.initialValue),
                equals: zr.equals,
                writer: pt=>_m
            },
            controller: pt=>{
                const at = pt.document
                  , dt = pt.value
                  , xt = pt.constraint;
                if (!(xt instanceof Br))
                    throw vt.shouldNeverHappen();
                const Ct = "expanded"in pt.params ? pt.params.expanded : void 0
                  , zt = "picker"in pt.params ? pt.params.picker : void 0;
                return new jp(at,{
                    axes: [Tl(dt.rawValue.x, xt.components[0]), Tl(dt.rawValue.y, xt.components[1])],
                    expanded: Ct != null ? Ct : !1,
                    invertsY: bm(pt.params),
                    maxValue: ym(dt.rawValue, xt),
                    parser: Lr,
                    pickerLayout: zt != null ? zt : "popup",
                    value: dt,
                    viewProps: pt.viewProps
                })
            }
        };
        class Al extends rt {
            constructor(at) {
                super(at),
                this.emitter_ = new mt,
                this.controller_.valueController.value.emitter.on("change", dt=>{
                    this.emitter_.emit("change", {
                        event: new ot(this,dt.rawValue)
                    })
                }
                )
            }
            get label() {
                return this.controller_.props.get("label")
            }
            set label(at) {
                this.controller_.props.set("label", at)
            }
            get options() {
                return this.controller_.valueController.props.get("options")
            }
            set options(at) {
                this.controller_.valueController.props.set("options", at)
            }
            get value() {
                return this.controller_.valueController.value.rawValue
            }
            set value(at) {
                this.controller_.valueController.value.rawValue = at
            }
            on(at, dt) {
                const xt = dt.bind(this);
                return this.emitter_.on(at, Ct=>{
                    xt(Ct.event)
                }
                ),
                this
            }
        }
        class Ll extends rt {
            constructor(at) {
                super(at),
                this.emitter_ = new mt,
                this.controller_.valueController.value.emitter.on("change", dt=>{
                    this.emitter_.emit("change", {
                        event: new ot(this,dt.rawValue)
                    })
                }
                )
            }
            get label() {
                return this.controller_.props.get("label")
            }
            set label(at) {
                this.controller_.props.set("label", at)
            }
            get maxValue() {
                return this.controller_.valueController.sliderController.props.get("maxValue")
            }
            set maxValue(at) {
                this.controller_.valueController.sliderController.props.set("maxValue", at)
            }
            get minValue() {
                return this.controller_.valueController.sliderController.props.get("minValue")
            }
            set minValue(at) {
                this.controller_.valueController.sliderController.props.set("minValue", at)
            }
            get value() {
                return this.controller_.valueController.value.rawValue
            }
            set value(at) {
                this.controller_.valueController.value.rawValue = at
            }
            on(at, dt) {
                const xt = dt.bind(this);
                return this.emitter_.on(at, Ct=>{
                    xt(Ct.event)
                }
                ),
                this
            }
        }
        class Pl extends rt {
            constructor(at) {
                super(at),
                this.emitter_ = new mt,
                this.controller_.valueController.value.emitter.on("change", dt=>{
                    this.emitter_.emit("change", {
                        event: new ot(this,dt.rawValue)
                    })
                }
                )
            }
            get label() {
                return this.controller_.props.get("label")
            }
            set label(at) {
                this.controller_.props.set("label", at)
            }
            get formatter() {
                return this.controller_.valueController.props.get("formatter")
            }
            set formatter(at) {
                this.controller_.valueController.props.set("formatter", at)
            }
            get value() {
                return this.controller_.valueController.value.rawValue
            }
            set value(at) {
                this.controller_.valueController.value.rawValue = at
            }
            on(at, dt) {
                const xt = dt.bind(this);
                return this.emitter_.on(at, Ct=>{
                    xt(Ct.event)
                }
                ),
                this
            }
        }
        const Sm = function() {
            return {
                id: "list",
                type: "blade",
                accept(pt) {
                    const at = _n
                      , dt = Fn(pt, {
                        options: at.required.custom(Co),
                        value: at.required.raw,
                        view: at.required.constant("list"),
                        label: at.optional.string
                    });
                    return dt ? {
                        params: dt
                    } : null
                },
                controller(pt) {
                    const at = new uo(Ps(pt.params.options))
                      , dt = qt(pt.params.value, {
                        constraint: at
                    })
                      , xt = new co(pt.document,{
                        props: new jt({
                            options: at.values.value("options")
                        }),
                        value: dt,
                        viewProps: pt.viewProps
                    });
                    return new Kn(pt.document,{
                        blade: pt.blade,
                        props: jt.fromObject({
                            label: pt.params.label
                        }),
                        valueController: xt
                    })
                },
                api(pt) {
                    return !(pt.controller instanceof Kn) || !(pt.controller.valueController instanceof co) ? null : new Al(pt.controller)
                }
            }
        }();
        function Mm(pt) {
            return pt.reduce((at,dt)=>Object.assign(at, {
                [dt.presetKey]: dt.read()
            }), {})
        }
        function Em(pt, at) {
            pt.forEach(dt=>{
                const xt = at[dt.presetKey];
                xt !== void 0 && dt.write(xt)
            }
            )
        }
        class Cm extends Yr {
            constructor(at, dt) {
                super(at, dt)
            }
            get element() {
                return this.controller_.view.element
            }
            importPreset(at) {
                const dt = this.controller_.rackController.rack.find(Qn).map(xt=>xt.binding.target);
                Em(dt, at),
                this.refresh()
            }
            exportPreset() {
                const at = this.controller_.rackController.rack.find(Qn).map(dt=>dt.binding.target);
                return Mm(at)
            }
            refresh() {
                this.controller_.rackController.rack.find(Qn).forEach(at=>{
                    at.binding.read()
                }
                ),
                this.controller_.rackController.rack.find(hr).forEach(at=>{
                    at.binding.read()
                }
                )
            }
        }
        class Tm extends Yn {
            constructor(at, dt) {
                super(at, {
                    expanded: dt.expanded,
                    blade: dt.blade,
                    props: dt.props,
                    root: !0,
                    viewProps: dt.viewProps
                })
            }
        }
        const Am = {
            id: "slider",
            type: "blade",
            accept(pt) {
                const at = _n
                  , dt = Fn(pt, {
                    max: at.required.number,
                    min: at.required.number,
                    view: at.required.constant("slider"),
                    format: at.optional.function,
                    label: at.optional.string,
                    value: at.optional.number
                });
                return dt ? {
                    params: dt
                } : null
            },
            controller(pt) {
                var at, dt;
                const xt = (at = pt.params.value) !== null && at !== void 0 ? at : 0
                  , Ct = new Kr({
                    max: pt.params.max,
                    min: pt.params.min
                })
                  , zt = new jo(pt.document,{
                    baseStep: 1,
                    parser: Lr,
                    sliderProps: new jt({
                        maxValue: Ct.values.value("max"),
                        minValue: Ct.values.value("min")
                    }),
                    textProps: jt.fromObject({
                        draggingScale: Jr(void 0, xt),
                        formatter: (dt = pt.params.format) !== null && dt !== void 0 ? dt : vu
                    }),
                    value: qt(xt, {
                        constraint: Ct
                    }),
                    viewProps: pt.viewProps
                });
                return new Kn(pt.document,{
                    blade: pt.blade,
                    props: jt.fromObject({
                        label: pt.params.label
                    }),
                    valueController: zt
                })
            },
            api(pt) {
                return !(pt.controller instanceof Kn) || !(pt.controller.valueController instanceof jo) ? null : new Ll(pt.controller)
            }
        }
          , Lm = function() {
            return {
                id: "text",
                type: "blade",
                accept(pt) {
                    const at = _n
                      , dt = Fn(pt, {
                        parse: at.required.function,
                        value: at.required.raw,
                        view: at.required.constant("text"),
                        format: at.optional.function,
                        label: at.optional.string
                    });
                    return dt ? {
                        params: dt
                    } : null
                },
                controller(pt) {
                    var at;
                    const dt = new Mo(pt.document,{
                        parser: pt.params.parse,
                        props: jt.fromObject({
                            formatter: (at = pt.params.format) !== null && at !== void 0 ? at : xt=>String(xt)
                        }),
                        value: qt(pt.params.value),
                        viewProps: pt.viewProps
                    });
                    return new Kn(pt.document,{
                        blade: pt.blade,
                        props: jt.fromObject({
                            label: pt.params.label
                        }),
                        valueController: dt
                    })
                },
                api(pt) {
                    return !(pt.controller instanceof Kn) || !(pt.controller.valueController instanceof Mo) ? null : new Pl(pt.controller)
                }
            }
        }();
        function Pm(pt) {
            const at = pt.createElement("div");
            return at.classList.add(bt("dfw")()),
            pt.body && pt.body.appendChild(at),
            at
        }
        function Rl(pt, at, dt) {
            if (pt.querySelector(`style[data-tp-style=${at}]`))
                return;
            const xt = pt.createElement("style");
            xt.dataset.tpStyle = at,
            xt.textContent = dt,
            pt.head.appendChild(xt)
        }
        class Rm extends Cm {
            constructor(at) {
                var dt, xt;
                const Ct = at != null ? at : {}
                  , zt = (dt = Ct.document) !== null && dt !== void 0 ? dt : Dn()
                  , Yt = gm()
                  , Sn = new Tm(zt,{
                    expanded: Ct.expanded,
                    blade: hn(),
                    props: jt.fromObject({
                        title: Ct.title
                    }),
                    viewProps: vr.create()
                });
                super(Sn, Yt),
                this.pool_ = Yt,
                this.containerElem_ = (xt = Ct.container) !== null && xt !== void 0 ? xt : Pm(zt),
                this.containerElem_.appendChild(this.element),
                this.doc_ = zt,
                this.usesDefaultWrapper_ = !Ct.container,
                this.setUpDefaultPlugins_()
            }
            get document() {
                if (!this.doc_)
                    throw vt.alreadyDisposed();
                return this.doc_
            }
            dispose() {
                const at = this.containerElem_;
                if (!at)
                    throw vt.alreadyDisposed();
                if (this.usesDefaultWrapper_) {
                    const dt = at.parentElement;
                    dt && dt.removeChild(at)
                }
                this.containerElem_ = null,
                this.doc_ = null,
                super.dispose()
            }
            registerPlugin(at) {
                ("plugin"in at ? [at.plugin] : "plugins"in at ? at.plugins : []).forEach(xt=>{
                    this.pool_.register(xt),
                    this.embedPluginStyle_(xt)
                }
                )
            }
            embedPluginStyle_(at) {
                at.css && Rl(this.document, `plugin-${at.id}`, at.css)
            }
            setUpDefaultPlugins_() {
                Rl(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230deg, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230deg, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230deg, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230deg, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230deg, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'),
                this.pool_.getAll().forEach(at=>{
                    this.embedPluginStyle_(at)
                }
                ),
                this.registerPlugin({
                    plugins: [Am, Sm, hs, Lm]
                })
            }
        }
        const km = new nt("3.1.2");
        tt.BladeApi = rt,
        tt.ButtonApi = wt,
        tt.FolderApi = Yr,
        tt.InputBindingApi = dr,
        tt.ListApi = Al,
        tt.MonitorBindingApi = _r,
        tt.Pane = Rm,
        tt.SeparatorApi = tr,
        tt.SliderApi = Ll,
        tt.TabApi = pr,
        tt.TabPageApi = Zr,
        tt.TextApi = Pl,
        tt.TpChangeEvent = ot,
        tt.VERSION = km,
        Object.defineProperty(tt, "__esModule", {
            value: !0
        })
    })
}
)(tweakpane, tweakpane.exports);
class GUI$1 {
    preInit() {}
    init() {
        this._post()
    }
    _post() {
        const $ = new tweakpane.exports.Pane({});
        if ($.containerElem_.style.width = "400px",
        properties.bloom) {
            const nt = $.addFolder({
                title: "bloom"
            });
            nt.add = this._add,
            nt.add(properties, "bloomAmount", 0, 5, 1e-5),
            nt.add(properties, "bloomRadius", -1, 1, 1e-5),
            nt.add(properties, "bloomThreshold", 0, 1, 1e-5),
            nt.add(properties, "bloomSmoothWidth", 0, 2, 1e-5),
            nt.add(properties, "haloWidth", 0, 2, 1e-5),
            nt.add(properties, "haloRGBShift", 0, .2, 1e-5),
            nt.add(properties, "haloStrength", 0, 3, 1e-5),
            nt.add(properties, "haloMaskInner", 0, 1, 1e-5),
            nt.add(properties, "haloMaskOuter", 0, 1, 1e-5)
        }
        if (properties.final) {
            const nt = $.addFolder({
                title: "color"
            });
            nt.add = this._add,
            nt.add(properties, "vignetteFrom", 0, 3, 1e-5),
            nt.add(properties, "vignetteTo", 0, 3, 1e-5),
            nt.add(properties, "vignetteColorHex"),
            nt.add(properties, "saturation", 0, 3, 1e-5),
            nt.add(properties, "contrast", -1, 3, 1e-5),
            nt.add(properties, "brightness", 0, 2, 1e-5),
            nt.add(properties, "tintColorHex"),
            nt.add(properties, "tintOpacity", 0, 1, 1e-5)
        }
        if (properties.bokeh) {
            const nt = $.addFolder({
                title: "bokeh"
            });
            nt.add = this._add,
            nt.add(properties, "bokehAmount", 0, 1, 1e-5),
            nt.add(properties, "bokehFNumber", 1e-4, 1, 1e-5),
            nt.add(properties, "bokehFocusDistance", 0, 20, 1e-5),
            nt.add(properties, "bokehFocalLength", 0, 3, 1e-5),
            nt.add(properties, "bokehKFilmHeight", 1e-5, 90, 1e-5),
            nt.add(properties.bokeh, "quality", 0, 3, 1)
        }
        if (properties.cameraMotionBlur) {
            const nt = $.addFolder({
                title: "cameraMotionBlur"
            });
            nt.add = this._add,
            nt.add(properties, "cameraMotionBlurAmount", 0, 3, 1e-5)
        }
        const tt = $.addFolder({
            title: "screenPaint"
        });
        if (tt.add = this._add,
        tt.add(properties, "screenPaintNeedsMouseDown"),
        tt.add(properties, "screenPaintMinRadius", 0, 200, 1),
        tt.add(properties, "screenPaintMaxRadius", 0, 300, 1),
        tt.add(properties, "screenPaintRadiusDistanceRange", 0, 300, 1),
        tt.add(properties, "screenPaintPaintStrength", 0, 10, .01),
        tt.add(properties, "screenPaintPushStrength", 0, 100, 1e-5),
        tt.add(properties, "screenPaintVelocityDissipation", 0, .999, 1e-5),
        tt.add(properties, "screenPaintWeight1Dissipation", 0, .999, 1e-5),
        tt.add(properties, "screenPaintWeight2Dissipation", 0, .999, 1e-5),
        tt.add(properties, "screenPaintUseNoise"),
        tt.add(properties, "screenPaintCurlScale", 0, .5, 1e-5),
        tt.add(properties, "screenPaintCurlStrength", 0, 5, 1e-5),
        properties.screenPaintDistortion) {
            const nt = $.addFolder({
                title: "screenPaintDistortion"
            });
            nt.add = this._add,
            nt.add(properties, "screenPaintDistortionAmount", 0, 100, 1e-5),
            nt.add(properties, "screenPaintDistortionRGBShift", 0, 3, 1e-5),
            nt.add(properties, "screenPaintDistortionMultiplier", 0, 3, 1e-5)
        }
    }
    _add($, tt, nt, rt, it) {
        this.addInput($, tt, {
            min: nt,
            max: rt,
            step: it
        })
    }
}
var gui = new GUI$1
  , particlesVert = `#define GLSLIFY 1
attribute vec4 a_random;
attribute vec2 a_simUv;
uniform sampler2D u_prevPosTex;
uniform sampler2D u_currPosTex;
uniform vec2 u_resolution;
uniform float u_time;
uniform float u_opacity;
uniform float u_pSizeMul;
uniform float u_pSoftMul;
uniform float u_focusDist;
varying float v_softness;
varying float v_opacity;
varying vec3 v_color;
float sizeFromLife(float life){float cut=0.008;return(1.0-smoothstep(1.0-cut,1.0,life))*smoothstep(0.0,cut,life);}
void main(){
    vec4 positionLife=texture2D(u_currPosTex,a_simUv);
    float lifeSize=sizeFromLife(positionLife.w);
    vec3 pos=positionLife.xyz;
    vec4 mvPosition=modelViewMatrix*vec4(pos,1.0);
    float dist=u_focusDist*10.0;
    float coef=abs(-mvPosition.z-dist)*0.3+pow(max(0.0,-mvPosition.z-dist),2.5)*0.5;
    v_softness=coef*u_pSoftMul*10.0;
    v_opacity=1.0;
    v_opacity=u_opacity*lifeSize;
    gl_Position=projectionMatrix*mvPosition;
    float pSize=(coef*200.0*u_pSizeMul)/-mvPosition.z*u_resolution.y/1280.0;
    gl_PointSize=pSize*lifeSize;
}`
  , particlesFrag = `#define GLSLIFY 1
varying float v_softness;
varying float v_opacity;
varying vec3 v_color;
float linearStep(float edge0,float edge1,float x){return clamp((x-edge0)/(edge1-edge0),0.0,1.0);}
void main(){
    float d=length(gl_PointCoord.xy*2.0-1.0);
    float b=linearStep(0.0,v_softness+fwidth(d),1.0-d);
    vec3 color=v_color*b*v_opacity;
    gl_FragColor=vec4(color,b*v_opacity);
}`
  , particlePositionShader = `#define GLSLIFY 1
uniform sampler2D u_defaultPosTex;
uniform sampler2D u_prevPosTex;
uniform sampler2D u_currVelTex;
uniform sampler2D u_logoPosTex;
uniform float u_simDieSpeed;
uniform vec3 u_curlNoiseScale;
uniform vec3 u_curlStrength;
uniform float u_curlStrMul;
uniform float u_simSpeed;
uniform vec3 u_bounds;
uniform vec3 u_screenBounds;
uniform float u_deltaTime;
uniform float u_time;
uniform float u_mode;
uniform float u_logoCutPercent;
varying vec2 v_uv;
vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}
float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}
vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
float permute(float x){return mod289(((x*34.0)+1.0)*x);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}
vec4 grad4(float j,vec4 ip){
    const vec4 ones=vec4(1.0,1.0,1.0,-1.0);
    vec4 p,s;
    p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;
    p.w=1.5-dot(abs(p.xyz),ones.xyz);
    s=vec4(lessThan(p,vec4(0.0)));
    p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;
    return p;
}
#define F4 0.309016994374947451
vec4 simplexNoiseDerivatives(vec4 v){
    const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);
    vec4 i=floor(v+dot(v,vec4(F4)));
    vec4 x0=v-i+dot(i,C.xxxx);
    vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);
    vec3 isYZ=step(x0.zww,x0.yyz);
    i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;
    vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);
    vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);
    float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);
    vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 values0=vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2));vec2 values1=vec2(dot(p3,x3),dot(p4,x4));vec3 m0=max(0.5-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.5-vec2(dot(x3,x3),dot(x4,x4)),0.0);vec3 temp0=-6.0*m0*m0*values0;vec2 temp1=-6.0*m1*m1*values1;vec3 mmm0=m0*m0*m0;vec2 mmm1=m1*m1*m1;float dx=temp0[0]*x0.x+temp0[1]*x1.x+temp0[2]*x2.x+temp1[0]*x3.x+temp1[1]*x4.x+mmm0[0]*p0.x+mmm0[1]*p1.x+mmm0[2]*p2.x+mmm1[0]*p3.x+mmm1[1]*p4.x;float dy=temp0[0]*x0.y+temp0[1]*x1.y+temp0[2]*x2.y+temp1[0]*x3.y+temp1[1]*x4.y+mmm0[0]*p0.y+mmm0[1]*p1.y+mmm0[2]*p2.y+mmm1[0]*p3.y+mmm1[1]*p4.y;float dz=temp0[0]*x0.z+temp0[1]*x1.z+temp0[2]*x2.z+temp1[0]*x3.z+temp1[1]*x4.z+mmm0[0]*p0.z+mmm0[1]*p1.z+mmm0[2]*p2.z+mmm1[0]*p3.z+mmm1[1]*p4.z;float dw=temp0[0]*x0.w+temp0[1]*x1.w+temp0[2]*x2.w+temp1[0]*x3.w+temp1[1]*x4.w+mmm0[0]*p0.w+mmm0[1]*p1.w+mmm0[2]*p2.w+mmm1[0]*p3.w+mmm1[1]*p4.w;return vec4(dx,dy,dz,dw)*49.0;}vec3 curl(in vec3 p,in float noiseTime,in float persistence){vec4 xNoisePotentialDerivatives=vec4(0.0);vec4 yNoisePotentialDerivatives=vec4(0.0);vec4 zNoisePotentialDerivatives=vec4(0.0);for(int i=0;i<2;++i){float twoPowI=pow(2.0,float(i));float scale=0.5*twoPowI*pow(persistence,float(i));xNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4(p*twoPowI,noiseTime))*scale;yNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4((p+vec3(123.4,129845.6,-1239.1))*twoPowI,noiseTime))*scale;zNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4((p+vec3(-9519.0,9051.0,-123.0))*twoPowI,noiseTime))*scale;}return vec3(zNoisePotentialDerivatives[1]-yNoisePotentialDerivatives[2],xNoisePotentialDerivatives[2]-zNoisePotentialDerivatives[0],yNoisePotentialDerivatives[0]-xNoisePotentialDerivatives[1]);}vec3 hash33(vec3 p3){p3=fract(p3*vec3(.1031,.1030,.0973));p3+=dot(p3,p3.yxz+33.33);return fract((p3.xxy+p3.yxx)*p3.zyx);}void main(){vec4 positionLife=texture2D(u_prevPosTex,v_uv);vec4 velInfo=texture2D(u_currVelTex,v_uv);positionLife.w-=u_deltaTime*u_simDieSpeed*0.01*(1.0+velInfo.w);if(positionLife.w<0.0){vec3 h=hash33(vec3(v_uv,u_time));float modeCut=step(u_logoCutPercent,h.x);if(u_mode*modeCut>0.5){vec3 p=texture2D(u_logoPosTex,v_uv).xyz;positionLife.xyz=p+h*0.2;}else{positionLife.xyz=texture2D(u_defaultPosTex,v_uv).xyz;}positionLife.w=1.0;}vec3 boundCheck=step(positionLife.xyz,u_bounds);boundCheck*=step(-u_bounds,positionLife.xyz);positionLife.w*=boundCheck.x*boundCheck.y*boundCheck.z;positionLife.xyz+=velInfo.xyz*u_deltaTime;vec3 curlStr=u_curlStrength*u_curlStrMul;vec3 curlScale=u_curlNoiseScale*1.0;vec3 curlVel=curl(positionLife.xyz*curlScale,u_time*u_simSpeed,0.02)*curlStr*u_deltaTime;curlVel/=1.0+velInfo.w*u_mode;positionLife.xyz+=curlVel;
    gl_FragColor=positionLife;
}`
  , particleVelocityShader = `#define GLSLIFY 1
uniform sampler2D u_prevPosTex;
uniform sampler2D u_prevVelTex;
uniform sampler2D u_logoPosTex;uniform sampler2D u_mousePaintTex;uniform float u_attractForce;
uniform vec3 u_windForce;uniform float u_windStrMul;uniform float u_mouseMoveIntensity;
uniform float u_mouseStrength;uniform vec3 u_screenBounds;uniform float u_simDieSpeed;
uniform float u_deltaTime;uniform float u_time;uniform float u_mode;uniform float u_logoCutPercent;
varying vec2 v_uv;
vec3 hash33(vec3 p3){p3=fract(p3*vec3(.1031,.1030,.0973));p3+=dot(p3,p3.yxz+33.33);return fract((p3.xxy+p3.yxx)*p3.zyx);}vec2 posToUv(vec3 pos){vec2 uv=pos.xy/u_screenBounds.xy;uv=(uv+vec2(1.0))/2.0;uv.y=1.0-uv.y;return uv;}
void main(){
    vec4 positionLife=texture2D(u_prevPosTex,v_uv);vec4 velInfo=texture2D(u_prevVelTex,v_uv);
    positionLife.w-=u_deltaTime*u_simDieSpeed*0.01;if(positionLife.w<0.0){vec3 h=hash33(vec3(v_uv,u_time));
        float modeCut=step(u_logoCutPercent,h.x);velInfo.w=(modeCut*h.y*2.0+1.0)*u_mode;}velInfo.xyz*=0.975;
        if(velInfo.w*u_mode>1.0){
            vec3 originPos=texture2D(u_logoPosTex,v_uv).xyz;vec3 attrV=originPos-positionLife.xyz;
            float dist2=dot(attrV,attrV);if(dist2>0.0001){attrV/=sqrt(dist2);}else{attrV=vec3(1.0,0.0,0.0);}
            velInfo.xyz+=attrV*u_attractForce*velInfo.w*u_deltaTime;}
            vec3 windVel=u_windForce*u_deltaTime*u_windStrMul;windVel/=1.0+velInfo.w*u_mode;velInfo.xyz+=windVel;
            vec2 posUv=posToUv(positionLife.xyz);
            vec3 mousePaintVel=(texture2D(u_mousePaintTex,posUv).xyz-0.5+0.001)*2.0;mousePaintVel.z=0.0;
            vec3 mouseFinalVel=mousePaintVel*0.8*u_mouseMoveIntensity*u_mouseStrength;
            mouseFinalVel*=1.0+velInfo.w*0.5*u_mode;velInfo.xyz+=mouseFinalVel;
            gl_FragColor=velInfo;
        }`;
function packTexture(et, $) {
    let tt = et.attributes
      , nt = {
        x: 0,
        y: 0
    }
      , rt = $.pack.length
      , it = Object.values(tt)[0].count
      , ot = $.vertexCount || it
      , st = Math.ceil(Math.sqrt(ot));
    nt.x = st * rt,
    nt.y = st;
    let lt = nt.x * nt.y * 4
      , ut = new Float32Array(lt)
      , ct = 0
      , ht = {};
    $.pack.flat().forEach(gt=>{
        ht[gt] === void 0 && (ht[gt] = 0)
    }
    );
    for (let gt = 0; gt < it; gt++)
        for (let vt = 0; vt < rt; vt++) {
            let yt = $.pack[vt];
            for (let wt = 0; wt < 4; wt++) {
                let mt = yt[wt];
                if (mt !== void 0) {
                    let _t = ht[mt];
                    ut[ct] = tt[mt].array[_t],
                    ht[mt] += 1
                } else
                    ut[ct] = 0;
                ct++
            }
        }
    for (; ct < lt; )
        ut[ct] = 0,
        ct++;
    return {
        texture: fboHelper.createDataTexture(ut, nt.x, nt.y, !0, !0, !0),
        textureSize: nt
    }
}
const TEX_SIZE = 128
  , PARTICLE_COUNT = TEX_SIZE * TEX_SIZE
  , GUI = settings.LOOK_DEV_MODE
  , SPAWN = {
    bounds: {
        x: 4,
        y: 2.4,
        z: .64
    },
    offset: {
        x: -3,
        y: -.5,
        z: 0
    }
}
  , KILL = {
    bounds: {
        x: 7,
        y: 5,
        z: 2
    }
};
/* Ghim */
class Particles {
    constructor() {
        Et(this, "container", new Object3D);
        Et(this, "prevPosRt", null);
        Et(this, "currPosRt", null);
        Et(this, "posSimMat", null);
        Et(this, "_v3", new Vector3);
        Et(this, "_graphVal", 0);
        Et(this, "sharedUniforms", {
            u_defaultPosTex: {
                value: null
            },
            u_prevPosTex: {
                value: null
            },
            u_currPosTex: {
                value: null
            },
            u_prevVelTex: {
                value: null
            },
            u_currVelTex: {
                value: null
            },
            u_logoPosTex: {
                value: null
            },
            u_mode: {
                value: 0
            },
            u_simDieSpeed: {
                value: .32
            },
            u_logoCutPercent: {
                value: .4
            },
            u_deltaTime: {
                value: 0
            },
            u_time: properties.sharedUniforms.u_time
        })
    }
    preInit() {
        properties.loader.add(settings.MODEL_PATH + "lsn_logo.buf", {
            onLoad: $=>this._logoModelLoad($)
        }),
        this._initPoints(),
        this._initTextures()
    }
    _logoModelLoad($) {
        const nt = [-.18, .16, 0].map(lt=>lt * Math.PI)
          , rt = [0, 0, -.32];
        $.translate(rt[0], rt[1], rt[2]),
        $.scale(.9, .9, .9),
        ["X", "Y"].forEach((lt,ut)=>{
            $[`rotate ${lt}`](nt[ut])
        }
        );
        let it = {
            vertexCount: Math.pow(64, 2),
            pack: [["position", "position", "position"]]
        };
        const {texture: ot, textureSize: st} = packTexture($, it);
        this.sharedUniforms.u_logoPosTex.value = ot
    }
    _initPoints() {
        let $ = new Float32Array(PARTICLE_COUNT * 3);
        for (let st = 0; st < PARTICLE_COUNT; st++) {
            let lt = this._getCubePosDistribution(SPAWN.bounds, SPAWN.offset, st > PARTICLE_COUNT * .5 ? 2 : 0);
            $[st * 3 + 0] = lt.x,
            $[st * 3 + 1] = lt.y,
            $[st * 3 + 2] = lt.z
        }
        let tt = new Float32Array(PARTICLE_COUNT * 4);
        for (let st = 0; st < PARTICLE_COUNT * 4; st++)
            tt[st] = Math.random();
        let nt = new Float32Array(PARTICLE_COUNT * 2);
        for (let st = 0; st < PARTICLE_COUNT; st++)
            nt[st * 2 + 0] = (st % TEX_SIZE + .5) / TEX_SIZE,
            nt[st * 2 + 1] = (Math.floor(st / TEX_SIZE) + .5) / TEX_SIZE;
        let rt = new BufferGeometry;
        rt.setAttribute("position", new BufferAttribute($,3)),
        rt.setAttribute("a_random", new BufferAttribute(tt,4)),
        rt.setAttribute("a_simUv", new BufferAttribute(nt,2));
        let it = new ShaderMaterial({
            uniforms: kn(wn({}, this.sharedUniforms), {
                u_resolution: properties.sharedUniforms.u_resolution,
                u_opacity: {
                    value: .32,
                    gui: !0
                },
                u_pSizeMul: {
                    value: .4,
                    gui: !0
                },
                u_pSoftMul: {
                    value: .92,
                    gui: [0, 2, .001]
                },
                u_focusDist: {
                    value: .32,
                    gui: !0
                }
            }),
            vertexShader: particlesVert,
            fragmentShader: particlesFrag,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        it.defines = {},
        it.extensions.derivatives = !0;
        let ot = new Points(rt,it);
        ot.frustumCulled = !1,
        this.mesh = ot,
        this.container.add(ot)
    }
    _initTextures() {
        let $ = this.mesh.geometry.attributes.position.array
          , tt = new Float32Array(PARTICLE_COUNT * 4);
        for (let rt = 0; rt < PARTICLE_COUNT; rt++)
            tt[rt * 4 + 0] = $[rt * 3 + 0],
            tt[rt * 4 + 1] = $[rt * 3 + 1],
            tt[rt * 4 + 2] = $[rt * 3 + 2],
            tt[rt * 4 + 3] = rt / PARTICLE_COUNT;
        let nt = fboHelper.createDataTexture(tt, TEX_SIZE, TEX_SIZE, !0, !0);
        nt.needsUpdate = !0,
        this.sharedUniforms.u_defaultPosTex.value = nt,
        this.prevPosRt = fboHelper.createRenderTarget(TEX_SIZE, TEX_SIZE, !0, !0),
        this.currPosRt = fboHelper.createRenderTarget(TEX_SIZE, TEX_SIZE, !0, !0),
        fboHelper.copy(nt, this.currPosRt),
        this.posSimMat = new RawShaderMaterial({
            uniforms: kn(wn({}, this.sharedUniforms), {
                u_mousePaintTex: screenPaint.sharedUniforms.u_currPaintTexture,
                u_curlNoiseScale: {
                    value: new Vector3(.2,.6,.2),
                    gui: [0, 2, .001]
                },
                u_curlStrength: {
                    value: new Vector3(.2,.12,.12),
                    gui: !0
                },
                u_curlStrMul: {
                    value: .8,
                    gui: !0
                },
                u_simSpeed: {
                    value: .12,
                    gui: [0, .4, .001]
                },
                u_bounds: {
                    value: new Vector3().copy(KILL.bounds)
                },
                u_screenBounds: {
                    value: new Vector3
                }
            }),
            vertexShader: fboHelper.vertexShader,
            fragmentShader: fboHelper.precisionPrefix + particlePositionShader
        }),
        this.sharedUniforms.u_prevPosTex.value = this.prevPosRt.texture,
        this.sharedUniforms.u_currPosTex.value = this.currPosRt.texture,
        this.prevVelRt = fboHelper.createRenderTarget(TEX_SIZE, TEX_SIZE, !0, !0),
        this.currVelRt = fboHelper.createRenderTarget(TEX_SIZE, TEX_SIZE, !0, !0),
        this.velSimMat = new RawShaderMaterial({
            uniforms: kn(wn({}, this.sharedUniforms), {
                u_mousePaintTex: screenPaint.sharedUniforms.u_currPaintTexture,
                u_attractForce: {
                    value: .32
                },
                u_windForce: {
                    value: new Vector3(.16,0,0),
                    gui: [0, 2, .01]
                },
                u_windStrMul: {
                    value: 1
                },
                u_mouseStrength: {
                    value: .2,
                    gui: [0, 4, .01]
                },
                u_mouseMoveIntensity: {
                    value: 0
                },
                u_screenBounds: {
                    value: new Vector3
                }
            }),
            vertexShader: fboHelper.vertexShader,
            fragmentShader: fboHelper.precisionPrefix + particleVelocityShader
        }),
        this.sharedUniforms.u_prevVelTex.value = this.prevVelRt.texture,
        this.sharedUniforms.u_currVelTex.value = this.currVelRt.texture
    }
    init() {
        if (!GUI)
            return;
        let $ = new tweakpane.exports.Pane({});
        $.containerElem_.style.width = "300px",
        guiAddUniforms($, this.mesh.material, "particleLook");
        let tt = guiAddUniforms($, this.posSimMat, "particleSim");
        guiAddUniforms(tt, this.velSimMat)
    }
    resize($, tt) {
        this._getScreenBounds($, tt)
    }
    _getScreenBounds($, tt) {
        let nt = properties.camera;
        this._v3.set(1, -1, .5),
        this._v3.unproject(nt),
        this._v3.sub(nt.position).normalize();
        let rt = -nt.position.z / this._v3.z;
        this._v3.multiplyScalar(rt),
        this._v3.add(nt.position),
        this.posSimMat.uniforms.u_screenBounds.value.copy(this._v3),
        this.velSimMat.uniforms.u_screenBounds.value.copy(this._v3)
    }
    update($) {
        this._renderRts(),
        this._updateUniforms($)
    }
    _updateUniforms($) {
        this.sharedUniforms.u_deltaTime.value = Math.min($, 1 / 60 * 3);
        let tt = input.lerpedWheelDelta;
        tt *= .0144;
        const nt = this.velSimMat.uniforms
          , rt = this.posSimMat.uniforms;
        nt.u_windForce.value.y = tt,
        rt.u_curlStrength.value.y = .12 + Math.abs(tt) * .5;
        const it = properties.particlePresets[properties.particleMode];
        this.sharedUniforms.u_simDieSpeed.value = it.simDieSpeed,
        this.sharedUniforms.u_logoCutPercent.value = .4,
        rt.u_curlStrMul.value = it.curlStrMul,
        nt.u_windStrMul.value = it.windStrMul,
        this.sharedUniforms.u_mode.value = properties.particleModeRatio > .5 ? 1 : 0;
        let ot = properties.particleMode
          , st = properties.particleModeRatio;
        ot == 1 ? st > .68 && st < .8 && (this.sharedUniforms.u_simDieSpeed.value = 48,
        this.sharedUniforms.u_logoCutPercent.value = 0) : st > .24 && st < .36 && (this.sharedUniforms.u_simDieSpeed.value = 48,
        this.sharedUniforms.u_logoCutPercent.value = 0,
        rt.u_curlStrMul.value = 16,
        nt.u_windStrMul.value = 16),
        this._getMouseIntensity()
    }
    _renderRts($) {
        let tt;
        tt = this.prevPosRt,
        this.prevPosRt = this.currPosRt,
        this.currPosRt = tt,
        this.sharedUniforms.u_prevPosTex.value = this.prevPosRt.texture,
        this.sharedUniforms.u_currPosTex.value = this.currPosRt.texture,
        fboHelper.render(this.posSimMat, this.currPosRt),
        tt = this.prevVelRt,
        this.prevVelRt = this.currVelRt,
        this.currVelRt = tt,
        this.sharedUniforms.u_prevVelTex.value = this.prevVelRt.texture,
        this.sharedUniforms.u_currVelTex.value = this.currVelRt.texture,
        fboHelper.render(this.velSimMat, this.currVelRt)
    }
    _getMouse3d() {
        let $ = properties.camera;
        this._v3.set(input.mouseXY.x, input.mouseXY.y, .5),
        this._v3.unproject($),
        this._v3.sub($.position).normalize();
        let tt = -$.position.z / this._v3.z;
        return this._v3.multiplyScalar(tt),
        this.testMesh.position.copy($.position).add(this._v3),
        this._v3
    }
    _getMouseIntensity() {
        let $ = input.deltaXY.length() * 32;
        $ = Math.min($, 2);
        let tt = this.velSimMat.uniforms.u_mouseMoveIntensity.value;
        return this.velSimMat.uniforms.u_mouseMoveIntensity.value += ($ - tt) * .072,
        properties.tabInFocus || (this.velSimMat.uniforms.u_mouseMoveIntensity.value = 0),
        $
    }
    _getCubePosDistribution($, tt, nt=0) {
        return Object.keys($).forEach(rt=>$[rt] += nt * (Math.random() - .5)),
        {
            x: (Math.pow(Math.random(), 4) * 2 - 1) * $.x + tt.x,
            y: (Math.random() * 2 - 1) * $.y + tt.y,
            z: (Math.random() * 2 - 1) * $.z + tt.z
        }
    }
}
var particles = new Particles;
class ThemeController {
    preInit() {}
    init() {}
    resize() {}
    update($) {
        let tt = properties.themeId
          , nt = 0
          , rt = "#fff";
        tt === 2 && (nt = 1,
        rt = "#000"),
        properties.postInvert += (nt - properties.postInvert) * .07,
        properties.vignetteColorHex = rt
    }
}
var themeController = new ThemeController;
class Visuals {
    constructor() {
        Et(this, "container", new Object3D);
        Et(this, "components", [particles, themeController])
    }
    preInit() {
        this.components.forEach($=>$.preInit()),
        this.components.forEach($=>{
            $.container && this.container.add($.container)
        }
        )
    }
    init() {
        this.components.forEach($=>$.init())
    }
    resize($, tt) {
        this.components.forEach(nt=>nt.resize($, tt))
    }
    update($) {
        this.components.forEach(tt=>tt.update($))
    }
}
var visuals = new Visuals;
const oo = class {
    constructor() {
        Et(this, "_scale", 1);
        Et(this, "_amplitude", 1);
        Et(this, "_r", []);
        for (let $ = 0; $ < oo.MAX_VERTICES; ++$)
            this._r.push(Math.random() - .5)
    }
    getVal($) {
        const tt = $ * this._scale
          , nt = Math.floor(tt)
          , rt = tt - nt
          , it = rt * rt * (3 - 2 * rt)
          , ot = nt & oo.MAX_VERTICES_MASK
          , st = ot + 1 & oo.MAX_VERTICES_MASK;
        return math.mix(this._r[ot], this._r[st], it) * this._amplitude
    }
    get amplitude() {
        return this._amplitude
    }
    set amplitude($) {
        this._amplitude = $
    }
    get scale() {
        return this._scale
    }
    set scale($) {
        this._scale = $
    }
}
;
let Simple1DNoise = oo;
Et(Simple1DNoise, "MAX_VERTICES", 256),
Et(Simple1DNoise, "MAX_VERTICES_MASK", oo.MAX_VERTICES - 1);
const _e = new Euler
  , _v = new Vector3
  , Io = class {
    constructor() {
        Et(this, "_position", new Vector3);
        Et(this, "_rotation", new Quaternion);
        Et(this, "_scale", new Vector3(1,1,1));
        Et(this, "_matrix", new Matrix4);
        Et(this, "_enablePositionNoise", !0);
        Et(this, "_enableRotationNoise", !0);
        Et(this, "_positionFrequency", .25);
        Et(this, "_rotationFrequency", .25);
        Et(this, "_positionAmplitude", .3);
        Et(this, "_rotationAmplitude", .003);
        Et(this, "_positionScale", new Vector3(1,1,1));
        Et(this, "_rotationScale", new Vector3(1,1,0));
        Et(this, "_positionFractalLevel", 3);
        Et(this, "_rotationFractalLevel", 3);
        Et(this, "_times", new Float32Array(6));
        Et(this, "_noise", new Simple1DNoise);
        this.rehash()
    }
    rehash() {
        for (let $ = 0; $ < 6; $++)
            this._times[$] = Math.random() * -1e4
    }
    _fbm($, tt) {
        let nt = 0
          , rt = .5;
        for (let it = 0; it < tt; it++)
            nt += rt * this._noise.getVal($),
            $ *= 2,
            rt *= .5;
        return nt
    }
    update($) {
        const tt = $ === void 0 ? 16.666666666666668 : $;
        if (this._enablePositionNoise) {
            for (let nt = 0; nt < 3; nt++)
                this._times[nt] += this._positionFrequency * tt;
            _v.set(this._fbm(this._times[0], this._positionFractalLevel), this._fbm(this._times[1], this._positionFractalLevel), this._fbm(this._times[2], this._positionFractalLevel)),
            _v.multiply(this._positionScale),
            _v.multiplyScalar(this._positionAmplitude * Io.FBM_NORM),
            this._position.copy(_v)
        }
        if (this._enableRotationNoise) {
            for (let nt = 0; nt < 3; nt++)
                this._times[nt + 3] += this._rotationFrequency * tt;
            _v.set(this._fbm(this._times[3], this._rotationFractalLevel), this._fbm(this._times[4], this._rotationFractalLevel), this._fbm(this._times[5], this._rotationFractalLevel)),
            _v.multiply(this._rotationScale),
            _v.multiplyScalar(this._rotationAmplitude * Io.FBM_NORM),
            _e.set(_v.x, _v.y, _v.z),
            this._rotation.setFromEuler(_e)
        }
        this._matrix.compose(this._position, this._rotation, this._scale)
    }
    get positionAmplitude() {
        return this._positionAmplitude
    }
    set positionAmplitude($) {
        this._positionAmplitude = $
    }
    get positionFrequency() {
        return this._positionFrequency
    }
    set positionFrequency($) {
        this._positionFrequency = $
    }
    get rotationAmplitude() {
        return this._rotationAmplitude
    }
    set rotationAmplitude($) {
        this._rotationAmplitude = $
    }
    get rotationFrequency() {
        return this._rotationFrequency
    }
    set rotationFrequency($) {
        this._rotationFrequency = $
    }
    get matrix() {
        return this._matrix
    }
    set matrix($) {
        this._matrix = $
    }
}
;
let BrownianMotion = Io;
Et(BrownianMotion, "FBM_NORM", 1 / .75);
const _changeEvent = {
    type: "change"
}
  , _startEvent = {
    type: "start"
}
  , _endEvent = {
    type: "end"
};
class OrbitControls extends EventDispatcher {
    constructor($, tt) {
        super(),
        tt === void 0 && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
        tt === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
        this.object = $,
        this.domElement = tt,
        this.domElement.style.touchAction = "none",
        this.enabled = !0,
        this.target = new Vector3,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .05,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: MOUSE.ROTATE,
            MIDDLE: MOUSE.DOLLY,
            RIGHT: MOUSE.PAN
        },
        this.touches = {
            ONE: TOUCH.ROTATE,
            TWO: TOUCH.DOLLY_PAN
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this._domElementKeyEvents = null,
        this.getPolarAngle = function() {
            return st.phi
        }
        ,
        this.getAzimuthalAngle = function() {
            return st.theta
        }
        ,
        this.getDistance = function() {
            return this.object.position.distanceTo(this.target)
        }
        ,
        this.listenToKeyEvents = function(Vt) {
            Vt.addEventListener("keydown", Dt),
            this._domElementKeyEvents = Vt
        }
        ,
        this.saveState = function() {
            nt.target0.copy(nt.target),
            nt.position0.copy(nt.object.position),
            nt.zoom0 = nt.object.zoom
        }
        ,
        this.reset = function() {
            nt.target.copy(nt.target0),
            nt.object.position.copy(nt.position0),
            nt.object.zoom = nt.zoom0,
            nt.object.updateProjectionMatrix(),
            nt.dispatchEvent(_changeEvent),
            nt.update(),
            it = rt.NONE
        }
        ,
        this.update = function() {
            const Vt = new Vector3
              , hn = new Quaternion().setFromUnitVectors($.up, new Vector3(0,1,0))
              , vn = hn.clone().invert()
              , En = new Vector3
              , Ut = new Quaternion
              , Cn = 2 * Math.PI;
            return function() {
                const Hn = nt.object.position;
                Vt.copy(Hn).sub(nt.target),
                Vt.applyQuaternion(hn),
                st.setFromVector3(Vt),
                nt.autoRotate && it === rt.NONE && Zt(Pt()),
                nt.enableDamping ? (st.theta += lt.theta * nt.dampingFactor,
                st.phi += lt.phi * nt.dampingFactor) : (st.theta += lt.theta,
                st.phi += lt.phi);
                let yn = nt.minAzimuthAngle
                  , xn = nt.maxAzimuthAngle;
                return isFinite(yn) && isFinite(xn) && (yn < -Math.PI ? yn += Cn : yn > Math.PI && (yn -= Cn),
                xn < -Math.PI ? xn += Cn : xn > Math.PI && (xn -= Cn),
                yn <= xn ? st.theta = Math.max(yn, Math.min(xn, st.theta)) : st.theta = st.theta > (yn + xn) / 2 ? Math.max(yn, st.theta) : Math.min(xn, st.theta)),
                st.phi = Math.max(nt.minPolarAngle, Math.min(nt.maxPolarAngle, st.phi)),
                st.makeSafe(),
                st.radius *= ut,
                st.radius = Math.max(nt.minDistance, Math.min(nt.maxDistance, st.radius)),
                nt.enableDamping === !0 ? nt.target.addScaledVector(ct, nt.dampingFactor) : nt.target.add(ct),
                Vt.setFromSpherical(st),
                Vt.applyQuaternion(vn),
                Hn.copy(nt.target).add(Vt),
                nt.object.lookAt(nt.target),
                nt.enableDamping === !0 ? (lt.theta *= 1 - nt.dampingFactor,
                lt.phi *= 1 - nt.dampingFactor,
                ct.multiplyScalar(1 - nt.dampingFactor)) : (lt.set(0, 0, 0),
                ct.set(0, 0, 0)),
                ut = 1,
                ht || En.distanceToSquared(nt.object.position) > ot || 8 * (1 - Ut.dot(nt.object.quaternion)) > ot ? (nt.dispatchEvent(_changeEvent),
                En.copy(nt.object.position),
                Ut.copy(nt.object.quaternion),
                ht = !1,
                !0) : !1
            }
        }(),
        this.dispose = function() {
            nt.domElement.removeEventListener("contextmenu", mn),
            nt.domElement.removeEventListener("pointerdown", Mn),
            nt.domElement.removeEventListener("pointercancel", $n),
            nt.domElement.removeEventListener("wheel", rr),
            nt.domElement.removeEventListener("pointermove", Dn),
            nt.domElement.removeEventListener("pointerup", Pn),
            nt._domElementKeyEvents !== null && nt._domElementKeyEvents.removeEventListener("keydown", Dt)
        }
        ;
        const nt = this
          , rt = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let it = rt.NONE;
        const ot = 1e-6
          , st = new Spherical
          , lt = new Spherical;
        let ut = 1;
        const ct = new Vector3;
        let ht = !1;
        const ft = new Vector2
          , gt = new Vector2
          , vt = new Vector2
          , yt = new Vector2
          , wt = new Vector2
          , mt = new Vector2
          , _t = new Vector2
          , bt = new Vector2
          , Mt = new Vector2
          , St = []
          , At = {};
        function Pt() {
            return 2 * Math.PI / 60 / 60 * nt.autoRotateSpeed
        }
        function Ot() {
            return Math.pow(.95, nt.zoomSpeed)
        }
        function Zt(Vt) {
            lt.theta -= Vt
        }
        function Nt(Vt) {
            lt.phi -= Vt
        }
        const Tt = function() {
            const Vt = new Vector3;
            return function(vn, En) {
                Vt.setFromMatrixColumn(En, 0),
                Vt.multiplyScalar(-vn),
                ct.add(Vt)
            }
        }()
          , Ft = function() {
            const Vt = new Vector3;
            return function(vn, En) {
                nt.screenSpacePanning === !0 ? Vt.setFromMatrixColumn(En, 1) : (Vt.setFromMatrixColumn(En, 0),
                Vt.crossVectors(nt.object.up, Vt)),
                Vt.multiplyScalar(vn),
                ct.add(Vt)
            }
        }()
          , $t = function() {
            const Vt = new Vector3;
            return function(vn, En) {
                const Ut = nt.domElement;
                if (nt.object.isPerspectiveCamera) {
                    const Cn = nt.object.position;
                    Vt.copy(Cn).sub(nt.target);
                    let Tn = Vt.length();
                    Tn *= Math.tan(nt.object.fov / 2 * Math.PI / 180),
                    Tt(2 * vn * Tn / Ut.clientHeight, nt.object.matrix),
                    Ft(2 * En * Tn / Ut.clientHeight, nt.object.matrix)
                } else
                    nt.object.isOrthographicCamera ? (Tt(vn * (nt.object.right - nt.object.left) / nt.object.zoom / Ut.clientWidth, nt.object.matrix),
                    Ft(En * (nt.object.top - nt.object.bottom) / nt.object.zoom / Ut.clientHeight, nt.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    nt.enablePan = !1)
            }
        }();
        function Wt(Vt) {
            nt.object.isPerspectiveCamera ? ut /= Vt : nt.object.isOrthographicCamera ? (nt.object.zoom = Math.max(nt.minZoom, Math.min(nt.maxZoom, nt.object.zoom * Vt)),
            nt.object.updateProjectionMatrix(),
            ht = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            nt.enableZoom = !1)
        }
        function Kt(Vt) {
            nt.object.isPerspectiveCamera ? ut *= Vt : nt.object.isOrthographicCamera ? (nt.object.zoom = Math.max(nt.minZoom, Math.min(nt.maxZoom, nt.object.zoom / Vt)),
            nt.object.updateProjectionMatrix(),
            ht = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            nt.enableZoom = !1)
        }
        function qt(Vt) {
            ft.set(Vt.clientX, Vt.clientY)
        }
        function jt(Vt) {
            _t.set(Vt.clientX, Vt.clientY)
        }
        function Bt(Vt) {
            yt.set(Vt.clientX, Vt.clientY)
        }
        function Xt(Vt) {
            gt.set(Vt.clientX, Vt.clientY),
            vt.subVectors(gt, ft).multiplyScalar(nt.rotateSpeed);
            const hn = nt.domElement;
            Zt(2 * Math.PI * vt.x / hn.clientHeight),
            Nt(2 * Math.PI * vt.y / hn.clientHeight),
            ft.copy(gt),
            nt.update()
        }
        function Jt(Vt) {
            bt.set(Vt.clientX, Vt.clientY),
            Mt.subVectors(bt, _t),
            Mt.y > 0 ? Wt(Ot()) : Mt.y < 0 && Kt(Ot()),
            _t.copy(bt),
            nt.update()
        }
        function Lt(Vt) {
            wt.set(Vt.clientX, Vt.clientY),
            mt.subVectors(wt, yt).multiplyScalar(nt.panSpeed),
            $t(mt.x, mt.y),
            yt.copy(wt),
            nt.update()
        }
        function Rt(Vt) {
            Vt.deltaY < 0 ? Kt(Ot()) : Vt.deltaY > 0 && Wt(Ot()),
            nt.update()
        }
        function _n(Vt) {
            let hn = !1;
            switch (Vt.code) {
            case nt.keys.UP:
                $t(0, nt.keyPanSpeed),
                hn = !0;
                break;
            case nt.keys.BOTTOM:
                $t(0, -nt.keyPanSpeed),
                hn = !0;
                break;
            case nt.keys.LEFT:
                $t(nt.keyPanSpeed, 0),
                hn = !0;
                break;
            case nt.keys.RIGHT:
                $t(-nt.keyPanSpeed, 0),
                hn = !0;
                break
            }
            hn && (Vt.preventDefault(),
            nt.update())
        }
        function Fn() {
            if (St.length === 1)
                ft.set(St[0].pageX, St[0].pageY);
            else {
                const Vt = .5 * (St[0].pageX + St[1].pageX)
                  , hn = .5 * (St[0].pageY + St[1].pageY);
                ft.set(Vt, hn)
            }
        }
        function Vn() {
            if (St.length === 1)
                yt.set(St[0].pageX, St[0].pageY);
            else {
                const Vt = .5 * (St[0].pageX + St[1].pageX)
                  , hn = .5 * (St[0].pageY + St[1].pageY);
                yt.set(Vt, hn)
            }
        }
        function sn() {
            const Vt = St[0].pageX - St[1].pageX
              , hn = St[0].pageY - St[1].pageY
              , vn = Math.sqrt(Vt * Vt + hn * hn);
            _t.set(0, vn)
        }
        function Un() {
            nt.enableZoom && sn(),
            nt.enablePan && Vn()
        }
        function zn() {
            nt.enableZoom && sn(),
            nt.enableRotate && Fn()
        }
        function Rn(Vt) {
            if (St.length == 1)
                gt.set(Vt.pageX, Vt.pageY);
            else {
                const vn = Ht(Vt)
                  , En = .5 * (Vt.pageX + vn.x)
                  , Ut = .5 * (Vt.pageY + vn.y);
                gt.set(En, Ut)
            }
            vt.subVectors(gt, ft).multiplyScalar(nt.rotateSpeed);
            const hn = nt.domElement;
            Zt(2 * Math.PI * vt.x / hn.clientHeight),
            Nt(2 * Math.PI * vt.y / hn.clientHeight),
            ft.copy(gt)
        }
        function Ln(Vt) {
            if (St.length === 1)
                wt.set(Vt.pageX, Vt.pageY);
            else {
                const hn = Ht(Vt)
                  , vn = .5 * (Vt.pageX + hn.x)
                  , En = .5 * (Vt.pageY + hn.y);
                wt.set(vn, En)
            }
            mt.subVectors(wt, yt).multiplyScalar(nt.panSpeed),
            $t(mt.x, mt.y),
            yt.copy(wt)
        }
        function Gn(Vt) {
            const hn = Ht(Vt)
              , vn = Vt.pageX - hn.x
              , En = Vt.pageY - hn.y
              , Ut = Math.sqrt(vn * vn + En * En);
            bt.set(0, Ut),
            Mt.set(0, Math.pow(bt.y / _t.y, nt.zoomSpeed)),
            Wt(Mt.y),
            _t.copy(bt)
        }
        function cn(Vt) {
            nt.enableZoom && Gn(Vt),
            nt.enablePan && Ln(Vt)
        }
        function bn(Vt) {
            nt.enableZoom && Gn(Vt),
            nt.enableRotate && Rn(Vt)
        }
        function Mn(Vt) {
            nt.enabled !== !1 && (St.length === 0 && (nt.domElement.setPointerCapture(Vt.pointerId),
            nt.domElement.addEventListener("pointermove", Dn),
            nt.domElement.addEventListener("pointerup", Pn)),
            An(Vt),
            Vt.pointerType === "touch" ? kt(Vt) : On(Vt))
        }
        function Dn(Vt) {
            nt.enabled !== !1 && (Vt.pointerType === "touch" ? pn(Vt) : Wn(Vt))
        }
        function Pn(Vt) {
            In(Vt),
            St.length === 0 && (nt.domElement.releasePointerCapture(Vt.pointerId),
            nt.domElement.removeEventListener("pointermove", Dn),
            nt.domElement.removeEventListener("pointerup", Pn)),
            nt.dispatchEvent(_endEvent),
            it = rt.NONE
        }
        function $n(Vt) {
            In(Vt)
        }
        function On(Vt) {
            let hn;
            switch (Vt.button) {
            case 0:
                hn = nt.mouseButtons.LEFT;
                break;
            case 1:
                hn = nt.mouseButtons.MIDDLE;
                break;
            case 2:
                hn = nt.mouseButtons.RIGHT;
                break;
            default:
                hn = -1
            }
            switch (hn) {
            case MOUSE.DOLLY:
                if (nt.enableZoom === !1)
                    return;
                jt(Vt),
                it = rt.DOLLY;
                break;
            case MOUSE.ROTATE:
                if (Vt.ctrlKey || Vt.metaKey || Vt.shiftKey) {
                    if (nt.enablePan === !1)
                        return;
                    Bt(Vt),
                    it = rt.PAN
                } else {
                    if (nt.enableRotate === !1)
                        return;
                    qt(Vt),
                    it = rt.ROTATE
                }
                break;
            case MOUSE.PAN:
                if (Vt.ctrlKey || Vt.metaKey || Vt.shiftKey) {
                    if (nt.enableRotate === !1)
                        return;
                    qt(Vt),
                    it = rt.ROTATE
                } else {
                    if (nt.enablePan === !1)
                        return;
                    Bt(Vt),
                    it = rt.PAN
                }
                break;
            default:
                it = rt.NONE
            }
            it !== rt.NONE && nt.dispatchEvent(_startEvent)
        }
        function Wn(Vt) {
            if (nt.enabled !== !1)
                switch (it) {
                case rt.ROTATE:
                    if (nt.enableRotate === !1)
                        return;
                    Xt(Vt);
                    break;
                case rt.DOLLY:
                    if (nt.enableZoom === !1)
                        return;
                    Jt(Vt);
                    break;
                case rt.PAN:
                    if (nt.enablePan === !1)
                        return;
                    Lt(Vt);
                    break
                }
        }
        function rr(Vt) {
            nt.enabled === !1 || nt.enableZoom === !1 || it !== rt.NONE || (nt.dispatchEvent(_startEvent),
            Rt(Vt),
            nt.dispatchEvent(_endEvent))
        }
        function Dt(Vt) {
            nt.enabled === !1 || nt.enablePan === !1 || _n(Vt)
        }
        function kt(Vt) {
            switch (Gt(Vt),
            St.length) {
            case 1:
                switch (nt.touches.ONE) {
                case TOUCH.ROTATE:
                    if (nt.enableRotate === !1)
                        return;
                    Fn(),
                    it = rt.TOUCH_ROTATE;
                    break;
                case TOUCH.PAN:
                    if (nt.enablePan === !1)
                        return;
                    Vn(),
                    it = rt.TOUCH_PAN;
                    break;
                default:
                    it = rt.NONE
                }
                break;
            case 2:
                switch (nt.touches.TWO) {
                case TOUCH.DOLLY_PAN:
                    if (nt.enableZoom === !1 && nt.enablePan === !1)
                        return;
                    Un(),
                    it = rt.TOUCH_DOLLY_PAN;
                    break;
                case TOUCH.DOLLY_ROTATE:
                    if (nt.enableZoom === !1 && nt.enableRotate === !1)
                        return;
                    zn(),
                    it = rt.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    it = rt.NONE
                }
                break;
            default:
                it = rt.NONE
            }
            it !== rt.NONE && nt.dispatchEvent(_startEvent)
        }
        function pn(Vt) {
            switch (Gt(Vt),
            it) {
            case rt.TOUCH_ROTATE:
                if (nt.enableRotate === !1)
                    return;
                Rn(Vt),
                nt.update();
                break;
            case rt.TOUCH_PAN:
                if (nt.enablePan === !1)
                    return;
                Ln(Vt),
                nt.update();
                break;
            case rt.TOUCH_DOLLY_PAN:
                if (nt.enableZoom === !1 && nt.enablePan === !1)
                    return;
                cn(Vt),
                nt.update();
                break;
            case rt.TOUCH_DOLLY_ROTATE:
                if (nt.enableZoom === !1 && nt.enableRotate === !1)
                    return;
                bn(Vt),
                nt.update();
                break;
            default:
                it = rt.NONE
            }
        }
        function mn(Vt) {
            nt.enabled
        }
        function An(Vt) {
            St.push(Vt)
        }
        function In(Vt) {
            delete At[Vt.pointerId];
            for (let hn = 0; hn < St.length; hn++)
                if (St[hn].pointerId == Vt.pointerId) {
                    St.splice(hn, 1);
                    return
                }
        }
        function Gt(Vt) {
            let hn = At[Vt.pointerId];
            hn === void 0 && (hn = new Vector2,
            At[Vt.pointerId] = hn),
            hn.set(Vt.pageX, Vt.pageY)
        }
        function Ht(Vt) {
            const hn = Vt.pointerId === St[0].pointerId ? St[1] : St[0];
            return At[hn.pointerId]
        }
        nt.domElement.addEventListener("contextmenu", mn),
        nt.domElement.addEventListener("pointerdown", Mn),
        nt.domElement.addEventListener("pointercancel", $n),
        nt.domElement.addEventListener("wheel", rr, {
            passive: !1
        }),
        this.update()
    }
}
class DeviceOrientationControls {
    constructor($) {
        Et(this, "object", null);
        Et(this, "enabled", !0);
        Et(this, "hasValue", !1);
        Et(this, "deviceOrientation", {});
        Et(this, "screenOrientation", 0);
        Et(this, "alphaOffset", 0);
        Et(this, "zee", new Vector3(0,0,1));
        Et(this, "euler", new Euler);
        Et(this, "q0", new Quaternion);
        Et(this, "q1", new Quaternion(-Math.sqrt(.5),0,0,Math.sqrt(.5)));
        Et(this, "_onBoundDeviceOrientationChangeEvent");
        Et(this, "_onBoundScreenOrientationChangeEvent");
        this.object = $,
        this.object.rotation.reorder("YXZ"),
        this._onBoundDeviceOrientationChangeEvent = this._onDeviceOrientationChangeEvent.bind(this),
        this._onBoundScreenOrientationChangeEvent = this._onScreenOrientationChangeEvent.bind(this),
        this.connect()
    }
    _onDeviceOrientationChangeEvent($) {
        this.deviceOrientation = $
    }
    _onScreenOrientationChangeEvent() {
        this.screenOrientation = window.orientation || 0
    }
    setObjectQuaternion($, tt, nt, rt, it) {
        this.euler.set(nt, tt, -rt, "YXZ"),
        $.setFromEuler(this.euler),
        $.multiply(this.q1),
        $.multiply(this.q0.setFromAxisAngle(this.zee, -it))
    }
    connect() {
        this._onBoundScreenOrientationChangeEvent(),
        window.DeviceOrientationEvent !== void 0 && typeof window.DeviceOrientationEvent.requestPermission == "function" ? window.DeviceOrientationEvent.requestPermission().then(function($) {
            $ == "granted" && (window.addEventListener("orientationchange", this._onBoundScreenOrientationChangeEvent, !1),
            window.addEventListener("deviceorientation", this._onBoundDeviceOrientationChangeEvent, !1))
        }).catch(function($) {}) : (window.addEventListener("orientationchange", this._onBoundScreenOrientationChangeEvent, !1),
        window.addEventListener("deviceorientation", this._onBoundDeviceOrientationChangeEvent, !1)),
        this.enabled = !0
    }
    disconnect() {
        window.removeEventListener("orientationchange", this._onBoundScreenOrientationChangeEvent, !1),
        window.removeEventListener("deviceorientation", this._onBoundDeviceOrientationChangeEvent, !1),
        this.enabled = !1
    }
    update() {
        if (this.enabled === !1)
            return;
        let $ = this.deviceOrientation;
        if ($) {
            let tt = $.alpha ? MathUtils$1.degToRad($.alpha) + this.alphaOffset : 0
              , nt = $.beta ? MathUtils$1.degToRad($.beta) : 0
              , rt = $.gamma ? MathUtils$1.degToRad($.gamma) : 0
              , it = this.screenOrientation ? MathUtils$1.degToRad(this.screenOrientation) : 0;
            this.setObjectQuaternion(this.object.quaternion, tt, nt, rt, it),
            this.hasValue = $.alpha && $.beta && $.gamma
        }
    }
    dispose() {
        this.disconnect()
    }
}
class CameraControls {
    constructor() {
        Et(this, "useOrbitControls", settings.LOOK_DEV_MODE)
    }
    preInit($) {
        this.DEFAULT_CAMERA_POSITION = properties.cameraDefaultPosition,
        this.DEFAULT_LOOKAT_POSITION = new Vector3(0,0,0),
        this._brownianMotion = null,
        this._orbitControls = null,
        this._orbitCamera = null,
        this._camera = null,
        this._deviceOrientationControls = null,
        this._baseDeviceControlQuaternion = null,
        this._targetDeviceControlQuaternion = null,
        this._deviceOrientationCamera = null,
        this._hasDeviceOrientationControlValues = !1,
        this._q = new Quaternion,
        this._e = new Euler,
        this._v1 = new Vector3,
        this._v2 = new Vector3,
        this._camera = properties.camera,
        this._camera.position.copy(this.DEFAULT_CAMERA_POSITION),
        this._brownianMotion = new BrownianMotion,
        this.useOrbitControls === !0 && (this._orbitCamera = this._camera.clone(),
        this._orbitControls = new OrbitControls(this._orbitCamera,properties.canvas),
        this._orbitControls.target0.copy(this.DEFAULT_LOOKAT_POSITION),
        this._orbitControls.reset()),
        browser$1.isMobile && (this._deviceOrientationCamera = new Camera,
        this._baseDeviceControlQuaternion = new Quaternion,
        this._targetDeviceControlQuaternion = new Quaternion,
        this._deviceOrientationControls = new DeviceOrientationControls(this._deviceOrientationCamera),
        properties.onFirstClicked.addOnce(()=>{
            this._deviceOrientationControls.connect()
        }
        ))
    }
    init() {}
    resize($, tt) {}
    update($) {
        this._camera.matrix.identity(),
        this._camera.matrix.decompose(this._camera.position, this._camera.quaternion, this._camera.scale),
        this._camera.position.copy(this.DEFAULT_CAMERA_POSITION),
        this._camera.lookAt(this.DEFAULT_LOOKAT_POSITION),
        browser$1.isMobile && this._deviceOrientationControls.update(),
        this.useOrbitControls === !0 && (this._orbitControls.update(),
        this._orbitCamera.updateMatrix(),
        this._orbitCamera.matrix.decompose(this._camera.position, this._camera.quaternion, this._camera.scale)),
        this._v1.set(0, 0, -1).applyQuaternion(this._camera.quaternion),
        this.useOrbitControls === !0 ? this.cameraDistance = this._v2.copy(this._orbitControls.target).sub(this._camera.position).dot(this._v1) : this.cameraDistance = this._v2.copy(this.DEFAULT_LOOKAT_POSITION).sub(this._camera.position).dot(this._v1),
        browser$1.isMobile ? (this._deviceOrientationControls.update(),
        this._deviceOrientationControls.hasValue && (this._hasDeviceOrientationControlValues || (this._targetDeviceControlQuaternion.copy(this._deviceOrientationCamera.quaternion),
        this._baseDeviceControlQuaternion.copy(this._deviceOrientationCamera.quaternion)),
        this._targetDeviceControlQuaternion.slerp(this._deviceOrientationCamera.quaternion, .08),
        this._baseDeviceControlQuaternion.slerp(this._targetDeviceControlQuaternion, .08),
        this._q.copy(this._baseDeviceControlQuaternion).invert().multiply(this._targetDeviceControlQuaternion),
        this._hasDeviceOrientationControlValues = !0,
        this._camera.quaternion.multiply(this._q))) : (this._camera.translateZ(this.cameraDistance * -1),
        properties.cameraLookX += (input.mouseXY.y * properties.cameraLookStrength - properties.cameraLookX) * properties.cameraLookEaseDamp,
        properties.cameraLookY += (-input.mouseXY.x * properties.cameraLookStrength - properties.cameraLookY) * properties.cameraLookEaseDamp,
        this._e.set(properties.cameraLookX, properties.cameraLookY, 0),
        this._q.setFromEuler(this._e),
        this._camera.quaternion.multiply(this._q),
        this._camera.translateZ(this.cameraDistance)),
        this._camera.matrix.compose(this._camera.position, this._camera.quaternion, this._camera.scale),
        this._v1.set(0, 0, -1).applyQuaternion(this._camera.quaternion),
        this.useOrbitControls === !0 && (properties.cameraDistance = this._v2.copy(this._orbitControls.target).sub(this._camera.position).dot(this._v1))
    }
}
var cameraControls = new CameraControls;
class WebglApp {
    constructor() {
        Et(this, "settings", settings);
        Et(this, "properties", properties)
    }
    setCanvas($) {
        return properties.canvas = $,
        properties._isSupported = support.isSupported(),
        properties._isSupported
    }
    preInit($) {
        for (const [tt,nt] of Object.entries(settings.CROSS_ORIGINS))
            properties.loader.setCrossOrigin(tt, nt);
        properties.loader.register(BufItem),
        properties.loader.register(TextureItem),
        properties.loader.register(ThreeLoaderItem),
        settings.LOOK_DEV_MODE && gui.preInit(),
        this.preInitStage(),
        properties.isStageReady === !0 && (input.preInit(),
        visuals.preInit(),
        cameraControls.preInit(),
        properties.loader.start(tt=>{
            properties.percent = tt,
            $ && $(tt)
        }
        )),
        properties.themeSignal.add(tt=>{
            properties.themeId = tt
        }
        )
    }
    preInitStage() {
        properties.width = window.innerWidth,
        properties.height = window.innerHeight,
        properties.renderer = new WebGLRenderer({
            canvas: properties.canvas,
            context: properties.gl
        }),
        properties.scene = new Scene,
        properties.camera = new PerspectiveCamera(60,1,.1,10),
        properties.scene.add(properties.camera),
        properties.sharedUniforms.u_resolution.value = properties.resolution = new Vector2,
        properties.sharedUniforms.u_bgColor.value = properties.bgColor = new Color,
        fboHelper.init(properties.renderer, settings.RENDER_TARGET_FLOAT_TYPE),
        textureHelper.init(),
        properties.postprocessing = new Postprocessing,
        properties.postprocessing.init({
            scene: properties.scene,
            camera: properties.camera
        }),
        blueNoise.preInit(),
        glPositionOffset.init(),
        screenPaint.init(),
        properties.screenPaint = screenPaint,
        properties.smaa = new Smaa,
        properties.smaa.init(),
        properties.smaa.setTextures(properties.loader.add(settings.TEXTURE_PATH + "smaa-area.png", {
            weight: 32
        }).content, properties.loader.add(settings.TEXTURE_PATH + "smaa-search.png", {
            weight: .1
        }).content),
        properties.postprocessing.queue.push(properties.smaa),
        properties.bloom = new Bloom,
        properties.bloom.init(),
        properties.final = new Final,
        properties.final.init(),
        properties.postprocessing.queue.push(properties.final),
        properties.screenPaintDistortion = new ScreenPaintDistortion,
        properties.screenPaintDistortion.init({
            screenPaint
        }),
        properties.postprocessing.queue.push(properties.screenPaintDistortion),
        properties.isStageReady = !0
    }
    init() {
        properties.smaa && properties.smaa.updateTextures(),
        settings.LOOK_DEV_MODE && gui.init(),
        input.init(),
        visuals.init(),
        cameraControls.init(),
        properties.scene.add(visuals.container),
        this.resize(properties.rawWidth, properties.rawHeight),
        properties.hasInitialized = !0,
        settings.IS_DEV === !1 && settings.IS_API_MODE !== !0 && console.log("%c Created by Lusion: https://lusion.co", "border:2px solid gray; padding:5px; font-family:monospace; font-size:11px;")
    }
    resize($, tt) {
        let nt = settings.UP_SCALE
          , rt = $
          , it = tt
          , ot = $ * settings.DPR
          , st = tt * settings.DPR;
        if (settings.USE_PIXEL_LIMIT === !0 && ot * st > settings.MAX_PIXEL_COUNT) {
            let lt = ot / st;
            st = Math.sqrt(settings.MAX_PIXEL_COUNT / lt),
            ot = Math.ceil(st * lt),
            st = Math.ceil(st)
        }
        properties.rawWidth = rt,
        properties.rawHeight = it,
        properties.width = Math.ceil(ot / nt),
        properties.height = Math.ceil(st / nt),
        properties.resolution.set(properties.width, properties.height),
        properties.renderer.setSize(properties.width, properties.height),
        properties.canvas.width = properties.width,
        properties.canvas.height = properties.height,
        properties.canvas.style.width = `${properties.rawWidth}px`,
        properties.canvas.style.height = `${properties.rawHeight}px`,
        properties.camera.aspect = properties.width / properties.height,
        properties.camera.updateProjectionMatrix(),
        properties.postprocessing.setSize(properties.width, properties.height),
        screenPaint.resize(properties.width, properties.height),
        visuals.resize(properties.width, properties.height)
    }
    render($=0) {
        properties.time = properties.sharedUniforms.u_time.value += $,
        properties.deltaTime = properties.sharedUniforms.u_deltaTime.value = $,
        cameraControls.update($),
        blueNoise.update($),
        input.update($),
        visuals.update($),
        screenPaint.update($),
        properties.renderer.setClearColor(properties.bgColor, 1),
        properties.bgColor.setStyle(properties.bgColorHex),
        properties.bloom.amount = properties.bloomAmount,
        properties.bloom.radius = properties.bloomRadius,
        properties.bloom.threshold = properties.bloomThreshold,
        properties.bloom.smoothWidth = properties.bloomSmoothWidth,
        properties.bloom.haloWidth = properties.haloWidth,
        properties.bloom.haloRGBShift = properties.haloRGBShift,
        properties.bloom.haloStrength = properties.haloStrength,
        properties.bloom.haloMaskInner = properties.haloMaskInner,
        properties.bloom.haloMaskOuter = properties.haloMaskOuter,
        properties.final.vignetteFrom = properties.vignetteFrom,
        properties.final.vignetteTo = properties.vignetteTo,
        properties.final.vignetteColor.setStyle(properties.vignetteColorHex),
        properties.final.saturation = properties.saturation,
        properties.final.contrast = properties.contrast,
        properties.final.brightness = properties.brightness,
        properties.final.tintColor.setStyle(properties.tintColorHex),
        properties.final.tintOpacity = properties.tintOpacity,
        properties.final.bgColor.setStyle(properties.bgColorHex),
        properties.final.opacity = properties.opacity,
        properties.final.postInvert = properties.postInvert,
        screenPaint.needsMouseDown = properties.screenPaintNeedsMouseDown,
        screenPaint.minRadius = properties.screenPaintMinRadius,
        screenPaint.maxRadius = properties.screenPaintMaxRadius,
        screenPaint.radiusDistanceRange = properties.screenPaintRadiusDistanceRange,
        screenPaint.paintStrength = properties.screenPaintPaintStrength,
        screenPaint.pushStrength = properties.screenPaintPushStrength,
        screenPaint.velocityDissipation = properties.screenPaintVelocityDissipation,
        screenPaint.weight1Dissipation = properties.screenPaintWeight1Dissipation,
        screenPaint.weight2Dissipation = properties.screenPaintWeight2Dissipation,
        screenPaint.useNoise = properties.screenPaintUseNoise,
        screenPaint.curlScale = properties.screenPaintCurlScale,
        screenPaint.curlStrength = properties.screenPaintCurlStrength,
        properties.screenPaintDistortion.amount = properties.screenPaintDistortionAmount,
        properties.screenPaintDistortion.rgbShift = properties.screenPaintDistortionRGBShift,
        properties.screenPaintDistortion.colorMultiplier = properties.screenPaintDistortionColorMultiplier,
        properties.screenPaintDistortion.multiplier = properties.screenPaintDistortionMultiplier,
        properties.particleModeRatio += (properties.particleMode - properties.particleModeRatio) * .02,
        properties.postprocessing.render(properties.scene, properties.camera, !0),
        window.__debugTexture && fboHelper.debugTo(window.__debugTexture, 300, 300),
        input.postUpdate($)
    }
}
const AnyItem = properties.loader.ITEM_CLASSES.any
  , Xr = class extends AnyItem {
    constructor(tt, nt) {
        Xr.canvas || Xr.initCanvas(),
        nt.loadFunc = ()=>{}
        ,
        nt.hasLoading = nt.hasLoading === void 0 ? !0 : nt.hasLoading,
        nt.refText = "refing something...",
        nt.refFontSize = nt.refFontSize || 120,
        nt.refFont = nt.refFont || "monospace:400:italic",
        nt.interval = nt.interval || 20,
        nt.refTextWidth = 0;
        super(tt, nt);
        Et(this, "_getTextWidth", (tt,nt,rt,it)=>{
            let ot = Xr.ctx;
            return ot.font = rt + " " + nt + " " + this.refFontSize + "px " + tt + (it ? ", " + it : ""),
            ot.measureText(this.refText).width
        }
        );
        this.loadFunc = this._loadFunc.bind(this)
    }
    static initCanvas() {
        let tt = document.createElement("canvas");
        tt.width = tt.height = 1,
        Xr.canvas = tt,
        Xr.ctx = tt.getContext("2d")
    }
    _loadFunc(tt, nt, rt) {
        let it = tt.split(",")
          , ot = [];
        for (let gt = 0; gt < it.length; gt++)
            ot.push(it[gt].trim());
        it = this.refFont.split(":");
        let st = it[0]
          , lt = it[1] || "normal"
          , ut = it[2] || "normal"
          , ct = st;
        this.refTextWidth = this._getTextWidth(st, lt, ut);
        let ht, ft = ot.length;
        ht = setInterval(()=>{
            it = ot[0].split(":"),
            st = it[0],
            lt = it[1] || "normal",
            ut = it[2] || "normal",
            this._getTextWidth(st, lt, ut, ct) !== this.refTextWidth && (ot.shift(),
            rt.dispatch((ft - ot.length) / ft),
            ot.length === 0 && (clearInterval(ht),
            nt()))
        }
        , this.refInterval)
    }
    _onLoaderLoad(tt, nt) {
        this.content = nt,
        tt(nt)
    }
    _onLoaderLoading(tt, nt) {
        tt.dispatch(nt.loaded / nt.total)
    }
}
;
let FontItem = Xr;
Et(FontItem, "canvas"),
Et(FontItem, "ctx");
FontItem.type = "font";
FontItem.extensions = [];
let webGlApp = new WebglApp;
const canvas = document.getElementById("canvas")
  , uiContainer = document.getElementById("ui");
let dateTime = performance.now();
const isSupportedWebGL = webGlApp.setCanvas(canvas);
uiContainer.style.display = "none";
canvas.style.visibility = "hidden";
if (isSupportedWebGL && !settings.WEBGL_DISABLED) {
    let et = function() {
        InfiniteGrid$1.preInit(),
        webGlApp.preInit(st=>{
            st === 1 && $()
        }
        ),
        (settings.LOOK_DEV_MODE || settings.SKIP_ANIMATION) && useGlobalStore.setState(st=>{
            st.isLoadingComplete = !0,
            st.isLoaderAnimationComplete = !0
        }
        ),
        settings.NO_WEBGL && (canvas.style.display = "none")
    }
      , $ = function() {
        InfiniteGrid$1.init(),
        webGlApp.init()
    }
      , tt = function() {
        let st = window.innerWidth
          , lt = window.innerHeight;
        InfiniteGrid$1.onResize(),
        webGlApp.resize(st, lt),
        updateViewport(st, lt)
    }
      , nt = function() {
        const st = performance.now()
          , lt = (st - dateTime) / 1e3;
        dateTime = st,
        properties.uiLoops.forEach(ut=>{
            ut && ut(lt)
        }
        ),
        InfiniteGrid$1.update(lt),
        webGlApp.render(lt),
        window.requestAnimationFrame(nt)
    }
      , rt = function() {
        let st = "light";
        window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches && (st = "dark");
        let lt = Object.values(THEMES).find(ut=>ut.name === st);
        useGlobalStore.setState(ut=>ut.currentTheme = lt.id),
        document.documentElement.setAttribute("data-theme", lt.name),
        properties.themeSignal.dispatch(lt.id)
    }
      , it = function() {
        rt(),
        properties.loader.register(FontItem),
        properties.loader.add("Aeonik:normal:normal,Aeonik:normal:italic,Aeonik:500:normal,Aeonik:900:normal,IBMPlexMono-Medium:normal:normal", {
            type: "font"
        }),
        properties.loader.start(st=>{
            st === 1 && (et(),
            window.addEventListener("resize", tt),
            tt(),
            settings.NO_WEBGL || (canvas.style.visibility = "visible",
            nt()),
            settings.NO_REACT || (uiContainer.style.display = "block",
            ReactApp()))
        }
        )
    }
      , ot = function(st=!0) {
        st ? properties.tabInFocus = !0 : (properties.tabInFocus = !1,
        updateLucyEmote$1("unamused", !0, !0))
    };
    webGlApp.settings.override({
        CROSS_ORIGINS: {
            "https://my_cdn/": "anonymous"
        }
    }),
    it(),
    document.addEventListener("visibilitychange", st=>{
        ot(document.visibilityState == "visible")
    }
    ),
    window.addEventListener("blur", ()=>{
        ot(!1)
    }
    ),
    window.addEventListener("focus", ()=>{
        ot(!0)
    }
    ),
    input.onDowned.add(()=>{
        useLogoStore.getState().lucyEmote === "unamused" && makeLucyWiggle()
    }
    )
} else
    canvas.style.visibility = "hidden",
    setTimeout(()=>{
        useGlobalStore.setState(et=>et.isLoadingComplete = !0)
    }
    , 1e3);
