/*! For license information please see main.js.LICENSE.txt */
(()=>{
    var t = {
        6955: ()=>{
            "serviceWorker"in navigator && navigator.serviceWorker.register("/service-worker.js")
        }
        ,
        1590: t=>{
            "use strict";
            var e, i = "object" == typeof Reflect ? Reflect : null, n = i && "function" == typeof i.apply ? i.apply : function(t, e, i) {
                return Function.prototype.apply.call(t, e, i)
            }
            ;
            e = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function(t) {
                return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
            }
            : function(t) {
                return Object.getOwnPropertyNames(t)
            }
            ;
            var r = Number.isNaN || function(t) {
                return t != t
            }
            ;
            function s() {
                s.init.call(this)
            }
            t.exports = s,
            t.exports.once = function(t, e) {
                return new Promise((function(i, n) {
                    function r(i) {
                        t.removeListener(e, s),
                        n(i)
                    }
                    function s() {
                        "function" == typeof t.removeListener && t.removeListener("error", r),
                        i([].slice.call(arguments))
                    }
                    m(t, e, s, {
                        once: !0
                    }),
                    "error" !== e && function(t, e, i) {
                        "function" == typeof t.on && m(t, "error", e, {
                            once: !0
                        })
                    }(t, r)
                }
                ))
            }
            ,
            s.EventEmitter = s,
            s.prototype._events = void 0,
            s.prototype._eventsCount = 0,
            s.prototype._maxListeners = void 0;
            var a = 10;
            function o(t) {
                if ("function" != typeof t)
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
            }
            function h(t) {
                return void 0 === t._maxListeners ? s.defaultMaxListeners : t._maxListeners
            }
            function l(t, e, i, n) {
                var r, s, a, l;
                if (o(i),
                void 0 === (s = t._events) ? (s = t._events = Object.create(null),
                t._eventsCount = 0) : (void 0 !== s.newListener && (t.emit("newListener", e, i.listener ? i.listener : i),
                s = t._events),
                a = s[e]),
                void 0 === a)
                    a = s[e] = i,
                    ++t._eventsCount;
                else if ("function" == typeof a ? a = s[e] = n ? [i, a] : [a, i] : n ? a.unshift(i) : a.push(i),
                (r = h(t)) > 0 && a.length > r && !a.warned) {
                    a.warned = !0;
                    var c = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    c.name = "MaxListenersExceededWarning",
                    c.emitter = t,
                    c.type = e,
                    c.count = a.length,
                    l = c,
                    console && console.warn && console.warn(l)
                }
                return t
            }
            function c() {
                if (!this.fired)
                    return this.target.removeListener(this.type, this.wrapFn),
                    this.fired = !0,
                    0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
            }
            function u(t, e, i) {
                var n = {
                    fired: !1,
                    wrapFn: void 0,
                    target: t,
                    type: e,
                    listener: i
                }
                  , r = c.bind(n);
                return r.listener = i,
                n.wrapFn = r,
                r
            }
            function d(t, e, i) {
                var n = t._events;
                if (void 0 === n)
                    return [];
                var r = n[e];
                return void 0 === r ? [] : "function" == typeof r ? i ? [r.listener || r] : [r] : i ? function(t) {
                    for (var e = new Array(t.length), i = 0; i < e.length; ++i)
                        e[i] = t[i].listener || t[i];
                    return e
                }(r) : f(r, r.length)
            }
            function p(t) {
                var e = this._events;
                if (void 0 !== e) {
                    var i = e[t];
                    if ("function" == typeof i)
                        return 1;
                    if (void 0 !== i)
                        return i.length
                }
                return 0
            }
            function f(t, e) {
                for (var i = new Array(e), n = 0; n < e; ++n)
                    i[n] = t[n];
                return i
            }
            function m(t, e, i, n) {
                if ("function" == typeof t.on)
                    n.once ? t.once(e, i) : t.on(e, i);
                else {
                    if ("function" != typeof t.addEventListener)
                        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
                    t.addEventListener(e, (function r(s) {
                        n.once && t.removeEventListener(e, r),
                        i(s)
                    }
                    ))
                }
            }
            Object.defineProperty(s, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return a
                },
                set: function(t) {
                    if ("number" != typeof t || t < 0 || r(t))
                        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
                    a = t
                }
            }),
            s.init = function() {
                void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null),
                this._eventsCount = 0),
                this._maxListeners = this._maxListeners || void 0
            }
            ,
            s.prototype.setMaxListeners = function(t) {
                if ("number" != typeof t || t < 0 || r(t))
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
                return this._maxListeners = t,
                this
            }
            ,
            s.prototype.getMaxListeners = function() {
                return h(this)
            }
            ,
            s.prototype.emit = function(t) {
                for (var e = [], i = 1; i < arguments.length; i++)
                    e.push(arguments[i]);
                var r = "error" === t
                  , s = this._events;
                if (void 0 !== s)
                    r = r && void 0 === s.error;
                else if (!r)
                    return !1;
                if (r) {
                    var a;
                    if (e.length > 0 && (a = e[0]),
                    a instanceof Error)
                        throw a;
                    var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
                    throw o.context = a,
                    o
                }
                var h = s[t];
                if (void 0 === h)
                    return !1;
                if ("function" == typeof h)
                    n(h, this, e);
                else {
                    var l = h.length
                      , c = f(h, l);
                    for (i = 0; i < l; ++i)
                        n(c[i], this, e)
                }
                return !0
            }
            ,
            s.prototype.addListener = function(t, e) {
                return l(this, t, e, !1)
            }
            ,
            s.prototype.on = s.prototype.addListener,
            s.prototype.prependListener = function(t, e) {
                return l(this, t, e, !0)
            }
            ,
            s.prototype.once = function(t, e) {
                return o(e),
                this.on(t, u(this, t, e)),
                this
            }
            ,
            s.prototype.prependOnceListener = function(t, e) {
                return o(e),
                this.prependListener(t, u(this, t, e)),
                this
            }
            ,
            s.prototype.removeListener = function(t, e) {
                var i, n, r, s, a;
                if (o(e),
                void 0 === (n = this._events))
                    return this;
                if (void 0 === (i = n[t]))
                    return this;
                if (i === e || i.listener === e)
                    0 == --this._eventsCount ? this._events = Object.create(null) : (delete n[t],
                    n.removeListener && this.emit("removeListener", t, i.listener || e));
                else if ("function" != typeof i) {
                    for (r = -1,
                    s = i.length - 1; s >= 0; s--)
                        if (i[s] === e || i[s].listener === e) {
                            a = i[s].listener,
                            r = s;
                            break
                        }
                    if (r < 0)
                        return this;
                    0 === r ? i.shift() : function(t, e) {
                        for (; e + 1 < t.length; e++)
                            t[e] = t[e + 1];
                        t.pop()
                    }(i, r),
                    1 === i.length && (n[t] = i[0]),
                    void 0 !== n.removeListener && this.emit("removeListener", t, a || e)
                }
                return this
            }
            ,
            s.prototype.off = s.prototype.removeListener,
            s.prototype.removeAllListeners = function(t) {
                var e, i, n;
                if (void 0 === (i = this._events))
                    return this;
                if (void 0 === i.removeListener)
                    return 0 === arguments.length ? (this._events = Object.create(null),
                    this._eventsCount = 0) : void 0 !== i[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete i[t]),
                    this;
                if (0 === arguments.length) {
                    var r, s = Object.keys(i);
                    for (n = 0; n < s.length; ++n)
                        "removeListener" !== (r = s[n]) && this.removeAllListeners(r);
                    return this.removeAllListeners("removeListener"),
                    this._events = Object.create(null),
                    this._eventsCount = 0,
                    this
                }
                if ("function" == typeof (e = i[t]))
                    this.removeListener(t, e);
                else if (void 0 !== e)
                    for (n = e.length - 1; n >= 0; n--)
                        this.removeListener(t, e[n]);
                return this
            }
            ,
            s.prototype.listeners = function(t) {
                return d(this, t, !0)
            }
            ,
            s.prototype.rawListeners = function(t) {
                return d(this, t, !1)
            }
            ,
            s.listenerCount = function(t, e) {
                return "function" == typeof t.listenerCount ? t.listenerCount(e) : p.call(t, e)
            }
            ,
            s.prototype.listenerCount = p,
            s.prototype.eventNames = function() {
                return this._eventsCount > 0 ? e(this._events) : []
            }
        }
        ,
        9940: (t,e,i)=>{
            var n = i(3203)(i(4362), "DataView");
            t.exports = n
        }
        ,
        1979: (t,e,i)=>{
            var n = i(9129)
              , r = i(7644)
              , s = i(3486)
              , a = i(4786)
              , o = i(6444);
            function h(t) {
                var e = -1
                  , i = null == t ? 0 : t.length;
                for (this.clear(); ++e < i; ) {
                    var n = t[e];
                    this.set(n[0], n[1])
                }
            }
            h.prototype.clear = n,
            h.prototype.delete = r,
            h.prototype.get = s,
            h.prototype.has = a,
            h.prototype.set = o,
            t.exports = h
        }
        ,
        2768: (t,e,i)=>{
            var n = i(3708)
              , r = i(6993)
              , s = i(286)
              , a = i(1678)
              , o = i(9743);
            function h(t) {
                var e = -1
                  , i = null == t ? 0 : t.length;
                for (this.clear(); ++e < i; ) {
                    var n = t[e];
                    this.set(n[0], n[1])
                }
            }
            h.prototype.clear = n,
            h.prototype.delete = r,
            h.prototype.get = s,
            h.prototype.has = a,
            h.prototype.set = o,
            t.exports = h
        }
        ,
        4804: (t,e,i)=>{
            var n = i(3203)(i(4362), "Map");
            t.exports = n
        }
        ,
        8423: (t,e,i)=>{
            var n = i(6977)
              , r = i(7474)
              , s = i(727)
              , a = i(3653)
              , o = i(6140);
            function h(t) {
                var e = -1
                  , i = null == t ? 0 : t.length;
                for (this.clear(); ++e < i; ) {
                    var n = t[e];
                    this.set(n[0], n[1])
                }
            }
            h.prototype.clear = n,
            h.prototype.delete = r,
            h.prototype.get = s,
            h.prototype.has = a,
            h.prototype.set = o,
            t.exports = h
        }
        ,
        7114: (t,e,i)=>{
            var n = i(3203)(i(4362), "Promise");
            t.exports = n
        }
        ,
        689: (t,e,i)=>{
            var n = i(3203)(i(4362), "Set");
            t.exports = n
        }
        ,
        9832: (t,e,i)=>{
            var n = i(8423)
              , r = i(9911)
              , s = i(7447);
            function a(t) {
                var e = -1
                  , i = null == t ? 0 : t.length;
                for (this.__data__ = new n; ++e < i; )
                    this.add(t[e])
            }
            a.prototype.add = a.prototype.push = r,
            a.prototype.has = s,
            t.exports = a
        }
        ,
        959: (t,e,i)=>{
            var n = i(2768)
              , r = i(7553)
              , s = i(6038)
              , a = i(2397)
              , o = i(2421)
              , h = i(2936);
            function l(t) {
                var e = this.__data__ = new n(t);
                this.size = e.size
            }
            l.prototype.clear = r,
            l.prototype.delete = s,
            l.prototype.get = a,
            l.prototype.has = o,
            l.prototype.set = h,
            t.exports = l
        }
        ,
        2773: (t,e,i)=>{
            var n = i(4362).Symbol;
            t.exports = n
        }
        ,
        2496: (t,e,i)=>{
            var n = i(4362).Uint8Array;
            t.exports = n
        }
        ,
        5284: (t,e,i)=>{
            var n = i(3203)(i(4362), "WeakMap");
            t.exports = n
        }
        ,
        4111: t=>{
            t.exports = function(t, e) {
                for (var i = -1, n = null == t ? 0 : t.length; ++i < n && !1 !== e(t[i], i, t); )
                    ;
                return t
            }
        }
        ,
        6523: t=>{
            t.exports = function(t, e) {
                for (var i = -1, n = null == t ? 0 : t.length, r = 0, s = []; ++i < n; ) {
                    var a = t[i];
                    e(a, i, t) && (s[r++] = a)
                }
                return s
            }
        }
        ,
        8083: (t,e,i)=>{
            var n = i(5094)
              , r = i(9246)
              , s = i(3670)
              , a = i(2343)
              , o = i(4782)
              , h = i(1589)
              , l = Object.prototype.hasOwnProperty;
            t.exports = function(t, e) {
                var i = s(t)
                  , c = !i && r(t)
                  , u = !i && !c && a(t)
                  , d = !i && !c && !u && h(t)
                  , p = i || c || u || d
                  , f = p ? n(t.length, String) : []
                  , m = f.length;
                for (var g in t)
                    !e && !l.call(t, g) || p && ("length" == g || u && ("offset" == g || "parent" == g) || d && ("buffer" == g || "byteLength" == g || "byteOffset" == g) || o(g, m)) || f.push(g);
                return f
            }
        }
        ,
        9258: t=>{
            t.exports = function(t, e) {
                for (var i = -1, n = null == t ? 0 : t.length, r = Array(n); ++i < n; )
                    r[i] = e(t[i], i, t);
                return r
            }
        }
        ,
        8421: t=>{
            t.exports = function(t, e) {
                for (var i = -1, n = e.length, r = t.length; ++i < n; )
                    t[r + i] = e[i];
                return t
            }
        }
        ,
        4481: t=>{
            t.exports = function(t, e) {
                for (var i = -1, n = null == t ? 0 : t.length; ++i < n; )
                    if (e(t[i], i, t))
                        return !0;
                return !1
            }
        }
        ,
        6213: (t,e,i)=>{
            var n = i(7950);
            t.exports = function(t, e) {
                for (var i = t.length; i--; )
                    if (n(t[i][0], e))
                        return i;
                return -1
            }
        }
        ,
        5806: (t,e,i)=>{
            var n = i(5645)
              , r = i(3978)(n);
            t.exports = r
        }
        ,
        7079: (t,e,i)=>{
            var n = i(7924)();
            t.exports = n
        }
        ,
        5645: (t,e,i)=>{
            var n = i(7079)
              , r = i(3225);
            t.exports = function(t, e) {
                return t && n(t, e, r)
            }
        }
        ,
        5974: (t,e,i)=>{
            var n = i(6883)
              , r = i(7102);
            t.exports = function(t, e) {
                for (var i = 0, s = (e = n(e, t)).length; null != t && i < s; )
                    t = t[r(e[i++])];
                return i && i == s ? t : void 0
            }
        }
        ,
        891: (t,e,i)=>{
            var n = i(8421)
              , r = i(3670);
            t.exports = function(t, e, i) {
                var s = e(t);
                return r(t) ? s : n(s, i(t))
            }
        }
        ,
        1185: (t,e,i)=>{
            var n = i(2773)
              , r = i(3888)
              , s = i(2299)
              , a = n ? n.toStringTag : void 0;
            t.exports = function(t) {
                return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : a && a in Object(t) ? r(t) : s(t)
            }
        }
        ,
        5529: t=>{
            t.exports = function(t, e) {
                return null != t && e in Object(t)
            }
        }
        ,
        1075: (t,e,i)=>{
            var n = i(1185)
              , r = i(4939);
            t.exports = function(t) {
                return r(t) && "[object Arguments]" == n(t)
            }
        }
        ,
        9856: (t,e,i)=>{
            var n = i(1829)
              , r = i(4939);
            t.exports = function t(e, i, s, a, o) {
                return e === i || (null == e || null == i || !r(e) && !r(i) ? e != e && i != i : n(e, i, s, a, t, o))
            }
        }
        ,
        1829: (t,e,i)=>{
            var n = i(959)
              , r = i(3426)
              , s = i(1402)
              , a = i(4572)
              , o = i(2417)
              , h = i(3670)
              , l = i(2343)
              , c = i(1589)
              , u = "[object Arguments]"
              , d = "[object Array]"
              , p = "[object Object]"
              , f = Object.prototype.hasOwnProperty;
            t.exports = function(t, e, i, m, g, v) {
                var y = h(t)
                  , x = h(e)
                  , _ = y ? d : o(t)
                  , b = x ? d : o(e)
                  , w = (_ = _ == u ? p : _) == p
                  , M = (b = b == u ? p : b) == p
                  , T = _ == b;
                if (T && l(t)) {
                    if (!l(e))
                        return !1;
                    y = !0,
                    w = !1
                }
                if (T && !w)
                    return v || (v = new n),
                    y || c(t) ? r(t, e, i, m, g, v) : s(t, e, _, i, m, g, v);
                if (!(1 & i)) {
                    var E = w && f.call(t, "__wrapped__")
                      , S = M && f.call(e, "__wrapped__");
                    if (E || S) {
                        var A = E ? t.value() : t
                          , L = S ? e.value() : e;
                        return v || (v = new n),
                        g(A, L, i, m, v)
                    }
                }
                return !!T && (v || (v = new n),
                a(t, e, i, m, g, v))
            }
        }
        ,
        4656: (t,e,i)=>{
            var n = i(959)
              , r = i(9856);
            t.exports = function(t, e, i, s) {
                var a = i.length
                  , o = a
                  , h = !s;
                if (null == t)
                    return !o;
                for (t = Object(t); a--; ) {
                    var l = i[a];
                    if (h && l[2] ? l[1] !== t[l[0]] : !(l[0]in t))
                        return !1
                }
                for (; ++a < o; ) {
                    var c = (l = i[a])[0]
                      , u = t[c]
                      , d = l[1];
                    if (h && l[2]) {
                        if (void 0 === u && !(c in t))
                            return !1
                    } else {
                        var p = new n;
                        if (s)
                            var f = s(u, d, c, t, e, p);
                        if (!(void 0 === f ? r(d, u, 3, s, p) : f))
                            return !1
                    }
                }
                return !0
            }
        }
        ,
        4106: (t,e,i)=>{
            var n = i(3626)
              , r = i(9249)
              , s = i(71)
              , a = i(1214)
              , o = /^\[object .+?Constructor\]$/
              , h = Function.prototype
              , l = Object.prototype
              , c = h.toString
              , u = l.hasOwnProperty
              , d = RegExp("^" + c.call(u).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            t.exports = function(t) {
                return !(!s(t) || r(t)) && (n(t) ? d : o).test(a(t))
            }
        }
        ,
        3638: (t,e,i)=>{
            var n = i(1185)
              , r = i(7100)
              , s = i(4939)
              , a = {};
            a["[object Float32Array]"] = a["[object Float64Array]"] = a["[object Int8Array]"] = a["[object Int16Array]"] = a["[object Int32Array]"] = a["[object Uint8Array]"] = a["[object Uint8ClampedArray]"] = a["[object Uint16Array]"] = a["[object Uint32Array]"] = !0,
            a["[object Arguments]"] = a["[object Array]"] = a["[object ArrayBuffer]"] = a["[object Boolean]"] = a["[object DataView]"] = a["[object Date]"] = a["[object Error]"] = a["[object Function]"] = a["[object Map]"] = a["[object Number]"] = a["[object Object]"] = a["[object RegExp]"] = a["[object Set]"] = a["[object String]"] = a["[object WeakMap]"] = !1,
            t.exports = function(t) {
                return s(t) && r(t.length) && !!a[n(t)]
            }
        }
        ,
        9047: (t,e,i)=>{
            var n = i(8334)
              , r = i(5941)
              , s = i(1559)
              , a = i(3670)
              , o = i(8886);
            t.exports = function(t) {
                return "function" == typeof t ? t : null == t ? s : "object" == typeof t ? a(t) ? r(t[0], t[1]) : n(t) : o(t)
            }
        }
        ,
        7521: (t,e,i)=>{
            var n = i(2803)
              , r = i(3865)
              , s = Object.prototype.hasOwnProperty;
            t.exports = function(t) {
                if (!n(t))
                    return r(t);
                var e = [];
                for (var i in Object(t))
                    s.call(t, i) && "constructor" != i && e.push(i);
                return e
            }
        }
        ,
        5901: (t,e,i)=>{
            var n = i(5806)
              , r = i(6175);
            t.exports = function(t, e) {
                var i = -1
                  , s = r(t) ? Array(t.length) : [];
                return n(t, (function(t, n, r) {
                    s[++i] = e(t, n, r)
                }
                )),
                s
            }
        }
        ,
        8334: (t,e,i)=>{
            var n = i(4656)
              , r = i(2811)
              , s = i(4248);
            t.exports = function(t) {
                var e = r(t);
                return 1 == e.length && e[0][2] ? s(e[0][0], e[0][1]) : function(i) {
                    return i === t || n(i, t, e)
                }
            }
        }
        ,
        5941: (t,e,i)=>{
            var n = i(9856)
              , r = i(643)
              , s = i(9059)
              , a = i(837)
              , o = i(3631)
              , h = i(4248)
              , l = i(7102);
            t.exports = function(t, e) {
                return a(t) && o(e) ? h(l(t), e) : function(i) {
                    var a = r(i, t);
                    return void 0 === a && a === e ? s(i, t) : n(e, a, 3)
                }
            }
        }
        ,
        3184: t=>{
            t.exports = function(t) {
                return function(e) {
                    return null == e ? void 0 : e[t]
                }
            }
        }
        ,
        886: (t,e,i)=>{
            var n = i(5974);
            t.exports = function(t) {
                return function(e) {
                    return n(e, t)
                }
            }
        }
        ,
        5094: t=>{
            t.exports = function(t, e) {
                for (var i = -1, n = Array(t); ++i < t; )
                    n[i] = e(i);
                return n
            }
        }
        ,
        8257: (t,e,i)=>{
            var n = i(2773)
              , r = i(9258)
              , s = i(3670)
              , a = i(4655)
              , o = n ? n.prototype : void 0
              , h = o ? o.toString : void 0;
            t.exports = function t(e) {
                if ("string" == typeof e)
                    return e;
                if (s(e))
                    return r(e, t) + "";
                if (a(e))
                    return h ? h.call(e) : "";
                var i = e + "";
                return "0" == i && 1 / e == -1 / 0 ? "-0" : i
            }
        }
        ,
        9081: t=>{
            t.exports = function(t) {
                return function(e) {
                    return t(e)
                }
            }
        }
        ,
        3159: t=>{
            t.exports = function(t, e) {
                return t.has(e)
            }
        }
        ,
        3183: (t,e,i)=>{
            var n = i(1559);
            t.exports = function(t) {
                return "function" == typeof t ? t : n
            }
        }
        ,
        6883: (t,e,i)=>{
            var n = i(3670)
              , r = i(837)
              , s = i(376)
              , a = i(2049);
            t.exports = function(t, e) {
                return n(t) ? t : r(t, e) ? [t] : s(a(t))
            }
        }
        ,
        1741: (t,e,i)=>{
            var n = i(4362)["__core-js_shared__"];
            t.exports = n
        }
        ,
        3978: (t,e,i)=>{
            var n = i(6175);
            t.exports = function(t, e) {
                return function(i, r) {
                    if (null == i)
                        return i;
                    if (!n(i))
                        return t(i, r);
                    for (var s = i.length, a = e ? s : -1, o = Object(i); (e ? a-- : ++a < s) && !1 !== r(o[a], a, o); )
                        ;
                    return i
                }
            }
        }
        ,
        7924: t=>{
            t.exports = function(t) {
                return function(e, i, n) {
                    for (var r = -1, s = Object(e), a = n(e), o = a.length; o--; ) {
                        var h = a[t ? o : ++r];
                        if (!1 === i(s[h], h, s))
                            break
                    }
                    return e
                }
            }
        }
        ,
        3426: (t,e,i)=>{
            var n = i(9832)
              , r = i(4481)
              , s = i(3159);
            t.exports = function(t, e, i, a, o, h) {
                var l = 1 & i
                  , c = t.length
                  , u = e.length;
                if (c != u && !(l && u > c))
                    return !1;
                var d = h.get(t)
                  , p = h.get(e);
                if (d && p)
                    return d == e && p == t;
                var f = -1
                  , m = !0
                  , g = 2 & i ? new n : void 0;
                for (h.set(t, e),
                h.set(e, t); ++f < c; ) {
                    var v = t[f]
                      , y = e[f];
                    if (a)
                        var x = l ? a(y, v, f, e, t, h) : a(v, y, f, t, e, h);
                    if (void 0 !== x) {
                        if (x)
                            continue;
                        m = !1;
                        break
                    }
                    if (g) {
                        if (!r(e, (function(t, e) {
                            if (!s(g, e) && (v === t || o(v, t, i, a, h)))
                                return g.push(e)
                        }
                        ))) {
                            m = !1;
                            break
                        }
                    } else if (v !== y && !o(v, y, i, a, h)) {
                        m = !1;
                        break
                    }
                }
                return h.delete(t),
                h.delete(e),
                m
            }
        }
        ,
        1402: (t,e,i)=>{
            var n = i(2773)
              , r = i(2496)
              , s = i(7950)
              , a = i(3426)
              , o = i(8961)
              , h = i(6983)
              , l = n ? n.prototype : void 0
              , c = l ? l.valueOf : void 0;
            t.exports = function(t, e, i, n, l, u, d) {
                switch (i) {
                case "[object DataView]":
                    if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
                        return !1;
                    t = t.buffer,
                    e = e.buffer;
                case "[object ArrayBuffer]":
                    return !(t.byteLength != e.byteLength || !u(new r(t), new r(e)));
                case "[object Boolean]":
                case "[object Date]":
                case "[object Number]":
                    return s(+t, +e);
                case "[object Error]":
                    return t.name == e.name && t.message == e.message;
                case "[object RegExp]":
                case "[object String]":
                    return t == e + "";
                case "[object Map]":
                    var p = o;
                case "[object Set]":
                    var f = 1 & n;
                    if (p || (p = h),
                    t.size != e.size && !f)
                        return !1;
                    var m = d.get(t);
                    if (m)
                        return m == e;
                    n |= 2,
                    d.set(t, e);
                    var g = a(p(t), p(e), n, l, u, d);
                    return d.delete(t),
                    g;
                case "[object Symbol]":
                    if (c)
                        return c.call(t) == c.call(e)
                }
                return !1
            }
        }
        ,
        4572: (t,e,i)=>{
            var n = i(5788)
              , r = Object.prototype.hasOwnProperty;
            t.exports = function(t, e, i, s, a, o) {
                var h = 1 & i
                  , l = n(t)
                  , c = l.length;
                if (c != n(e).length && !h)
                    return !1;
                for (var u = c; u--; ) {
                    var d = l[u];
                    if (!(h ? d in e : r.call(e, d)))
                        return !1
                }
                var p = o.get(t)
                  , f = o.get(e);
                if (p && f)
                    return p == e && f == t;
                var m = !0;
                o.set(t, e),
                o.set(e, t);
                for (var g = h; ++u < c; ) {
                    var v = t[d = l[u]]
                      , y = e[d];
                    if (s)
                        var x = h ? s(y, v, d, e, t, o) : s(v, y, d, t, e, o);
                    if (!(void 0 === x ? v === y || a(v, y, i, s, o) : x)) {
                        m = !1;
                        break
                    }
                    g || (g = "constructor" == d)
                }
                if (m && !g) {
                    var _ = t.constructor
                      , b = e.constructor;
                    _ == b || !("constructor"in t) || !("constructor"in e) || "function" == typeof _ && _ instanceof _ && "function" == typeof b && b instanceof b || (m = !1)
                }
                return o.delete(t),
                o.delete(e),
                m
            }
        }
        ,
        8556: (t,e,i)=>{
            var n = "object" == typeof i.g && i.g && i.g.Object === Object && i.g;
            t.exports = n
        }
        ,
        5788: (t,e,i)=>{
            var n = i(891)
              , r = i(6918)
              , s = i(3225);
            t.exports = function(t) {
                return n(t, s, r)
            }
        }
        ,
        404: (t,e,i)=>{
            var n = i(4480);
            t.exports = function(t, e) {
                var i = t.__data__;
                return n(e) ? i["string" == typeof e ? "string" : "hash"] : i.map
            }
        }
        ,
        2811: (t,e,i)=>{
            var n = i(3631)
              , r = i(3225);
            t.exports = function(t) {
                for (var e = r(t), i = e.length; i--; ) {
                    var s = e[i]
                      , a = t[s];
                    e[i] = [s, a, n(a)]
                }
                return e
            }
        }
        ,
        3203: (t,e,i)=>{
            var n = i(4106)
              , r = i(7338);
            t.exports = function(t, e) {
                var i = r(t, e);
                return n(i) ? i : void 0
            }
        }
        ,
        3888: (t,e,i)=>{
            var n = i(2773)
              , r = Object.prototype
              , s = r.hasOwnProperty
              , a = r.toString
              , o = n ? n.toStringTag : void 0;
            t.exports = function(t) {
                var e = s.call(t, o)
                  , i = t[o];
                try {
                    t[o] = void 0;
                    var n = !0
                } catch (t) {}
                var r = a.call(t);
                return n && (e ? t[o] = i : delete t[o]),
                r
            }
        }
        ,
        6918: (t,e,i)=>{
            var n = i(6523)
              , r = i(4043)
              , s = Object.prototype.propertyIsEnumerable
              , a = Object.getOwnPropertySymbols
              , o = a ? function(t) {
                return null == t ? [] : (t = Object(t),
                n(a(t), (function(e) {
                    return s.call(t, e)
                }
                )))
            }
            : r;
            t.exports = o
        }
        ,
        2417: (t,e,i)=>{
            var n = i(9940)
              , r = i(4804)
              , s = i(7114)
              , a = i(689)
              , o = i(5284)
              , h = i(1185)
              , l = i(1214)
              , c = "[object Map]"
              , u = "[object Promise]"
              , d = "[object Set]"
              , p = "[object WeakMap]"
              , f = "[object DataView]"
              , m = l(n)
              , g = l(r)
              , v = l(s)
              , y = l(a)
              , x = l(o)
              , _ = h;
            (n && _(new n(new ArrayBuffer(1))) != f || r && _(new r) != c || s && _(s.resolve()) != u || a && _(new a) != d || o && _(new o) != p) && (_ = function(t) {
                var e = h(t)
                  , i = "[object Object]" == e ? t.constructor : void 0
                  , n = i ? l(i) : "";
                if (n)
                    switch (n) {
                    case m:
                        return f;
                    case g:
                        return c;
                    case v:
                        return u;
                    case y:
                        return d;
                    case x:
                        return p
                    }
                return e
            }
            ),
            t.exports = _
        }
        ,
        7338: t=>{
            t.exports = function(t, e) {
                return null == t ? void 0 : t[e]
            }
        }
        ,
        4727: (t,e,i)=>{
            var n = i(6883)
              , r = i(9246)
              , s = i(3670)
              , a = i(4782)
              , o = i(7100)
              , h = i(7102);
            t.exports = function(t, e, i) {
                for (var l = -1, c = (e = n(e, t)).length, u = !1; ++l < c; ) {
                    var d = h(e[l]);
                    if (!(u = null != t && i(t, d)))
                        break;
                    t = t[d]
                }
                return u || ++l != c ? u : !!(c = null == t ? 0 : t.length) && o(c) && a(d, c) && (s(t) || r(t))
            }
        }
        ,
        9129: (t,e,i)=>{
            var n = i(6326);
            t.exports = function() {
                this.__data__ = n ? n(null) : {},
                this.size = 0
            }
        }
        ,
        7644: t=>{
            t.exports = function(t) {
                var e = this.has(t) && delete this.__data__[t];
                return this.size -= e ? 1 : 0,
                e
            }
        }
        ,
        3486: (t,e,i)=>{
            var n = i(6326)
              , r = Object.prototype.hasOwnProperty;
            t.exports = function(t) {
                var e = this.__data__;
                if (n) {
                    var i = e[t];
                    return "__lodash_hash_undefined__" === i ? void 0 : i
                }
                return r.call(e, t) ? e[t] : void 0
            }
        }
        ,
        4786: (t,e,i)=>{
            var n = i(6326)
              , r = Object.prototype.hasOwnProperty;
            t.exports = function(t) {
                var e = this.__data__;
                return n ? void 0 !== e[t] : r.call(e, t)
            }
        }
        ,
        6444: (t,e,i)=>{
            var n = i(6326);
            t.exports = function(t, e) {
                var i = this.__data__;
                return this.size += this.has(t) ? 0 : 1,
                i[t] = n && void 0 === e ? "__lodash_hash_undefined__" : e,
                this
            }
        }
        ,
        4782: t=>{
            var e = /^(?:0|[1-9]\d*)$/;
            t.exports = function(t, i) {
                var n = typeof t;
                return !!(i = null == i ? 9007199254740991 : i) && ("number" == n || "symbol" != n && e.test(t)) && t > -1 && t % 1 == 0 && t < i
            }
        }
        ,
        837: (t,e,i)=>{
            var n = i(3670)
              , r = i(4655)
              , s = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
              , a = /^\w*$/;
            t.exports = function(t, e) {
                if (n(t))
                    return !1;
                var i = typeof t;
                return !("number" != i && "symbol" != i && "boolean" != i && null != t && !r(t)) || a.test(t) || !s.test(t) || null != e && t in Object(e)
            }
        }
        ,
        4480: t=>{
            t.exports = function(t) {
                var e = typeof t;
                return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t
            }
        }
        ,
        9249: (t,e,i)=>{
            var n, r = i(1741), s = (n = /[^.]+$/.exec(r && r.keys && r.keys.IE_PROTO || "")) ? "Symbol(src)_1." + n : "";
            t.exports = function(t) {
                return !!s && s in t
            }
        }
        ,
        2803: t=>{
            var e = Object.prototype;
            t.exports = function(t) {
                var i = t && t.constructor;
                return t === ("function" == typeof i && i.prototype || e)
            }
        }
        ,
        3631: (t,e,i)=>{
            var n = i(71);
            t.exports = function(t) {
                return t == t && !n(t)
            }
        }
        ,
        3708: t=>{
            t.exports = function() {
                this.__data__ = [],
                this.size = 0
            }
        }
        ,
        6993: (t,e,i)=>{
            var n = i(6213)
              , r = Array.prototype.splice;
            t.exports = function(t) {
                var e = this.__data__
                  , i = n(e, t);
                return !(i < 0 || (i == e.length - 1 ? e.pop() : r.call(e, i, 1),
                --this.size,
                0))
            }
        }
        ,
        286: (t,e,i)=>{
            var n = i(6213);
            t.exports = function(t) {
                var e = this.__data__
                  , i = n(e, t);
                return i < 0 ? void 0 : e[i][1]
            }
        }
        ,
        1678: (t,e,i)=>{
            var n = i(6213);
            t.exports = function(t) {
                return n(this.__data__, t) > -1
            }
        }
        ,
        9743: (t,e,i)=>{
            var n = i(6213);
            t.exports = function(t, e) {
                var i = this.__data__
                  , r = n(i, t);
                return r < 0 ? (++this.size,
                i.push([t, e])) : i[r][1] = e,
                this
            }
        }
        ,
        6977: (t,e,i)=>{
            var n = i(1979)
              , r = i(2768)
              , s = i(4804);
            t.exports = function() {
                this.size = 0,
                this.__data__ = {
                    hash: new n,
                    map: new (s || r),
                    string: new n
                }
            }
        }
        ,
        7474: (t,e,i)=>{
            var n = i(404);
            t.exports = function(t) {
                var e = n(this, t).delete(t);
                return this.size -= e ? 1 : 0,
                e
            }
        }
        ,
        727: (t,e,i)=>{
            var n = i(404);
            t.exports = function(t) {
                return n(this, t).get(t)
            }
        }
        ,
        3653: (t,e,i)=>{
            var n = i(404);
            t.exports = function(t) {
                return n(this, t).has(t)
            }
        }
        ,
        6140: (t,e,i)=>{
            var n = i(404);
            t.exports = function(t, e) {
                var i = n(this, t)
                  , r = i.size;
                return i.set(t, e),
                this.size += i.size == r ? 0 : 1,
                this
            }
        }
        ,
        8961: t=>{
            t.exports = function(t) {
                var e = -1
                  , i = Array(t.size);
                return t.forEach((function(t, n) {
                    i[++e] = [n, t]
                }
                )),
                i
            }
        }
        ,
        4248: t=>{
            t.exports = function(t, e) {
                return function(i) {
                    return null != i && i[t] === e && (void 0 !== e || t in Object(i))
                }
            }
        }
        ,
        5933: (t,e,i)=>{
            var n = i(104);
            t.exports = function(t) {
                var e = n(t, (function(t) {
                    return 500 === i.size && i.clear(),
                    t
                }
                ))
                  , i = e.cache;
                return e
            }
        }
        ,
        6326: (t,e,i)=>{
            var n = i(3203)(Object, "create");
            t.exports = n
        }
        ,
        3865: (t,e,i)=>{
            var n = i(5290)(Object.keys, Object);
            t.exports = n
        }
        ,
        1985: (t,e,i)=>{
            t = i.nmd(t);
            var n = i(8556)
              , r = e && !e.nodeType && e
              , s = r && t && !t.nodeType && t
              , a = s && s.exports === r && n.process
              , o = function() {
                try {
                    return s && s.require && s.require("util").types || a && a.binding && a.binding("util")
                } catch (t) {}
            }();
            t.exports = o
        }
        ,
        2299: t=>{
            var e = Object.prototype.toString;
            t.exports = function(t) {
                return e.call(t)
            }
        }
        ,
        5290: t=>{
            t.exports = function(t, e) {
                return function(i) {
                    return t(e(i))
                }
            }
        }
        ,
        4362: (t,e,i)=>{
            var n = i(8556)
              , r = "object" == typeof self && self && self.Object === Object && self
              , s = n || r || Function("return this")();
            t.exports = s
        }
        ,
        9911: t=>{
            t.exports = function(t) {
                return this.__data__.set(t, "__lodash_hash_undefined__"),
                this
            }
        }
        ,
        7447: t=>{
            t.exports = function(t) {
                return this.__data__.has(t)
            }
        }
        ,
        6983: t=>{
            t.exports = function(t) {
                var e = -1
                  , i = Array(t.size);
                return t.forEach((function(t) {
                    i[++e] = t
                }
                )),
                i
            }
        }
        ,
        7553: (t,e,i)=>{
            var n = i(2768);
            t.exports = function() {
                this.__data__ = new n,
                this.size = 0
            }
        }
        ,
        6038: t=>{
            t.exports = function(t) {
                var e = this.__data__
                  , i = e.delete(t);
                return this.size = e.size,
                i
            }
        }
        ,
        2397: t=>{
            t.exports = function(t) {
                return this.__data__.get(t)
            }
        }
        ,
        2421: t=>{
            t.exports = function(t) {
                return this.__data__.has(t)
            }
        }
        ,
        2936: (t,e,i)=>{
            var n = i(2768)
              , r = i(4804)
              , s = i(8423);
            t.exports = function(t, e) {
                var i = this.__data__;
                if (i instanceof n) {
                    var a = i.__data__;
                    if (!r || a.length < 199)
                        return a.push([t, e]),
                        this.size = ++i.size,
                        this;
                    i = this.__data__ = new s(a)
                }
                return i.set(t, e),
                this.size = i.size,
                this
            }
        }
        ,
        376: (t,e,i)=>{
            var n = i(5933)
              , r = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
              , s = /\\(\\)?/g
              , a = n((function(t) {
                var e = [];
                return 46 === t.charCodeAt(0) && e.push(""),
                t.replace(r, (function(t, i, n, r) {
                    e.push(n ? r.replace(s, "$1") : i || t)
                }
                )),
                e
            }
            ));
            t.exports = a
        }
        ,
        7102: (t,e,i)=>{
            var n = i(4655);
            t.exports = function(t) {
                if ("string" == typeof t || n(t))
                    return t;
                var e = t + "";
                return "0" == e && 1 / t == -1 / 0 ? "-0" : e
            }
        }
        ,
        1214: t=>{
            var e = Function.prototype.toString;
            t.exports = function(t) {
                if (null != t) {
                    try {
                        return e.call(t)
                    } catch (t) {}
                    try {
                        return t + ""
                    } catch (t) {}
                }
                return ""
            }
        }
        ,
        6270: (t,e,i)=>{
            t.exports = i(9982)
        }
        ,
        7950: t=>{
            t.exports = function(t, e) {
                return t === e || t != t && e != e
            }
        }
        ,
        9982: (t,e,i)=>{
            var n = i(4111)
              , r = i(5806)
              , s = i(3183)
              , a = i(3670);
            t.exports = function(t, e) {
                return (a(t) ? n : r)(t, s(e))
            }
        }
        ,
        643: (t,e,i)=>{
            var n = i(5974);
            t.exports = function(t, e, i) {
                var r = null == t ? void 0 : n(t, e);
                return void 0 === r ? i : r
            }
        }
        ,
        9059: (t,e,i)=>{
            var n = i(5529)
              , r = i(4727);
            t.exports = function(t, e) {
                return null != t && r(t, e, n)
            }
        }
        ,
        1559: t=>{
            t.exports = function(t) {
                return t
            }
        }
        ,
        9246: (t,e,i)=>{
            var n = i(1075)
              , r = i(4939)
              , s = Object.prototype
              , a = s.hasOwnProperty
              , o = s.propertyIsEnumerable
              , h = n(function() {
                return arguments
            }()) ? n : function(t) {
                return r(t) && a.call(t, "callee") && !o.call(t, "callee")
            }
            ;
            t.exports = h
        }
        ,
        3670: t=>{
            var e = Array.isArray;
            t.exports = e
        }
        ,
        6175: (t,e,i)=>{
            var n = i(3626)
              , r = i(7100);
            t.exports = function(t) {
                return null != t && r(t.length) && !n(t)
            }
        }
        ,
        2343: (t,e,i)=>{
            t = i.nmd(t);
            var n = i(4362)
              , r = i(3444)
              , s = e && !e.nodeType && e
              , a = s && t && !t.nodeType && t
              , o = a && a.exports === s ? n.Buffer : void 0
              , h = (o ? o.isBuffer : void 0) || r;
            t.exports = h
        }
        ,
        3626: (t,e,i)=>{
            var n = i(1185)
              , r = i(71);
            t.exports = function(t) {
                if (!r(t))
                    return !1;
                var e = n(t);
                return "[object Function]" == e || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e
            }
        }
        ,
        7100: t=>{
            t.exports = function(t) {
                return "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991
            }
        }
        ,
        71: t=>{
            t.exports = function(t) {
                var e = typeof t;
                return null != t && ("object" == e || "function" == e)
            }
        }
        ,
        4939: t=>{
            t.exports = function(t) {
                return null != t && "object" == typeof t
            }
        }
        ,
        4655: (t,e,i)=>{
            var n = i(1185)
              , r = i(4939);
            t.exports = function(t) {
                return "symbol" == typeof t || r(t) && "[object Symbol]" == n(t)
            }
        }
        ,
        1589: (t,e,i)=>{
            var n = i(3638)
              , r = i(9081)
              , s = i(1985)
              , a = s && s.isTypedArray
              , o = a ? r(a) : n;
            t.exports = o
        }
        ,
        3225: (t,e,i)=>{
            var n = i(8083)
              , r = i(7521)
              , s = i(6175);
            t.exports = function(t) {
                return s(t) ? n(t) : r(t)
            }
        }
        ,
        7976: (t,e,i)=>{
            var n = i(9258)
              , r = i(9047)
              , s = i(5901)
              , a = i(3670);
            t.exports = function(t, e) {
                return (a(t) ? n : s)(t, r(e, 3))
            }
        }
        ,
        104: (t,e,i)=>{
            var n = i(8423);
            function r(t, e) {
                if ("function" != typeof t || null != e && "function" != typeof e)
                    throw new TypeError("Expected a function");
                var i = function() {
                    var n = arguments
                      , r = e ? e.apply(this, n) : n[0]
                      , s = i.cache;
                    if (s.has(r))
                        return s.get(r);
                    var a = t.apply(this, n);
                    return i.cache = s.set(r, a) || s,
                    a
                };
                return i.cache = new (r.Cache || n),
                i
            }
            r.Cache = n,
            t.exports = r
        }
        ,
        8886: (t,e,i)=>{
            var n = i(3184)
              , r = i(886)
              , s = i(837)
              , a = i(7102);
            t.exports = function(t) {
                return s(t) ? n(a(t)) : r(t)
            }
        }
        ,
        4043: t=>{
            t.exports = function() {
                return []
            }
        }
        ,
        3444: t=>{
            t.exports = function() {
                return !1
            }
        }
        ,
        2049: (t,e,i)=>{
            var n = i(8257);
            t.exports = function(t) {
                return null == t ? "" : n(t)
            }
        }
        ,
        7320: (t,e,i)=>{
            t.exports = i(1045)
        }
        ,
        7230: t=>{
            "use strict";
            var e = !("undefined" == typeof window || !window.document || !window.document.createElement)
              , i = {
                canUseDOM: e,
                canUseWorkers: "undefined" != typeof Worker,
                canUseEventListeners: e && !(!window.addEventListener && !window.attachEvent),
                canUseViewport: e && !!window.screen,
                isInWorker: !e
            };
            t.exports = i
        }
        ,
        2907: t=>{
            var e, i, n, r, s, a, o, h, l, c, u, d, p, f, m, g = !1;
            function v() {
                if (!g) {
                    g = !0;
                    var t = navigator.userAgent
                      , v = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(t)
                      , y = /(Mac OS X)|(Windows)|(Linux)/.exec(t);
                    if (d = /\b(iPhone|iP[ao]d)/.exec(t),
                    p = /\b(iP[ao]d)/.exec(t),
                    c = /Android/i.exec(t),
                    f = /FBAN\/\w+;/i.exec(t),
                    m = /Mobile/i.exec(t),
                    u = !!/Win64/.exec(t),
                    v) {
                        (e = v[1] ? parseFloat(v[1]) : v[5] ? parseFloat(v[5]) : NaN) && document && document.documentMode && (e = document.documentMode);
                        var x = /(?:Trident\/(\d+.\d+))/.exec(t);
                        a = x ? parseFloat(x[1]) + 4 : e,
                        i = v[2] ? parseFloat(v[2]) : NaN,
                        n = v[3] ? parseFloat(v[3]) : NaN,
                        (r = v[4] ? parseFloat(v[4]) : NaN) ? (v = /(?:Chrome\/(\d+\.\d+))/.exec(t),
                        s = v && v[1] ? parseFloat(v[1]) : NaN) : s = NaN
                    } else
                        e = i = n = s = r = NaN;
                    if (y) {
                        if (y[1]) {
                            var _ = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(t);
                            o = !_ || parseFloat(_[1].replace("_", "."))
                        } else
                            o = !1;
                        h = !!y[2],
                        l = !!y[3]
                    } else
                        o = h = l = !1
                }
            }
            var y = {
                ie: function() {
                    return v() || e
                },
                ieCompatibilityMode: function() {
                    return v() || a > e
                },
                ie64: function() {
                    return y.ie() && u
                },
                firefox: function() {
                    return v() || i
                },
                opera: function() {
                    return v() || n
                },
                webkit: function() {
                    return v() || r
                },
                safari: function() {
                    return y.webkit()
                },
                chrome: function() {
                    return v() || s
                },
                windows: function() {
                    return v() || h
                },
                osx: function() {
                    return v() || o
                },
                linux: function() {
                    return v() || l
                },
                iphone: function() {
                    return v() || d
                },
                mobile: function() {
                    return v() || d || p || c || m
                },
                nativeApp: function() {
                    return v() || f
                },
                android: function() {
                    return v() || c
                },
                ipad: function() {
                    return v() || p
                }
            };
            t.exports = y
        }
        ,
        4284: (t,e,i)=>{
            "use strict";
            var n, r = i(7230);
            r.canUseDOM && (n = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", "")),
            t.exports = function(t, e) {
                if (!r.canUseDOM || e && !("addEventListener"in document))
                    return !1;
                var i = "on" + t
                  , s = i in document;
                if (!s) {
                    var a = document.createElement("div");
                    a.setAttribute(i, "return;"),
                    s = "function" == typeof a[i]
                }
                return !s && n && "wheel" === t && (s = document.implementation.hasFeature("Events.wheel", "3.0")),
                s
            }
        }
        ,
        1045: (t,e,i)=>{
            "use strict";
            var n = i(2907)
              , r = i(4284);
            function s(t) {
                var e = 0
                  , i = 0
                  , n = 0
                  , r = 0;
                return "detail"in t && (i = t.detail),
                "wheelDelta"in t && (i = -t.wheelDelta / 120),
                "wheelDeltaY"in t && (i = -t.wheelDeltaY / 120),
                "wheelDeltaX"in t && (e = -t.wheelDeltaX / 120),
                "axis"in t && t.axis === t.HORIZONTAL_AXIS && (e = i,
                i = 0),
                n = 10 * e,
                r = 10 * i,
                "deltaY"in t && (r = t.deltaY),
                "deltaX"in t && (n = t.deltaX),
                (n || r) && t.deltaMode && (1 == t.deltaMode ? (n *= 40,
                r *= 40) : (n *= 800,
                r *= 800)),
                n && !e && (e = n < 1 ? -1 : 1),
                r && !i && (i = r < 1 ? -1 : 1),
                {
                    spinX: e,
                    spinY: i,
                    pixelX: n,
                    pixelY: r
                }
            }
            s.getEventType = function() {
                return n.firefox() ? "DOMMouseScroll" : r("wheel") ? "wheel" : "mousewheel"
            }
            ,
            t.exports = s
        }
    }
      , e = {};
    function i(n) {
        var r = e[n];
        if (void 0 !== r)
            return r.exports;
        var s = e[n] = {
            id: n,
            loaded: !1,
            exports: {}
        };
        return t[n](s, s.exports, i),
        s.loaded = !0,
        s.exports
    }
    i.n = t=>{
        var e = t && t.__esModule ? ()=>t.default : ()=>t;
        return i.d(e, {
            a: e
        }),
        e
    }
    ,
    i.d = (t,e)=>{
        for (var n in e)
            i.o(e, n) && !i.o(t, n) && Object.defineProperty(t, n, {
                enumerable: !0,
                get: e[n]
            })
    }
    ,
    i.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window)
                return window
        }
    }(),
    i.o = (t,e)=>Object.prototype.hasOwnProperty.call(t, e),
    i.nmd = t=>(t.paths = [],
    t.children || (t.children = []),
    t),
    (()=>{
        var t;
        i.g.importScripts && (t = i.g.location + "");
        var e = i.g.document;
        if (!t && e && (e.currentScript && (t = e.currentScript.src),
        !t)) {
            var n = e.getElementsByTagName("script");
            n.length && (t = n[n.length - 1].src)
        }
        if (!t)
            throw new Error("Automatic publicPath is not supported in this browser");
        t = t.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"),
        i.p = t
    }
    )(),
    (()=>{
        "use strict";
        function t(t) {
            if (void 0 === t)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }
        function e(t, e) {
            t.prototype = Object.create(e.prototype),
            t.prototype.constructor = t,
            t.__proto__ = e
        }
        i(6955);
        var n, r, s, a, o, h, l, c, u, d, p, f, m, g = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        }, v = {
            duration: .5,
            overwrite: !1,
            delay: 0
        }, y = 1e8, x = 1e-8, _ = 2 * Math.PI, b = _ / 4, w = 0, M = Math.sqrt, T = Math.cos, E = Math.sin, S = function(t) {
            return "string" == typeof t
        }, A = function(t) {
            return "function" == typeof t
        }, L = function(t) {
            return "number" == typeof t
        }, P = function(t) {
            return void 0 === t
        }, C = function(t) {
            return "object" == typeof t
        }, R = function(t) {
            return !1 !== t
        }, O = function() {
            return "undefined" != typeof window
        }, D = function(t) {
            return A(t) || S(t)
        }, I = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {}
        , N = Array.isArray, z = /(?:-?\.?\d|\.)+/gi, B = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, k = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, F = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, U = /[+-]=-?[.\d]+/, H = /[^,'"\[\]\s]+/gi, j = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, G = {}, W = {}, V = function(t) {
            return (W = vt(t, G)) && ri
        }, q = function(t, e) {
            return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
        }, X = function(t, e) {
            return !e && console.warn(t)
        }, Y = function(t, e) {
            return t && (G[t] = e) && W && (W[t] = e) || G
        }, Z = function() {
            return 0
        }, J = {}, $ = [], Q = {}, K = {}, tt = {}, et = 30, it = [], nt = "", rt = function(t) {
            var e, i, n = t[0];
            if (C(n) || A(n) || (t = [t]),
            !(e = (n._gsap || {}).harness)) {
                for (i = it.length; i-- && !it[i].targetTest(n); )
                    ;
                e = it[i]
            }
            for (i = t.length; i--; )
                t[i] && (t[i]._gsap || (t[i]._gsap = new Ae(t[i],e))) || t.splice(i, 1);
            return t
        }, st = function(t) {
            return t._gsap || rt(Xt(t))[0]._gsap
        }, at = function(t, e, i) {
            return (i = t[e]) && A(i) ? t[e]() : P(i) && t.getAttribute && t.getAttribute(e) || i
        }, ot = function(t, e) {
            return (t = t.split(",")).forEach(e) || t
        }, ht = function(t) {
            return Math.round(1e5 * t) / 1e5 || 0
        }, lt = function(t) {
            return Math.round(1e7 * t) / 1e7 || 0
        }, ct = function(t, e) {
            var i = e.charAt(0)
              , n = parseFloat(e.substr(2));
            return t = parseFloat(t),
            "+" === i ? t + n : "-" === i ? t - n : "*" === i ? t * n : t / n
        }, ut = function(t, e) {
            for (var i = e.length, n = 0; t.indexOf(e[n]) < 0 && ++n < i; )
                ;
            return n < i
        }, dt = function() {
            var t, e, i = $.length, n = $.slice(0);
            for (Q = {},
            $.length = 0,
            t = 0; t < i; t++)
                (e = n[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
        }, pt = function(t, e, i, n) {
            $.length && dt(),
            t.render(e, i, n),
            $.length && dt()
        }, ft = function(t) {
            var e = parseFloat(t);
            return (e || 0 === e) && (t + "").match(H).length < 2 ? e : S(t) ? t.trim() : t
        }, mt = function(t) {
            return t
        }, gt = function(t, e) {
            for (var i in e)
                i in t || (t[i] = e[i]);
            return t
        }, vt = function(t, e) {
            for (var i in e)
                t[i] = e[i];
            return t
        }, yt = function t(e, i) {
            for (var n in i)
                "__proto__" !== n && "constructor" !== n && "prototype" !== n && (e[n] = C(i[n]) ? t(e[n] || (e[n] = {}), i[n]) : i[n]);
            return e
        }, xt = function(t, e) {
            var i, n = {};
            for (i in t)
                i in e || (n[i] = t[i]);
            return n
        }, _t = function(t) {
            var e, i = t.parent || r, n = t.keyframes ? (e = N(t.keyframes),
            function(t, i) {
                for (var n in i)
                    n in t || "duration" === n && e || "ease" === n || (t[n] = i[n])
            }
            ) : gt;
            if (R(t.inherit))
                for (; i; )
                    n(t, i.vars.defaults),
                    i = i.parent || i._dp;
            return t
        }, bt = function(t, e, i, n, r) {
            void 0 === i && (i = "_first"),
            void 0 === n && (n = "_last");
            var s, a = t[n];
            if (r)
                for (s = e[r]; a && a[r] > s; )
                    a = a._prev;
            return a ? (e._next = a._next,
            a._next = e) : (e._next = t[i],
            t[i] = e),
            e._next ? e._next._prev = e : t[n] = e,
            e._prev = a,
            e.parent = e._dp = t,
            e
        }, wt = function(t, e, i, n) {
            void 0 === i && (i = "_first"),
            void 0 === n && (n = "_last");
            var r = e._prev
              , s = e._next;
            r ? r._next = s : t[i] === e && (t[i] = s),
            s ? s._prev = r : t[n] === e && (t[n] = r),
            e._next = e._prev = e.parent = null
        }, Mt = function(t, e) {
            t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t),
            t._act = 0
        }, Tt = function(t, e) {
            if (t && (!e || e._end > t._dur || e._start < 0))
                for (var i = t; i; )
                    i._dirty = 1,
                    i = i.parent;
            return t
        }, Et = function t(e) {
            return !e || e._ts && t(e.parent)
        }, St = function(t) {
            return t._repeat ? At(t._tTime, t = t.duration() + t._rDelay) * t : 0
        }, At = function(t, e) {
            var i = Math.floor(t /= e);
            return t && i === t ? i - 1 : i
        }, Lt = function(t, e) {
            return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
        }, Pt = function(t) {
            return t._end = lt(t._start + (t._tDur / Math.abs(t._ts || t._rts || x) || 0))
        }, Ct = function(t, e) {
            var i = t._dp;
            return i && i.smoothChildTiming && t._ts && (t._start = lt(i._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)),
            Pt(t),
            i._dirty || Tt(i, t)),
            t
        }, Rt = function(t, e) {
            var i;
            if ((e._time || e._initted && !e._dur) && (i = Lt(t.rawTime(), e),
            (!e._dur || Gt(0, e.totalDuration(), i) - e._tTime > x) && e.render(i, !0)),
            Tt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                if (t._dur < t.duration())
                    for (i = t; i._dp; )
                        i.rawTime() >= 0 && i.totalTime(i._tTime),
                        i = i._dp;
                t._zTime = -1e-8
            }
        }, Ot = function(t, e, i, n) {
            return e.parent && Mt(e),
            e._start = lt((L(i) ? i : i || t !== r ? Ut(t, i, e) : t._time) + e._delay),
            e._end = lt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
            bt(t, e, "_first", "_last", t._sort ? "_start" : 0),
            zt(e) || (t._recent = e),
            n || Rt(t, e),
            t
        }, Dt = function(t, e) {
            return (G.ScrollTrigger || q("scrollTrigger", e)) && G.ScrollTrigger.create(e, t)
        }, It = function(t, e, i, n) {
            return Ne(t, e),
            t._initted ? !i && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && l !== fe.frame ? ($.push(t),
            t._lazy = [e, n],
            1) : void 0 : 1
        }, Nt = function t(e) {
            var i = e.parent;
            return i && i._ts && i._initted && !i._lock && (i.rawTime() < 0 || t(i))
        }, zt = function(t) {
            var e = t.data;
            return "isFromStart" === e || "isStart" === e
        }, Bt = function(t, e, i, n) {
            var r = t._repeat
              , s = lt(e) || 0
              , a = t._tTime / t._tDur;
            return a && !n && (t._time *= s / t._dur),
            t._dur = s,
            t._tDur = r ? r < 0 ? 1e10 : lt(s * (r + 1) + t._rDelay * r) : s,
            a > 0 && !n ? Ct(t, t._tTime = t._tDur * a) : t.parent && Pt(t),
            i || Tt(t.parent, t),
            t
        }, kt = function(t) {
            return t instanceof Pe ? Tt(t) : Bt(t, t._dur)
        }, Ft = {
            _start: 0,
            endTime: Z,
            totalDuration: Z
        }, Ut = function t(e, i, n) {
            var r, s, a, o = e.labels, h = e._recent || Ft, l = e.duration() >= y ? h.endTime(!1) : e._dur;
            return S(i) && (isNaN(i) || i in o) ? (s = i.charAt(0),
            a = "%" === i.substr(-1),
            r = i.indexOf("="),
            "<" === s || ">" === s ? (r >= 0 && (i = i.replace(/=/, "")),
            ("<" === s ? h._start : h.endTime(h._repeat >= 0)) + (parseFloat(i.substr(1)) || 0) * (a ? (r < 0 ? h : n).totalDuration() / 100 : 1)) : r < 0 ? (i in o || (o[i] = l),
            o[i]) : (s = parseFloat(i.charAt(r - 1) + i.substr(r + 1)),
            a && n && (s = s / 100 * (N(n) ? n[0] : n).totalDuration()),
            r > 1 ? t(e, i.substr(0, r - 1), n) + s : l + s)) : null == i ? l : +i
        }, Ht = function(t, e, i) {
            var n, r, s = L(e[1]), a = (s ? 2 : 1) + (t < 2 ? 0 : 1), o = e[a];
            if (s && (o.duration = e[1]),
            o.parent = i,
            t) {
                for (n = o,
                r = i; r && !("immediateRender"in n); )
                    n = r.vars.defaults || {},
                    r = R(r.vars.inherit) && r.parent;
                o.immediateRender = R(n.immediateRender),
                t < 2 ? o.runBackwards = 1 : o.startAt = e[a - 1]
            }
            return new Ue(e[0],o,e[a + 1])
        }, jt = function(t, e) {
            return t || 0 === t ? e(t) : e
        }, Gt = function(t, e, i) {
            return i < t ? t : i > e ? e : i
        }, Wt = function(t, e) {
            return S(t) && (e = j.exec(t)) ? e[1] : ""
        }, Vt = [].slice, qt = function(t, e) {
            return t && C(t) && "length"in t && (!e && !t.length || t.length - 1 in t && C(t[0])) && !t.nodeType && t !== s
        }, Xt = function(t, e, i) {
            return !S(t) || i || !a && me() ? N(t) ? function(t, e, i) {
                return void 0 === i && (i = []),
                t.forEach((function(t) {
                    var n;
                    return S(t) && !e || qt(t, 1) ? (n = i).push.apply(n, Xt(t)) : i.push(t)
                }
                )) || i
            }(t, i) : qt(t) ? Vt.call(t, 0) : t ? [t] : [] : Vt.call((e || o).querySelectorAll(t), 0)
        }, Yt = function(t) {
            return t.sort((function() {
                return .5 - Math.random()
            }
            ))
        }, Zt = function(t) {
            if (A(t))
                return t;
            var e = C(t) ? t : {
                each: t
            }
              , i = we(e.ease)
              , n = e.from || 0
              , r = parseFloat(e.base) || 0
              , s = {}
              , a = n > 0 && n < 1
              , o = isNaN(n) || a
              , h = e.axis
              , l = n
              , c = n;
            return S(n) ? l = c = {
                center: .5,
                edges: .5,
                end: 1
            }[n] || 0 : !a && o && (l = n[0],
            c = n[1]),
            function(t, a, u) {
                var d, p, f, m, g, v, x, _, b, w = (u || e).length, T = s[w];
                if (!T) {
                    if (!(b = "auto" === e.grid ? 0 : (e.grid || [1, y])[1])) {
                        for (x = -y; x < (x = u[b++].getBoundingClientRect().left) && b < w; )
                            ;
                        b--
                    }
                    for (T = s[w] = [],
                    d = o ? Math.min(b, w) * l - .5 : n % b,
                    p = b === y ? 0 : o ? w * c / b - .5 : n / b | 0,
                    x = 0,
                    _ = y,
                    v = 0; v < w; v++)
                        f = v % b - d,
                        m = p - (v / b | 0),
                        T[v] = g = h ? Math.abs("y" === h ? m : f) : M(f * f + m * m),
                        g > x && (x = g),
                        g < _ && (_ = g);
                    "random" === n && Yt(T),
                    T.max = x - _,
                    T.min = _,
                    T.v = w = (parseFloat(e.amount) || parseFloat(e.each) * (b > w ? w - 1 : h ? "y" === h ? w / b : b : Math.max(b, w / b)) || 0) * ("edges" === n ? -1 : 1),
                    T.b = w < 0 ? r - w : r,
                    T.u = Wt(e.amount || e.each) || 0,
                    i = i && w < 0 ? _e(i) : i
                }
                return w = (T[t] - T.min) / T.max || 0,
                lt(T.b + (i ? i(w) : w) * T.v) + T.u
            }
        }, Jt = function(t) {
            var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
            return function(i) {
                var n = Math.round(parseFloat(i) / t) * t * e;
                return (n - n % 1) / e + (L(i) ? 0 : Wt(i))
            }
        }, $t = function(t, e) {
            var i, n, r = N(t);
            return !r && C(t) && (i = r = t.radius || y,
            t.values ? (t = Xt(t.values),
            (n = !L(t[0])) && (i *= i)) : t = Jt(t.increment)),
            jt(e, r ? A(t) ? function(e) {
                return n = t(e),
                Math.abs(n - e) <= i ? n : e
            }
            : function(e) {
                for (var r, s, a = parseFloat(n ? e.x : e), o = parseFloat(n ? e.y : 0), h = y, l = 0, c = t.length; c--; )
                    (r = n ? (r = t[c].x - a) * r + (s = t[c].y - o) * s : Math.abs(t[c] - a)) < h && (h = r,
                    l = c);
                return l = !i || h <= i ? t[l] : e,
                n || l === e || L(e) ? l : l + Wt(e)
            }
            : Jt(t))
        }, Qt = function(t, e, i, n) {
            return jt(N(t) ? !e : !0 === i ? !!(i = 0) : !n, (function() {
                return N(t) ? t[~~(Math.random() * t.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((t - i / 2 + Math.random() * (e - t + .99 * i)) / i) * i * n) / n
            }
            ))
        }, Kt = function(t, e, i) {
            return jt(i, (function(i) {
                return t[~~e(i)]
            }
            ))
        }, te = function(t) {
            for (var e, i, n, r, s = 0, a = ""; ~(e = t.indexOf("random(", s)); )
                n = t.indexOf(")", e),
                r = "[" === t.charAt(e + 7),
                i = t.substr(e + 7, n - e - 7).match(r ? H : z),
                a += t.substr(s, e - s) + Qt(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5),
                s = n + 1;
            return a + t.substr(s, t.length - s)
        }, ee = function(t, e, i, n, r) {
            var s = e - t
              , a = n - i;
            return jt(r, (function(e) {
                return i + ((e - t) / s * a || 0)
            }
            ))
        }, ie = function(t, e, i) {
            var n, r, s, a = t.labels, o = y;
            for (n in a)
                (r = a[n] - e) < 0 == !!i && r && o > (r = Math.abs(r)) && (s = n,
                o = r);
            return s
        }, ne = function(t, e, i) {
            var n, r, s = t.vars, a = s[e];
            if (a)
                return n = s[e + "Params"],
                r = s.callbackScope || t,
                i && $.length && dt(),
                n ? a.apply(r, n) : a.call(r)
        }, re = function(t) {
            return Mt(t),
            t.scrollTrigger && t.scrollTrigger.kill(!1),
            t.progress() < 1 && ne(t, "onInterrupt"),
            t
        }, se = 255, ae = {
            aqua: [0, se, se],
            lime: [0, se, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, se],
            navy: [0, 0, 128],
            white: [se, se, se],
            olive: [128, 128, 0],
            yellow: [se, se, 0],
            orange: [se, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [se, 0, 0],
            pink: [se, 192, 203],
            cyan: [0, se, se],
            transparent: [se, se, se, 0]
        }, oe = function(t, e, i) {
            return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) * se + .5 | 0
        }, he = function(t, e, i) {
            var n, r, s, a, o, h, l, c, u, d, p = t ? L(t) ? [t >> 16, t >> 8 & se, t & se] : 0 : ae.black;
            if (!p) {
                if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)),
                ae[t])
                    p = ae[t];
                else if ("#" === t.charAt(0)) {
                    if (t.length < 6 && (n = t.charAt(1),
                    r = t.charAt(2),
                    s = t.charAt(3),
                    t = "#" + n + n + r + r + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")),
                    9 === t.length)
                        return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & se, p & se, parseInt(t.substr(7), 16) / 255];
                    p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & se, t & se]
                } else if ("hsl" === t.substr(0, 3))
                    if (p = d = t.match(z),
                    e) {
                        if (~t.indexOf("="))
                            return p = t.match(B),
                            i && p.length < 4 && (p[3] = 1),
                            p
                    } else
                        a = +p[0] % 360 / 360,
                        o = +p[1] / 100,
                        n = 2 * (h = +p[2] / 100) - (r = h <= .5 ? h * (o + 1) : h + o - h * o),
                        p.length > 3 && (p[3] *= 1),
                        p[0] = oe(a + 1 / 3, n, r),
                        p[1] = oe(a, n, r),
                        p[2] = oe(a - 1 / 3, n, r);
                else
                    p = t.match(z) || ae.transparent;
                p = p.map(Number)
            }
            return e && !d && (n = p[0] / se,
            r = p[1] / se,
            s = p[2] / se,
            h = ((l = Math.max(n, r, s)) + (c = Math.min(n, r, s))) / 2,
            l === c ? a = o = 0 : (u = l - c,
            o = h > .5 ? u / (2 - l - c) : u / (l + c),
            a = l === n ? (r - s) / u + (r < s ? 6 : 0) : l === r ? (s - n) / u + 2 : (n - r) / u + 4,
            a *= 60),
            p[0] = ~~(a + .5),
            p[1] = ~~(100 * o + .5),
            p[2] = ~~(100 * h + .5)),
            i && p.length < 4 && (p[3] = 1),
            p
        }, le = function(t) {
            var e = []
              , i = []
              , n = -1;
            return t.split(ue).forEach((function(t) {
                var r = t.match(k) || [];
                e.push.apply(e, r),
                i.push(n += r.length + 1)
            }
            )),
            e.c = i,
            e
        }, ce = function(t, e, i) {
            var n, r, s, a, o = "", h = (t + o).match(ue), l = e ? "hsla(" : "rgba(", c = 0;
            if (!h)
                return t;
            if (h = h.map((function(t) {
                return (t = he(t, e, 1)) && l + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
            }
            )),
            i && (s = le(t),
            (n = i.c).join(o) !== s.c.join(o)))
                for (a = (r = t.replace(ue, "1").split(k)).length - 1; c < a; c++)
                    o += r[c] + (~n.indexOf(c) ? h.shift() || l + "0,0,0,0)" : (s.length ? s : h.length ? h : i).shift());
            if (!r)
                for (a = (r = t.split(ue)).length - 1; c < a; c++)
                    o += r[c] + h[c];
            return o + r[a]
        }, ue = function() {
            var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (t in ae)
                e += "|" + t + "\\b";
            return new RegExp(e + ")","gi")
        }(), de = /hsl[a]?\(/, pe = function(t) {
            var e, i = t.join(" ");
            if (ue.lastIndex = 0,
            ue.test(i))
                return e = de.test(i),
                t[1] = ce(t[1], e),
                t[0] = ce(t[0], e, le(t[1])),
                !0
        }, fe = function() {
            var t, e, i, n, r, l, c = Date.now, d = 500, p = 33, f = c(), m = f, g = 1e3 / 240, v = g, y = [], x = function i(s) {
                var a, o, h, u, x = c() - m, _ = !0 === s;
                if (x > d && (f += x - p),
                ((a = (h = (m += x) - f) - v) > 0 || _) && (u = ++n.frame,
                r = h - 1e3 * n.time,
                n.time = h /= 1e3,
                v += a + (a >= g ? 4 : g - a),
                o = 1),
                _ || (t = e(i)),
                o)
                    for (l = 0; l < y.length; l++)
                        y[l](h, r, u, s)
            };
            return n = {
                time: 0,
                frame: 0,
                tick: function() {
                    x(!0)
                },
                deltaRatio: function(t) {
                    return r / (1e3 / (t || 60))
                },
                wake: function() {
                    h && (!a && O() && (s = a = window,
                    o = s.document || {},
                    G.gsap = ri,
                    (s.gsapVersions || (s.gsapVersions = [])).push(ri.version),
                    V(W || s.GreenSockGlobals || !s.gsap && s || {}),
                    i = s.requestAnimationFrame),
                    t && n.sleep(),
                    e = i || function(t) {
                        return setTimeout(t, v - 1e3 * n.time + 1 | 0)
                    }
                    ,
                    u = 1,
                    x(2))
                },
                sleep: function() {
                    (i ? s.cancelAnimationFrame : clearTimeout)(t),
                    u = 0,
                    e = Z
                },
                lagSmoothing: function(t, e) {
                    d = t || 1e8,
                    p = Math.min(e, d, 0)
                },
                fps: function(t) {
                    g = 1e3 / (t || 240),
                    v = 1e3 * n.time + g
                },
                add: function(t, e, i) {
                    var r = e ? function(e, i, s, a) {
                        t(e, i, s, a),
                        n.remove(r)
                    }
                    : t;
                    return n.remove(t),
                    y[i ? "unshift" : "push"](r),
                    me(),
                    r
                },
                remove: function(t, e) {
                    ~(e = y.indexOf(t)) && y.splice(e, 1) && l >= e && l--
                },
                _listeners: y
            }
        }(), me = function() {
            return !u && fe.wake()
        }, ge = {}, ve = /^[\d.\-M][\d.\-,\s]/, ye = /["']/g, xe = function(t) {
            for (var e, i, n, r = {}, s = t.substr(1, t.length - 3).split(":"), a = s[0], o = 1, h = s.length; o < h; o++)
                i = s[o],
                e = o !== h - 1 ? i.lastIndexOf(",") : i.length,
                n = i.substr(0, e),
                r[a] = isNaN(n) ? n.replace(ye, "").trim() : +n,
                a = i.substr(e + 1).trim();
            return r
        }, _e = function(t) {
            return function(e) {
                return 1 - t(1 - e)
            }
        }, be = function t(e, i) {
            for (var n, r = e._first; r; )
                r instanceof Pe ? t(r, i) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === i || (r.timeline ? t(r.timeline, i) : (n = r._ease,
                r._ease = r._yEase,
                r._yEase = n,
                r._yoyo = i)),
                r = r._next
        }, we = function(t, e) {
            return t && (A(t) ? t : ge[t] || function(t) {
                var e, i, n, r, s = (t + "").split("("), a = ge[s[0]];
                return a && s.length > 1 && a.config ? a.config.apply(null, ~t.indexOf("{") ? [xe(s[1])] : (e = t,
                i = e.indexOf("(") + 1,
                n = e.indexOf(")"),
                r = e.indexOf("(", i),
                e.substring(i, ~r && r < n ? e.indexOf(")", n + 1) : n)).split(",").map(ft)) : ge._CE && ve.test(t) ? ge._CE("", t) : a
            }(t)) || e
        }, Me = function(t, e, i, n) {
            void 0 === i && (i = function(t) {
                return 1 - e(1 - t)
            }
            ),
            void 0 === n && (n = function(t) {
                return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
            }
            );
            var r, s = {
                easeIn: e,
                easeOut: i,
                easeInOut: n
            };
            return ot(t, (function(t) {
                for (var e in ge[t] = G[t] = s,
                ge[r = t.toLowerCase()] = i,
                s)
                    ge[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = ge[t + "." + e] = s[e]
            }
            )),
            s
        }, Te = function(t) {
            return function(e) {
                return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
            }
        }, Ee = function t(e, i, n) {
            var r = i >= 1 ? i : 1
              , s = (n || (e ? .3 : .45)) / (i < 1 ? i : 1)
              , a = s / _ * (Math.asin(1 / r) || 0)
              , o = function(t) {
                return 1 === t ? 1 : r * Math.pow(2, -10 * t) * E((t - a) * s) + 1
            }
              , h = "out" === e ? o : "in" === e ? function(t) {
                return 1 - o(1 - t)
            }
            : Te(o);
            return s = _ / s,
            h.config = function(i, n) {
                return t(e, i, n)
            }
            ,
            h
        }, Se = function t(e, i) {
            void 0 === i && (i = 1.70158);
            var n = function(t) {
                return t ? --t * t * ((i + 1) * t + i) + 1 : 0
            }
              , r = "out" === e ? n : "in" === e ? function(t) {
                return 1 - n(1 - t)
            }
            : Te(n);
            return r.config = function(i) {
                return t(e, i)
            }
            ,
            r
        };
        ot("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
            var i = e < 5 ? e + 1 : e;
            Me(t + ",Power" + (i - 1), e ? function(t) {
                return Math.pow(t, i)
            }
            : function(t) {
                return t
            }
            , (function(t) {
                return 1 - Math.pow(1 - t, i)
            }
            ), (function(t) {
                return t < .5 ? Math.pow(2 * t, i) / 2 : 1 - Math.pow(2 * (1 - t), i) / 2
            }
            ))
        }
        )),
        ge.Linear.easeNone = ge.none = ge.Linear.easeIn,
        Me("Elastic", Ee("in"), Ee("out"), Ee()),
        d = 7.5625,
        f = 1 / (p = 2.75),
        Me("Bounce", (function(t) {
            return 1 - m(1 - t)
        }
        ), m = function(t) {
            return t < f ? d * t * t : t < .7272727272727273 ? d * Math.pow(t - 1.5 / p, 2) + .75 : t < .9090909090909092 ? d * (t -= 2.25 / p) * t + .9375 : d * Math.pow(t - 2.625 / p, 2) + .984375
        }
        ),
        Me("Expo", (function(t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0
        }
        )),
        Me("Circ", (function(t) {
            return -(M(1 - t * t) - 1)
        }
        )),
        Me("Sine", (function(t) {
            return 1 === t ? 1 : 1 - T(t * b)
        }
        )),
        Me("Back", Se("in"), Se("out"), Se()),
        ge.SteppedEase = ge.steps = G.SteppedEase = {
            config: function(t, e) {
                void 0 === t && (t = 1);
                var i = 1 / t
                  , n = t + (e ? 0 : 1)
                  , r = e ? 1 : 0;
                return function(t) {
                    return ((n * Gt(0, .99999999, t) | 0) + r) * i
                }
            }
        },
        v.ease = ge["quad.out"],
        ot("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
            return nt += t + "," + t + "Params,"
        }
        ));
        var Ae = function(t, e) {
            this.id = w++,
            t._gsap = this,
            this.target = t,
            this.harness = e,
            this.get = e ? e.get : at,
            this.set = e ? e.getSetter : Ve
        }
          , Le = function() {
            function t(t) {
                this.vars = t,
                this._delay = +t.delay || 0,
                (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
                this._yoyo = !!t.yoyo || !!t.yoyoEase),
                this._ts = 1,
                Bt(this, +t.duration, 1, 1),
                this.data = t.data,
                u || fe.wake()
            }
            var e = t.prototype;
            return e.delay = function(t) {
                return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay),
                this._delay = t,
                this) : this._delay
            }
            ,
            e.duration = function(t) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
            }
            ,
            e.totalDuration = function(t) {
                return arguments.length ? (this._dirty = 0,
                Bt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }
            ,
            e.totalTime = function(t, e) {
                if (me(),
                !arguments.length)
                    return this._tTime;
                var i = this._dp;
                if (i && i.smoothChildTiming && this._ts) {
                    for (Ct(this, t),
                    !i._dp || i.parent || Rt(i, this); i && i.parent; )
                        i.parent._time !== i._start + (i._ts >= 0 ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0),
                        i = i.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Ot(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === x || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t),
                pt(this, t, e)),
                this
            }
            ,
            e.time = function(t, e) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + St(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
            }
            ,
            e.totalProgress = function(t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }
            ,
            e.progress = function(t, e) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + St(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }
            ,
            e.iteration = function(t, e) {
                var i = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (t - 1) * i, e) : this._repeat ? At(this._tTime, i) + 1 : 1
            }
            ,
            e.timeScale = function(t) {
                if (!arguments.length)
                    return -1e-8 === this._rts ? 0 : this._rts;
                if (this._rts === t)
                    return this;
                var e = this.parent && this._ts ? Lt(this.parent._time, this) : this._tTime;
                return this._rts = +t || 0,
                this._ts = this._ps || -1e-8 === t ? 0 : this._rts,
                this.totalTime(Gt(-this._delay, this._tDur, e), !0),
                Pt(this),
                function(t) {
                    for (var e = t.parent; e && e.parent; )
                        e._dirty = 1,
                        e.totalDuration(),
                        e = e.parent;
                    return t
                }(this)
            }
            ,
            e.paused = function(t) {
                return arguments.length ? (this._ps !== t && (this._ps = t,
                t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
                this._ts = this._act = 0) : (me(),
                this._ts = this._rts,
                this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== x && (this._tTime -= x)))),
                this) : this._ps
            }
            ,
            e.startTime = function(t) {
                if (arguments.length) {
                    this._start = t;
                    var e = this.parent || this._dp;
                    return e && (e._sort || !this.parent) && Ot(e, this, t - this._delay),
                    this
                }
                return this._start
            }
            ,
            e.endTime = function(t) {
                return this._start + (R(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }
            ,
            e.rawTime = function(t) {
                var e = this.parent || this._dp;
                return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Lt(e.rawTime(t), this) : this._tTime : this._tTime
            }
            ,
            e.globalTime = function(t) {
                for (var e = this, i = arguments.length ? t : e.rawTime(); e; )
                    i = e._start + i / (e._ts || 1),
                    e = e._dp;
                return i
            }
            ,
            e.repeat = function(t) {
                return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t,
                kt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
            }
            ,
            e.repeatDelay = function(t) {
                if (arguments.length) {
                    var e = this._time;
                    return this._rDelay = t,
                    kt(this),
                    e ? this.time(e) : this
                }
                return this._rDelay
            }
            ,
            e.yoyo = function(t) {
                return arguments.length ? (this._yoyo = t,
                this) : this._yoyo
            }
            ,
            e.seek = function(t, e) {
                return this.totalTime(Ut(this, t), R(e))
            }
            ,
            e.restart = function(t, e) {
                return this.play().totalTime(t ? -this._delay : 0, R(e))
            }
            ,
            e.play = function(t, e) {
                return null != t && this.seek(t, e),
                this.reversed(!1).paused(!1)
            }
            ,
            e.reverse = function(t, e) {
                return null != t && this.seek(t || this.totalDuration(), e),
                this.reversed(!0).paused(!1)
            }
            ,
            e.pause = function(t, e) {
                return null != t && this.seek(t, e),
                this.paused(!0)
            }
            ,
            e.resume = function() {
                return this.paused(!1)
            }
            ,
            e.reversed = function(t) {
                return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)),
                this) : this._rts < 0
            }
            ,
            e.invalidate = function() {
                return this._initted = this._act = 0,
                this._zTime = -1e-8,
                this
            }
            ,
            e.isActive = function() {
                var t, e = this.parent || this._dp, i = this._start;
                return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= i && t < this.endTime(!0) - x))
            }
            ,
            e.eventCallback = function(t, e, i) {
                var n = this.vars;
                return arguments.length > 1 ? (e ? (n[t] = e,
                i && (n[t + "Params"] = i),
                "onUpdate" === t && (this._onUpdate = e)) : delete n[t],
                this) : n[t]
            }
            ,
            e.then = function(t) {
                var e = this;
                return new Promise((function(i) {
                    var n = A(t) ? t : mt
                      , r = function() {
                        var t = e.then;
                        e.then = null,
                        A(n) && (n = n(e)) && (n.then || n === e) && (e.then = t),
                        i(n),
                        e.then = t
                    };
                    e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                }
                ))
            }
            ,
            e.kill = function() {
                re(this)
            }
            ,
            t
        }();
        gt(Le.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Pe = function(i) {
            function n(e, n) {
                var s;
                return void 0 === e && (e = {}),
                (s = i.call(this, e) || this).labels = {},
                s.smoothChildTiming = !!e.smoothChildTiming,
                s.autoRemoveChildren = !!e.autoRemoveChildren,
                s._sort = R(e.sortChildren),
                r && Ot(e.parent || r, t(s), n),
                e.reversed && s.reverse(),
                e.paused && s.paused(!0),
                e.scrollTrigger && Dt(t(s), e.scrollTrigger),
                s
            }
            e(n, i);
            var s = n.prototype;
            return s.to = function(t, e, i) {
                return Ht(0, arguments, this),
                this
            }
            ,
            s.from = function(t, e, i) {
                return Ht(1, arguments, this),
                this
            }
            ,
            s.fromTo = function(t, e, i, n) {
                return Ht(2, arguments, this),
                this
            }
            ,
            s.set = function(t, e, i) {
                return e.duration = 0,
                e.parent = this,
                _t(e).repeatDelay || (e.repeat = 0),
                e.immediateRender = !!e.immediateRender,
                new Ue(t,e,Ut(this, i),1),
                this
            }
            ,
            s.call = function(t, e, i) {
                return Ot(this, Ue.delayedCall(0, t, e), i)
            }
            ,
            s.staggerTo = function(t, e, i, n, r, s, a) {
                return i.duration = e,
                i.stagger = i.stagger || n,
                i.onComplete = s,
                i.onCompleteParams = a,
                i.parent = this,
                new Ue(t,i,Ut(this, r)),
                this
            }
            ,
            s.staggerFrom = function(t, e, i, n, r, s, a) {
                return i.runBackwards = 1,
                _t(i).immediateRender = R(i.immediateRender),
                this.staggerTo(t, e, i, n, r, s, a)
            }
            ,
            s.staggerFromTo = function(t, e, i, n, r, s, a, o) {
                return n.startAt = i,
                _t(n).immediateRender = R(n.immediateRender),
                this.staggerTo(t, e, n, r, s, a, o)
            }
            ,
            s.render = function(t, e, i) {
                var n, s, a, o, h, l, c, u, d, p, f, m, g = this._time, v = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, _ = t <= 0 ? 0 : lt(t), b = this._zTime < 0 != t < 0 && (this._initted || !y);
                if (this !== r && _ > v && t >= 0 && (_ = v),
                _ !== this._tTime || i || b) {
                    if (g !== this._time && y && (_ += this._time - g,
                    t += this._time - g),
                    n = _,
                    d = this._start,
                    l = !(u = this._ts),
                    b && (y || (g = this._zTime),
                    (t || !e) && (this._zTime = t)),
                    this._repeat) {
                        if (f = this._yoyo,
                        h = y + this._rDelay,
                        this._repeat < -1 && t < 0)
                            return this.totalTime(100 * h + t, e, i);
                        if (n = lt(_ % h),
                        _ === v ? (o = this._repeat,
                        n = y) : ((o = ~~(_ / h)) && o === _ / h && (n = y,
                        o--),
                        n > y && (n = y)),
                        p = At(this._tTime, h),
                        !g && this._tTime && p !== o && (p = o),
                        f && 1 & o && (n = y - n,
                        m = 1),
                        o !== p && !this._lock) {
                            var w = f && 1 & p
                              , M = w === (f && 1 & o);
                            if (o < p && (w = !w),
                            g = w ? 0 : y,
                            this._lock = 1,
                            this.render(g || (m ? 0 : lt(o * h)), e, !y)._lock = 0,
                            this._tTime = _,
                            !e && this.parent && ne(this, "onRepeat"),
                            this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1),
                            g && g !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                                return this;
                            if (y = this._dur,
                            v = this._tDur,
                            M && (this._lock = 2,
                            g = w ? y : -1e-4,
                            this.render(g, !0),
                            this.vars.repeatRefresh && !m && this.invalidate()),
                            this._lock = 0,
                            !this._ts && !l)
                                return this;
                            be(this, m)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (c = function(t, e, i) {
                        var n;
                        if (i > e)
                            for (n = t._first; n && n._start <= i; ) {
                                if ("isPause" === n.data && n._start > e)
                                    return n;
                                n = n._next
                            }
                        else
                            for (n = t._last; n && n._start >= i; ) {
                                if ("isPause" === n.data && n._start < e)
                                    return n;
                                n = n._prev
                            }
                    }(this, lt(g), lt(n)),
                    c && (_ -= n - (n = c._start))),
                    this._tTime = _,
                    this._time = n,
                    this._act = !u,
                    this._initted || (this._onUpdate = this.vars.onUpdate,
                    this._initted = 1,
                    this._zTime = t,
                    g = 0),
                    !g && n && !e && (ne(this, "onStart"),
                    this._tTime !== _))
                        return this;
                    if (n >= g && t >= 0)
                        for (s = this._first; s; ) {
                            if (a = s._next,
                            (s._act || n >= s._start) && s._ts && c !== s) {
                                if (s.parent !== this)
                                    return this.render(t, e, i);
                                if (s.render(s._ts > 0 ? (n - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (n - s._start) * s._ts, e, i),
                                n !== this._time || !this._ts && !l) {
                                    c = 0,
                                    a && (_ += this._zTime = -1e-8);
                                    break
                                }
                            }
                            s = a
                        }
                    else {
                        s = this._last;
                        for (var T = t < 0 ? t : n; s; ) {
                            if (a = s._prev,
                            (s._act || T <= s._end) && s._ts && c !== s) {
                                if (s.parent !== this)
                                    return this.render(t, e, i);
                                if (s.render(s._ts > 0 ? (T - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (T - s._start) * s._ts, e, i),
                                n !== this._time || !this._ts && !l) {
                                    c = 0,
                                    a && (_ += this._zTime = T ? -1e-8 : x);
                                    break
                                }
                            }
                            s = a
                        }
                    }
                    if (c && !e && (this.pause(),
                    c.render(n >= g ? 0 : -1e-8)._zTime = n >= g ? 1 : -1,
                    this._ts))
                        return this._start = d,
                        Pt(this),
                        this.render(t, e, i);
                    this._onUpdate && !e && ne(this, "onUpdate", !0),
                    (_ === v && this._tTime >= this.totalDuration() || !_ && g) && (d !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((t || !y) && (_ === v && this._ts > 0 || !_ && this._ts < 0) && Mt(this, 1),
                    e || t < 0 && !g || !_ && !g && v || (ne(this, _ === v && t >= 0 ? "onComplete" : "onReverseComplete", !0),
                    this._prom && !(_ < v && this.timeScale() > 0) && this._prom())))
                }
                return this
            }
            ,
            s.add = function(t, e) {
                var i = this;
                if (L(e) || (e = Ut(this, e, t)),
                !(t instanceof Le)) {
                    if (N(t))
                        return t.forEach((function(t) {
                            return i.add(t, e)
                        }
                        )),
                        this;
                    if (S(t))
                        return this.addLabel(t, e);
                    if (!A(t))
                        return this;
                    t = Ue.delayedCall(0, t)
                }
                return this !== t ? Ot(this, t, e) : this
            }
            ,
            s.getChildren = function(t, e, i, n) {
                void 0 === t && (t = !0),
                void 0 === e && (e = !0),
                void 0 === i && (i = !0),
                void 0 === n && (n = -y);
                for (var r = [], s = this._first; s; )
                    s._start >= n && (s instanceof Ue ? e && r.push(s) : (i && r.push(s),
                    t && r.push.apply(r, s.getChildren(!0, e, i)))),
                    s = s._next;
                return r
            }
            ,
            s.getById = function(t) {
                for (var e = this.getChildren(1, 1, 1), i = e.length; i--; )
                    if (e[i].vars.id === t)
                        return e[i]
            }
            ,
            s.remove = function(t) {
                return S(t) ? this.removeLabel(t) : A(t) ? this.killTweensOf(t) : (wt(this, t),
                t === this._recent && (this._recent = this._last),
                Tt(this))
            }
            ,
            s.totalTime = function(t, e) {
                return arguments.length ? (this._forcing = 1,
                !this._dp && this._ts && (this._start = lt(fe.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))),
                i.prototype.totalTime.call(this, t, e),
                this._forcing = 0,
                this) : this._tTime
            }
            ,
            s.addLabel = function(t, e) {
                return this.labels[t] = Ut(this, e),
                this
            }
            ,
            s.removeLabel = function(t) {
                return delete this.labels[t],
                this
            }
            ,
            s.addPause = function(t, e, i) {
                var n = Ue.delayedCall(0, e || Z, i);
                return n.data = "isPause",
                this._hasPause = 1,
                Ot(this, n, Ut(this, t))
            }
            ,
            s.removePause = function(t) {
                var e = this._first;
                for (t = Ut(this, t); e; )
                    e._start === t && "isPause" === e.data && Mt(e),
                    e = e._next
            }
            ,
            s.killTweensOf = function(t, e, i) {
                for (var n = this.getTweensOf(t, i), r = n.length; r--; )
                    Ce !== n[r] && n[r].kill(t, e);
                return this
            }
            ,
            s.getTweensOf = function(t, e) {
                for (var i, n = [], r = Xt(t), s = this._first, a = L(e); s; )
                    s instanceof Ue ? ut(s._targets, r) && (a ? (!Ce || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && n.push(s) : (i = s.getTweensOf(r, e)).length && n.push.apply(n, i),
                    s = s._next;
                return n
            }
            ,
            s.tweenTo = function(t, e) {
                e = e || {};
                var i, n = this, r = Ut(n, t), s = e, a = s.startAt, o = s.onStart, h = s.onStartParams, l = s.immediateRender, c = Ue.to(n, gt({
                    ease: e.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: "auto",
                    duration: e.duration || Math.abs((r - (a && "time"in a ? a.time : n._time)) / n.timeScale()) || x,
                    onStart: function() {
                        if (n.pause(),
                        !i) {
                            var t = e.duration || Math.abs((r - (a && "time"in a ? a.time : n._time)) / n.timeScale());
                            c._dur !== t && Bt(c, t, 0, 1).render(c._time, !0, !0),
                            i = 1
                        }
                        o && o.apply(c, h || [])
                    }
                }, e));
                return l ? c.render(0) : c
            }
            ,
            s.tweenFromTo = function(t, e, i) {
                return this.tweenTo(e, gt({
                    startAt: {
                        time: Ut(this, t)
                    }
                }, i))
            }
            ,
            s.recent = function() {
                return this._recent
            }
            ,
            s.nextLabel = function(t) {
                return void 0 === t && (t = this._time),
                ie(this, Ut(this, t))
            }
            ,
            s.previousLabel = function(t) {
                return void 0 === t && (t = this._time),
                ie(this, Ut(this, t), 1)
            }
            ,
            s.currentLabel = function(t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + x)
            }
            ,
            s.shiftChildren = function(t, e, i) {
                void 0 === i && (i = 0);
                for (var n, r = this._first, s = this.labels; r; )
                    r._start >= i && (r._start += t,
                    r._end += t),
                    r = r._next;
                if (e)
                    for (n in s)
                        s[n] >= i && (s[n] += t);
                return Tt(this)
            }
            ,
            s.invalidate = function() {
                var t = this._first;
                for (this._lock = 0; t; )
                    t.invalidate(),
                    t = t._next;
                return i.prototype.invalidate.call(this)
            }
            ,
            s.clear = function(t) {
                void 0 === t && (t = !0);
                for (var e, i = this._first; i; )
                    e = i._next,
                    this.remove(i),
                    i = e;
                return this._dp && (this._time = this._tTime = this._pTime = 0),
                t && (this.labels = {}),
                Tt(this)
            }
            ,
            s.totalDuration = function(t) {
                var e, i, n, s = 0, a = this, o = a._last, h = y;
                if (arguments.length)
                    return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t));
                if (a._dirty) {
                    for (n = a.parent; o; )
                        e = o._prev,
                        o._dirty && o.totalDuration(),
                        (i = o._start) > h && a._sort && o._ts && !a._lock ? (a._lock = 1,
                        Ot(a, o, i - o._delay, 1)._lock = 0) : h = i,
                        i < 0 && o._ts && (s -= i,
                        (!n && !a._dp || n && n.smoothChildTiming) && (a._start += i / a._ts,
                        a._time -= i,
                        a._tTime -= i),
                        a.shiftChildren(-i, !1, -Infinity),
                        h = 0),
                        o._end > s && o._ts && (s = o._end),
                        o = e;
                    Bt(a, a === r && a._time > s ? a._time : s, 1, 1),
                    a._dirty = 0
                }
                return a._tDur
            }
            ,
            n.updateRoot = function(t) {
                if (r._ts && (pt(r, Lt(t, r)),
                l = fe.frame),
                fe.frame >= et) {
                    et += g.autoSleep || 120;
                    var e = r._first;
                    if ((!e || !e._ts) && g.autoSleep && fe._listeners.length < 2) {
                        for (; e && !e._ts; )
                            e = e._next;
                        e || fe.sleep()
                    }
                }
            }
            ,
            n
        }(Le);
        gt(Pe.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var Ce, Re, Oe = function(t, e, i, n, r, s, a) {
            var o, h, l, c, u, d, p, f, m = new ti(this._pt,t,e,0,1,Ye,null,r), g = 0, v = 0;
            for (m.b = i,
            m.e = n,
            i += "",
            (p = ~(n += "").indexOf("random(")) && (n = te(n)),
            s && (s(f = [i, n], t, e),
            i = f[0],
            n = f[1]),
            h = i.match(F) || []; o = F.exec(n); )
                c = o[0],
                u = n.substring(g, o.index),
                l ? l = (l + 1) % 5 : "rgba(" === u.substr(-5) && (l = 1),
                c !== h[v++] && (d = parseFloat(h[v - 1]) || 0,
                m._pt = {
                    _next: m._pt,
                    p: u || 1 === v ? u : ",",
                    s: d,
                    c: "=" === c.charAt(1) ? ct(d, c) - d : parseFloat(c) - d,
                    m: l && l < 4 ? Math.round : 0
                },
                g = F.lastIndex);
            return m.c = g < n.length ? n.substring(g, n.length) : "",
            m.fp = a,
            (U.test(n) || p) && (m.e = 0),
            this._pt = m,
            m
        }, De = function(t, e, i, n, r, s, a, o, h) {
            A(n) && (n = n(r || 0, t, s));
            var l, c = t[e], u = "get" !== i ? i : A(c) ? h ? t[e.indexOf("set") || !A(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](h) : t[e]() : c, d = A(c) ? h ? Ge : je : He;
            if (S(n) && (~n.indexOf("random(") && (n = te(n)),
            "=" === n.charAt(1) && ((l = ct(u, n) + (Wt(u) || 0)) || 0 === l) && (n = l)),
            u !== n || Re)
                return isNaN(u * n) || "" === n ? (!c && !(e in t) && q(e, n),
                Oe.call(this, t, e, u, n, d, o || g.stringFilter, h)) : (l = new ti(this._pt,t,e,+u || 0,n - (u || 0),"boolean" == typeof c ? Xe : qe,0,d),
                h && (l.fp = h),
                a && l.modifier(a, this, t),
                this._pt = l)
        }, Ie = function(t, e, i, n, r, s) {
            var a, o, h, l;
            if (K[t] && !1 !== (a = new K[t]).init(r, a.rawVars ? e[t] : function(t, e, i, n, r) {
                if (A(t) && (t = Be(t, r, e, i, n)),
                !C(t) || t.style && t.nodeType || N(t) || I(t))
                    return S(t) ? Be(t, r, e, i, n) : t;
                var s, a = {};
                for (s in t)
                    a[s] = Be(t[s], r, e, i, n);
                return a
            }(e[t], n, r, s, i), i, n, s) && (i._pt = o = new ti(i._pt,r,t,0,1,a.render,a,0,a.priority),
            i !== c))
                for (h = i._ptLookup[i._targets.indexOf(r)],
                l = a._props.length; l--; )
                    h[a._props[l]] = o;
            return a
        }, Ne = function t(e, i) {
            var s, a, o, h, l, c, u, d, p, f, m, g, _, b = e.vars, w = b.ease, M = b.startAt, T = b.immediateRender, E = b.lazy, S = b.onUpdate, A = b.onUpdateParams, L = b.callbackScope, P = b.runBackwards, C = b.yoyoEase, O = b.keyframes, D = b.autoRevert, I = e._dur, N = e._startAt, z = e._targets, B = e.parent, k = B && "nested" === B.data ? B.parent._targets : z, F = "auto" === e._overwrite && !n, U = e.timeline;
            if (U && (!O || !w) && (w = "none"),
            e._ease = we(w, v.ease),
            e._yEase = C ? _e(we(!0 === C ? w : C, v.ease)) : 0,
            C && e._yoyo && !e._repeat && (C = e._yEase,
            e._yEase = e._ease,
            e._ease = C),
            e._from = !U && !!b.runBackwards,
            !U || O && !b.stagger) {
                if (g = (d = z[0] ? st(z[0]).harness : 0) && b[d.prop],
                s = xt(b, J),
                N && (Mt(N.render(-1, !0)),
                N._lazy = 0),
                M)
                    if (Mt(e._startAt = Ue.set(z, gt({
                        data: "isStart",
                        overwrite: !1,
                        parent: B,
                        immediateRender: !0,
                        lazy: R(E),
                        startAt: null,
                        delay: 0,
                        onUpdate: S,
                        onUpdateParams: A,
                        callbackScope: L,
                        stagger: 0
                    }, M))),
                    i < 0 && !T && !D && e._startAt.render(-1, !0),
                    T) {
                        if (i > 0 && !D && (e._startAt = 0),
                        I && i <= 0)
                            return void (i && (e._zTime = i))
                    } else
                        !1 === D && (e._startAt = 0);
                else if (P && I)
                    if (N)
                        !D && (e._startAt = 0);
                    else if (i && (T = !1),
                    o = gt({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: T && R(E),
                        immediateRender: T,
                        stagger: 0,
                        parent: B
                    }, s),
                    g && (o[d.prop] = g),
                    Mt(e._startAt = Ue.set(z, o)),
                    i < 0 && e._startAt.render(-1, !0),
                    e._zTime = i,
                    T) {
                        if (!i)
                            return
                    } else
                        t(e._startAt, x);
                for (e._pt = e._ptCache = 0,
                E = I && R(E) || E && !I,
                a = 0; a < z.length; a++) {
                    if (u = (l = z[a])._gsap || rt(z)[a]._gsap,
                    e._ptLookup[a] = f = {},
                    Q[u.id] && $.length && dt(),
                    m = k === z ? a : k.indexOf(l),
                    d && !1 !== (p = new d).init(l, g || s, e, m, k) && (e._pt = h = new ti(e._pt,l,p.name,0,1,p.render,p,0,p.priority),
                    p._props.forEach((function(t) {
                        f[t] = h
                    }
                    )),
                    p.priority && (c = 1)),
                    !d || g)
                        for (o in s)
                            K[o] && (p = Ie(o, s, e, m, l, k)) ? p.priority && (c = 1) : f[o] = h = De.call(e, l, o, "get", s[o], m, k, 0, b.stringFilter);
                    e._op && e._op[a] && e.kill(l, e._op[a]),
                    F && e._pt && (Ce = e,
                    r.killTweensOf(l, f, e.globalTime(i)),
                    _ = !e.parent,
                    Ce = 0),
                    e._pt && E && (Q[u.id] = 1)
                }
                c && Ke(e),
                e._onInit && e._onInit(e)
            }
            e._onUpdate = S,
            e._initted = (!e._op || e._pt) && !_,
            O && i <= 0 && U.render(y, !0, !0)
        }, ze = function(t, e, i, n) {
            var r, s, a = e.ease || n || "power1.inOut";
            if (N(e))
                s = i[t] || (i[t] = []),
                e.forEach((function(t, i) {
                    return s.push({
                        t: i / (e.length - 1) * 100,
                        v: t,
                        e: a
                    })
                }
                ));
            else
                for (r in e)
                    s = i[r] || (i[r] = []),
                    "ease" === r || s.push({
                        t: parseFloat(t),
                        v: e[r],
                        e: a
                    })
        }, Be = function(t, e, i, n, r) {
            return A(t) ? t.call(e, i, n, r) : S(t) && ~t.indexOf("random(") ? te(t) : t
        }, ke = nt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Fe = {};
        ot(ke + ",id,stagger,delay,duration,paused,scrollTrigger", (function(t) {
            return Fe[t] = 1
        }
        ));
        var Ue = function(i) {
            function s(e, s, a, o) {
                var h;
                "number" == typeof s && (a.duration = s,
                s = a,
                a = null);
                var l, c, u, d, p, f, m, v, y = (h = i.call(this, o ? s : _t(s)) || this).vars, x = y.duration, _ = y.delay, b = y.immediateRender, w = y.stagger, M = y.overwrite, T = y.keyframes, E = y.defaults, S = y.scrollTrigger, A = y.yoyoEase, P = s.parent || r, O = (N(e) || I(e) ? L(e[0]) : "length"in s) ? [e] : Xt(e);
                if (h._targets = O.length ? rt(O) : X("GSAP target " + e + " not found. https://greensock.com", !g.nullTargetWarn) || [],
                h._ptLookup = [],
                h._overwrite = M,
                T || w || D(x) || D(_)) {
                    if (s = h.vars,
                    (l = h.timeline = new Pe({
                        data: "nested",
                        defaults: E || {}
                    })).kill(),
                    l.parent = l._dp = t(h),
                    l._start = 0,
                    w || D(x) || D(_)) {
                        if (d = O.length,
                        m = w && Zt(w),
                        C(w))
                            for (p in w)
                                ~ke.indexOf(p) && (v || (v = {}),
                                v[p] = w[p]);
                        for (c = 0; c < d; c++)
                            (u = xt(s, Fe)).stagger = 0,
                            A && (u.yoyoEase = A),
                            v && vt(u, v),
                            f = O[c],
                            u.duration = +Be(x, t(h), c, f, O),
                            u.delay = (+Be(_, t(h), c, f, O) || 0) - h._delay,
                            !w && 1 === d && u.delay && (h._delay = _ = u.delay,
                            h._start += _,
                            u.delay = 0),
                            l.to(f, u, m ? m(c, f, O) : 0),
                            l._ease = ge.none;
                        l.duration() ? x = _ = 0 : h.timeline = 0
                    } else if (T) {
                        _t(gt(l.vars.defaults, {
                            ease: "none"
                        })),
                        l._ease = we(T.ease || s.ease || "none");
                        var z, B, k, F = 0;
                        if (N(T))
                            T.forEach((function(t) {
                                return l.to(O, t, ">")
                            }
                            ));
                        else {
                            for (p in u = {},
                            T)
                                "ease" === p || "easeEach" === p || ze(p, T[p], u, T.easeEach);
                            for (p in u)
                                for (z = u[p].sort((function(t, e) {
                                    return t.t - e.t
                                }
                                )),
                                F = 0,
                                c = 0; c < z.length; c++)
                                    (k = {
                                        ease: (B = z[c]).e,
                                        duration: (B.t - (c ? z[c - 1].t : 0)) / 100 * x
                                    })[p] = B.v,
                                    l.to(O, k, F),
                                    F += k.duration;
                            l.duration() < x && l.to({}, {
                                duration: x - l.duration()
                            })
                        }
                    }
                    x || h.duration(x = l.duration())
                } else
                    h.timeline = 0;
                return !0 !== M || n || (Ce = t(h),
                r.killTweensOf(O),
                Ce = 0),
                Ot(P, t(h), a),
                s.reversed && h.reverse(),
                s.paused && h.paused(!0),
                (b || !x && !T && h._start === lt(P._time) && R(b) && Et(t(h)) && "nested" !== P.data) && (h._tTime = -1e-8,
                h.render(Math.max(0, -_))),
                S && Dt(t(h), S),
                h
            }
            e(s, i);
            var a = s.prototype;
            return a.render = function(t, e, i) {
                var n, r, s, a, o, h, l, c, u, d = this._time, p = this._tDur, f = this._dur, m = t > p - x && t >= 0 ? p : t < x ? 0 : t;
                if (f) {
                    if (m !== this._tTime || !t || i || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
                        if (n = m,
                        c = this.timeline,
                        this._repeat) {
                            if (a = f + this._rDelay,
                            this._repeat < -1 && t < 0)
                                return this.totalTime(100 * a + t, e, i);
                            if (n = lt(m % a),
                            m === p ? (s = this._repeat,
                            n = f) : ((s = ~~(m / a)) && s === m / a && (n = f,
                            s--),
                            n > f && (n = f)),
                            (h = this._yoyo && 1 & s) && (u = this._yEase,
                            n = f - n),
                            o = At(this._tTime, a),
                            n === d && !i && this._initted)
                                return this._tTime = m,
                                this;
                            s !== o && (c && this._yEase && be(c, h),
                            !this.vars.repeatRefresh || h || this._lock || (this._lock = i = 1,
                            this.render(lt(a * s), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (It(this, t < 0 ? t : n, i, e))
                                return this._tTime = 0,
                                this;
                            if (d !== this._time)
                                return this;
                            if (f !== this._dur)
                                return this.render(t, e, i)
                        }
                        if (this._tTime = m,
                        this._time = n,
                        !this._act && this._ts && (this._act = 1,
                        this._lazy = 0),
                        this.ratio = l = (u || this._ease)(n / f),
                        this._from && (this.ratio = l = 1 - l),
                        n && !d && !e && (ne(this, "onStart"),
                        this._tTime !== m))
                            return this;
                        for (r = this._pt; r; )
                            r.r(l, r.d),
                            r = r._next;
                        c && c.render(t < 0 ? t : !n && h ? -1e-8 : c._dur * c._ease(n / this._dur), e, i) || this._startAt && (this._zTime = t),
                        this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, i),
                        ne(this, "onUpdate")),
                        this._repeat && s !== o && this.vars.onRepeat && !e && this.parent && ne(this, "onRepeat"),
                        m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0),
                        (t || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && Mt(this, 1),
                        e || t < 0 && !d || !m && !d || (ne(this, m === p ? "onComplete" : "onReverseComplete", !0),
                        this._prom && !(m < p && this.timeScale() > 0) && this._prom()))
                    }
                } else
                    !function(t, e, i, n) {
                        var r, s, a, o = t.ratio, h = e < 0 || !e && (!t._start && Nt(t) && (t._initted || !zt(t)) || (t._ts < 0 || t._dp._ts < 0) && !zt(t)) ? 0 : 1, l = t._rDelay, c = 0;
                        if (l && t._repeat && (c = Gt(0, t._tDur, e),
                        s = At(c, l),
                        t._yoyo && 1 & s && (h = 1 - h),
                        s !== At(t._tTime, l) && (o = 1 - h,
                        t.vars.repeatRefresh && t._initted && t.invalidate())),
                        h !== o || n || t._zTime === x || !e && t._zTime) {
                            if (!t._initted && It(t, e, n, i))
                                return;
                            for (a = t._zTime,
                            t._zTime = e || (i ? x : 0),
                            i || (i = e && !a),
                            t.ratio = h,
                            t._from && (h = 1 - h),
                            t._time = 0,
                            t._tTime = c,
                            r = t._pt; r; )
                                r.r(h, r.d),
                                r = r._next;
                            t._startAt && e < 0 && t._startAt.render(e, !0, !0),
                            t._onUpdate && !i && ne(t, "onUpdate"),
                            c && t._repeat && !i && t.parent && ne(t, "onRepeat"),
                            (e >= t._tDur || e < 0) && t.ratio === h && (h && Mt(t, 1),
                            i || (ne(t, h ? "onComplete" : "onReverseComplete", !0),
                            t._prom && t._prom()))
                        } else
                            t._zTime || (t._zTime = e)
                    }(this, t, e, i);
                return this
            }
            ,
            a.targets = function() {
                return this._targets
            }
            ,
            a.invalidate = function() {
                return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0,
                this._ptLookup = [],
                this.timeline && this.timeline.invalidate(),
                i.prototype.invalidate.call(this)
            }
            ,
            a.resetTo = function(t, e, i, n) {
                u || fe.wake(),
                this._ts || this.play();
                var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                return this._initted || Ne(this, r),
                function(t, e, i, n, r, s, a) {
                    var o, h, l, c = (t._pt && t._ptCache || (t._ptCache = {}))[e];
                    if (!c)
                        for (c = t._ptCache[e] = [],
                        h = t._ptLookup,
                        l = t._targets.length; l--; ) {
                            if ((o = h[l][e]) && o.d && o.d._pt)
                                for (o = o.d._pt; o && o.p !== e; )
                                    o = o._next;
                            if (!o)
                                return Re = 1,
                                t.vars[e] = "+=0",
                                Ne(t, a),
                                Re = 0,
                                1;
                            c.push(o)
                        }
                    for (l = c.length; l--; )
                        (o = c[l]).s = !n && 0 !== n || r ? o.s + (n || 0) + s * o.c : n,
                        o.c = i - o.s,
                        o.e && (o.e = ht(i) + Wt(o.e)),
                        o.b && (o.b = o.s + Wt(o.b))
                }(this, t, e, i, n, this._ease(r / this._dur), r) ? this.resetTo(t, e, i, n) : (Ct(this, 0),
                this.parent || bt(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
                this.render(0))
            }
            ,
            a.kill = function(t, e) {
                if (void 0 === e && (e = "all"),
                !(t || e && "all" !== e))
                    return this._lazy = this._pt = 0,
                    this.parent ? re(this) : this;
                if (this.timeline) {
                    var i = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(t, e, Ce && !0 !== Ce.vars.overwrite)._first || re(this),
                    this.parent && i !== this.timeline.totalDuration() && Bt(this, this._dur * this.timeline._tDur / i, 0, 1),
                    this
                }
                var n, r, s, a, o, h, l, c = this._targets, u = t ? Xt(t) : c, d = this._ptLookup, p = this._pt;
                if ((!e || "all" === e) && function(t, e) {
                    for (var i = t.length, n = i === e.length; n && i-- && t[i] === e[i]; )
                        ;
                    return i < 0
                }(c, u))
                    return "all" === e && (this._pt = 0),
                    re(this);
                for (n = this._op = this._op || [],
                "all" !== e && (S(e) && (o = {},
                ot(e, (function(t) {
                    return o[t] = 1
                }
                )),
                e = o),
                e = function(t, e) {
                    var i, n, r, s, a = t[0] ? st(t[0]).harness : 0, o = a && a.aliases;
                    if (!o)
                        return e;
                    for (n in i = vt({}, e),
                    o)
                        if (n in i)
                            for (r = (s = o[n].split(",")).length; r--; )
                                i[s[r]] = i[n];
                    return i
                }(c, e)),
                l = c.length; l--; )
                    if (~u.indexOf(c[l]))
                        for (o in r = d[l],
                        "all" === e ? (n[l] = e,
                        a = r,
                        s = {}) : (s = n[l] = n[l] || {},
                        a = e),
                        a)
                            (h = r && r[o]) && ("kill"in h.d && !0 !== h.d.kill(o) || wt(this, h, "_pt"),
                            delete r[o]),
                            "all" !== s && (s[o] = 1);
                return this._initted && !this._pt && p && re(this),
                this
            }
            ,
            s.to = function(t, e) {
                return new s(t,e,arguments[2])
            }
            ,
            s.from = function(t, e) {
                return Ht(1, arguments)
            }
            ,
            s.delayedCall = function(t, e, i, n) {
                return new s(e,0,{
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: e,
                    onReverseComplete: e,
                    onCompleteParams: i,
                    onReverseCompleteParams: i,
                    callbackScope: n
                })
            }
            ,
            s.fromTo = function(t, e, i) {
                return Ht(2, arguments)
            }
            ,
            s.set = function(t, e) {
                return e.duration = 0,
                e.repeatDelay || (e.repeat = 0),
                new s(t,e)
            }
            ,
            s.killTweensOf = function(t, e, i) {
                return r.killTweensOf(t, e, i)
            }
            ,
            s
        }(Le);
        gt(Ue.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }),
        ot("staggerTo,staggerFrom,staggerFromTo", (function(t) {
            Ue[t] = function() {
                var e = new Pe
                  , i = Vt.call(arguments, 0);
                return i.splice("staggerFromTo" === t ? 5 : 4, 0, 0),
                e[t].apply(e, i)
            }
        }
        ));
        var He = function(t, e, i) {
            return t[e] = i
        }
          , je = function(t, e, i) {
            return t[e](i)
        }
          , Ge = function(t, e, i, n) {
            return t[e](n.fp, i)
        }
          , We = function(t, e, i) {
            return t.setAttribute(e, i)
        }
          , Ve = function(t, e) {
            return A(t[e]) ? je : P(t[e]) && t.setAttribute ? We : He
        }
          , qe = function(t, e) {
            return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
        }
          , Xe = function(t, e) {
            return e.set(e.t, e.p, !!(e.s + e.c * t), e)
        }
          , Ye = function(t, e) {
            var i = e._pt
              , n = "";
            if (!t && e.b)
                n = e.b;
            else if (1 === t && e.e)
                n = e.e;
            else {
                for (; i; )
                    n = i.p + (i.m ? i.m(i.s + i.c * t) : Math.round(1e4 * (i.s + i.c * t)) / 1e4) + n,
                    i = i._next;
                n += e.c
            }
            e.set(e.t, e.p, n, e)
        }
          , Ze = function(t, e) {
            for (var i = e._pt; i; )
                i.r(t, i.d),
                i = i._next
        }
          , Je = function(t, e, i, n) {
            for (var r, s = this._pt; s; )
                r = s._next,
                s.p === n && s.modifier(t, e, i),
                s = r
        }
          , $e = function(t) {
            for (var e, i, n = this._pt; n; )
                i = n._next,
                n.p === t && !n.op || n.op === t ? wt(this, n, "_pt") : n.dep || (e = 1),
                n = i;
            return !e
        }
          , Qe = function(t, e, i, n) {
            n.mSet(t, e, n.m.call(n.tween, i, n.mt), n)
        }
          , Ke = function(t) {
            for (var e, i, n, r, s = t._pt; s; ) {
                for (e = s._next,
                i = n; i && i.pr > s.pr; )
                    i = i._next;
                (s._prev = i ? i._prev : r) ? s._prev._next = s : n = s,
                (s._next = i) ? i._prev = s : r = s,
                s = e
            }
            t._pt = n
        }
          , ti = function() {
            function t(t, e, i, n, r, s, a, o, h) {
                this.t = e,
                this.s = n,
                this.c = r,
                this.p = i,
                this.r = s || qe,
                this.d = a || this,
                this.set = o || He,
                this.pr = h || 0,
                this._next = t,
                t && (t._prev = this)
            }
            return t.prototype.modifier = function(t, e, i) {
                this.mSet = this.mSet || this.set,
                this.set = Qe,
                this.m = t,
                this.mt = i,
                this.tween = e
            }
            ,
            t
        }();
        ot(nt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
            return J[t] = 1
        }
        )),
        G.TweenMax = G.TweenLite = Ue,
        G.TimelineLite = G.TimelineMax = Pe,
        r = new Pe({
            sortChildren: !1,
            defaults: v,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }),
        g.stringFilter = pe;
        var ei = {
            registerPlugin: function() {
                for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
                    e[i] = arguments[i];
                e.forEach((function(t) {
                    return function(t) {
                        var e = (t = !t.name && t.default || t).name
                          , i = A(t)
                          , n = e && !i && t.init ? function() {
                            this._props = []
                        }
                        : t
                          , r = {
                            init: Z,
                            render: Ze,
                            add: De,
                            kill: $e,
                            modifier: Je,
                            rawVars: 0
                        }
                          , s = {
                            targetTest: 0,
                            get: 0,
                            getSetter: Ve,
                            aliases: {},
                            register: 0
                        };
                        if (me(),
                        t !== n) {
                            if (K[e])
                                return;
                            gt(n, gt(xt(t, r), s)),
                            vt(n.prototype, vt(r, xt(t, s))),
                            K[n.prop = e] = n,
                            t.targetTest && (it.push(n),
                            J[e] = 1),
                            e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                        }
                        Y(e, n),
                        t.register && t.register(ri, n, ti)
                    }(t)
                }
                ))
            },
            timeline: function(t) {
                return new Pe(t)
            },
            getTweensOf: function(t, e) {
                return r.getTweensOf(t, e)
            },
            getProperty: function(t, e, i, n) {
                S(t) && (t = Xt(t)[0]);
                var r = st(t || {}).get
                  , s = i ? mt : ft;
                return "native" === i && (i = ""),
                t ? e ? s((K[e] && K[e].get || r)(t, e, i, n)) : function(e, i, n) {
                    return s((K[e] && K[e].get || r)(t, e, i, n))
                }
                : t
            },
            quickSetter: function(t, e, i) {
                if ((t = Xt(t)).length > 1) {
                    var n = t.map((function(t) {
                        return ri.quickSetter(t, e, i)
                    }
                    ))
                      , r = n.length;
                    return function(t) {
                        for (var e = r; e--; )
                            n[e](t)
                    }
                }
                t = t[0] || {};
                var s = K[e]
                  , a = st(t)
                  , o = a.harness && (a.harness.aliases || {})[e] || e
                  , h = s ? function(e) {
                    var n = new s;
                    c._pt = 0,
                    n.init(t, i ? e + i : e, c, 0, [t]),
                    n.render(1, n),
                    c._pt && Ze(1, c)
                }
                : a.set(t, o);
                return s ? h : function(e) {
                    return h(t, o, i ? e + i : e, a, 1)
                }
            },
            quickTo: function(t, e, i) {
                var n, r = ri.to(t, vt(((n = {})[e] = "+=0.1",
                n.paused = !0,
                n), i || {})), s = function(t, i, n) {
                    return r.resetTo(e, t, i, n)
                };
                return s.tween = r,
                s
            },
            isTweening: function(t) {
                return r.getTweensOf(t, !0).length > 0
            },
            defaults: function(t) {
                return t && t.ease && (t.ease = we(t.ease, v.ease)),
                yt(v, t || {})
            },
            config: function(t) {
                return yt(g, t || {})
            },
            registerEffect: function(t) {
                var e = t.name
                  , i = t.effect
                  , n = t.plugins
                  , r = t.defaults
                  , s = t.extendTimeline;
                (n || "").split(",").forEach((function(t) {
                    return t && !K[t] && !G[t] && X(e + " effect requires " + t + " plugin.")
                }
                )),
                tt[e] = function(t, e, n) {
                    return i(Xt(t), gt(e || {}, r), n)
                }
                ,
                s && (Pe.prototype[e] = function(t, i, n) {
                    return this.add(tt[e](t, C(i) ? i : (n = i) && {}, this), n)
                }
                )
            },
            registerEase: function(t, e) {
                ge[t] = we(e)
            },
            parseEase: function(t, e) {
                return arguments.length ? we(t, e) : ge
            },
            getById: function(t) {
                return r.getById(t)
            },
            exportRoot: function(t, e) {
                void 0 === t && (t = {});
                var i, n, s = new Pe(t);
                for (s.smoothChildTiming = R(t.smoothChildTiming),
                r.remove(s),
                s._dp = 0,
                s._time = s._tTime = r._time,
                i = r._first; i; )
                    n = i._next,
                    !e && !i._dur && i instanceof Ue && i.vars.onComplete === i._targets[0] || Ot(s, i, i._start - i._delay),
                    i = n;
                return Ot(r, s, 0),
                s
            },
            utils: {
                wrap: function t(e, i, n) {
                    var r = i - e;
                    return N(e) ? Kt(e, t(0, e.length), i) : jt(n, (function(t) {
                        return (r + (t - e) % r) % r + e
                    }
                    ))
                },
                wrapYoyo: function t(e, i, n) {
                    var r = i - e
                      , s = 2 * r;
                    return N(e) ? Kt(e, t(0, e.length - 1), i) : jt(n, (function(t) {
                        return e + ((t = (s + (t - e) % s) % s || 0) > r ? s - t : t)
                    }
                    ))
                },
                distribute: Zt,
                random: Qt,
                snap: $t,
                normalize: function(t, e, i) {
                    return ee(t, e, 0, 1, i)
                },
                getUnit: Wt,
                clamp: function(t, e, i) {
                    return jt(i, (function(i) {
                        return Gt(t, e, i)
                    }
                    ))
                },
                splitColor: he,
                toArray: Xt,
                selector: function(t) {
                    return t = Xt(t)[0] || X("Invalid scope") || {},
                    function(e) {
                        var i = t.current || t.nativeElement || t;
                        return Xt(e, i.querySelectorAll ? i : i === t ? X("Invalid scope") || o.createElement("div") : t)
                    }
                },
                mapRange: ee,
                pipe: function() {
                    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
                        e[i] = arguments[i];
                    return function(t) {
                        return e.reduce((function(t, e) {
                            return e(t)
                        }
                        ), t)
                    }
                },
                unitize: function(t, e) {
                    return function(i) {
                        return t(parseFloat(i)) + (e || Wt(i))
                    }
                },
                interpolate: function t(e, i, n, r) {
                    var s = isNaN(e + i) ? 0 : function(t) {
                        return (1 - t) * e + t * i
                    }
                    ;
                    if (!s) {
                        var a, o, h, l, c, u = S(e), d = {};
                        if (!0 === n && (r = 1) && (n = null),
                        u)
                            e = {
                                p: e
                            },
                            i = {
                                p: i
                            };
                        else if (N(e) && !N(i)) {
                            for (h = [],
                            l = e.length,
                            c = l - 2,
                            o = 1; o < l; o++)
                                h.push(t(e[o - 1], e[o]));
                            l--,
                            s = function(t) {
                                t *= l;
                                var e = Math.min(c, ~~t);
                                return h[e](t - e)
                            }
                            ,
                            n = i
                        } else
                            r || (e = vt(N(e) ? [] : {}, e));
                        if (!h) {
                            for (a in i)
                                De.call(d, e, a, "get", i[a]);
                            s = function(t) {
                                return Ze(t, d) || (u ? e.p : e)
                            }
                        }
                    }
                    return jt(n, s)
                },
                shuffle: Yt
            },
            install: V,
            effects: tt,
            ticker: fe,
            updateRoot: Pe.updateRoot,
            plugins: K,
            globalTimeline: r,
            core: {
                PropTween: ti,
                globals: Y,
                Tween: Ue,
                Timeline: Pe,
                Animation: Le,
                getCache: st,
                _removeLinkedListItem: wt,
                suppressOverwrites: function(t) {
                    return n = t
                }
            }
        };
        ot("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
            return ei[t] = Ue[t]
        }
        )),
        fe.add(Pe.updateRoot),
        c = ei.to({}, {
            duration: 0
        });
        var ii = function(t, e) {
            for (var i = t._pt; i && i.p !== e && i.op !== e && i.fp !== e; )
                i = i._next;
            return i
        }
          , ni = function(t, e) {
            return {
                name: t,
                rawVars: 1,
                init: function(t, i, n) {
                    n._onInit = function(t) {
                        var n, r;
                        if (S(i) && (n = {},
                        ot(i, (function(t) {
                            return n[t] = 1
                        }
                        )),
                        i = n),
                        e) {
                            for (r in n = {},
                            i)
                                n[r] = e(i[r]);
                            i = n
                        }
                        !function(t, e) {
                            var i, n, r, s = t._targets;
                            for (i in e)
                                for (n = s.length; n--; )
                                    (r = t._ptLookup[n][i]) && (r = r.d) && (r._pt && (r = ii(r, i)),
                                    r && r.modifier && r.modifier(e[i], t, s[n], i))
                        }(t, i)
                    }
                }
            }
        }
          , ri = ei.registerPlugin({
            name: "attr",
            init: function(t, e, i, n, r) {
                var s, a;
                for (s in e)
                    (a = this.add(t, "setAttribute", (t.getAttribute(s) || 0) + "", e[s], n, r, 0, 0, s)) && (a.op = s),
                    this._props.push(s)
            }
        }, {
            name: "endArray",
            init: function(t, e) {
                for (var i = e.length; i--; )
                    this.add(t, i, t[i] || 0, e[i])
            }
        }, ni("roundProps", Jt), ni("modifiers"), ni("snap", $t)) || ei;
        Ue.version = Pe.version = ri.version = "3.10.4",
        h = 1,
        O() && me(),
        ge.Power0,
        ge.Power1,
        ge.Power2,
        ge.Power3,
        ge.Power4,
        ge.Linear,
        ge.Quad,
        ge.Cubic,
        ge.Quart,
        ge.Quint,
        ge.Strong,
        ge.Elastic,
        ge.Back,
        ge.SteppedEase,
        ge.Bounce,
        ge.Sine,
        ge.Expo,
        ge.Circ;
        var si, ai, oi, hi, li, ci, ui, di = {}, pi = 180 / Math.PI, fi = Math.PI / 180, mi = Math.atan2, gi = /([A-Z])/g, vi = /(left|right|width|margin|padding|x)/i, yi = /[\s,\(]\S/, xi = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        }, _i = function(t, e) {
            return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        }, bi = function(t, e) {
            return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        }, wi = function(t, e) {
            return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
        }, Mi = function(t, e) {
            var i = e.s + e.c * t;
            e.set(e.t, e.p, ~~(i + (i < 0 ? -.5 : .5)) + e.u, e)
        }, Ti = function(t, e) {
            return e.set(e.t, e.p, t ? e.e : e.b, e)
        }, Ei = function(t, e) {
            return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
        }, Si = function(t, e, i) {
            return t.style[e] = i
        }, Ai = function(t, e, i) {
            return t.style.setProperty(e, i)
        }, Li = function(t, e, i) {
            return t._gsap[e] = i
        }, Pi = function(t, e, i) {
            return t._gsap.scaleX = t._gsap.scaleY = i
        }, Ci = function(t, e, i, n, r) {
            var s = t._gsap;
            s.scaleX = s.scaleY = i,
            s.renderTransform(r, s)
        }, Ri = function(t, e, i, n, r) {
            var s = t._gsap;
            s[e] = i,
            s.renderTransform(r, s)
        }, Oi = "transform", Di = Oi + "Origin", Ii = function(t, e) {
            var i = ai.createElementNS ? ai.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : ai.createElement(t);
            return i.style ? i : ai.createElement(t)
        }, Ni = function t(e, i, n) {
            var r = getComputedStyle(e);
            return r[i] || r.getPropertyValue(i.replace(gi, "-$1").toLowerCase()) || r.getPropertyValue(i) || !n && t(e, Bi(i) || i, 1) || ""
        }, zi = "O,Moz,ms,Ms,Webkit".split(","), Bi = function(t, e, i) {
            var n = (e || li).style
              , r = 5;
            if (t in n && !i)
                return t;
            for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(zi[r] + t in n); )
                ;
            return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? zi[r] : "") + t
        }, ki = function() {
            "undefined" != typeof window && window.document && (si = window,
            ai = si.document,
            oi = ai.documentElement,
            li = Ii("div") || {
                style: {}
            },
            Ii("div"),
            Oi = Bi(Oi),
            Di = Oi + "Origin",
            li.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
            ui = !!Bi("perspective"),
            hi = 1)
        }, Fi = function t(e) {
            var i, n = Ii("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, a = this.style.cssText;
            if (oi.appendChild(n),
            n.appendChild(this),
            this.style.display = "block",
            e)
                try {
                    i = this.getBBox(),
                    this._gsapBBox = this.getBBox,
                    this.getBBox = t
                } catch (t) {}
            else
                this._gsapBBox && (i = this._gsapBBox());
            return r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
            oi.removeChild(n),
            this.style.cssText = a,
            i
        }, Ui = function(t, e) {
            for (var i = e.length; i--; )
                if (t.hasAttribute(e[i]))
                    return t.getAttribute(e[i])
        }, Hi = function(t) {
            var e;
            try {
                e = t.getBBox()
            } catch (i) {
                e = Fi.call(t, !0)
            }
            return e && (e.width || e.height) || t.getBBox === Fi || (e = Fi.call(t, !0)),
            !e || e.width || e.x || e.y ? e : {
                x: +Ui(t, ["x", "cx", "x1"]) || 0,
                y: +Ui(t, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            }
        }, ji = function(t) {
            return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Hi(t))
        }, Gi = function(t, e) {
            if (e) {
                var i = t.style;
                e in di && e !== Di && (e = Oi),
                i.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e),
                i.removeProperty(e.replace(gi, "-$1").toLowerCase())) : i.removeAttribute(e)
            }
        }, Wi = function(t, e, i, n, r, s) {
            var a = new ti(t._pt,e,i,0,1,s ? Ei : Ti);
            return t._pt = a,
            a.b = n,
            a.e = r,
            t._props.push(i),
            a
        }, Vi = {
            deg: 1,
            rad: 1,
            turn: 1
        }, qi = function t(e, i, n, r) {
            var s, a, o, h, l = parseFloat(n) || 0, c = (n + "").trim().substr((l + "").length) || "px", u = li.style, d = vi.test(i), p = "svg" === e.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r;
            return r === c || !l || Vi[r] || Vi[c] ? l : ("px" !== c && !g && (l = t(e, i, n, "px")),
            h = e.getCTM && ji(e),
            !v && "%" !== c || !di[i] && !~i.indexOf("adius") ? (u[d ? "width" : "height"] = m + (g ? c : r),
            a = ~i.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode,
            h && (a = (e.ownerSVGElement || {}).parentNode),
            a && a !== ai && a.appendChild || (a = ai.body),
            (o = a._gsap) && v && o.width && d && o.time === fe.time ? ht(l / o.width * m) : ((v || "%" === c) && (u.position = Ni(e, "position")),
            a === e && (u.position = "static"),
            a.appendChild(li),
            s = li[f],
            a.removeChild(li),
            u.position = "absolute",
            d && v && ((o = st(a)).time = fe.time,
            o.width = a[f]),
            ht(g ? s * l / m : s && l ? m / s * l : 0))) : (s = h ? e.getBBox()[d ? "width" : "height"] : e[f],
            ht(v ? l / s * m : l / 100 * s)))
        }, Xi = function(t, e, i, n) {
            var r;
            return hi || ki(),
            e in xi && "transform" !== e && ~(e = xi[e]).indexOf(",") && (e = e.split(",")[0]),
            di[e] && "transform" !== e ? (r = an(t, n),
            r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : on(Ni(t, Di)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || n || ~(r + "").indexOf("calc(")) && (r = Qi[e] && Qi[e](t, e, i) || Ni(t, e) || at(t, e) || ("opacity" === e ? 1 : 0)),
            i && !~(r + "").trim().indexOf(" ") ? qi(t, e, r, i) + i : r
        }, Yi = function(t, e, i, n) {
            if (!i || "none" === i) {
                var r = Bi(e, t, 1)
                  , s = r && Ni(t, r, 1);
                s && s !== i ? (e = r,
                i = s) : "borderColor" === e && (i = Ni(t, "borderTopColor"))
            }
            var a, o, h, l, c, u, d, p, f, m, v, y = new ti(this._pt,t.style,e,0,1,Ye), x = 0, _ = 0;
            if (y.b = i,
            y.e = n,
            i += "",
            "auto" == (n += "") && (t.style[e] = n,
            n = Ni(t, e) || n,
            t.style[e] = i),
            pe(a = [i, n]),
            n = a[1],
            h = (i = a[0]).match(k) || [],
            (n.match(k) || []).length) {
                for (; o = k.exec(n); )
                    d = o[0],
                    f = n.substring(x, o.index),
                    c ? c = (c + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (c = 1),
                    d !== (u = h[_++] || "") && (l = parseFloat(u) || 0,
                    v = u.substr((l + "").length),
                    "=" === d.charAt(1) && (d = ct(l, d) + v),
                    p = parseFloat(d),
                    m = d.substr((p + "").length),
                    x = k.lastIndex - m.length,
                    m || (m = m || g.units[e] || v,
                    x === n.length && (n += m,
                    y.e += m)),
                    v !== m && (l = qi(t, e, u, m) || 0),
                    y._pt = {
                        _next: y._pt,
                        p: f || 1 === _ ? f : ",",
                        s: l,
                        c: p - l,
                        m: c && c < 4 || "zIndex" === e ? Math.round : 0
                    });
                y.c = x < n.length ? n.substring(x, n.length) : ""
            } else
                y.r = "display" === e && "none" === n ? Ei : Ti;
            return U.test(n) && (y.e = 0),
            this._pt = y,
            y
        }, Zi = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        }, Ji = function(t) {
            var e = t.split(" ")
              , i = e[0]
              , n = e[1] || "50%";
            return "top" !== i && "bottom" !== i && "left" !== n && "right" !== n || (t = i,
            i = n,
            n = t),
            e[0] = Zi[i] || i,
            e[1] = Zi[n] || n,
            e.join(" ")
        }, $i = function(t, e) {
            if (e.tween && e.tween._time === e.tween._dur) {
                var i, n, r, s = e.t, a = s.style, o = e.u, h = s._gsap;
                if ("all" === o || !0 === o)
                    a.cssText = "",
                    n = 1;
                else
                    for (r = (o = o.split(",")).length; --r > -1; )
                        i = o[r],
                        di[i] && (n = 1,
                        i = "transformOrigin" === i ? Di : Oi),
                        Gi(s, i);
                n && (Gi(s, Oi),
                h && (h.svg && s.removeAttribute("transform"),
                an(s, 1),
                h.uncache = 1))
            }
        }, Qi = {
            clearProps: function(t, e, i, n, r) {
                if ("isFromStart" !== r.data) {
                    var s = t._pt = new ti(t._pt,e,i,0,0,$i);
                    return s.u = n,
                    s.pr = -10,
                    s.tween = r,
                    t._props.push(i),
                    1
                }
            }
        }, Ki = [1, 0, 0, 1, 0, 0], tn = {}, en = function(t) {
            return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
        }, nn = function(t) {
            var e = Ni(t, Oi);
            return en(e) ? Ki : e.substr(7).match(B).map(ht)
        }, rn = function(t, e) {
            var i, n, r, s, a = t._gsap || st(t), o = t.style, h = nn(t);
            return a.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (h = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Ki : h : (h !== Ki || t.offsetParent || t === oi || a.svg || (r = o.display,
            o.display = "block",
            (i = t.parentNode) && t.offsetParent || (s = 1,
            n = t.nextSibling,
            oi.appendChild(t)),
            h = nn(t),
            r ? o.display = r : Gi(t, "display"),
            s && (n ? i.insertBefore(t, n) : i ? i.appendChild(t) : oi.removeChild(t))),
            e && h.length > 6 ? [h[0], h[1], h[4], h[5], h[12], h[13]] : h)
        }, sn = function(t, e, i, n, r, s) {
            var a, o, h, l = t._gsap, c = r || rn(t, !0), u = l.xOrigin || 0, d = l.yOrigin || 0, p = l.xOffset || 0, f = l.yOffset || 0, m = c[0], g = c[1], v = c[2], y = c[3], x = c[4], _ = c[5], b = e.split(" "), w = parseFloat(b[0]) || 0, M = parseFloat(b[1]) || 0;
            i ? c !== Ki && (o = m * y - g * v) && (h = w * (-g / o) + M * (m / o) - (m * _ - g * x) / o,
            w = w * (y / o) + M * (-v / o) + (v * _ - y * x) / o,
            M = h) : (w = (a = Hi(t)).x + (~b[0].indexOf("%") ? w / 100 * a.width : w),
            M = a.y + (~(b[1] || b[0]).indexOf("%") ? M / 100 * a.height : M)),
            n || !1 !== n && l.smooth ? (x = w - u,
            _ = M - d,
            l.xOffset = p + (x * m + _ * v) - x,
            l.yOffset = f + (x * g + _ * y) - _) : l.xOffset = l.yOffset = 0,
            l.xOrigin = w,
            l.yOrigin = M,
            l.smooth = !!n,
            l.origin = e,
            l.originIsAbsolute = !!i,
            t.style[Di] = "0px 0px",
            s && (Wi(s, l, "xOrigin", u, w),
            Wi(s, l, "yOrigin", d, M),
            Wi(s, l, "xOffset", p, l.xOffset),
            Wi(s, l, "yOffset", f, l.yOffset)),
            t.setAttribute("data-svg-origin", w + " " + M)
        }, an = function(t, e) {
            var i = t._gsap || new Ae(t);
            if ("x"in i && !e && !i.uncache)
                return i;
            var n, r, s, a, o, h, l, c, u, d, p, f, m, v, y, x, _, b, w, M, T, E, S, A, L, P, C, R, O, D, I, N, z = t.style, B = i.scaleX < 0, k = "px", F = "deg", U = Ni(t, Di) || "0";
            return n = r = s = h = l = c = u = d = p = 0,
            a = o = 1,
            i.svg = !(!t.getCTM || !ji(t)),
            v = rn(t, i.svg),
            i.svg && (A = (!i.uncache || "0px 0px" === U) && !e && t.getAttribute("data-svg-origin"),
            sn(t, A || U, !!A || i.originIsAbsolute, !1 !== i.smooth, v)),
            f = i.xOrigin || 0,
            m = i.yOrigin || 0,
            v !== Ki && (b = v[0],
            w = v[1],
            M = v[2],
            T = v[3],
            n = E = v[4],
            r = S = v[5],
            6 === v.length ? (a = Math.sqrt(b * b + w * w),
            o = Math.sqrt(T * T + M * M),
            h = b || w ? mi(w, b) * pi : 0,
            (u = M || T ? mi(M, T) * pi + h : 0) && (o *= Math.abs(Math.cos(u * fi))),
            i.svg && (n -= f - (f * b + m * M),
            r -= m - (f * w + m * T))) : (N = v[6],
            D = v[7],
            C = v[8],
            R = v[9],
            O = v[10],
            I = v[11],
            n = v[12],
            r = v[13],
            s = v[14],
            l = (y = mi(N, O)) * pi,
            y && (A = E * (x = Math.cos(-y)) + C * (_ = Math.sin(-y)),
            L = S * x + R * _,
            P = N * x + O * _,
            C = E * -_ + C * x,
            R = S * -_ + R * x,
            O = N * -_ + O * x,
            I = D * -_ + I * x,
            E = A,
            S = L,
            N = P),
            c = (y = mi(-M, O)) * pi,
            y && (x = Math.cos(-y),
            I = T * (_ = Math.sin(-y)) + I * x,
            b = A = b * x - C * _,
            w = L = w * x - R * _,
            M = P = M * x - O * _),
            h = (y = mi(w, b)) * pi,
            y && (A = b * (x = Math.cos(y)) + w * (_ = Math.sin(y)),
            L = E * x + S * _,
            w = w * x - b * _,
            S = S * x - E * _,
            b = A,
            E = L),
            l && Math.abs(l) + Math.abs(h) > 359.9 && (l = h = 0,
            c = 180 - c),
            a = ht(Math.sqrt(b * b + w * w + M * M)),
            o = ht(Math.sqrt(S * S + N * N)),
            y = mi(E, S),
            u = Math.abs(y) > 2e-4 ? y * pi : 0,
            p = I ? 1 / (I < 0 ? -I : I) : 0),
            i.svg && (A = t.getAttribute("transform"),
            i.forceCSS = t.setAttribute("transform", "") || !en(Ni(t, Oi)),
            A && t.setAttribute("transform", A))),
            Math.abs(u) > 90 && Math.abs(u) < 270 && (B ? (a *= -1,
            u += h <= 0 ? 180 : -180,
            h += h <= 0 ? 180 : -180) : (o *= -1,
            u += u <= 0 ? 180 : -180)),
            e = e || i.uncache,
            i.x = n - ((i.xPercent = n && (!e && i.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? t.offsetWidth * i.xPercent / 100 : 0) + k,
            i.y = r - ((i.yPercent = r && (!e && i.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * i.yPercent / 100 : 0) + k,
            i.z = s + k,
            i.scaleX = ht(a),
            i.scaleY = ht(o),
            i.rotation = ht(h) + F,
            i.rotationX = ht(l) + F,
            i.rotationY = ht(c) + F,
            i.skewX = u + F,
            i.skewY = d + F,
            i.transformPerspective = p + k,
            (i.zOrigin = parseFloat(U.split(" ")[2]) || 0) && (z[Di] = on(U)),
            i.xOffset = i.yOffset = 0,
            i.force3D = g.force3D,
            i.renderTransform = i.svg ? fn : ui ? pn : ln,
            i.uncache = 0,
            i
        }, on = function(t) {
            return (t = t.split(" "))[0] + " " + t[1]
        }, hn = function(t, e, i) {
            var n = Wt(e);
            return ht(parseFloat(e) + parseFloat(qi(t, "x", i + "px", n))) + n
        }, ln = function(t, e) {
            e.z = "0px",
            e.rotationY = e.rotationX = "0deg",
            e.force3D = 0,
            pn(t, e)
        }, cn = "0deg", un = "0px", dn = ") ", pn = function(t, e) {
            var i = e || this
              , n = i.xPercent
              , r = i.yPercent
              , s = i.x
              , a = i.y
              , o = i.z
              , h = i.rotation
              , l = i.rotationY
              , c = i.rotationX
              , u = i.skewX
              , d = i.skewY
              , p = i.scaleX
              , f = i.scaleY
              , m = i.transformPerspective
              , g = i.force3D
              , v = i.target
              , y = i.zOrigin
              , x = ""
              , _ = "auto" === g && t && 1 !== t || !0 === g;
            if (y && (c !== cn || l !== cn)) {
                var b, w = parseFloat(l) * fi, M = Math.sin(w), T = Math.cos(w);
                w = parseFloat(c) * fi,
                b = Math.cos(w),
                s = hn(v, s, M * b * -y),
                a = hn(v, a, -Math.sin(w) * -y),
                o = hn(v, o, T * b * -y + y)
            }
            m !== un && (x += "perspective(" + m + dn),
            (n || r) && (x += "translate(" + n + "%, " + r + "%) "),
            (_ || s !== un || a !== un || o !== un) && (x += o !== un || _ ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + dn),
            h !== cn && (x += "rotate(" + h + dn),
            l !== cn && (x += "rotateY(" + l + dn),
            c !== cn && (x += "rotateX(" + c + dn),
            u === cn && d === cn || (x += "skew(" + u + ", " + d + dn),
            1 === p && 1 === f || (x += "scale(" + p + ", " + f + dn),
            v.style[Oi] = x || "translate(0, 0)"
        }, fn = function(t, e) {
            var i, n, r, s, a, o = e || this, h = o.xPercent, l = o.yPercent, c = o.x, u = o.y, d = o.rotation, p = o.skewX, f = o.skewY, m = o.scaleX, g = o.scaleY, v = o.target, y = o.xOrigin, x = o.yOrigin, _ = o.xOffset, b = o.yOffset, w = o.forceCSS, M = parseFloat(c), T = parseFloat(u);
            d = parseFloat(d),
            p = parseFloat(p),
            (f = parseFloat(f)) && (p += f = parseFloat(f),
            d += f),
            d || p ? (d *= fi,
            p *= fi,
            i = Math.cos(d) * m,
            n = Math.sin(d) * m,
            r = Math.sin(d - p) * -g,
            s = Math.cos(d - p) * g,
            p && (f *= fi,
            a = Math.tan(p - f),
            r *= a = Math.sqrt(1 + a * a),
            s *= a,
            f && (a = Math.tan(f),
            i *= a = Math.sqrt(1 + a * a),
            n *= a)),
            i = ht(i),
            n = ht(n),
            r = ht(r),
            s = ht(s)) : (i = m,
            s = g,
            n = r = 0),
            (M && !~(c + "").indexOf("px") || T && !~(u + "").indexOf("px")) && (M = qi(v, "x", c, "px"),
            T = qi(v, "y", u, "px")),
            (y || x || _ || b) && (M = ht(M + y - (y * i + x * r) + _),
            T = ht(T + x - (y * n + x * s) + b)),
            (h || l) && (a = v.getBBox(),
            M = ht(M + h / 100 * a.width),
            T = ht(T + l / 100 * a.height)),
            a = "matrix(" + i + "," + n + "," + r + "," + s + "," + M + "," + T + ")",
            v.setAttribute("transform", a),
            w && (v.style[Oi] = a)
        }, mn = function(t, e, i, n, r) {
            var s, a, o = 360, h = S(r), l = parseFloat(r) * (h && ~r.indexOf("rad") ? pi : 1) - n, c = n + l + "deg";
            return h && ("short" === (s = r.split("_")[1]) && (l %= o) != l % 180 && (l += l < 0 ? o : -360),
            "cw" === s && l < 0 ? l = (l + 36e9) % o - ~~(l / o) * o : "ccw" === s && l > 0 && (l = (l - 36e9) % o - ~~(l / o) * o)),
            t._pt = a = new ti(t._pt,e,i,n,l,bi),
            a.e = c,
            a.u = "deg",
            t._props.push(i),
            a
        }, gn = function(t, e) {
            for (var i in e)
                t[i] = e[i];
            return t
        }, vn = function(t, e, i) {
            var n, r, s, a, o, h, l, c = gn({}, i._gsap), u = i.style;
            for (r in c.svg ? (s = i.getAttribute("transform"),
            i.setAttribute("transform", ""),
            u[Oi] = e,
            n = an(i, 1),
            Gi(i, Oi),
            i.setAttribute("transform", s)) : (s = getComputedStyle(i)[Oi],
            u[Oi] = e,
            n = an(i, 1),
            u[Oi] = s),
            di)
                (s = c[r]) !== (a = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = Wt(s) !== (l = Wt(a)) ? qi(i, r, s, l) : parseFloat(s),
                h = parseFloat(a),
                t._pt = new ti(t._pt,n,r,o,h - o,_i),
                t._pt.u = l || 0,
                t._props.push(r));
            gn(n, c)
        };
        ot("padding,margin,Width,Radius", (function(t, e) {
            var i = "Top"
              , n = "Right"
              , r = "Bottom"
              , s = "Left"
              , a = (e < 3 ? [i, n, r, s] : [i + s, i + n, r + n, r + s]).map((function(i) {
                return e < 2 ? t + i : "border" + i + t
            }
            ));
            Qi[e > 1 ? "border" + t : t] = function(t, e, i, n, r) {
                var s, o;
                if (arguments.length < 4)
                    return s = a.map((function(e) {
                        return Xi(t, e, i)
                    }
                    )),
                    5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o;
                s = (n + "").split(" "),
                o = {},
                a.forEach((function(t, e) {
                    return o[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
                }
                )),
                t.init(e, o, r)
            }
        }
        ));
        var yn, xn, _n = {
            name: "css",
            register: ki,
            targetTest: function(t) {
                return t.style && t.nodeType
            },
            init: function(t, e, i, n, r) {
                var s, a, o, h, l, c, u, d, p, f, m, v, y, x, _, b = this._props, w = t.style, M = i.vars.startAt;
                for (u in hi || ki(),
                e)
                    if ("autoRound" !== u && (a = e[u],
                    !K[u] || !Ie(u, e, i, n, t, r)))
                        if (l = typeof a,
                        c = Qi[u],
                        "function" === l && (l = typeof (a = a.call(i, n, t, r))),
                        "string" === l && ~a.indexOf("random(") && (a = te(a)),
                        c)
                            c(this, t, u, a, i) && (_ = 1);
                        else if ("--" === u.substr(0, 2))
                            s = (getComputedStyle(t).getPropertyValue(u) + "").trim(),
                            a += "",
                            ue.lastIndex = 0,
                            ue.test(s) || (d = Wt(s),
                            p = Wt(a)),
                            p ? d !== p && (s = qi(t, u, s, p) + p) : d && (a += d),
                            this.add(w, "setProperty", s, a, n, r, 0, 0, u),
                            b.push(u);
                        else if ("undefined" !== l) {
                            if (M && u in M ? (s = "function" == typeof M[u] ? M[u].call(i, n, t, r) : M[u],
                            S(s) && ~s.indexOf("random(") && (s = te(s)),
                            Wt(s + "") || (s += g.units[u] || Wt(Xi(t, u)) || ""),
                            "=" === (s + "").charAt(1) && (s = Xi(t, u))) : s = Xi(t, u),
                            h = parseFloat(s),
                            (f = "string" === l && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)),
                            o = parseFloat(a),
                            u in xi && ("autoAlpha" === u && (1 === h && "hidden" === Xi(t, "visibility") && o && (h = 0),
                            Wi(this, w, "visibility", h ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)),
                            "scale" !== u && "transform" !== u && ~(u = xi[u]).indexOf(",") && (u = u.split(",")[0])),
                            m = u in di)
                                if (v || ((y = t._gsap).renderTransform && !e.parseTransform || an(t, e.parseTransform),
                                x = !1 !== e.smoothOrigin && y.smooth,
                                (v = this._pt = new ti(this._pt,w,Oi,0,1,y.renderTransform,y,0,-1)).dep = 1),
                                "scale" === u)
                                    this._pt = new ti(this._pt,y,"scaleY",y.scaleY,(f ? ct(y.scaleY, f + o) : o) - y.scaleY || 0),
                                    b.push("scaleY", u),
                                    u += "X";
                                else {
                                    if ("transformOrigin" === u) {
                                        a = Ji(a),
                                        y.svg ? sn(t, a, 0, x, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== y.zOrigin && Wi(this, y, "zOrigin", y.zOrigin, p),
                                        Wi(this, w, u, on(s), on(a)));
                                        continue
                                    }
                                    if ("svgOrigin" === u) {
                                        sn(t, a, 1, x, 0, this);
                                        continue
                                    }
                                    if (u in tn) {
                                        mn(this, y, u, h, f ? ct(h, f + a) : a);
                                        continue
                                    }
                                    if ("smoothOrigin" === u) {
                                        Wi(this, y, "smooth", y.smooth, a);
                                        continue
                                    }
                                    if ("force3D" === u) {
                                        y[u] = a;
                                        continue
                                    }
                                    if ("transform" === u) {
                                        vn(this, a, t);
                                        continue
                                    }
                                }
                            else
                                u in w || (u = Bi(u) || u);
                            if (m || (o || 0 === o) && (h || 0 === h) && !yi.test(a) && u in w)
                                o || (o = 0),
                                (d = (s + "").substr((h + "").length)) !== (p = Wt(a) || (u in g.units ? g.units[u] : d)) && (h = qi(t, u, s, p)),
                                this._pt = new ti(this._pt,m ? y : w,u,h,(f ? ct(h, f + o) : o) - h,m || "px" !== p && "zIndex" !== u || !1 === e.autoRound ? _i : Mi),
                                this._pt.u = p || 0,
                                d !== p && "%" !== p && (this._pt.b = s,
                                this._pt.r = wi);
                            else if (u in w)
                                Yi.call(this, t, u, s, f ? f + a : a);
                            else {
                                if (!(u in t)) {
                                    q(u, a);
                                    continue
                                }
                                this.add(t, u, s || t[u], f ? f + a : a, n, r)
                            }
                            b.push(u)
                        }
                _ && Ke(this)
            },
            get: Xi,
            aliases: xi,
            getSetter: function(t, e, i) {
                var n = xi[e];
                return n && n.indexOf(",") < 0 && (e = n),
                e in di && e !== Di && (t._gsap.x || Xi(t, "x")) ? i && ci === i ? "scale" === e ? Pi : Li : (ci = i || {}) && ("scale" === e ? Ci : Ri) : t.style && !P(t.style[e]) ? Si : ~e.indexOf("-") ? Ai : Ve(t, e)
            },
            core: {
                _removeProperty: Gi,
                _getMatrix: rn
            }
        };
        ri.utils.checkPrefix = Bi,
        xn = ot("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (yn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
            di[t] = 1
        }
        )),
        ot(yn, (function(t) {
            g.units[t] = "deg",
            tn[t] = 1
        }
        )),
        xi[xn[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + yn,
        ot("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
            var e = t.split(":");
            xi[e[1]] = xn[e[0]]
        }
        )),
        ot("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
            g.units[t] = "px"
        }
        )),
        ri.registerPlugin(_n);
        var bn = ri.registerPlugin(_n) || ri;
        bn.core.Tween;
        class wn {
            constructor(t) {
                this.dt = t,
                this.template = void 0,
                this.html = "",
                this.cpblt = null
            }
            rt({url: t=window.location.pathname}) {
                this.template = void 0;
                const e = t.replace(window.location.origin, "")
                  , {pages: i} = this.dt.dt;
                if (t.indexOf("/project/") > -1) {
                    const t = e.replace("/project/", "/")
                      , n = Object.keys(i.projects).find((e=>t === e));
                    if (n) {
                        const t = i.projects[n];
                        return t.meta && (document.querySelector("title").innerHTML = t.meta),
                        this.html = t.html,
                        void (this.template = "project")
                    }
                } else {
                    const t = Object.keys(i).find((t=>e === t));
                    if (t) {
                        const e = i[t];
                        return e.meta && (document.querySelector("title").innerHTML = e.meta),
                        e.cpblt ? this.cpblt = e.cpblt : this.cpblt = null,
                        this.html = e.html,
                        void (this.template = t.split("/")[1] || "home")
                    }
                }
                const n = i["/404"];
                return this.html = n.html,
                this.template = "not_found",
                document.querySelector("title").innerHTML = "404 - Not found",
                this.html,
                this.template
            }
        }
        var Mn = i(6270)
          , Tn = i.n(Mn)
          , En = i(7976)
          , Sn = i.n(En);
        class An {
            constructor({el: t}) {
                this.el = t,
                this.createObserver()
            }
            createObserver() {
                this.oberserver = new IntersectionObserver((t=>{
                    t.forEach((t=>{
                        t.isIntersecting ? (this.inView = !0,
                        this.animateIn(),
                        (this.el.classList.contains("project_hero_media_btn") || this.el.classList.contains("lazy")) && this.oberserver.unobserve(this.el)) : (this.inView = !1,
                        this.animateOut())
                    }
                    ))
                }
                )),
                this.oberserver.observe(this.el)
            }
            animateIn() {}
            animateOut() {}
            onResize() {}
        }
        const Ln = t=>t.getBoundingClientRect()
          , Pn = (t,e=document)=>e.querySelector(t)
          , Cn = (t,e=document)=>e.querySelectorAll(t)
          , Rn = (t,e,i)=>t <= e ? e : t >= i ? i : t
          , On = (t,e,i,n,r)=>Rn((t - e) * (r - n) / (i - e) + n, Math.min(n, r), Math.max(n, r));
        class Dn extends An {
            constructor({el: t}) {
                super({
                    el: t
                }),
                this.inner = Pn(".innerCircle canvas", this.el),
                this.arrow = Pn(".innerArrow svg", this.el),
                this.text = [...Cn("p", this.el)],
                this.innerText = Pn(".btn_inner_text", this.el),
                this.hoverArrow = Pn(".mag_hover", this.el),
                this.mag = {
                    x: {
                        current: 0,
                        target: 0,
                        lerp: .1
                    },
                    y: {
                        current: 0,
                        target: 0,
                        lerp: .1
                    }
                },
                this.s = 0
            }
            cb() {
                this.b = Ln(this.el),
                this.top = this.b.top + this.s
            }
            rs() {
                this.cb()
            }
            quadraticInOut(t) {
                let e = 2 * t * t;
                return t < .5 ? e : 4 * t - e - 1
            }
            update(t, e) {
                if (!this.inView)
                    return;
                if (!this.b)
                    return;
                this.s = e;
                const i = t.x
                  , n = t.y
                  , {left: r, top: s, width: a, height: o} = this.b;
                let h = 0
                  , l = 0;
                ((t,e,i,n)=>{
                    let r = t - i
                      , s = e - n;
                    return Math.hypot(r, s)
                }
                )(i, n + e, r + a / 2, this.top + o / 2) < 1.25 * a ? (clearTimeout(this.timer),
                this.innerText && (this.innerText.style.opacity = 0,
                this.hoverArrow.style.opacity = 1),
                h = .3 * (i - (r + a / 2)),
                l = .3 * (n + e - (this.top + o / 2)),
                this.mag.x.target = h,
                this.mag.y.target = l) : this.timer = setTimeout((()=>{
                    this.innerText && (this.innerText.style.opacity = 1,
                    this.hoverArrow.style.opacity = 0),
                    this.mag.x.target *= .2,
                    this.mag.y.target *= .2
                }
                ), 150),
                this.mag.x.current = bn.utils.interpolate(this.mag.x.current, this.mag.x.target, this.mag.x.lerp),
                this.mag.y.current = bn.utils.interpolate(this.mag.y.current, this.mag.y.target, this.mag.y.lerp),
                this.el.style.transform = `translate3d(${this.mag.x.current}px, ${this.mag.y.current}px, 0)`,
                this.inner && (this.inner.style.transform = `translate3d(${1.5 * this.mag.x.current}px, ${1.5 * this.mag.y.current}px, 0)`),
                this.arrow && (this.arrow.style.transform = `translate3d(${.8 * this.mag.x.current}px, ${.8 * this.mag.y.current}px, 0)`),
                this.hoverArrow && (this.hoverArrow.style.transform = `translate3d(${.8 * this.mag.x.current}px, ${.8 * this.mag.y.current}px, 0)`),
                this.text && this.text.forEach((t=>{
                    t.style.transform = `translate3d(${.8 * this.mag.x.current}px, ${.8 * this.mag.y.current}px, 0)`
                }
                ))
            }
        }
        const In = "mousedown"
          , Nn = "mouseup"
          , zn = "mousemove"
          , Bn = "mouseenter"
          , kn = "mouseleave"
          , Fn = "click"
          , Un = "touchstart"
          , Hn = "touchmove"
          , jn = "touchend"
          , Gn = "pointerup"
          , Wn = (t,e,i=window)=>i.addEventListener(t, e)
          , Vn = (t,e,i=window)=>i.removeEventListener(t, e);
        class qn {
            constructor({el: t}) {
                this.el = t,
                this.inner = Pn(".link_inner", this.el),
                this.outer = Pn(".link_outer", this.el),
                this.hover = Pn(".cta_hover", this.el),
                this.nav = this.el.classList.contains("nav_cta"),
                this.stop = this.el.classList.contains("home_about_header_nav_item"),
                this.nthv = this.el.classList.contains("nthv"),
                this.noOut = this.el.parentElement.classList.contains("home_about_header_nav_items"),
                this.ael()
            }
            onEnter() {
                this.el.classList.contains("nthv") || (bn.killTweensOf(this.inner),
                bn.killTweensOf(this.outer),
                bn.killTweensOf(this.hover),
                bn.fromTo(this.outer, {
                    y: 0
                }, {
                    y: "-100%",
                    duration: .3,
                    ease: "Power2.easeIn"
                }),
                bn.fromTo(this.inner, {
                    y: "100%"
                }, {
                    y: "0",
                    duration: .3,
                    ease: "Power2.easeOut",
                    delay: .15
                }),
                this.stop || bn.fromTo(this.hover, {
                    y: "75%",
                    scale: 0
                }, {
                    y: "0",
                    scale: 1,
                    duration: .5,
                    ease: "Power3.easeOut"
                }))
            }
            onLeave() {
                this.el.classList.contains("nthv") || this.hold || this.noOut || (bn.killTweensOf(this.inner),
                bn.killTweensOf(this.outer),
                bn.killTweensOf(this.hover),
                bn.fromTo(this.inner, {
                    y: 0
                }, {
                    y: "-100%",
                    duration: .3,
                    ease: "Power2.easeIn"
                }),
                bn.fromTo(this.outer, {
                    y: "100%"
                }, {
                    y: "0",
                    duration: .5,
                    ease: "Power3.easeOut",
                    delay: .15
                }),
                this.stop || bn.to(this.hover, {
                    scale: 0,
                    y: "75%",
                    duration: .3,
                    ease: "Power2.easeOut"
                }))
            }
            onClick() {
                this.el.classList.add("nthv")
            }
            ael() {
                Wn(Bn, this.onEnter.bind(this), this.el),
                Wn(kn, this.onLeave.bind(this), this.el),
                this.nav && Wn(Fn, this.onClick.bind(this), this.el)
            }
        }
        class Xn extends An {
            constructor({el: t}) {
                super({
                    el: t
                }),
                this.el = t,
                this.ctx = this.el.getContext("2d"),
                this.play = Pn(".project_controls_play", this.el.parentElement),
                this.pause = Pn(".project_controls_pause", this.el.parentElement),
                this.container = Pn(".project_controls", this.el.parentElement),
                this.video = Pn("video", this.el.parentElement),
                this.th = {
                    start: -.5,
                    end: -.5
                },
                this.state = {
                    play: !0,
                    pause: !1
                },
                this.ael()
            }
            cb(t, e) {
                this.size = {
                    x: e,
                    y: t,
                    radius: t
                },
                this.origin = {
                    x: 100,
                    y: 0
                },
                this.el.height = 2 * t,
                this.el.width = 2 * e,
                this.size.x <= 0 || this.d(this.ctx)
            }
            d(t) {
                if (!this.b)
                    return;
                const {x: e, y: i, radius: n} = this.size;
                t.clearRect(0, 0, this.el.width, this.el.height),
                t.beginPath(),
                t.moveTo(this.b.width, this.b.width),
                t.arc(this.b.width, this.b.width, n - 2, this.th.start * Math.PI, this.th.end * Math.PI),
                t.lineWidth = 2,
                t.fillStyle = "#F1F1F1",
                t.fill()
            }
            onEnter() {
                this.played && bn.to(this.container, {
                    scale: 1.4,
                    duration: .2,
                    ease: "Power2.easeOut"
                })
            }
            onLeave() {
                this.played && bn.to(this.container, {
                    scale: 1.2,
                    duration: .2,
                    ease: "Power2.easeOut"
                })
            }
            onCLick() {
                this.played && (!0 === this.state.play ? (bn.to(this.play, {
                    opacity: 0,
                    duration: .1
                }),
                bn.to(this.pause, {
                    opacity: 1,
                    duration: .1
                }),
                this.state = {
                    play: !1,
                    pause: !0
                },
                this.video.muted = !1,
                this.video.currentTime = 0,
                this.video.volume = 1) : (bn.to(this.pause, {
                    opacity: 0,
                    duration: .1
                }),
                bn.to(this.play, {
                    opacity: 1,
                    duration: .1
                }),
                this.state = {
                    play: !0,
                    pause: !1
                },
                this.video.muted = !0))
            }
            rs() {
                this.b = Ln(this.el);
                const {height: t, width: e} = this.b;
                this.cb(t, e)
            }
            animateIn() {
                bn.to(this.play, {
                    opacity: 1,
                    delay: 1.5,
                    ease: "Power2.easeInOut"
                }),
                bn.to(this.container, {
                    scale: 1.2,
                    delay: 1.8,
                    ease: "Power2.easeInOut"
                }),
                bn.to(this.th, {
                    end: 3.51,
                    start: 1.5,
                    duration: 2,
                    ease: "Expo.easeInOut",
                    onComplete: ()=>this.played = !0
                })
            }
            update() {
                this.size && (this.size.x <= 0 || this.played || this.d(this.ctx))
            }
            ael() {
                Wn(Fn, this.onCLick.bind(this), this.container),
                Wn(zn, this.onEnter.bind(this), this.container),
                Wn(kn, this.onLeave.bind(this), this.container)
            }
        }
        class Yn extends An {
            constructor({el: t}) {
                super({
                    el: t
                }),
                this.el = t
            }
            animateIn() {
                this.el.loop = !0,
                this.el.setAttribute("playsinline", ""),
                this.el.play(),
                this.started = !0,
                this.el.classList.contains("stop")
            }
            animateOut() {
                this.el.pause()
            }
        }
        class Zn {
            constructor({el: t}) {
                this.el = t,
                this.img = this.el.firstElementChild,
                this.s = 0,
                this.here = "https://images.prismic.io/chris-folio/09a2dd2a-44ea-4cb8-87c4-1403c6788e13_PDP-Coffee-Think+Whole+Bean.jpg?auto=compress,format" === this.img.src
            }
            cfc() {}
            rs(t, e) {
                this.v = t,
                this.bp = Ln(this.el);
                const i = new Image;
                i.src = this.img.src,
                i.crossOrigin = "anonymous",
                i.onload = t=>{
                    this.bc = Ln(this.img),
                    this.diff = (this.bc.height - this.bp.height) / 2,
                    this.img.style.top = `-${this.diff}px`
                }
                ,
                this.top = this.bp.top + e
            }
            update(t) {
                if (this.s = t,
                !this.bp || this.diff <= 0)
                    return;
                const {height: e} = this.bp
                  , {h: i} = this.v;
                this.fc = 2 * ((this.top + e - t) / (i + e) - .5),
                this.fc > 1.01 || this.fc < -1.01 || (this.img.style.transform = `translate3d(0,${this.diff * this.fc}px, 0)`)
            }
        }
        const Jn = new class {
            isPhone() {
                return this.isPhoneChecked || (this.isPhoneChecked = !0,
                this.isPhoneCheck = document.documentElement.classList.contains("phone")),
                this.isPhoneCheck
            }
            isTablet() {
                return this.isTabletChecked || (this.isTabletChecked = !0,
                this.isTabletCheck = document.documentElement.classList.contains("tablet")),
                this.isTabletCheck
            }
            isDesktop() {
                return this.isDesktopChecked || (this.isDesktopChecked = !0,
                this.isDesktopCheck = document.documentElement.classList.contains("desktop")),
                this.isDesktopCheck
            }
        }
        ;
        class $n {
            constructor({el: t}) {
                this.el = t
            }
            cb() {
                this.b = Ln(this.el)
            }
            rs() {
                this.isRs = !0,
                this.cb(),
                this.transformResize(),
                this.isRs = !1
            }
            transformResize() {
                this.el.style.transform = `translate3d(0,${-this.s}px,0)`
            }
            transform() {
                if (this.isRs)
                    return;
                if (!this.b)
                    return;
                const {top: t, bottom: e} = this.b
                  , i = t - this.s
                  , n = e - this.s;
                i < 300 + window.innerHeight && n > -300 && (this.el.style.transform = `translate3d(0,${-this.s}px,0)`)
            }
            update(t) {
                this.s = t,
                this.transform()
            }
        }
        class Qn {
            constructor({id: t, elements: e, element: i}) {
                this.id = t,
                this.navAbout = Pn(".nav_about"),
                this.navProjects = Pn(".nav_projects"),
                this.selector = i,
                this.selectorChildren = {
                    ...e,
                    magHover: "[data-h]",
                    btnC: "[data-btnC]",
                    linkHover: "[data-link-h]",
                    videos: "video",
                    lazy: "[data-lazy]",
                    para: "[data-mb-pr]"
                }
            }
            create() {
                this.element = document.querySelector(this.selector),
                this.elements = {},
                this.scroll = {
                    current: 0,
                    target: 0,
                    last: 0,
                    limit: 0,
                    ease: .08,
                    threshold: 200
                },
                this.delta = 0,
                this.tempPos = 0,
                Tn()(this.selectorChildren, ((t,e)=>{
                    t instanceof window.HTMLElement || t instanceof window.NodeList || Array.isArray(t) ? this.elements[e] = t : (this.elements[e] = document.querySelectorAll(t),
                    0 === this.elements[e].length ? this.elements[e] = null : 1 === this.elements[e].length && (this.elements[e] = document.querySelector(t)))
                }
                ));
                const t = window.location.pathname;
                t.indexOf("projects") > -1 ? (this.navProjects.classList.add("nthv"),
                this.navAbout.classList.remove("nthv")) : t.indexOf("about") > -1 ? (this.navProjects.classList.remove("nthv"),
                this.navAbout.classList.add("nthv")) : (this.navAbout.classList.remove("nthv"),
                this.navProjects.classList.remove("nthv")),
                this.createScrollSections(),
                this.createAnimations()
            }
            createAnimations() {
                this.animations = [],
                this.videoPlay = Sn()(this.elements.videos, (t=>new Yn({
                    el: t
                }))),
                Jn.isPhone() || Jn.isTablet() || (this.elements.btnC && (this.elements.btnC.length > 1 ? (this.btnAnim = Sn()(this.elements.btnC, (t=>new Xn({
                    el: t
                }))),
                this.btnMulti = !0) : this.btnAnim = new Xn({
                    el: this.elements.btnC
                })),
                Jn.isPhone() || (this.elements.magHover && (void 0 === this.elements.magHover.length ? (this.magAnim = new Dn({
                    el: this.elements.magHover
                }),
                this.magNbr = 1) : (this.magAnim = Sn()(this.elements.magHover, (t=>new Dn({
                    el: t
                }))),
                this.magNbr = 2,
                this.animations.push(this.magAnim))),
                Jn.isTablet() || (this.linkAnim = Sn()(this.elements.linkHover, (t=>new qn({
                    el: t
                }))),
                this.elements.para && (this.elements.para.length > 1 ? this.paraAnims = Sn()(this.elements.para, (t=>new Zn({
                    el: t
                }))) : this.paraAnim = new Zn({
                    el: this.elements.para
                })))))
            }
            createScrollSections() {
                if (this.elements.ssc) {
                    const t = [...this.elements.ssc];
                    this.storeSections = Sn()(t, (t=>new $n({
                        el: t
                    })))
                }
            }
            show() {
                return new Promise((t=>{
                    bn.to(this.element, {
                        autoAlpha: 1,
                        duration: .3,
                        onComplete: t,
                        ease: "Expo.easeInout"
                    })
                }
                ))
            }
            hide() {
                this.destroy();
                let t = 0;
                return this.element.classList.contains("projects") && (t = -20),
                bn.to(this.element, {
                    transformOrigin: "top",
                    y: "-15rem",
                    x: `${t}rem`,
                    scale: .7,
                    duration: 1.2,
                    ease: "Power3.easeInOut"
                }),
                new Promise((t=>{
                    bn.to(this.element, {
                        delay: .2,
                        autoAlpha: 0,
                        onComplete: t,
                        duration: .4,
                        ease: "Expo.easeInout"
                    })
                }
                ))
            }
            loadClass() {
                return new Promise((t=>{
                    bn.to("header", {
                        delay: 0,
                        autoAlpha: 1,
                        onComplete: t,
                        duration: .4
                    })
                }
                ))
            }
            onWheel(t) {
                this.d = t,
                Jn.isDesktop() && (this.scroll.target += t)
            }
            onScroll(t) {
                this.scroll.current = t
            }
            onTouchMove(t) {
                this.scroll.target += t
            }
            rsBannerMulti() {
                [...this.elements.imgBanner].forEach((t=>{
                    const e = t.getAttribute("data-src")
                      , i = window.TEXTURES[e]
                      , n = i[2] / i[1]
                      , r = Ln(t).width;
                    t.style.height = r * n + "px"
                }
                ))
            }
            rsBanner() {
                const t = this.elements.imgBanner.getAttribute("data-src")
                  , e = window.TEXTURES[t]
                  , i = e[2] / e[1]
                  , n = Ln(this.elements.imgBanner).width;
                this.elements.imgBanner.style.height = n * i + "px"
            }
            rs(t) {
                this.isResizing = !0,
                Jn.isDesktop() && this.elements.imgBanner && (void 0 === this.elements.imgBanner.length ? this.rsBanner() : this.rsBannerMulti()),
                this.elements.ssc && (this.elements.ssc.forEach((t=>t.style.transform = "translate3d(0,0,0)")),
                this.storeSections.forEach((t=>t.rs())),
                this.elements.anchors && this.createAnchors()),
                this.paraAnim && this.paraAnim.rs(t, this.scroll.current),
                this.paraAnims && this.paraAnims.forEach((e=>e.rs(t, this.scroll.current))),
                this.btnAnim && (this.btnMulti ? this.btnAnim.forEach((e=>e.rs(t))) : this.btnAnim.rs(t)),
                this.elements.wrapper && (this.scroll.limit = this.elements.wrapper.clientHeight - window.innerHeight),
                2 === this.magNbr ? this.magAnim.forEach((t=>t.rs())) : void 0 === this.magNbr || this.magAnim.rs(),
                this.isResizing = !1
            }
            update(t) {
                this.isResizing || (2 === this.magNbr ? this.magAnim && this.magAnim.forEach((e=>e.update(t, this.scroll.current))) : this.magAnim && this.magAnim.update(t, this.scroll.current),
                Jn.isDesktop() && (this.scroll.target = bn.utils.clamp(0, this.scroll.limit, this.scroll.target),
                this.scroll.current = bn.utils.interpolate(this.scroll.current, this.scroll.target, this.scroll.ease),
                this.scroll.current < .01 && (this.scroll.current = 0),
                this.scroll.current > this.scroll.limit && (this.scroll.current = this.scroll.limit),
                this.paraAnim && this.paraAnim.update(this.scroll.current),
                this.paraAnims && this.paraAnims.forEach((t=>t.update(this.scroll.current)))),
                this.btnAnim && (this.btnMulti ? this.btnAnim.forEach((t=>t.update())) : this.btnAnim.update()),
                Jn.isDesktop() && this.elements.ssc && this.storeSections.forEach((t=>t.update(Math.round(this.scroll.current)))))
            }
            addEventListeners() {}
            removeEventListeners() {}
            destroy() {
                this.removeEventListeners()
            }
        }
        class Kn extends Qn {
            constructor() {
                super({
                    id: "welcome",
                    element: ".welcome",
                    elements: {}
                })
            }
            create() {
                super.create()
            }
        }
        class tr {
            constructor({el: t, index: e}) {
                this.el = t,
                this.index = e,
                this.items = [...Cn(".home_hero_title_marquee", this.el)],
                this.dist1 = 0,
                this.dist2 = 0
            }
            update() {
                1 === this.index ? (this.dist1 += .15,
                this.dist2 += .15,
                this.dist1 >= 70 && (this.dist1 = -130),
                this.dist2 >= 170 && (this.dist2 = -30),
                this.items[0].style.transform = `translateX(${this.dist2}%)`,
                this.items[1].style.transform = `translateX(${this.dist1}%)`) : 2 === this.index ? (this.dist1 -= .17,
                this.dist2 -= .17,
                this.dist1 <= -100 && (this.dist1 = 100),
                this.dist2 <= -200 && (this.dist2 = 0),
                this.items[0].style.transform = `translateX(${this.dist1}%)`,
                this.items[1].style.transform = `translateX(${this.dist2}%)`) : (this.dist1 -= .25,
                this.dist2 -= .25,
                this.dist1 <= -100 && (this.dist1 = 100),
                this.dist2 <= -200 && (this.dist2 = 0),
                this.items[0].style.transform = `translateX(${this.dist1}%)`,
                this.items[1].style.transform = `translateX(${this.dist2}%)`)
            }
        }
        class er {
            constructor({el: t, name: e=!1}) {
                this.el = t,
                this.name = e,
                this.items = [...Cn(".marquee_anim", this.el)],
                this.dist1 = 0,
                this.dist2 = 0
            }
            update() {
                this.dist1 -= .5,
                this.dist2 -= .5,
                this.name ? (-100 === this.dist1 && (this.dist1 = 100),
                -200 === this.dist2 && (this.dist2 = 0)) : this.name || (-100 === this.dist1 && (this.dist1 = 100),
                -200 === this.dist2 && (this.dist2 = 0)),
                this.items[0].style.transform = `translateX(${this.dist1}%)`,
                this.items[1].style.transform = `translateX(${this.dist2}%)`
            }
        }
        class ir extends An {
            constructor({el: t, touch: e=!1, contact: i=!1, next: n=!1}) {
                super({
                    el: t
                }),
                this.el = t,
                this.touch = e,
                this.contact = !1,
                this.next = n,
                this.ctx = this.el.getContext("2d"),
                this.fc = 1,
                this.th = {
                    start: -.5,
                    end: -.5
                },
                this.touch && (this.contact ? this.text = [...Cn(".home_btn_hover_arrow.mag_hover.contact_btn_hover_arrow", this.el.parentElement.parentElement)] : (this.next,
                this.text = [...Cn("p", this.el.parentElement.parentElement)]))
            }
            go() {
                bn.to(this.th, {
                    end: 3.5,
                    start: 1.5,
                    duration: 1.4,
                    delay: .75,
                    ease: "Power2.easeOut",
                    onComplete: ()=>this.played = !0
                })
            }
            gocl() {
                bn.to(this.th, {
                    end: 3.5,
                    start: 1.5,
                    duration: 1,
                    ease: "Power2.easeOut",
                    onComplete: ()=>this.played = !0
                })
            }
            ungo() {
                this.played = !1,
                bn.to(this.th, {
                    end: -.5,
                    start: -.5,
                    duration: 1,
                    ease: "Power2.easeOut",
                    onComplete: ()=>this.played = !0
                })
            }
            scd() {
                bn.to(this, {
                    fc: .65
                })
            }
            scu() {
                bn.to(this, {
                    fc: 1
                })
            }
            cb() {
                this.b = Ln(this.el),
                this.size = {
                    x: this.b.width,
                    y: this.b.height,
                    radius: this.b.height
                },
                this.el.height = 2 * this.b.height,
                this.el.width = 2 * this.b.width,
                this.d()
            }
            d() {
                if (!this.size)
                    return;
                const {x: t, y: e, radius: i} = this.size
                  , {start: n, end: r} = this.th;
                this.viewed || this.touch && this.inView && (this.viewed = !0,
                this.gocl(),
                bn.to(this.text, {
                    opacity: 1,
                    delay: .6
                })),
                this.ctx.clearRect(0, 0, this.el.width, this.el.height),
                this.ctx.beginPath(),
                this.ctx.arc(t, e, this.fc * i - 2 * this.fc, n * Math.PI, r * Math.PI),
                this.ctx.lineWidth = 2,
                this.ctx.strokeStyle = "#ffff",
                this.ctx.stroke()
            }
            rs() {
                this.cb()
            }
            update() {
                this.d()
            }
        }
        class nr {
            constructor({el: t, text: e, title: i}) {
                this.el = t,
                this.text = e,
                this.title = i
            }
            rs() {}
            update(t) {
                this.el.style.transform = `translate3d(${-1 * t}px,0,0)`,
                this.text.style.transform = `translate3d(${-1 * t}px,0,0)`
            }
        }
        function rr(t, e) {
            return t + Math.random() * (e - t)
        }
        let sr = .3
          , ar = .6
          , or = .45;
        class hr {
            constructor(t, e, i, n, r, s) {
                this.x = t,
                this.y = e,
                this.radius = i,
                this.index = n,
                this.rem = r,
                this.text = s.split(" "),
                this.px = t,
                this.py = e,
                this.fx = 0,
                this.fy = 0,
                this.strokeStyle = "rgba(255,255,255,0.8)",
                this.fillStyle = "rgba(255,255,255,1)",
                this.hover = !1,
                this.big = !1,
                this.size = Jn.isDesktop() ? .55 * devicePixelRatio : .45 * devicePixelRatio
            }
            fr(t) {
                this.dragged || (t *= t,
                this.fy += ar,
                this.x += this.fx * t,
                this.y += this.fy * t,
                this.fx = this.fy = 0)
            }
            tr() {
                if (this.dragged)
                    return;
                let t = 2 * this.x - this.px
                  , e = 2 * this.y - this.py;
                this.px = this.x,
                this.py = this.y,
                this.x = t,
                this.y = e
            }
            d(t) {
                t.lineWidth = 1,
                this.hover ? (t.strokeStyle = "rgba(255, 77, 77, 1)",
                t.font = 2.5 * this.rem * this.size + "px PP Telegraf",
                t.textAlign = "center",
                t.textBaseline = "middle") : (t.strokeStyle = "rgba(77, 77, 77, 1)",
                t.font = 2.5 * this.rem * this.size + "px PP Telegraf",
                t.textAlign = "center",
                t.textBaseline = "middle"),
                t.beginPath(),
                t.arc(this.x, this.y, this.radius, 0, 2 * Math.PI),
                this.hover ? (t.fillStyle = "white",
                t.fill(),
                t.fillStyle = "black") : (t.fillStyle = "rgba(179, 179, 179, 1)",
                t.stroke()),
                this.text.length < 2 ? t.fillText(this.text[0], this.x, this.y) : (t.fillText(this.text[0], this.x, this.y - 1.5 * this.rem * this.size),
                t.fillText(this.text[1], this.x, this.y + 1.5 * this.rem * this.size))
            }
        }
        class lr extends An {
            constructor({canvas: t, cp: e}) {
                super({
                    el: t
                }),
                this.canvas = t,
                this.cp = e,
                this.nbBalls = this.cp.length,
                this.ctx = this.canvas.getContext("2d"),
                this.lrg = Jn.isDesktop() ? 11 * devicePixelRatio : 7 * devicePixelRatio,
                this.balls = [],
                this.mouse = {
                    x: 0,
                    y: 0,
                    down: !1
                },
                this.force = .003,
                this.s = 0,
                this.currentIndex = -1,
                this.ael()
            }
            create() {
                bn.to(".home_capabilities_headline p span", {
                    y: 0,
                    duration: 1.5,
                    ease: "Power4.easeOut",
                    stagger: .08
                });
                for (let t = 0; t < this.nbBalls; t++)
                    setTimeout((()=>{
                        this.add(rr(75, this.canvas.width - 75), rr(-150, -200), 75, t, this.cp[t])
                    }
                    ), 275 * t)
            }
            add(t, e, i, n, r) {
                let s = t
                  , a = e
                  , o = Jn.isDesktop() || Jn.isTablet() ? rr(6.5 * devicePixelRatio * this.rem, 6.5 * devicePixelRatio * this.rem) : rr(4.5 * devicePixelRatio * this.rem, 4.5 * devicePixelRatio * this.rem);
                this.balls.length,
                this.balls.push(new hr(s,a,o,n,this.rem,r.toUpperCase()))
            }
            onEnter(t) {
                this.mouse.down = !0,
                t.touches && (this.mouse.x = (t.touches[0].clientX - this.b.left) * devicePixelRatio,
                this.mouse.y = (t.touches[0].clientY - this.top) * devicePixelRatio)
            }
            onLeave() {
                this.mouse.down = !1,
                this.drag = !1,
                this.balls.forEach((t=>{
                    t.hover = !1,
                    t.dragged = !1,
                    t.big && (bn.to(t, {
                        radius: t.prevRad,
                        duration: .3,
                        ease: "Power1.easeInOut"
                    }),
                    t.big = !1)
                }
                ))
            }
            onMove(t) {
                this.fallen && (this.drag && !Jn.isDesktop() && t.preventDefault(),
                this.mouse.x = (t.clientX - this.b.left) * devicePixelRatio,
                this.mouse.y = (t.clientY - this.top) * devicePixelRatio,
                !0 === this.drag && this.balls.forEach((t=>{
                    t.dragged && (t.x = this.mouse.x,
                    t.y = this.mouse.y)
                }
                )))
            }
            onTouchMove(t) {
                this.fallen && (this.drag && t.preventDefault(),
                this.mouse.x = (t.touches[0].clientX - this.b.left) * devicePixelRatio,
                this.mouse.y = (t.touches[0].clientY - this.top) * devicePixelRatio,
                this.balls.forEach((t=>{
                    if (t.hover)
                        t.dragged = !0,
                        this.drag = !0,
                        t.big || (t.prevRad = t.radius,
                        bn.to(t, {
                            radius: this.lrg * this.rem,
                            duration: .3,
                            ease: "Power1.easeInOut"
                        }),
                        t.big = !0);
                    else {
                        if (!t.big)
                            return;
                        bn.to(t, {
                            radius: t.radius,
                            duration: .3,
                            ease: "Power1.easeInOut"
                        }),
                        t.big = !1
                    }
                }
                )),
                !0 === this.drag && this.balls.forEach((t=>{
                    t.dragged && (t.x = this.mouse.x,
                    t.y = this.mouse.y)
                }
                )))
            }
            onDown(t) {
                t.touches && (this.mouse.x = (t.touches[0].clientX - this.b.left) * devicePixelRatio,
                this.mouse.y = (t.touches[0].clientY - this.top) * devicePixelRatio),
                t.touches || this.balls.forEach((t=>{
                    if (t.hover)
                        t.dragged = !0,
                        this.drag = !0,
                        t.big || (t.prevRad = t.radius,
                        bn.to(t, {
                            radius: this.lrg * this.rem,
                            duration: .3,
                            ease: "Power1.easeInOut"
                        }),
                        t.big = !0);
                    else {
                        if (!t.big)
                            return;
                        bn.to(t, {
                            radius: t.radius,
                            duration: .3,
                            ease: "Power1.easeInOut"
                        }),
                        t.big = !1
                    }
                }
                ))
            }
            onUp() {
                this.drag = !1,
                this.balls.forEach((t=>{
                    !0 === t.dragged && (t.px = this.mouse.x,
                    t.py = this.mouse.y,
                    t.fx = 0,
                    t.fy = 0,
                    bn.to(t, {
                        radius: t.prevRad,
                        duration: .3,
                        ease: "Power1.easeInOut"
                    }),
                    t.big = !1),
                    t.dragged = !1
                }
                ))
            }
            rs(t) {
                this.b = t,
                this.cTop = this.b.top + this.s;
                const e = devicePixelRatio;
                Jn.isDesktop() ? this.rem = window.innerWidth / 1440 * 10 : Jn.isPhone() ? this.rem = window.innerWidth / 375 * 10 : this.rem = window.innerWidth / 768 * 10,
                this.balls.forEach((t=>{
                    t.radius = 15 * this.rem,
                    t.rem = this.rem
                }
                ));
                let i = 0
                  , n = 0;
                Jn.isDesktop() ? (i = 134 * this.rem,
                n = 61.5 * this.rem) : Jn.isPhone() ? (i = 33.2 * this.rem,
                n = 61.5 * this.rem) : Jn.isTablet() && (i = 70.8 * this.rem,
                n = 61.5 * this.rem),
                this.canvas.width = i * e,
                this.canvas.height = n * e,
                this.canvas.style.setProperty("width", i + "px"),
                this.canvas.style.setProperty("height", n + "px")
            }
            edg() {
                let t = this.balls.length
                  , e = 0;
                for (this.fallen || (this.balls.forEach((t=>{
                    t.y > 15 * this.rem && (e += 1)
                }
                )),
                e >= this.nbBalls && (this.fallen = !0,
                ar = .1,
                or = .4,
                this.force = .08)); t--; )
                    if (!this.balls[t].dragged) {
                        const e = this.balls[t];
                        if (e.x < e.radius) {
                            let t = e.px - e.x;
                            e.x = e.radius,
                            e.px = e.x - t * sr
                        } else if (e.x + e.radius > this.canvas.width) {
                            let t = e.px - e.x;
                            e.x = this.canvas.width - e.radius,
                            e.px = e.x - t * sr
                        }
                        if (e.y < -27.5 * this.rem && !this.fallen) {
                            let t = e.py - e.y;
                            e.y = -20 - this.rem,
                            e.py = e.y - t * sr
                        }
                        if (e.y < e.radius && this.fallen) {
                            let t = e.py - e.y;
                            e.y = e.radius,
                            e.py = e.y - t * sr
                        }
                        if (e.y + e.radius > this.canvas.height) {
                            let t = e.py - e.y;
                            e.y = this.canvas.height - e.radius,
                            e.py = e.y - t * sr
                        }
                    }
            }
            cl(t) {
                let e = this.balls.length;
                for (; e--; ) {
                    const i = this.balls[e];
                    if (this.mouse.down) {
                        let t = i.x - this.mouse.x
                          , n = i.y - this.mouse.y
                          , r = Math.sqrt(t * t + n * n)
                          , s = r - i.radius
                          , a = r - (i.radius + this.lrg * this.rem);
                        if (i.hover = s < 0,
                        this.drag && !this.balls[e].dragged && a < 0) {
                            let e = t * (a / r)
                              , s = n * (a / r);
                            i.x -= 5e-5 * e,
                            i.y -= 5e-5 * s
                        }
                    }
                    let n = this.balls.length;
                    for (; n--; )
                        if (n != e && !this.balls[n].dragged) {
                            let e = this.balls[n]
                              , r = i.x - e.x
                              , s = i.y - e.y
                              , a = r * r + s * s
                              , o = Math.sqrt(a)
                              , h = o - (i.radius + e.radius);
                            if (h < 0) {
                                let n = i.x - i.px
                                  , l = i.y - i.py
                                  , c = e.x - e.px
                                  , u = e.y - e.py
                                  , d = r * (h / o)
                                  , p = s * (h / o);
                                if (i.x -= d * this.force,
                                i.y -= p * this.force,
                                e.x += d * this.force,
                                e.y += p * this.force,
                                t) {
                                    let t = sr * (r * n + s * l) / a
                                      , o = sr * (r * c + s * u) / a;
                                    n += o * r - t * r,
                                    c += t * r - o * r,
                                    l += o * s - t * s,
                                    u += t * s - o * s,
                                    i.px = i.x - n,
                                    i.py = i.y - l,
                                    e.px = e.x - c,
                                    e.py = e.y - u
                                }
                            }
                        }
                }
            }
            update(t) {
                if (!this.inView)
                    return;
                this.s = t;
                let e = 6;
                this.top = this.cTop - t;
                let i = or / e;
                for (; e--; ) {
                    for (this.i = this.balls.length; this.i--; ) {
                        const t = this.balls[this.i];
                        t.fr(i),
                        t.tr(),
                        this.edg()
                    }
                    for (this.cl(),
                    this.edg(),
                    this.i = this.balls.length; this.i--; )
                        this.balls[this.i].tr();
                    this.cl(),
                    this.edg()
                }
                for (this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height),
                this.i = this.balls.length; this.i--; )
                    this.balls[this.i].d(this.ctx)
            }
            ael() {
                Jn.isDesktop() ? (this.canvas.addEventListener("mouseenter", this.onEnter.bind(this)),
                this.canvas.addEventListener("mouseleave", this.onLeave.bind(this)),
                this.canvas.addEventListener("mousemove", this.onMove.bind(this)),
                this.canvas.addEventListener("pointerdown", this.onDown.bind(this)),
                this.canvas.addEventListener("pointerup", this.onUp.bind(this))) : (this.canvas.addEventListener("touchstart", this.onEnter.bind(this)),
                this.canvas.addEventListener("touchend", this.onLeave.bind(this)),
                this.canvas.addEventListener("touchmove", this.onTouchMove.bind(this)),
                this.canvas.addEventListener("touchstart", this.onDown.bind(this)),
                this.canvas.addEventListener("touchend", this.onUp.bind(this)))
            }
        }
        class cr {
            constructor({el: t}) {
                this.el = t,
                this.add = 0,
                this.multi = 0,
                this.d = 0
            }
            rs(t, e) {
                this.isRs = !0,
                this.el.style.transform = "translate3d(0,0,0)",
                this.b = Ln(this.el),
                this.container = t;
                const {left: i, right: n, width: r} = this.b;
                this.ct = 0,
                this.dt = 0,
                this.s = 0,
                this.left = r + i,
                this.right = n - r - e.w,
                this.isRs = !1
            }
            update(t, e, i) {
                this.isRs || (void 0 !== i && (this.d = i),
                this.multi = Math.abs(this.d),
                this.multi *= .2,
                this.multi = bn.utils.clamp(0, 2, this.multi),
                this.add += 5 + this.multi,
                this.s = this.add - this.dt,
                this.el.style.transform = `translate3d(${-1 * this.s}px, 0,0)`,
                this.left - this.s < 0 && (this.ct += 1,
                this.dt = this.container * this.ct))
            }
        }
        function ur({element: t, expression: e=" ", append: i=!0}) {
            const n = function(t, e) {
                const i = t.split("<br>");
                let n = [];
                return Tn()(i, ((t,i)=>{
                    i > 0 && n.push("<br>"),
                    n = n.concat(t.split(e));
                    let r = !1
                      , s = "";
                    const a = [];
                    Tn()(n, (t=>{
                        r || !t.includes("<a") && !t.includes("<strong") || (s = "",
                        r = !0),
                        r && (s += ` ${t}`),
                        r && (t.includes("/a>") || t.includes("/strong>")) && (a.push(s),
                        s = ""),
                        r || "" !== s || a.push(t),
                        r && (t.includes("/a>") || t.includes("/strong>")) && (r = !1)
                    }
                    )),
                    n = a
                }
                )),
                n
            }(t.innerHTML.toString().trim(), e);
            let r = "";
            Tn()(n, (t=>{
                if (t.indexOf("<br>") > -1) {
                    const e = t.split("<br>");
                    Tn()(e, ((t,e)=>{
                        r += e > 0 ? "<br>" + dr(t) : dr(t)
                    }
                    ))
                } else
                    r += dr(t)
            }
            )),
            t.innerHTML = r;
            const s = t.querySelectorAll("span");
            return i && Tn()(s, (t=>{
                const e = 1 === t.textContent.length
                  , i = "" !== t.innerHTML.trim()
                  , n = "&" !== t.textContent
                  , r = "-" !== t.textContent;
                e && i && n && r && (t.innerHTML = `${t.textContent}&nbsp;`)
            }
            )),
            s
        }
        function dr(t) {
            return "" === (t = t.trim()) || " " === t ? t : "<br>" === t ? "<br>" : `<span>${t}</span>` + (t.length > 1 ? " " : "")
        }
        class pr extends Qn {
            constructor() {
                super({
                    id: "home",
                    element: ".home",
                    elements: {
                        wrapper: ".home",
                        ssc: ".ssc",
                        aboutTitles: ".home_about_title",
                        titleContainer: ".home_about_titles_c",
                        imgContainer: ".home_about_img",
                        img: ".home_about_img_media",
                        homeBtn: ".home_hero_arrow_circle_c",
                        homeAbout: ".home_about",
                        header: "header",
                        nameTitle: ".home_about_title",
                        heroDescription: ".home_hero_description",
                        heroDescriptionTouch: ".home_hero_description--touch",
                        heroDescriptionTablet: ".home_hero_description--tablet",
                        aboutDesciption: ".home_about_description",
                        homeFeatDescription: ".home_feature_intro_description",
                        footer: ".footer_c",
                        titleMarquee: ".home_hero_title_marquee-el",
                        homeTouchCl: ".home_hero_cl.circAn1",
                        homeTabletCl: ".home_hero_circle .circAn",
                        touchArrow: ".home_hero_arrow--touch",
                        aboutBtn: ".home_about_button .circAn1",
                        featBtn: ".home_featured_button .circAn1",
                        contactBtn: ".home_contact_circle .circAn1",
                        featImg: ".home_featured_img",
                        featRef: ".featRef",
                        text: ".home_featured_text",
                        featC: ".home_featured_c",
                        featTitles: ".home_featured_t",
                        featTitleref: ".home_featured_title_1",
                        projectNbr: ".home_featured_nbr p span",
                        headerTouch: ".header--touch",
                        scrollAb: ".home_hero_arrow_cl_c--touch",
                        about: ".home_about",
                        canvas2D: "#canvas2D",
                        contact: ".footer--touch",
                        vbg: ".m-bg"
                    }
                })
            }
            create(t, e, i) {
                super.create(),
                this.load(),
                this.cp = i,
                Jn.isDesktop() || (this.featTitles = [],
                this.tg = 0,
                this.ps = 0,
                Jn.isTablet() || (this.marqueeStore = Sn()(this.elements.titleMarquee, ((t,e)=>new tr({
                    el: t,
                    index: e
                })))),
                this.heroCl = new ir({
                    el: Jn.isPhone() ? this.elements.homeTouchCl : this.elements.homeTabletCl[0]
                }),
                this.featCl = new ir({
                    el: this.elements.featBtn,
                    touch: !0
                }),
                this.aboutCl = new ir({
                    el: this.elements.aboutBtn,
                    touch: !0
                }),
                this.contactCl = new ir({
                    el: this.elements.contactBtn,
                    touch: !0,
                    contact: !0
                }),
                this.nameMarquee = new er({
                    el: this.elements.titleContainer,
                    name: !0
                })),
                this.s = {
                    current: 0,
                    target: 0,
                    ease: .75
                },
                this.seenCv = !1,
                Jn.isTablet() && (ur({
                    element: this.elements.heroDescriptionTablet,
                    expression: "<br>",
                    append: !0
                }),
                this.heroBioSplit = ur({
                    element: this.elements.heroDescriptionTablet,
                    expression: "<br>",
                    append: !0
                })),
                Jn.isDesktop() && (ur({
                    element: this.elements.heroDescription,
                    expression: "<br>",
                    append: !0
                }),
                this.heroBioSplit = ur({
                    element: this.elements.heroDescription,
                    expression: "<br>",
                    append: !0
                }),
                ur({
                    element: this.elements.aboutDesciption,
                    expression: "<br>",
                    append: !0
                }),
                this.aboutBioSplit = ur({
                    element: this.elements.aboutDesciption,
                    expression: "<br>",
                    append: !0
                }),
                ur({
                    element: this.elements.homeFeatDescription,
                    expression: "<br>",
                    append: !0
                }),
                this.featIntro = ur({
                    element: this.elements.homeFeatDescription,
                    expression: "<br>",
                    append: !0
                }),
                this.heroBioSplit[0].classList.add("home_bio_offset"),
                this.aboutBioSplit[0].classList.add("home_about_offset"),
                this.featIntro[0].classList.add("home_feat_offset")),
                Jn.isPhone() && this.createMedias(),
                this.createTexts(),
                this.createCanvas(),
                this.ael()
            }
            load() {
                Jn.isDesktop() || [...Cn("img")].forEach((t=>{
                    const e = t.getAttribute("data-touch");
                    if (!e)
                        return;
                    const i = new Image;
                    i.src = e,
                    i.crossOrigin = "anonymous",
                    t.src = i.src
                }
                ))
            }
            intro(t) {
                Jn.isPhone() ? (ur({
                    element: this.elements.heroDescriptionTouch,
                    expression: "<br>",
                    append: !0
                }),
                this.heroBioSplit = ur({
                    element: this.elements.heroDescriptionTouch,
                    expression: "<br>",
                    append: !0
                }),
                this.heroBioSplit[0].classList.add("home_bio_offset"),
                t ? setTimeout((()=>{
                    setTimeout((()=>{
                        bn.to(".home_hero_title--touch", {
                            display: "block",
                            duration: 0
                        }),
                        bn.to(".home_hero_title--touch", {
                            opacity: 1,
                            duration: 1,
                            duration: .65
                        }),
                        bn.to(this.elements.touchArrow, {
                            y: "-50%",
                            opacity: 1,
                            delay: .4,
                            duration: .7,
                            ease: "Power2.easeOut"
                        }),
                        bn.to(".home_hero_scroll_arrow", {
                            opacity: 1,
                            y: "0.4rem",
                            delay: .85,
                            duration: .95,
                            ease: "Power3.easeOut"
                        }),
                        bn.to(".home_hero_scroll_text", {
                            y: 0,
                            delay: .85,
                            duration: .95,
                            ease: "Power3.easeOut"
                        }),
                        bn.to(".home_hero_description--touch span span", {
                            y: 0,
                            duration: 1.35,
                            stagger: .08,
                            ease: "Power3.easeOut"
                        }),
                        bn.to(".home_hero_title_marquee-el", {
                            y: 0,
                            duration: 1.4,
                            stagger: -.135,
                            ease: "Power3.easeOut"
                        })
                    }
                    ), 800),
                    this.heroCl && this.heroCl.go(),
                    bn.fromTo(".header--touch_wrapper", {
                        y: "-100%"
                    }, {
                        y: 0,
                        duration: 1.4,
                        ease: "Power3.easeOut",
                        delay: .95
                    })
                }
                ), 2e3) : (bn.to(".home_hero_title--touch", {
                    display: "block",
                    duration: 0
                }),
                bn.to(".home_hero_title--touch", {
                    opacity: 1,
                    duration: 1,
                    duration: .65
                }),
                bn.to(".home_hero_description--touch span span", {
                    y: 0,
                    duration: 1.2,
                    stagger: .08,
                    ease: "Power3.easeOut"
                }),
                bn.to(".home_hero_title_marquee-el", {
                    y: 0,
                    duration: 1.4,
                    stagger: -.11,
                    ease: "Power3.easeOut"
                }),
                bn.to(this.elements.touchArrow, {
                    y: "-50%",
                    opacity: 1,
                    delay: .4,
                    duration: .7,
                    ease: "Power2.easeOut"
                }),
                bn.to(".home_hero_scroll_arrow", {
                    opacity: 1,
                    y: "0.4rem",
                    delay: .3,
                    duration: .7,
                    ease: "Power2.easeOut"
                }),
                bn.to(".home_hero_scroll_text", {
                    y: 0,
                    delay: .3,
                    duration: .7,
                    ease: "Power2.easeOut"
                }),
                this.heroCl && this.heroCl.go())) : this.tabIntro(t)
            }
            tabIntro(t) {
                let e = 0;
                t && (e = 2500),
                setTimeout((()=>{
                    bn.fromTo(".home_hero_arrow.innerArrow", {
                        y: "-2.5rem"
                    }, {
                        y: "-50%",
                        opacity: 1,
                        delay: 1,
                        ease: "Power3.easeOut"
                    }),
                    this.heroCl && this.heroCl.go(),
                    bn.to(".home_f span", {
                        y: "-104%",
                        stagger: .025,
                        duration: 1,
                        delay: .25,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(".home_s span", {
                        y: "0",
                        stagger: .025,
                        duration: 1,
                        delay: .35,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(".home_hero_description--tablet span span", {
                        y: "0",
                        stagger: .055,
                        duration: 1.45,
                        delay: .9,
                        ease: "Power3.easeOut"
                    }),
                    bn.to(".home_hero_scroll_text", {
                        y: 0,
                        duration: 1.4,
                        delay: .55,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(".home_hero_scroll_arrow", {
                        opacity: 1,
                        y: "0.4rem",
                        x: "0.4rem",
                        delay: .55,
                        ease: "Expo.easeOut"
                    })
                }
                ), e)
            }
            createMedias() {
                this.featStore = Sn()(this.elements.featImg, ((t,e)=>new nr({
                    el: t,
                    text: this.elements.text[e]
                })))
            }
            createTexts() {
                Jn.isPhone() || (this.textStore = Sn()(this.elements.aboutTitles, (t=>new cr({
                    el: t
                }))))
            }
            createCanvas() {
                this.canvas = new lr({
                    canvas: this.elements.canvas2D,
                    cp: this.cp
                })
            }
            start(t) {
                this.isDown = !0,
                this.touch = t.touches[0].clientX
            }
            launchCv() {
                this.canvas.create()
            }
            move(t) {
                this.isDown && (this.distance = 1 * (this.touch - t.touches[0].clientX),
                this.touch = t.touches[0].clientX,
                setTimeout((()=>{
                    this.distance = 0
                }
                ), 50),
                this.tg += 9e-4 * this.distance)
            }
            end() {
                this.isDown = !1
            }
            onWheel(t) {
                super.onWheel(t),
                Jn.isPhone() || (1 === Math.sign(t) ? (bn.killTweensOf(this.elements.header),
                bn.to(this.elements.header, {
                    y: "-100%",
                    duration: 1,
                    ease: "Power3.easeOut"
                })) : (bn.killTweensOf(this.elements.header),
                bn.to(this.elements.header, {
                    y: "0",
                    duration: 1,
                    ease: "Power3.easeOut"
                })),
                this.scroll.current >= this.scroll.limit - 50 && (bn.killTweensOf(this.elements.header),
                bn.to(this.elements.header, {
                    y: "0",
                    duration: 1,
                    ease: "Power3.easeOut"
                }),
                bn.to(this.elements.footer, {
                    y: "0",
                    duration: 1,
                    ease: "Power3.easeOut",
                    delay: .2
                })))
            }
            rs(t) {
                super.rs(t),
                this.v = t,
                this.b = Ln(this.elements.titleContainer),
                this.canvasB = Ln(this.elements.canvas2D);
                const {bottom: e} = this.canvasB;
                this.canvasBT = e + this.scroll.current,
                this.canvas.rs(this.canvasB),
                this.bAbout = Ln(this.elements.homeAbout).top + this.scroll.current;
                const {width: i} = this.b;
                if (!Jn.isDesktop()) {
                    this.abB = Ln(this.elements.about).top;
                    const t = 1 * Ln(this.elements.featRef).width
                      , e = Ln(this.elements.featImg[0]).width;
                    this.tr = t + e,
                    this.heroCl.rs(),
                    this.aboutCl.rs(),
                    this.featCl.rs(),
                    this.contactCl.rs()
                }
                this.textStore && this.textStore.forEach((e=>e.rs(i, t)))
            }
            onClick() {
                bn.to(this.scroll, {
                    target: this.bAbout,
                    duration: 1.8,
                    ease: "Expo.easeInOut"
                }),
                bn.killTweensOf(this.elements.header),
                bn.to(this.elements.header, {
                    y: "-100%",
                    duration: 1.8,
                    ease: "Expo.easeInOut"
                })
            }
            onCLickSc() {
                this.element.parentElement.scrollTo({
                    top: this.abB,
                    left: 0,
                    behavior: "smooth"
                })
            }
            scrollNav(t) {
                this.scroll.current > this.scroll.limit - 50 || (1 === Math.sign(t) ? (bn.killTweensOf(this.elements.headerTouch),
                bn.to(this.elements.headerTouch, {
                    y: "-110%",
                    duration: .25
                })) : (bn.killTweensOf(this.elements.headerTouch),
                bn.to(this.elements.headerTouch, {
                    y: "0",
                    duration: .25
                })))
            }
            update(t) {
                if (super.update(t),
                !this.v)
                    return;
                const {h: e} = this.v;
                this.seenCv || this.canvasBT - e - this.scroll.current < .5 * e && (this.seenCv = !0,
                this.launchCv()),
                this.canvas.update(this.scroll.current),
                this.scroll.target > this.scroll.current ? this.si = "l" : this.si = "r",
                this.textStore && this.textStore.forEach((t=>t.update(.7 * this.scroll.current, this.si, this.d))),
                Jn.isDesktop() || (Jn.isTablet() || this.marqueeStore.forEach((t=>t.update())),
                this.nameMarquee.update(),
                this.heroCl.update(),
                this.aboutCl.update(),
                this.featCl.update(),
                this.contactCl.update(),
                this.isDown)
            }
            ael() {
                Wn(Fn, this.onClick.bind(this), this.elements.homeBtn),
                Jn.isTablet() && Wn(Fn, this.onCLickSc.bind(this), this.elements.homeBtn),
                Jn.isPhone() && (this.elements.featC.addEventListener("touchstart", this.start),
                this.elements.featC.addEventListener("touchmove", this.move),
                Wn(jn, this.end.bind(this)),
                Wn(Fn, this.onCLickSc.bind(this), this.elements.scrollAb))
            }
            rel() {
                Vn(Fn, this.onClick.bind(this), this.elements.homeBtn),
                Jn.isTablet() && Vn(Fn, this.onCLickSc.bind(this), this.elements.homeBtn),
                Jn.isPhone() && (Vn(Un, this.start.bind(this), this.elements.featC),
                Vn(Hn, this.move.bind(this), this.elements.featC),
                Vn(jn, this.end.bind(this)),
                Vn(Fn, this.onCLickSc.bind(this), this.elements.scrollAb))
            }
        }
        class fr extends Qn {
            constructor() {
                super({
                    id: "about",
                    element: ".about",
                    elements: {
                        wrapper: ".about",
                        ssc: ".ssc",
                        header: ".header",
                        brands: ".about_brand_arrow_c",
                        skills: ".about_skill",
                        aboutDescription: ".about_hero_description",
                        aboutBio: ".about_bio .n1",
                        footer: ".footer_c",
                        contactBtn: ".home_contact_circle .circAn1",
                        headerTouch: ".header--touch"
                    }
                })
            }
            create(t, e) {
                super.create(),
                this.load(),
                this.first = e,
                this.trimDots(),
                Jn.isDesktop() && (ur({
                    element: this.elements.aboutBio,
                    expression: "<br>",
                    append: !0
                }),
                ur({
                    element: this.elements.aboutDescription,
                    expression: "<br>",
                    append: !0
                }),
                ur({
                    element: this.elements.aboutDescription,
                    expression: "<br>",
                    append: !0
                }),
                this.aboutBioSplit = ur({
                    element: this.elements.aboutBio,
                    expression: "<br>",
                    append: !0
                }),
                this.aboutBioSplit[0].classList.add("about_bio_offset")),
                Jn.isDesktop() || (this.contactCl = new ir({
                    el: this.elements.contactBtn,
                    touch: !0,
                    contact: !0
                }))
            }
            load() {
                if (Jn.isDesktop())
                    return;
                const t = Pn("img")
                  , e = t.getAttribute("data-src")
                  , i = new Image;
                i.src = e,
                i.crossOrigin = "anonymous",
                t.src = i.src
            }
            intro() {
                if (Jn.isDesktop())
                    return;
                let t = 0;
                t = this.first ? 2500 : 0,
                setTimeout((()=>{
                    this.first && bn.fromTo(".header--touch_wrapper", {
                        y: "-100%"
                    }, {
                        y: 0,
                        duration: 1.4,
                        ease: "Power3.easeOut",
                        delay: .95
                    }),
                    bn.to([".about_hero_img img", ".about_hero_img img_overlay"], {
                        scale: 1,
                        opacity: 1,
                        ease: "Power2.easeInOut",
                        duration: 1.8
                    }),
                    bn.to([".about_hero_title", ".about_hero_line_description_c"], {
                        y: 0,
                        opacity: 1,
                        stagger: 3,
                        delay: .3,
                        stagger: .25,
                        duration: 1.2,
                        ease: "Power3.easeInOut"
                    })
                }
                ), t)
            }
            trimDots() {
                this.elements.brands.forEach(((t,e)=>{
                    if (0 === e && t.classList.add("list_offset"),
                    e === this.elements.brands.length - 1) {
                        const e = t.querySelector(".about_list_dot");
                        e.parentElement.removeChild(e)
                    }
                }
                )),
                this.elements.skills.forEach(((t,e)=>{
                    if (e === this.elements.skills.length - 1) {
                        const e = t.querySelector(".about_list_dot");
                        e.parentElement.removeChild(e)
                    }
                }
                ))
            }
            onWheel(t) {
                super.onWheel(t),
                Jn.isPhone() || (1 === Math.sign(t) ? (bn.killTweensOf(this.elements.header),
                bn.to(this.elements.header, {
                    y: "-100%",
                    duration: 1,
                    ease: "Power3.easeOut"
                })) : (bn.killTweensOf(this.elements.header),
                bn.to(this.elements.header, {
                    y: "0",
                    duration: 1,
                    ease: "Power3.easeOut"
                })),
                this.scroll.current >= this.scroll.limit - 50 && (bn.killTweensOf(this.elements.header),
                bn.to(this.elements.header, {
                    y: "0",
                    duration: 1,
                    ease: "Power3.easeOut"
                }),
                bn.to(this.elements.footer, {
                    y: "0",
                    duration: 1,
                    ease: "Power3.easeOut",
                    delay: .2
                })))
            }
            rs(t) {
                super.rs(t),
                Jn.isDesktop() || this.contactCl.rs()
            }
            scrollNav(t) {
                1 === Math.sign(t) ? bn.to(this.elements.headerTouch, {
                    y: "-110%",
                    duration: .25
                }) : bn.to(this.elements.headerTouch, {
                    y: "0",
                    duration: .25
                })
            }
            update(t) {
                super.update(t),
                Jn.isDesktop() || this.contactCl.update()
            }
        }
        class mr {
            constructor({el: t, title: e, bullet: i, index: n, nbr: r, label: s}) {
                this.el = t,
                this.title = e,
                this.bullet = i,
                this.index = n,
                this.nbr = r,
                this.label = s,
                this.ct = 0,
                this.dt = 0,
                this.s = 0
            }
            rs(t, e, i) {
                this.isRs = !0,
                this.v = e,
                this.el.style.transform = "translate3d(0,0,0) scale(1)",
                this.container = t,
                this.b = Ln(this.el),
                this.ct = 0,
                this.dt = 0,
                this.s = 0;
                const {left: n, right: r, width: s, height: a} = this.b;
                this.width = s,
                this.left = s + n,
                this.right = r - s - e.w,
                this.isRs = !1
            }
            update(t, e) {
                if (this.isRs)
                    return;
                if (!this.v)
                    return;
                this.s = t - this.dt;
                const {w: i} = this.v;
                Jn.isTablet() ? (this.left - this.s < 0 && (this.ct += 1,
                this.dt = this.container * this.ct),
                this.right - this.s > 0 && (this.ct -= 1,
                this.dt = this.container * this.ct)) : ("l" === e && this.left - this.s < 0 && (this.ct += 1,
                this.dt = this.container * this.ct),
                "r" === e && this.right - this.s > 0 && (this.ct -= 1,
                this.dt = this.container * this.ct)),
                this.fc = (this.left - this.s) / (i + this.width) - .5;
                const n = On(this.fc, -.25, .25, -1, 1)
                  , r = On(Math.abs(this.fc), .1, 0, 0, .5);
                let s = On(Math.abs(this.fc), 0, .3, .8, 0)
                  , a = On(Math.abs(this.fc), 0, .3, 1, 0);
                this.bullet.style.transform = `scaleY(${1 + s})`,
                this.bullet.style.opacity = a + .4,
                Jn.isTablet() ? (this.el.parentElement.style.transform = `translate3d(${-1 * this.s}px, 0,0)`,
                this.el.style.opacity = a + .3,
                this.el.style.filter = `grayscale(${1 - a})`) : (this.el.parentElement.style.transform = `translate3d(${-1 * this.s}px, 0,0) scaleX(${.5 + .5 * a})`,
                this.el.style.transform = `scaleX(${1.5 - .5 * a})`),
                this.title.style.transform = `translateY(${100 * n}%)`,
                this.nbr.style.transform = `translateY(${100 * n}%)`,
                this.label.style.opacity = r
            }
        }
        class gr extends Qn {
            constructor() {
                super({
                    id: "projects",
                    element: ".projects",
                    elements: {
                        wrapper: ".projects",
                        images: ".projects_img_media",
                        container: ".projects_images_c",
                        titles: ".n2",
                        bulletContainer: ".projects_bullets_c",
                        titleTouch: ".projects_titles_c--touch",
                        count: ".projects_count_c",
                        underline: ".projects_unederLine_c",
                        labelContainer: ".projects_descriptions_c",
                        label: ".projects_description_label"
                    }
                })
            }
            create(t, e) {
                super.create(),
                this.load(),
                this.first = e,
                Jn.isDesktop() || (this.tg = 0,
                this.ps = 0,
                this.tps = 0,
                this.distance = 0,
                this.started = !1,
                this.test = {
                    current: 0,
                    target: 0,
                    ease: .12
                },
                setTimeout((()=>{
                    this.played = !0
                }
                ), 5e3),
                this.createNumbersAndLines(),
                this.createBullets(),
                this.ael())
            }
            load() {
                Jn.isDesktop() || [...Cn("img")].forEach((t=>{
                    const e = t.getAttribute("data-src");
                    if (!e)
                        return;
                    const i = new Image;
                    i.src = e,
                    i.crossOrigin = "anonymous",
                    t.src = i.src
                }
                ))
            }
            intro() {
                if (Jn.isDesktop())
                    return;
                let t = 0;
                t = this.first ? 2500 : 0,
                setTimeout((()=>{
                    this.first && bn.fromTo(".header--touch_wrapper", {
                        y: "-100%"
                    }, {
                        y: 0,
                        duration: 1.4,
                        ease: "Power3.easeOut",
                        delay: .95
                    }),
                    bn.to(".projects_wrapper", {
                        opacity: 1,
                        duration: 1,
                        ease: "Power3.easeIn"
                    })
                }
                ), t)
            }
            createBullets() {
                this.bullets = [],
                this.elements.images.forEach(((t,e)=>{
                    const i = document.createElement("div");
                    i.classList.add("projects_bullet"),
                    this.elements.bulletContainer.appendChild(i),
                    this.bullets.push(i)
                }
                )),
                this.createMedias()
            }
            createMedias() {
                this.store = Sn()(this.elements.images, ((t,e)=>new mr({
                    el: t,
                    title: this.elements.titles[e],
                    bullet: this.bullets[e],
                    nbr: this.nbrs[e],
                    label: this.elements.label[e],
                    index: e
                })))
            }
            createNumbersAndLines() {
                const t = Pn(".projects_count_c")
                  , e = Pn("p", t);
                this.linesContainer = Pn(".projects_unederLine_c"),
                this.nbrs = [],
                this.lines = [],
                this.elements.images.forEach(((t,i)=>{
                    const n = document.createElement("span")
                      , r = document.createElement("div");
                    n.classList.add("projects_case_nbr"),
                    r.classList.add("projects_case_underline"),
                    n.textContent = i + 1,
                    e.appendChild(n),
                    this.linesContainer.appendChild(r),
                    this.nbrs.push(n),
                    this.lines.push(r)
                }
                ))
            }
            start(t) {
                this.isDown = !0,
                this.started = !0,
                this.touch = t.touches[0].clientX
            }
            move(t) {
                this.isDown && (this.distance = 1 * (this.touch - t.touches[0].clientX),
                this.touch = t.touches[0].clientX,
                setTimeout((()=>{
                    this.distance = 0
                }
                ), 50),
                this.tg += 9e-4 * this.distance,
                this.test.target += this.distance)
            }
            end(t) {
                this.isDown = !1
            }
            rs(t) {
                if (super.rs(t),
                Jn.isDesktop())
                    return;
                this.isRs = !0,
                this.elements.images.forEach((t=>{
                    t.parentElement.style.transform = "translate3d(0,0,0) scale(1)"
                }
                )),
                this.ps = this.tg = 0;
                const e = Jn.isTablet() ? t.w / 768 * 10 * 1.5 : t.w / 375 * 10
                  , i = Ln(this.elements.container)
                  , n = Ln(this.elements.images[0]);
                Jn.isTablet() ? this.store.forEach((r=>r.rs(i.width + e, t, n.left))) : this.store.forEach((e=>e.rs(i.width + n.left / 2, t, n.left))),
                this.tr = e + n.width;
                const r = this.elements.labelContainer.style.top;
                this.elements.labelContainer.style.top = Jn.isTablet() ? `${i.bottom}px` : r,
                setTimeout((()=>{
                    const t = Ln(this.elements.titleTouch).top
                      , e = Ln(this.elements.count).height;
                    this.elements.count.style.top = t - e - 30 + "px",
                    this.elements.underline.style.top = t - 20 + "px",
                    this.isRs = !1
                }
                ), 10)
            }
            update(t) {
                if (super.update(t),
                Jn.isDesktop())
                    return;
                if (this.isRs)
                    return;
                if (this.isResizing)
                    return;
                this.test.current = bn.utils.interpolate(this.test.current, this.test.target, this.test.ease),
                this.side = this.test.target - this.test.current,
                Math.abs(this.side) > .5 ? this.elements.labelContainer.style.opacity = 0 : this.elements.labelContainer.style.opacity = 1,
                this.ps += this.tg,
                this.dr = this.tps - this.ps,
                this.tps = this.ps,
                1 === Math.sign(this.dr) ? this.si = "r" : this.si = "l",
                this.tg *= .91,
                this.rd = Math.round(this.ps);
                let e = this.rd - this.ps;
                this.ps += Math.sign(e) * Math.pow(Math.abs(e), .3) * .01,
                this.store.forEach((t=>t.update(this.ps * this.tr, this.si)))
            }
            ael() {
                Jn.isDesktop() || (Wn(Un, this.start.bind(this)),
                Wn(Hn, this.move.bind(this)),
                Wn(jn, this.end.bind(this)))
            }
            rel() {
                Jn.isDesktop() || (Vn(Un, this.start.bind(this)),
                Vn(Hn, this.move.bind(this)),
                Vn(jn, this.end.bind(this)))
            }
        }
        class vr extends Qn {
            constructor() {
                super({
                    id: "project",
                    element: ".project",
                    elements: {
                        wrapper: ".project",
                        ssc: ".ssc",
                        description: ".project_hero_description h2",
                        roles: ".project_hero_roles_p",
                        projIndex: ".project_nbr span",
                        viewCTA: ".project_view_cta",
                        header: ".header",
                        footer: ".footer_c",
                        next1: ".next1 p",
                        next2: ".next2 p",
                        nextBtn: ".project_next_case_c .circAn1",
                        headerTouch: ".header--touch",
                        challenge: ".project_description_challenge_d p",
                        approach: ".project_description_approach_d p",
                        miniHeader: ".mini_header",
                        test1: ".project_mobile_scroll_text",
                        test2: ".project_site_scroll_text",
                        imgBanner: ".img_banner"
                    }
                })
            }
            create(t, e) {
                if (super.create(),
                this.load(),
                this.first = e,
                ur({
                    element: this.elements.description,
                    expression: "<br>",
                    append: !0
                }),
                ur({
                    element: this.elements.description,
                    expression: "<br>",
                    append: !0
                }),
                ur({
                    element: this.elements.roles,
                    expression: "<br>",
                    append: !0
                }),
                ur({
                    element: this.elements.roles,
                    expression: "<br>",
                    append: !0
                }),
                ur({
                    element: this.elements.challenge,
                    expression: "<br>",
                    append: !0
                }),
                this.challengeSpans = ur({
                    element: this.elements.challenge,
                    expression: "<br>",
                    append: !0
                }),
                ur({
                    element: this.elements.approach,
                    expression: "<br>",
                    append: !0
                }),
                this.approachSpans = ur({
                    element: this.elements.approach,
                    expression: "<br>",
                    append: !0
                }),
                Jn.isDesktop() && this.intro(t, e),
                this.createMiniHeaders(),
                this.approachSpans[0].classList.add("project_intro_offset"),
                this.challengeSpans[0].classList.add("project_intro_offset"),
                (Jn.isPhone() || Jn.isTablet()) && (this.nextBtn = new ir({
                    el: this.elements.nextBtn,
                    touch: !0,
                    contact: !1,
                    next: !0
                })),
                !Jn.isDesktop())
                    return;
                const i = [...this.elements.next1.innerHTML];
                this.elements.next1.innerHTML = "";
                const n = [...this.elements.next2.innerHTML];
                this.elements.next2.innerHTML = "",
                i.map((t=>this.elements.next1.innerHTML += " " === t ? '<span class="project_space"></span>' : `<span>${t}</span>`)),
                n.map((t=>this.elements.next2.innerHTML += " " === t ? '<span class="project_space"></span>' : `<span>${t}</span>`))
            }
            load() {
                Jn.isDesktop() || [...Cn("img")].forEach((t=>{
                    const e = t.getAttribute("data-src");
                    if (!e)
                        return;
                    const i = new Image;
                    i.src = e,
                    i.crossOrigin = "anonymous",
                    t.src = i.src
                }
                ))
            }
            intro(t, e) {
                if (Jn.isDesktop()) {
                    if (t)
                        bn.to(".project_hero_line", {
                            scaleX: 1,
                            duration: 1.2,
                            delay: .1,
                            ease: "Expo.easeInOut"
                        }),
                        bn.to(".project_hero_header_rv", {
                            y: 0,
                            duration: 1.2,
                            delay: .1,
                            ease: "Expo.easeInOut"
                        }),
                        bn.to(".project_hero_title h1 span", {
                            y: 0,
                            duration: 1,
                            ease: "Power3.easeOut"
                        }),
                        bn.to(".project_hero_description h2 span span", {
                            y: 0,
                            stagger: .12,
                            delay: .3,
                            duration: 1.5,
                            ease: "Power3.easeOut"
                        });
                    else {
                        let t = 0;
                        t = e ? 2e3 : 600,
                        setTimeout((()=>{
                            bn.to(".project_hero_line", {
                                scaleX: 1,
                                duration: 1.2,
                                delay: .1,
                                ease: "Expo.easeInOut"
                            }),
                            bn.to(".project_hero_header_rv", {
                                y: 0,
                                duration: 1.2,
                                delay: .1,
                                ease: "Expo.easeInOut"
                            }),
                            bn.to(".project_hero_title h1 span", {
                                y: 0,
                                duration: 1,
                                ease: "Power3.easeOut"
                            }),
                            bn.to(".project_hero_description h2 span span", {
                                y: 0,
                                stagger: .12,
                                delay: .3,
                                duration: 1.5,
                                ease: "Power3.easeOut"
                            })
                        }
                        ), t)
                    }
                    this.elements.test1 && bn.to(this.elements.test1, {
                        opacity: 1,
                        delay: 2
                    }),
                    this.elements.test2 && bn.to(this.elements.test2, {
                        opacity: 1,
                        delay: 2
                    })
                } else {
                    let t = 0;
                    t = this.first ? 2500 : 600,
                    this.first ? setTimeout((()=>{
                        bn.fromTo(".header--touch_wrapper", {
                            y: "-100%"
                        }, {
                            y: 0,
                            duration: 1.4,
                            ease: "Power3.easeOut",
                            delay: .95
                        }),
                        bn.to(".project_hero_line", {
                            scaleX: 1,
                            duration: 1.2,
                            delay: .3,
                            ease: "Expo.easeInOut"
                        }),
                        bn.to(".project_hero_header_rv", {
                            y: 0,
                            duration: 1.2,
                            delay: .5,
                            ease: "Expo.easeOut"
                        }),
                        bn.to(".project_hero_title h1 span", {
                            y: 0,
                            duration: 1,
                            delay: .8,
                            ease: "Power3.easeOut"
                        }),
                        bn.fromTo([".project_hero_img img", ".project_hero_img .img_overlay"], {
                            opacity: 0,
                            scale: .98
                        }, {
                            opacity: 1,
                            scale: 1,
                            delay: .15,
                            duration: 1,
                            ease: "Power3.easeInOut"
                        }),
                        bn.to(".project_hero_description h2 span span", {
                            y: 0,
                            stagger: .12,
                            delay: .13,
                            duration: 1.25,
                            ease: "Power3.easeOut"
                        }),
                        bn.to(".project_hero_roles_title span", {
                            y: 0,
                            y: 0,
                            delay: .3,
                            duration: 1.25,
                            ease: "Power3.easeOut"
                        }),
                        bn.to(".project_hero_roles span", {
                            y: 0,
                            stagger: .05,
                            delay: 0,
                            duration: 1,
                            ease: "Power3.easeOut"
                        }),
                        this.elements.viewCTA && (bn.to(".project_view_cta_border svg rect", {
                            strokeDashoffset: 0,
                            duration: 1.2,
                            delay: .3,
                            ease: "Power3.easeInOut"
                        }),
                        bn.to([".link_outer p", ".link_outer .project_view_cta_arrow"], {
                            y: 0,
                            opacity: 1,
                            duration: 1.2,
                            delay: .3,
                            ease: "Power3.easeInOut"
                        }))
                    }
                    ), 2500) : setTimeout((()=>{
                        bn.to(".project_hero_line", {
                            scaleX: 1,
                            duration: 1.2,
                            delay: .1,
                            ease: "Expo.easeInOut"
                        }),
                        bn.to(".project_hero_header_rv", {
                            y: 0,
                            duration: 1.2,
                            delay: .1,
                            ease: "Expo.easeInOut"
                        }),
                        bn.to(".project_hero_title h1 span", {
                            y: 0,
                            duration: 1,
                            ease: "Power3.easeOut"
                        }),
                        bn.to(".project_hero_description h2 span span", {
                            y: 0,
                            stagger: .12,
                            delay: .3,
                            duration: 1.5,
                            ease: "Power3.easeOut"
                        }),
                        bn.fromTo([".project_hero_img img", ".project_hero_img .img_overlay"], {
                            opacity: 0,
                            scale: .98
                        }, {
                            opacity: 1,
                            scale: 1,
                            delay: .15,
                            duration: .8,
                            ease: "Power3.easeInOut"
                        }),
                        bn.to(".project_hero_roles_title span", {
                            y: 0,
                            y: 0,
                            delay: .8,
                            duration: 1.25,
                            ease: "Power3.easeOut"
                        }),
                        bn.to(".project_hero_roles span", {
                            y: 0,
                            stagger: .05,
                            delay: .9,
                            duration: 1,
                            ease: "Power3.easeOut"
                        }),
                        this.elements.viewCTA && (bn.to(".project_view_cta_border svg rect", {
                            strokeDashoffset: 0,
                            duration: 1.2,
                            delay: .3,
                            ease: "Power3.easeInOut"
                        }),
                        bn.to([".link_outer p", ".link_outer .project_view_cta_arrow"], {
                            y: 0,
                            opacity: 1,
                            duration: 1.2,
                            delay: .3,
                            ease: "Power3.easeInOut"
                        }))
                    }
                    ), 200)
                }
            }
            createMiniHeaders() {
                const t = this.elements.miniHeader.length;
                this.elements.miniHeader.forEach(((e,i)=>{
                    const n = e.querySelector(".header_nbr");
                    e.querySelector(".header_total").innerHTML = t < 10 ? `/0 ${t}` : `${t}/`,
                    n.innerHTML = i + 1 < 10 ? `0 ${i + 1}/` : `${i + 1}/`
                }
                ))
            }
            onWheel(t) {
                super.onWheel(t),
                1 === Math.sign(t) ? (bn.killTweensOf(this.elements.header),
                bn.to(this.elements.header, {
                    y: "-100%",
                    duration: 1,
                    ease: "Power3.easeOut"
                })) : (bn.killTweensOf(this.elements.header),
                bn.to(this.elements.header, {
                    y: "0",
                    duration: 1,
                    ease: "Power3.easeOut"
                })),
                this.scroll.current >= this.scroll.limit - 50 && (bn.killTweensOf(this.elements.header),
                bn.to(this.elements.header, {
                    y: "0",
                    duration: 1,
                    ease: "Power3.easeOut"
                }),
                bn.to(this.elements.footer, {
                    y: "0",
                    duration: 1,
                    ease: "Power3.easeOut",
                    delay: .2
                }))
            }
            rs(t) {
                if (super.rs(t),
                !Jn.isDesktop()) {
                    if (this.nextBtn.rs(),
                    Jn.isPhone()) {
                        const t = window.innerWidth / 375 * 10;
                        Ln(Pn(".project_hero_title")).height / t > 6 && this.adjTitleM()
                    }
                    if (Jn.isTablet()) {
                        const t = window.innerWidth / 768 * 10;
                        Ln(Pn(".project_hero_title")).height / t > 9 && this.adjTitleT()
                    }
                }
            }
            adjTitleM() {
                Pn(".project_hero_title").style.top = "-9.5rem",
                Pn(".project_hero").style.marginTop = "10rem"
            }
            adjTitleT() {
                Pn(".project_hero_img").style.top = "26.8rem",
                Pn(".project_hero_description").style.top = "34rem",
                Pn(".project_hero_roles_title").style.top = "60rem",
                Pn(".project_hero_roles").style.top = "64.4rem",
                this.elements.viewCTA && (this.elements.viewCTA.style.top = "76.6rem"),
                Pn(".project_hero").style.height = "94rem"
            }
            scrollNav(t) {
                this.scroll.current > this.scroll.limit - 50 || (1 === Math.sign(t) ? (bn.killTweensOf(this.elements.headerTouch),
                bn.to(this.elements.headerTouch, {
                    y: "-110%",
                    duration: .25
                })) : (bn.killTweensOf(this.elements.headerTouch),
                bn.to(this.elements.headerTouch, {
                    y: "0",
                    duration: .25
                })))
            }
            update(t) {
                super.update(t),
                Jn.isDesktop() || this.nextBtn.update()
            }
        }
        class yr extends Qn {
            constructor() {
                super({
                    id: "not_found",
                    element: ".not_found",
                    elements: {
                        marquee: ".not_found_404_marquee_text",
                        circle: ".circAn"
                    }
                })
            }
            create() {
                super.create(),
                this.dist1 = 0,
                this.dist2 = 0,
                this.dist3 = 0,
                this.dist4 = 0,
                this.cl = Sn()(this.elements.circle, (t=>new ir({
                    el: t
                }))),
                this.intro()
            }
            intro() {
                this.cl.forEach((t=>t.go())),
                bn.to(".btn_inner_text p", {
                    opacity: 1,
                    delay: 1,
                    duration: .5
                })
            }
            rs() {
                super.rs(),
                this.cl.forEach((t=>t.rs()))
            }
            update(t, e) {
                super.update(t, e),
                this.cl.forEach((t=>t.update())),
                this.dist1 -= .5,
                this.dist2 -= .5,
                this.dist3 -= .5,
                this.dist4 -= .5,
                -110 === this.dist1 && (this.dist1 = 305),
                -210 === this.dist2 && (this.dist2 = 205),
                -310 === this.dist3 && (this.dist3 = 105),
                -410 === this.dist4 && (this.dist4 = 5),
                this.elements.marquee[0].style.transform = `translateX(${this.dist1}%)`,
                this.elements.marquee[1].style.transform = `translateX(${this.dist2}%)`,
                this.elements.marquee[2].style.transform = `translateX(${this.dist3}%)`,
                this.elements.marquee[3].style.transform = `translateX(${this.dist4}%)`
            }
        }
        class xr extends Qn {
            constructor() {
                super({
                    id: "contact",
                    element: ".contact",
                    elements: {
                        circle: ".circAn"
                    }
                })
            }
            create(t, e) {
                super.create(),
                this.createCl(),
                this.rv(e)
            }
            createCl() {
                const t = this.elements.circle;
                this.cl = Sn()(t, (t=>new ir({
                    el: t
                })))
            }
            intro() {}
            rv(t) {
                if (Jn.isDesktop())
                    return;
                let e = t ? 3100 : 500
                  , i = Jn.isPhone() ? [".home_contact_title_el1", " .home_contact_title_el1 ", ".home_contact_mail span", ".footer_nav_item a"] : [".home_contact_title_el1", " .home_contact_title_el1 ", ".home_contact_mail span", ".footer_sen p", ".footer_nav_item a"];
                setTimeout((()=>{
                    bn.to(i, {
                        y: 0,
                        duration: 1,
                        ease: "Power3.easeOut",
                        stagger: .05
                    }),
                    bn.to(".home_featured_btn_text p", {
                        opacity: 1,
                        delay: 1
                    }),
                    this.cl.forEach((t=>t.go()))
                }
                ), e)
            }
            rs() {
                super.rs(),
                this.cl.forEach((t=>t.rs()))
            }
            update(t, e) {
                super.update(t, e),
                this.cl.forEach((t=>t.update()))
            }
        }
        const _r = 0
          , br = 1
          , wr = 2
          , Mr = 1
          , Tr = 2
          , Er = 3
          , Sr = 0
          , Ar = 1
          , Lr = 2
          , Pr = 0
          , Cr = 1
          , Rr = 2
          , Or = 3
          , Dr = 4
          , Ir = 5
          , Nr = 100
          , zr = 101
          , Br = 102
          , kr = 103
          , Fr = 104
          , Ur = 200
          , Hr = 201
          , jr = 202
          , Gr = 203
          , Wr = 204
          , Vr = 205
          , qr = 206
          , Xr = 207
          , Yr = 208
          , Zr = 209
          , Jr = 210
          , $r = 0
          , Qr = 1
          , Kr = 2
          , ts = 3
          , es = 4
          , is = 5
          , ns = 6
          , rs = 7
          , ss = 0
          , as = 1
          , os = 2
          , hs = 0
          , ls = 1
          , cs = 2
          , us = 3
          , ds = 4
          , ps = 5
          , fs = 301
          , ms = 302
          , gs = 303
          , vs = 304
          , ys = 306
          , xs = 307
          , _s = 1e3
          , bs = 1001
          , ws = 1002
          , Ms = 1003
          , Ts = 1004
          , Es = 1005
          , Ss = 1006
          , As = 1007
          , Ls = 1008
          , Ps = 1009
          , Cs = 1010
          , Rs = 1011
          , Os = 1012
          , Ds = 1013
          , Is = 1014
          , Ns = 1015
          , zs = 1016
          , Bs = 1017
          , ks = 1018
          , Fs = 1019
          , Us = 1020
          , Hs = 1021
          , js = 1022
          , Gs = 1023
          , Ws = 1024
          , Vs = 1025
          , qs = 1026
          , Xs = 1027
          , Ys = 1028
          , Zs = 1029
          , Js = 1030
          , $s = 1031
          , Qs = 1032
          , Ks = 1033
          , ta = 33776
          , ea = 33777
          , ia = 33778
          , na = 33779
          , ra = 35840
          , sa = 35841
          , aa = 35842
          , oa = 35843
          , ha = 36196
          , la = 37492
          , ca = 37496
          , ua = 37808
          , da = 37809
          , pa = 37810
          , fa = 37811
          , ma = 37812
          , ga = 37813
          , va = 37814
          , ya = 37815
          , xa = 37816
          , _a = 37817
          , ba = 37818
          , wa = 37819
          , Ma = 37820
          , Ta = 37821
          , Ea = 36492
          , Sa = 37840
          , Aa = 37841
          , La = 37842
          , Pa = 37843
          , Ca = 37844
          , Ra = 37845
          , Oa = 37846
          , Da = 37847
          , Ia = 37848
          , Na = 37849
          , za = 37850
          , Ba = 37851
          , ka = 37852
          , Fa = 37853
          , Ua = 2300
          , Ha = 2301
          , ja = 2302
          , Ga = 2400
          , Wa = 2401
          , Va = 2402
          , qa = 3e3
          , Xa = 3001
          , Ya = 3007
          , Za = 3002
          , Ja = 3003
          , $a = 3004
          , Qa = 3005
          , Ka = 3006
          , to = 3201
          , eo = 0
          , io = 1
          , no = 7680
          , ro = 519
          , so = 35044
          , ao = 35048
          , oo = "300 es";
        function ho() {}
        Object.assign(ho.prototype, {
            addEventListener: function(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const i = this._listeners;
                void 0 === i[t] && (i[t] = []),
                -1 === i[t].indexOf(e) && i[t].push(e)
            },
            hasEventListener: function(t, e) {
                if (void 0 === this._listeners)
                    return !1;
                const i = this._listeners;
                return void 0 !== i[t] && -1 !== i[t].indexOf(e)
            },
            removeEventListener: function(t, e) {
                if (void 0 === this._listeners)
                    return;
                const i = this._listeners[t];
                if (void 0 !== i) {
                    const t = i.indexOf(e);
                    -1 !== t && i.splice(t, 1)
                }
            },
            dispatchEvent: function(t) {
                if (void 0 === this._listeners)
                    return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const i = e.slice(0);
                    for (let e = 0, n = i.length; e < n; e++)
                        i[e].call(this, t)
                }
            }
        });
        const lo = [];
        for (let t = 0; t < 256; t++)
            lo[t] = (t < 16 ? "0" : "") + t.toString(16);
        let co = 1234567;
        const uo = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                const t = 4294967295 * Math.random() | 0
                  , e = 4294967295 * Math.random() | 0
                  , i = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0;
                return (lo[255 & t] + lo[t >> 8 & 255] + lo[t >> 16 & 255] + lo[t >> 24 & 255] + "-" + lo[255 & e] + lo[e >> 8 & 255] + "-" + lo[e >> 16 & 15 | 64] + lo[e >> 24 & 255] + "-" + lo[63 & i | 128] + lo[i >> 8 & 255] + "-" + lo[i >> 16 & 255] + lo[i >> 24 & 255] + lo[255 & n] + lo[n >> 8 & 255] + lo[n >> 16 & 255] + lo[n >> 24 & 255]).toUpperCase()
            },
            clamp: function(t, e, i) {
                return Math.max(e, Math.min(i, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, i, n, r) {
                return n + (t - e) * (r - n) / (i - e)
            },
            lerp: function(t, e, i) {
                return (1 - i) * t + i * e
            },
            damp: function(t, e, i, n) {
                return uo.lerp(t, e, 1 - Math.exp(-i * n))
            },
            pingpong: function(t, e=1) {
                return e - Math.abs(uo.euclideanModulo(t, 2 * e) - e)
            },
            smoothstep: function(t, e, i) {
                return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            seededRandom: function(t) {
                return void 0 !== t && (co = t % 2147483647),
                co = 16807 * co % 2147483647,
                (co - 1) / 2147483646
            },
            degToRad: function(t) {
                return t * uo.DEG2RAD
            },
            radToDeg: function(t) {
                return t * uo.RAD2DEG
            },
            isPowerOfTwo: function(t) {
                return 0 == (t & t - 1) && 0 !== t
            },
            ceilPowerOfTwo: function(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: function(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
            },
            setQuaternionFromProperEuler: function(t, e, i, n, r) {
                const s = Math.cos
                  , a = Math.sin
                  , o = s(i / 2)
                  , h = a(i / 2)
                  , l = s((e + n) / 2)
                  , c = a((e + n) / 2)
                  , u = s((e - n) / 2)
                  , d = a((e - n) / 2)
                  , p = s((n - e) / 2)
                  , f = a((n - e) / 2);
                switch (r) {
                case "XYX":
                    t.set(o * c, h * u, h * d, o * l);
                    break;
                case "YZY":
                    t.set(h * d, o * c, h * u, o * l);
                    break;
                case "ZXZ":
                    t.set(h * u, h * d, o * c, o * l);
                    break;
                case "XZX":
                    t.set(o * c, h * f, h * p, o * l);
                    break;
                case "YXY":
                    t.set(h * p, o * c, h * f, o * l);
                    break;
                case "ZYZ":
                    t.set(h * f, h * p, o * c, o * l);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            }
        };
        class po {
            constructor(t=0, e=0) {
                this.x = t,
                this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t,
                this.y = e,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x
                  , i = this.y
                  , n = t.elements;
                return this.x = n[0] * e + n[3] * i + n[6],
                this.y = n[1] * e + n[4] * i + n[7],
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this
            }
            clampLength(t, e) {
                const i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , i = this.y - t.y;
                return e * e + i * i
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this
            }
            lerpVectors(t, e, i) {
                return this.x = t.x + (e.x - t.x) * i,
                this.y = t.y + (e.y - t.y) * i,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t
            }
            fromBufferAttribute(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this
            }
            rotateAround(t, e) {
                const i = Math.cos(e)
                  , n = Math.sin(e)
                  , r = this.x - t.x
                  , s = this.y - t.y;
                return this.x = r * i - s * n + t.x,
                this.y = r * n + s * i + t.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
        }
        po.prototype.isVector2 = !0;
        class fo {
            constructor() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, i, n, r, s, a, o, h) {
                const l = this.elements;
                return l[0] = t,
                l[1] = n,
                l[2] = a,
                l[3] = e,
                l[4] = r,
                l[5] = o,
                l[6] = i,
                l[7] = s,
                l[8] = h,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(t) {
                const e = this.elements
                  , i = t.elements;
                return e[0] = i[0],
                e[1] = i[1],
                e[2] = i[2],
                e[3] = i[3],
                e[4] = i[4],
                e[5] = i[5],
                e[6] = i[6],
                e[7] = i[7],
                e[8] = i[8],
                this
            }
            extractBasis(t, e, i) {
                return t.setFromMatrix3Column(this, 0),
                e.setFromMatrix3Column(this, 1),
                i.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
                this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const i = t.elements
                  , n = e.elements
                  , r = this.elements
                  , s = i[0]
                  , a = i[3]
                  , o = i[6]
                  , h = i[1]
                  , l = i[4]
                  , c = i[7]
                  , u = i[2]
                  , d = i[5]
                  , p = i[8]
                  , f = n[0]
                  , m = n[3]
                  , g = n[6]
                  , v = n[1]
                  , y = n[4]
                  , x = n[7]
                  , _ = n[2]
                  , b = n[5]
                  , w = n[8];
                return r[0] = s * f + a * v + o * _,
                r[3] = s * m + a * y + o * b,
                r[6] = s * g + a * x + o * w,
                r[1] = h * f + l * v + c * _,
                r[4] = h * m + l * y + c * b,
                r[7] = h * g + l * x + c * w,
                r[2] = u * f + d * v + p * _,
                r[5] = u * m + d * y + p * b,
                r[8] = u * g + d * x + p * w,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[3] *= t,
                e[6] *= t,
                e[1] *= t,
                e[4] *= t,
                e[7] *= t,
                e[2] *= t,
                e[5] *= t,
                e[8] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , i = t[1]
                  , n = t[2]
                  , r = t[3]
                  , s = t[4]
                  , a = t[5]
                  , o = t[6]
                  , h = t[7]
                  , l = t[8];
                return e * s * l - e * a * h - i * r * l + i * a * o + n * r * h - n * s * o
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , i = t[1]
                  , n = t[2]
                  , r = t[3]
                  , s = t[4]
                  , a = t[5]
                  , o = t[6]
                  , h = t[7]
                  , l = t[8]
                  , c = l * s - a * h
                  , u = a * o - l * r
                  , d = h * r - s * o
                  , p = e * c + i * u + n * d;
                if (0 === p)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return t[0] = c * f,
                t[1] = (n * h - l * i) * f,
                t[2] = (a * i - n * s) * f,
                t[3] = u * f,
                t[4] = (l * e - n * o) * f,
                t[5] = (n * r - a * e) * f,
                t[6] = d * f,
                t[7] = (i * o - h * e) * f,
                t[8] = (s * e - i * r) * f,
                this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1],
                e[1] = e[3],
                e[3] = t,
                t = e[2],
                e[2] = e[6],
                e[6] = t,
                t = e[5],
                e[5] = e[7],
                e[7] = t,
                this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0],
                t[1] = e[3],
                t[2] = e[6],
                t[3] = e[1],
                t[4] = e[4],
                t[5] = e[7],
                t[6] = e[2],
                t[7] = e[5],
                t[8] = e[8],
                this
            }
            setUvTransform(t, e, i, n, r, s, a) {
                const o = Math.cos(r)
                  , h = Math.sin(r);
                return this.set(i * o, i * h, -i * (o * s + h * a) + s + t, -n * h, n * o, -n * (-h * s + o * a) + a + e, 0, 0, 1),
                this
            }
            scale(t, e) {
                const i = this.elements;
                return i[0] *= t,
                i[3] *= t,
                i[6] *= t,
                i[1] *= e,
                i[4] *= e,
                i[7] *= e,
                this
            }
            rotate(t) {
                const e = Math.cos(t)
                  , i = Math.sin(t)
                  , n = this.elements
                  , r = n[0]
                  , s = n[3]
                  , a = n[6]
                  , o = n[1]
                  , h = n[4]
                  , l = n[7];
                return n[0] = e * r + i * o,
                n[3] = e * s + i * h,
                n[6] = e * a + i * l,
                n[1] = -i * r + e * o,
                n[4] = -i * s + e * h,
                n[7] = -i * a + e * l,
                this
            }
            translate(t, e) {
                const i = this.elements;
                return i[0] += t * i[2],
                i[3] += t * i[5],
                i[6] += t * i[8],
                i[1] += e * i[2],
                i[4] += e * i[5],
                i[7] += e * i[8],
                this
            }
            equals(t) {
                const e = this.elements
                  , i = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== i[t])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let i = 0; i < 9; i++)
                    this.elements[i] = t[i + e];
                return this
            }
            toArray(t=[], e=0) {
                const i = this.elements;
                return t[e] = i[0],
                t[e + 1] = i[1],
                t[e + 2] = i[2],
                t[e + 3] = i[3],
                t[e + 4] = i[4],
                t[e + 5] = i[5],
                t[e + 6] = i[6],
                t[e + 7] = i[7],
                t[e + 8] = i[8],
                t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        let mo;
        fo.prototype.isMatrix3 = !0;
        const go = {
            getDataURL: function(t) {
                if (/^data:/i.test(t.src))
                    return t.src;
                if ("undefined" == typeof HTMLCanvasElement)
                    return t.src;
                let e;
                if (t instanceof HTMLCanvasElement)
                    e = t;
                else {
                    void 0 === mo && (mo = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                    mo.width = t.width,
                    mo.height = t.height;
                    const i = mo.getContext("2d");
                    t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height),
                    e = mo
                }
                return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            }
        };
        let vo = 0;
        class yo extends ho {
            constructor(t=yo.DEFAULT_IMAGE, e=yo.DEFAULT_MAPPING, i=bs, n=bs, r=Ss, s=Ls, a=Gs, o=Ps, h=1, l=qa) {
                super(),
                Object.defineProperty(this, "id", {
                    value: vo++
                }),
                this.uuid = uo.generateUUID(),
                this.name = "",
                this.image = t,
                this.mipmaps = [],
                this.mapping = e,
                this.wrapS = i,
                this.wrapT = n,
                this.magFilter = r,
                this.minFilter = s,
                this.anisotropy = h,
                this.format = a,
                this.internalFormat = null,
                this.type = o,
                this.offset = new po(0,0),
                this.repeat = new po(1,1),
                this.center = new po(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new fo,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                this.encoding = l,
                this.version = 0,
                this.onUpdate = null
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name,
                this.image = t.image,
                this.mipmaps = t.mipmaps.slice(0),
                this.mapping = t.mapping,
                this.wrapS = t.wrapS,
                this.wrapT = t.wrapT,
                this.magFilter = t.magFilter,
                this.minFilter = t.minFilter,
                this.anisotropy = t.anisotropy,
                this.format = t.format,
                this.internalFormat = t.internalFormat,
                this.type = t.type,
                this.offset.copy(t.offset),
                this.repeat.copy(t.repeat),
                this.center.copy(t.center),
                this.rotation = t.rotation,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrix.copy(t.matrix),
                this.generateMipmaps = t.generateMipmaps,
                this.premultiplyAlpha = t.premultiplyAlpha,
                this.flipY = t.flipY,
                this.unpackAlignment = t.unpackAlignment,
                this.encoding = t.encoding,
                this
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid])
                    return t.textures[this.uuid];
                const i = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    const n = this.image;
                    if (void 0 === n.uuid && (n.uuid = uo.generateUUID()),
                    !e && void 0 === t.images[n.uuid]) {
                        let e;
                        if (Array.isArray(n)) {
                            e = [];
                            for (let t = 0, i = n.length; t < i; t++)
                                n[t].isDataTexture ? e.push(xo(n[t].image)) : e.push(xo(n[t]))
                        } else
                            e = xo(n);
                        t.images[n.uuid] = {
                            uuid: n.uuid,
                            url: e
                        }
                    }
                    i.image = n.uuid
                }
                return e || (t.textures[this.uuid] = i),
                i
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (300 !== this.mapping)
                    return t;
                if (t.applyMatrix3(this.matrix),
                t.x < 0 || t.x > 1)
                    switch (this.wrapS) {
                    case _s:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case bs:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case ws:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                if (t.y < 0 || t.y > 1)
                    switch (this.wrapT) {
                    case _s:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case bs:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case ws:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                return this.flipY && (t.y = 1 - t.y),
                t
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        function xo(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? go.getDataURL(t) : t.data ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        yo.DEFAULT_IMAGE = void 0,
        yo.DEFAULT_MAPPING = 300,
        yo.prototype.isTexture = !0;
        class _o {
            constructor(t=0, e=0, i=0, n=1) {
                this.x = t,
                this.y = e,
                this.z = i,
                this.w = n
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, i, n) {
                return this.x = t,
                this.y = e,
                this.z = i,
                this.w = n,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this.w = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setW(t) {
                return this.w = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this.w = void 0 !== t.w ? t.w : 1,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this.w += t.w,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this.w += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this.w = t.w + e.w,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this.w += t.w * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this.w -= t.w,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this.w -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this.w = t.w - e.w,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this.w *= t.w,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this.w *= t,
                this
            }
            applyMatrix4(t) {
                const e = this.x
                  , i = this.y
                  , n = this.z
                  , r = this.w
                  , s = t.elements;
                return this.x = s[0] * e + s[4] * i + s[8] * n + s[12] * r,
                this.y = s[1] * e + s[5] * i + s[9] * n + s[13] * r,
                this.z = s[2] * e + s[6] * i + s[10] * n + s[14] * r,
                this.w = s[3] * e + s[7] * i + s[11] * n + s[15] * r,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = t.x / e,
                this.y = t.y / e,
                this.z = t.z / e),
                this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, i, n, r;
                const s = .01
                  , a = .1
                  , o = t.elements
                  , h = o[0]
                  , l = o[4]
                  , c = o[8]
                  , u = o[1]
                  , d = o[5]
                  , p = o[9]
                  , f = o[2]
                  , m = o[6]
                  , g = o[10];
                if (Math.abs(l - u) < s && Math.abs(c - f) < s && Math.abs(p - m) < s) {
                    if (Math.abs(l + u) < a && Math.abs(c + f) < a && Math.abs(p + m) < a && Math.abs(h + d + g - 3) < a)
                        return this.set(1, 0, 0, 0),
                        this;
                    e = Math.PI;
                    const t = (h + 1) / 2
                      , o = (d + 1) / 2
                      , v = (g + 1) / 2
                      , y = (l + u) / 4
                      , x = (c + f) / 4
                      , _ = (p + m) / 4;
                    return t > o && t > v ? t < s ? (i = 0,
                    n = .707106781,
                    r = .707106781) : (i = Math.sqrt(t),
                    n = y / i,
                    r = x / i) : o > v ? o < s ? (i = .707106781,
                    n = 0,
                    r = .707106781) : (n = Math.sqrt(o),
                    i = y / n,
                    r = _ / n) : v < s ? (i = .707106781,
                    n = .707106781,
                    r = 0) : (r = Math.sqrt(v),
                    i = x / r,
                    n = _ / r),
                    this.set(i, n, r, e),
                    this
                }
                let v = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (u - l) * (u - l));
                return Math.abs(v) < .001 && (v = 1),
                this.x = (m - p) / v,
                this.y = (c - f) / v,
                this.z = (u - l) / v,
                this.w = Math.acos((h + d + g - 1) / 2),
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this.w = Math.min(this.w, t.w),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this.w = Math.max(this.w, t.w),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this.w = Math.max(t.w, Math.min(e.w, this.w)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this.w = Math.max(t, Math.min(e, this.w)),
                this
            }
            clampLength(t, e) {
                const i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this.w += (t.w - this.w) * e,
                this
            }
            lerpVectors(t, e, i) {
                return this.x = t.x + (e.x - t.x) * i,
                this.y = t.y + (e.y - t.y) * i,
                this.z = t.z + (e.z - t.z) * i,
                this.w = t.w + (e.w - t.w) * i,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this.w = t[e + 3],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t[e + 3] = this.w,
                t
            }
            fromBufferAttribute(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this.w = t.getW(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
        }
        _o.prototype.isVector4 = !0;
        class bo extends ho {
            constructor(t, e, i) {
                super(),
                this.width = t,
                this.height = e,
                this.depth = 1,
                this.scissor = new _o(0,0,t,e),
                this.scissorTest = !1,
                this.viewport = new _o(0,0,t,e),
                i = i || {},
                this.texture = new yo(void 0,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),
                this.texture.image = {},
                this.texture.image.width = t,
                this.texture.image.height = e,
                this.texture.image.depth = 1,
                this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps,
                this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Ss,
                this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer,
                this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer,
                this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
            }
            setTexture(t) {
                t.image = {
                    width: this.width,
                    height: this.height,
                    depth: this.depth
                },
                this.texture = t
            }
            setSize(t, e, i=1) {
                this.width === t && this.height === e && this.depth === i || (this.width = t,
                this.height = e,
                this.depth = i,
                this.texture.image.width = t,
                this.texture.image.height = e,
                this.texture.image.depth = i,
                this.dispose()),
                this.viewport.set(0, 0, t, e),
                this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.width = t.width,
                this.height = t.height,
                this.depth = t.depth,
                this.viewport.copy(t.viewport),
                this.texture = t.texture.clone(),
                this.depthBuffer = t.depthBuffer,
                this.stencilBuffer = t.stencilBuffer,
                this.depthTexture = t.depthTexture,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        bo.prototype.isWebGLRenderTarget = !0,
        class extends bo {
            constructor(t, e, i) {
                super(t, e, i),
                this.samples = 4
            }
            copy(t) {
                return super.copy.call(this, t),
                this.samples = t.samples,
                this
            }
        }
        .prototype.isWebGLMultisampleRenderTarget = !0;
        class wo {
            constructor(t=0, e=0, i=0, n=1) {
                this._x = t,
                this._y = e,
                this._z = i,
                this._w = n
            }
            static slerp(t, e, i, n) {
                return i.copy(t).slerp(e, n)
            }
            static slerpFlat(t, e, i, n, r, s, a) {
                let o = i[n + 0]
                  , h = i[n + 1]
                  , l = i[n + 2]
                  , c = i[n + 3];
                const u = r[s + 0]
                  , d = r[s + 1]
                  , p = r[s + 2]
                  , f = r[s + 3];
                if (0 === a)
                    return t[e + 0] = o,
                    t[e + 1] = h,
                    t[e + 2] = l,
                    void (t[e + 3] = c);
                if (1 === a)
                    return t[e + 0] = u,
                    t[e + 1] = d,
                    t[e + 2] = p,
                    void (t[e + 3] = f);
                if (c !== f || o !== u || h !== d || l !== p) {
                    let t = 1 - a;
                    const e = o * u + h * d + l * p + c * f
                      , i = e >= 0 ? 1 : -1
                      , n = 1 - e * e;
                    if (n > Number.EPSILON) {
                        const r = Math.sqrt(n)
                          , s = Math.atan2(r, e * i);
                        t = Math.sin(t * s) / r,
                        a = Math.sin(a * s) / r
                    }
                    const r = a * i;
                    if (o = o * t + u * r,
                    h = h * t + d * r,
                    l = l * t + p * r,
                    c = c * t + f * r,
                    t === 1 - a) {
                        const t = 1 / Math.sqrt(o * o + h * h + l * l + c * c);
                        o *= t,
                        h *= t,
                        l *= t,
                        c *= t
                    }
                }
                t[e] = o,
                t[e + 1] = h,
                t[e + 2] = l,
                t[e + 3] = c
            }
            static multiplyQuaternionsFlat(t, e, i, n, r, s) {
                const a = i[n]
                  , o = i[n + 1]
                  , h = i[n + 2]
                  , l = i[n + 3]
                  , c = r[s]
                  , u = r[s + 1]
                  , d = r[s + 2]
                  , p = r[s + 3];
                return t[e] = a * p + l * c + o * d - h * u,
                t[e + 1] = o * p + l * u + h * c - a * d,
                t[e + 2] = h * p + l * d + a * u - o * c,
                t[e + 3] = l * p - a * c - o * u - h * d,
                t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t,
                this._onChangeCallback()
            }
            set(t, e, i, n) {
                return this._x = t,
                this._y = e,
                this._z = i,
                this._w = n,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(t) {
                return this._x = t.x,
                this._y = t.y,
                this._z = t.z,
                this._w = t.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(t, e) {
                if (!t || !t.isEuler)
                    throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const i = t._x
                  , n = t._y
                  , r = t._z
                  , s = t._order
                  , a = Math.cos
                  , o = Math.sin
                  , h = a(i / 2)
                  , l = a(n / 2)
                  , c = a(r / 2)
                  , u = o(i / 2)
                  , d = o(n / 2)
                  , p = o(r / 2);
                switch (s) {
                case "XYZ":
                    this._x = u * l * c + h * d * p,
                    this._y = h * d * c - u * l * p,
                    this._z = h * l * p + u * d * c,
                    this._w = h * l * c - u * d * p;
                    break;
                case "YXZ":
                    this._x = u * l * c + h * d * p,
                    this._y = h * d * c - u * l * p,
                    this._z = h * l * p - u * d * c,
                    this._w = h * l * c + u * d * p;
                    break;
                case "ZXY":
                    this._x = u * l * c - h * d * p,
                    this._y = h * d * c + u * l * p,
                    this._z = h * l * p + u * d * c,
                    this._w = h * l * c - u * d * p;
                    break;
                case "ZYX":
                    this._x = u * l * c - h * d * p,
                    this._y = h * d * c + u * l * p,
                    this._z = h * l * p - u * d * c,
                    this._w = h * l * c + u * d * p;
                    break;
                case "YZX":
                    this._x = u * l * c + h * d * p,
                    this._y = h * d * c + u * l * p,
                    this._z = h * l * p - u * d * c,
                    this._w = h * l * c - u * d * p;
                    break;
                case "XZY":
                    this._x = u * l * c - h * d * p,
                    this._y = h * d * c - u * l * p,
                    this._z = h * l * p + u * d * c,
                    this._w = h * l * c + u * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                }
                return !1 !== e && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(t, e) {
                const i = e / 2
                  , n = Math.sin(i);
                return this._x = t.x * n,
                this._y = t.y * n,
                this._z = t.z * n,
                this._w = Math.cos(i),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t) {
                const e = t.elements
                  , i = e[0]
                  , n = e[4]
                  , r = e[8]
                  , s = e[1]
                  , a = e[5]
                  , o = e[9]
                  , h = e[2]
                  , l = e[6]
                  , c = e[10]
                  , u = i + a + c;
                if (u > 0) {
                    const t = .5 / Math.sqrt(u + 1);
                    this._w = .25 / t,
                    this._x = (l - o) * t,
                    this._y = (r - h) * t,
                    this._z = (s - n) * t
                } else if (i > a && i > c) {
                    const t = 2 * Math.sqrt(1 + i - a - c);
                    this._w = (l - o) / t,
                    this._x = .25 * t,
                    this._y = (n + s) / t,
                    this._z = (r + h) / t
                } else if (a > c) {
                    const t = 2 * Math.sqrt(1 + a - i - c);
                    this._w = (r - h) / t,
                    this._x = (n + s) / t,
                    this._y = .25 * t,
                    this._z = (o + l) / t
                } else {
                    const t = 2 * Math.sqrt(1 + c - i - a);
                    this._w = (s - n) / t,
                    this._x = (r + h) / t,
                    this._y = (o + l) / t,
                    this._z = .25 * t
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(t, e) {
                let i = t.dot(e) + 1;
                return i < 1e-6 ? (i = 0,
                Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
                this._y = t.x,
                this._z = 0,
                this._w = i) : (this._x = 0,
                this._y = -t.z,
                this._z = t.y,
                this._w = i)) : (this._x = t.y * e.z - t.z * e.y,
                this._y = t.z * e.x - t.x * e.z,
                this._z = t.x * e.y - t.y * e.x,
                this._w = i),
                this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(uo.clamp(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const i = this.angleTo(t);
                if (0 === i)
                    return this;
                const n = Math.min(1, e / i);
                return this.slerp(t, n),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (t = 1 / t,
                this._x = this._x * t,
                this._y = this._y * t,
                this._z = this._z * t,
                this._w = this._w * t),
                this._onChangeCallback(),
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const i = t._x
                  , n = t._y
                  , r = t._z
                  , s = t._w
                  , a = e._x
                  , o = e._y
                  , h = e._z
                  , l = e._w;
                return this._x = i * l + s * a + n * h - r * o,
                this._y = n * l + s * o + r * a - i * h,
                this._z = r * l + s * h + i * o - n * a,
                this._w = s * l - i * a - n * o - r * h,
                this._onChangeCallback(),
                this
            }
            slerp(t, e) {
                if (0 === e)
                    return this;
                if (1 === e)
                    return this.copy(t);
                const i = this._x
                  , n = this._y
                  , r = this._z
                  , s = this._w;
                let a = s * t._w + i * t._x + n * t._y + r * t._z;
                if (a < 0 ? (this._w = -t._w,
                this._x = -t._x,
                this._y = -t._y,
                this._z = -t._z,
                a = -a) : this.copy(t),
                a >= 1)
                    return this._w = s,
                    this._x = i,
                    this._y = n,
                    this._z = r,
                    this;
                const o = 1 - a * a;
                if (o <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * s + e * this._w,
                    this._x = t * i + e * this._x,
                    this._y = t * n + e * this._y,
                    this._z = t * r + e * this._z,
                    this.normalize(),
                    this._onChangeCallback(),
                    this
                }
                const h = Math.sqrt(o)
                  , l = Math.atan2(h, a)
                  , c = Math.sin((1 - e) * l) / h
                  , u = Math.sin(e * l) / h;
                return this._w = s * c + this._w * u,
                this._x = i * c + this._x * u,
                this._y = n * c + this._y * u,
                this._z = r * c + this._z * u,
                this._onChangeCallback(),
                this
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e=0) {
                return this._x = t[e],
                this._y = t[e + 1],
                this._z = t[e + 2],
                this._w = t[e + 3],
                this._onChangeCallback(),
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._w,
                t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e),
                this._y = t.getY(e),
                this._z = t.getZ(e),
                this._w = t.getW(e),
                this
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
        }
        wo.prototype.isQuaternion = !0;
        class Mo {
            constructor(t=0, e=0, i=0) {
                this.x = t,
                this.y = e,
                this.z = i
            }
            set(t, e, i) {
                return void 0 === i && (i = this.z),
                this.x = t,
                this.y = e,
                this.z = i,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                this.multiplyVectors(t, e)) : (this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this)
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x,
                this.y = t.y * e.y,
                this.z = t.z * e.z,
                this
            }
            applyEuler(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                this.applyQuaternion(Eo.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(Eo.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x
                  , i = this.y
                  , n = this.z
                  , r = t.elements;
                return this.x = r[0] * e + r[3] * i + r[6] * n,
                this.y = r[1] * e + r[4] * i + r[7] * n,
                this.z = r[2] * e + r[5] * i + r[8] * n,
                this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x
                  , i = this.y
                  , n = this.z
                  , r = t.elements
                  , s = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * s,
                this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * s,
                this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * s,
                this
            }
            applyQuaternion(t) {
                const e = this.x
                  , i = this.y
                  , n = this.z
                  , r = t.x
                  , s = t.y
                  , a = t.z
                  , o = t.w
                  , h = o * e + s * n - a * i
                  , l = o * i + a * e - r * n
                  , c = o * n + r * i - s * e
                  , u = -r * e - s * i - a * n;
                return this.x = h * o + u * -r + l * -a - c * -s,
                this.y = l * o + u * -s + c * -r - h * -a,
                this.z = c * o + u * -a + h * -s - l * -r,
                this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x
                  , i = this.y
                  , n = this.z
                  , r = t.elements;
                return this.x = r[0] * e + r[4] * i + r[8] * n,
                this.y = r[1] * e + r[5] * i + r[9] * n,
                this.z = r[2] * e + r[6] * i + r[10] * n,
                this.normalize()
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this.z /= t.z,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this
            }
            clampLength(t, e) {
                const i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this
            }
            lerpVectors(t, e, i) {
                return this.x = t.x + (e.x - t.x) * i,
                this.y = t.y + (e.y - t.y) * i,
                this.z = t.z + (e.z - t.z) * i,
                this
            }
            cross(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
                this.crossVectors(t, e)) : this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const i = t.x
                  , n = t.y
                  , r = t.z
                  , s = e.x
                  , a = e.y
                  , o = e.z;
                return this.x = n * o - r * a,
                this.y = r * s - i * o,
                this.z = i * a - n * s,
                this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e)
                    return this.set(0, 0, 0);
                const i = t.dot(this) / e;
                return this.copy(t).multiplyScalar(i)
            }
            projectOnPlane(t) {
                return To.copy(this).projectOnVector(t),
                this.sub(To)
            }
            reflect(t) {
                return this.sub(To.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e)
                    return Math.PI / 2;
                const i = this.dot(t) / e;
                return Math.acos(uo.clamp(i, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , i = this.y - t.y
                  , n = this.z - t.z;
                return e * e + i * i + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, i) {
                const n = Math.sin(e) * t;
                return this.x = n * Math.sin(i),
                this.y = Math.cos(e) * t,
                this.z = n * Math.cos(i),
                this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, i) {
                return this.x = t * Math.sin(e),
                this.y = i,
                this.z = t * Math.cos(e),
                this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12],
                this.y = e[13],
                this.z = e[14],
                this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length()
                  , i = this.setFromMatrixColumn(t, 1).length()
                  , n = this.setFromMatrixColumn(t, 2).length();
                return this.x = e,
                this.y = i,
                this.z = n,
                this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t
            }
            fromBufferAttribute(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
        }
        Mo.prototype.isVector3 = !0;
        const To = new Mo
          , Eo = new wo;
        class So {
            constructor(t=new Mo(1 / 0,1 / 0,1 / 0), e=new Mo(-1 / 0,-1 / 0,-1 / 0)) {
                this.min = t,
                this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            }
            setFromArray(t) {
                let e = 1 / 0
                  , i = 1 / 0
                  , n = 1 / 0
                  , r = -1 / 0
                  , s = -1 / 0
                  , a = -1 / 0;
                for (let o = 0, h = t.length; o < h; o += 3) {
                    const h = t[o]
                      , l = t[o + 1]
                      , c = t[o + 2];
                    h < e && (e = h),
                    l < i && (i = l),
                    c < n && (n = c),
                    h > r && (r = h),
                    l > s && (s = l),
                    c > a && (a = c)
                }
                return this.min.set(e, i, n),
                this.max.set(r, s, a),
                this
            }
            setFromBufferAttribute(t) {
                let e = 1 / 0
                  , i = 1 / 0
                  , n = 1 / 0
                  , r = -1 / 0
                  , s = -1 / 0
                  , a = -1 / 0;
                for (let o = 0, h = t.count; o < h; o++) {
                    const h = t.getX(o)
                      , l = t.getY(o)
                      , c = t.getZ(o);
                    h < e && (e = h),
                    l < i && (i = l),
                    c < n && (n = c),
                    h > r && (r = h),
                    l > s && (s = l),
                    c > a && (a = c)
                }
                return this.min.set(e, i, n),
                this.max.set(r, s, a),
                this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, i = t.length; e < i; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const i = Lo.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(i),
                this.max.copy(t).add(i),
                this
            }
            setFromObject(t) {
                return this.makeEmpty(),
                this.expandByObject(t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"),
                t = new Mo),
                this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"),
                t = new Mo),
                this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            }
            expandByVector(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            }
            expandByObject(t) {
                t.updateWorldMatrix(!1, !1);
                const e = t.geometry;
                void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(),
                Po.copy(e.boundingBox),
                Po.applyMatrix4(t.matrixWorld),
                this.union(Po));
                const i = t.children;
                for (let t = 0, e = i.length; t < e; t++)
                    this.expandByObject(i[t]);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"),
                e = new Mo),
                e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, Lo),
                Lo.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, i;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                i = t.normal.x * this.min.x),
                t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                i += t.normal.y * this.min.y),
                t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                i += t.normal.z * this.min.z),
                e <= -t.constant && i >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(zo),
                Bo.subVectors(this.max, zo),
                Co.subVectors(t.a, zo),
                Ro.subVectors(t.b, zo),
                Oo.subVectors(t.c, zo),
                Do.subVectors(Ro, Co),
                Io.subVectors(Oo, Ro),
                No.subVectors(Co, Oo);
                let e = [0, -Do.z, Do.y, 0, -Io.z, Io.y, 0, -No.z, No.y, Do.z, 0, -Do.x, Io.z, 0, -Io.x, No.z, 0, -No.x, -Do.y, Do.x, 0, -Io.y, Io.x, 0, -No.y, No.x, 0];
                return !!Uo(e, Co, Ro, Oo, Bo) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!Uo(e, Co, Ro, Oo, Bo) && (ko.crossVectors(Do, Io),
                e = [ko.x, ko.y, ko.z],
                Uo(e, Co, Ro, Oo, Bo)))
            }
            clampPoint(t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"),
                e = new Mo),
                e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return Lo.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            getBoundingSphere(t) {
                return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
                this.getCenter(t.center),
                t.radius = .5 * this.getSize(Lo).length(),
                t
            }
            intersect(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (Ao[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                Ao[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                Ao[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                Ao[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                Ao[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                Ao[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                Ao[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                Ao[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(Ao)),
                this
            }
            translate(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        So.prototype.isBox3 = !0;
        const Ao = [new Mo, new Mo, new Mo, new Mo, new Mo, new Mo, new Mo, new Mo]
          , Lo = new Mo
          , Po = new So
          , Co = new Mo
          , Ro = new Mo
          , Oo = new Mo
          , Do = new Mo
          , Io = new Mo
          , No = new Mo
          , zo = new Mo
          , Bo = new Mo
          , ko = new Mo
          , Fo = new Mo;
        function Uo(t, e, i, n, r) {
            for (let s = 0, a = t.length - 3; s <= a; s += 3) {
                Fo.fromArray(t, s);
                const a = r.x * Math.abs(Fo.x) + r.y * Math.abs(Fo.y) + r.z * Math.abs(Fo.z)
                  , o = e.dot(Fo)
                  , h = i.dot(Fo)
                  , l = n.dot(Fo);
                if (Math.max(-Math.max(o, h, l), Math.min(o, h, l)) > a)
                    return !1
            }
            return !0
        }
        const Ho = new So;
        class jo {
            constructor(t=new Mo, e=-1) {
                this.center = t,
                this.radius = e
            }
            set(t, e) {
                return this.center.copy(t),
                this.radius = e,
                this
            }
            setFromPoints(t, e) {
                const i = this.center;
                void 0 !== e ? i.copy(e) : Ho.setFromPoints(t).getCenter(i);
                let n = 0;
                for (let e = 0, r = t.length; e < r; e++)
                    n = Math.max(n, i.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(n),
                this
            }
            copy(t) {
                return this.center.copy(t.center),
                this.radius = t.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const i = this.center.distanceToSquared(t);
                return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
                e = new Mo),
                e.copy(t),
                i > this.radius * this.radius && (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
                e
            }
            getBoundingBox(t) {
                return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
                t = new So),
                this.isEmpty() ? (t.makeEmpty(),
                t) : (t.set(this.center, this.center),
                t.expandByScalar(this.radius),
                t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t),
                this.radius = this.radius * t.getMaxScaleOnAxis(),
                this
            }
            translate(t) {
                return this.center.add(t),
                this
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Go = new Mo
          , Wo = new Mo
          , Vo = new Mo
          , qo = new Mo
          , Xo = new Mo
          , Yo = new Mo
          , Zo = new Mo;
        class Jo {
            constructor(t=new Mo, e=new Mo(0,0,-1)) {
                this.origin = t,
                this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t),
                this.direction.copy(e),
                this
            }
            copy(t) {
                return this.origin.copy(t.origin),
                this.direction.copy(t.direction),
                this
            }
            at(t, e) {
                return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"),
                e = new Mo),
                e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(),
                this
            }
            recast(t) {
                return this.origin.copy(this.at(t, Go)),
                this
            }
            closestPointToPoint(t, e) {
                void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
                e = new Mo),
                e.subVectors(t, this.origin);
                const i = e.dot(this.direction);
                return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = Go.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (Go.copy(this.direction).multiplyScalar(e).add(this.origin),
                Go.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, i, n) {
                Wo.copy(t).add(e).multiplyScalar(.5),
                Vo.copy(e).sub(t).normalize(),
                qo.copy(this.origin).sub(Wo);
                const r = .5 * t.distanceTo(e)
                  , s = -this.direction.dot(Vo)
                  , a = qo.dot(this.direction)
                  , o = -qo.dot(Vo)
                  , h = qo.lengthSq()
                  , l = Math.abs(1 - s * s);
                let c, u, d, p;
                if (l > 0)
                    if (c = s * o - a,
                    u = s * a - o,
                    p = r * l,
                    c >= 0)
                        if (u >= -p)
                            if (u <= p) {
                                const t = 1 / l;
                                c *= t,
                                u *= t,
                                d = c * (c + s * u + 2 * a) + u * (s * c + u + 2 * o) + h
                            } else
                                u = r,
                                c = Math.max(0, -(s * u + a)),
                                d = -c * c + u * (u + 2 * o) + h;
                        else
                            u = -r,
                            c = Math.max(0, -(s * u + a)),
                            d = -c * c + u * (u + 2 * o) + h;
                    else
                        u <= -p ? (c = Math.max(0, -(-s * r + a)),
                        u = c > 0 ? -r : Math.min(Math.max(-r, -o), r),
                        d = -c * c + u * (u + 2 * o) + h) : u <= p ? (c = 0,
                        u = Math.min(Math.max(-r, -o), r),
                        d = u * (u + 2 * o) + h) : (c = Math.max(0, -(s * r + a)),
                        u = c > 0 ? r : Math.min(Math.max(-r, -o), r),
                        d = -c * c + u * (u + 2 * o) + h);
                else
                    u = s > 0 ? -r : r,
                    c = Math.max(0, -(s * u + a)),
                    d = -c * c + u * (u + 2 * o) + h;
                return i && i.copy(this.direction).multiplyScalar(c).add(this.origin),
                n && n.copy(Vo).multiplyScalar(u).add(Wo),
                d
            }
            intersectSphere(t, e) {
                Go.subVectors(t.center, this.origin);
                const i = Go.dot(this.direction)
                  , n = Go.dot(Go) - i * i
                  , r = t.radius * t.radius;
                if (n > r)
                    return null;
                const s = Math.sqrt(r - n)
                  , a = i - s
                  , o = i + s;
                return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e)
                    return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const i = -(this.origin.dot(t.normal) + t.constant) / e;
                return i >= 0 ? i : null
            }
            intersectPlane(t, e) {
                const i = this.distanceToPlane(t);
                return null === i ? null : this.at(i, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let i, n, r, s, a, o;
                const h = 1 / this.direction.x
                  , l = 1 / this.direction.y
                  , c = 1 / this.direction.z
                  , u = this.origin;
                return h >= 0 ? (i = (t.min.x - u.x) * h,
                n = (t.max.x - u.x) * h) : (i = (t.max.x - u.x) * h,
                n = (t.min.x - u.x) * h),
                l >= 0 ? (r = (t.min.y - u.y) * l,
                s = (t.max.y - u.y) * l) : (r = (t.max.y - u.y) * l,
                s = (t.min.y - u.y) * l),
                i > s || r > n ? null : ((r > i || i != i) && (i = r),
                (s < n || n != n) && (n = s),
                c >= 0 ? (a = (t.min.z - u.z) * c,
                o = (t.max.z - u.z) * c) : (a = (t.max.z - u.z) * c,
                o = (t.min.z - u.z) * c),
                i > o || a > n ? null : ((a > i || i != i) && (i = a),
                (o < n || n != n) && (n = o),
                n < 0 ? null : this.at(i >= 0 ? i : n, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, Go)
            }
            intersectTriangle(t, e, i, n, r) {
                Xo.subVectors(e, t),
                Yo.subVectors(i, t),
                Zo.crossVectors(Xo, Yo);
                let s, a = this.direction.dot(Zo);
                if (a > 0) {
                    if (n)
                        return null;
                    s = 1
                } else {
                    if (!(a < 0))
                        return null;
                    s = -1,
                    a = -a
                }
                qo.subVectors(this.origin, t);
                const o = s * this.direction.dot(Yo.crossVectors(qo, Yo));
                if (o < 0)
                    return null;
                const h = s * this.direction.dot(Xo.cross(qo));
                if (h < 0)
                    return null;
                if (o + h > a)
                    return null;
                const l = -s * qo.dot(Zo);
                return l < 0 ? null : this.at(l / a, r)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t),
                this.direction.transformDirection(t),
                this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class $o {
            constructor() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, i, n, r, s, a, o, h, l, c, u, d, p, f, m) {
                const g = this.elements;
                return g[0] = t,
                g[4] = e,
                g[8] = i,
                g[12] = n,
                g[1] = r,
                g[5] = s,
                g[9] = a,
                g[13] = o,
                g[2] = h,
                g[6] = l,
                g[10] = c,
                g[14] = u,
                g[3] = d,
                g[7] = p,
                g[11] = f,
                g[15] = m,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return (new $o).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements
                  , i = t.elements;
                return e[0] = i[0],
                e[1] = i[1],
                e[2] = i[2],
                e[3] = i[3],
                e[4] = i[4],
                e[5] = i[5],
                e[6] = i[6],
                e[7] = i[7],
                e[8] = i[8],
                e[9] = i[9],
                e[10] = i[10],
                e[11] = i[11],
                e[12] = i[12],
                e[13] = i[13],
                e[14] = i[14],
                e[15] = i[15],
                this
            }
            copyPosition(t) {
                const e = this.elements
                  , i = t.elements;
                return e[12] = i[12],
                e[13] = i[13],
                e[14] = i[14],
                this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(t, e, i) {
                return t.setFromMatrixColumn(this, 0),
                e.setFromMatrixColumn(this, 1),
                i.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(t, e, i) {
                return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(t) {
                const e = this.elements
                  , i = t.elements
                  , n = 1 / Qo.setFromMatrixColumn(t, 0).length()
                  , r = 1 / Qo.setFromMatrixColumn(t, 1).length()
                  , s = 1 / Qo.setFromMatrixColumn(t, 2).length();
                return e[0] = i[0] * n,
                e[1] = i[1] * n,
                e[2] = i[2] * n,
                e[3] = 0,
                e[4] = i[4] * r,
                e[5] = i[5] * r,
                e[6] = i[6] * r,
                e[7] = 0,
                e[8] = i[8] * s,
                e[9] = i[9] * s,
                e[10] = i[10] * s,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromEuler(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const e = this.elements
                  , i = t.x
                  , n = t.y
                  , r = t.z
                  , s = Math.cos(i)
                  , a = Math.sin(i)
                  , o = Math.cos(n)
                  , h = Math.sin(n)
                  , l = Math.cos(r)
                  , c = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = s * l
                      , i = s * c
                      , n = a * l
                      , r = a * c;
                    e[0] = o * l,
                    e[4] = -o * c,
                    e[8] = h,
                    e[1] = i + n * h,
                    e[5] = t - r * h,
                    e[9] = -a * o,
                    e[2] = r - t * h,
                    e[6] = n + i * h,
                    e[10] = s * o
                } else if ("YXZ" === t.order) {
                    const t = o * l
                      , i = o * c
                      , n = h * l
                      , r = h * c;
                    e[0] = t + r * a,
                    e[4] = n * a - i,
                    e[8] = s * h,
                    e[1] = s * c,
                    e[5] = s * l,
                    e[9] = -a,
                    e[2] = i * a - n,
                    e[6] = r + t * a,
                    e[10] = s * o
                } else if ("ZXY" === t.order) {
                    const t = o * l
                      , i = o * c
                      , n = h * l
                      , r = h * c;
                    e[0] = t - r * a,
                    e[4] = -s * c,
                    e[8] = n + i * a,
                    e[1] = i + n * a,
                    e[5] = s * l,
                    e[9] = r - t * a,
                    e[2] = -s * h,
                    e[6] = a,
                    e[10] = s * o
                } else if ("ZYX" === t.order) {
                    const t = s * l
                      , i = s * c
                      , n = a * l
                      , r = a * c;
                    e[0] = o * l,
                    e[4] = n * h - i,
                    e[8] = t * h + r,
                    e[1] = o * c,
                    e[5] = r * h + t,
                    e[9] = i * h - n,
                    e[2] = -h,
                    e[6] = a * o,
                    e[10] = s * o
                } else if ("YZX" === t.order) {
                    const t = s * o
                      , i = s * h
                      , n = a * o
                      , r = a * h;
                    e[0] = o * l,
                    e[4] = r - t * c,
                    e[8] = n * c + i,
                    e[1] = c,
                    e[5] = s * l,
                    e[9] = -a * l,
                    e[2] = -h * l,
                    e[6] = i * c + n,
                    e[10] = t - r * c
                } else if ("XZY" === t.order) {
                    const t = s * o
                      , i = s * h
                      , n = a * o
                      , r = a * h;
                    e[0] = o * l,
                    e[4] = -c,
                    e[8] = h * l,
                    e[1] = t * c + r,
                    e[5] = s * l,
                    e[9] = i * c - n,
                    e[2] = n * c - i,
                    e[6] = a * l,
                    e[10] = r * c + t
                }
                return e[3] = 0,
                e[7] = 0,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(th, t, eh)
            }
            lookAt(t, e, i) {
                const n = this.elements;
                return rh.subVectors(t, e),
                0 === rh.lengthSq() && (rh.z = 1),
                rh.normalize(),
                ih.crossVectors(i, rh),
                0 === ih.lengthSq() && (1 === Math.abs(i.z) ? rh.x += 1e-4 : rh.z += 1e-4,
                rh.normalize(),
                ih.crossVectors(i, rh)),
                ih.normalize(),
                nh.crossVectors(rh, ih),
                n[0] = ih.x,
                n[4] = nh.x,
                n[8] = rh.x,
                n[1] = ih.y,
                n[5] = nh.y,
                n[9] = rh.y,
                n[2] = ih.z,
                n[6] = nh.z,
                n[10] = rh.z,
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const i = t.elements
                  , n = e.elements
                  , r = this.elements
                  , s = i[0]
                  , a = i[4]
                  , o = i[8]
                  , h = i[12]
                  , l = i[1]
                  , c = i[5]
                  , u = i[9]
                  , d = i[13]
                  , p = i[2]
                  , f = i[6]
                  , m = i[10]
                  , g = i[14]
                  , v = i[3]
                  , y = i[7]
                  , x = i[11]
                  , _ = i[15]
                  , b = n[0]
                  , w = n[4]
                  , M = n[8]
                  , T = n[12]
                  , E = n[1]
                  , S = n[5]
                  , A = n[9]
                  , L = n[13]
                  , P = n[2]
                  , C = n[6]
                  , R = n[10]
                  , O = n[14]
                  , D = n[3]
                  , I = n[7]
                  , N = n[11]
                  , z = n[15];
                return r[0] = s * b + a * E + o * P + h * D,
                r[4] = s * w + a * S + o * C + h * I,
                r[8] = s * M + a * A + o * R + h * N,
                r[12] = s * T + a * L + o * O + h * z,
                r[1] = l * b + c * E + u * P + d * D,
                r[5] = l * w + c * S + u * C + d * I,
                r[9] = l * M + c * A + u * R + d * N,
                r[13] = l * T + c * L + u * O + d * z,
                r[2] = p * b + f * E + m * P + g * D,
                r[6] = p * w + f * S + m * C + g * I,
                r[10] = p * M + f * A + m * R + g * N,
                r[14] = p * T + f * L + m * O + g * z,
                r[3] = v * b + y * E + x * P + _ * D,
                r[7] = v * w + y * S + x * C + _ * I,
                r[11] = v * M + y * A + x * R + _ * N,
                r[15] = v * T + y * L + x * O + _ * z,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[4] *= t,
                e[8] *= t,
                e[12] *= t,
                e[1] *= t,
                e[5] *= t,
                e[9] *= t,
                e[13] *= t,
                e[2] *= t,
                e[6] *= t,
                e[10] *= t,
                e[14] *= t,
                e[3] *= t,
                e[7] *= t,
                e[11] *= t,
                e[15] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , i = t[4]
                  , n = t[8]
                  , r = t[12]
                  , s = t[1]
                  , a = t[5]
                  , o = t[9]
                  , h = t[13]
                  , l = t[2]
                  , c = t[6]
                  , u = t[10]
                  , d = t[14];
                return t[3] * (+r * o * c - n * h * c - r * a * u + i * h * u + n * a * d - i * o * d) + t[7] * (+e * o * d - e * h * u + r * s * u - n * s * d + n * h * l - r * o * l) + t[11] * (+e * h * c - e * a * d - r * s * c + i * s * d + r * a * l - i * h * l) + t[15] * (-n * a * l - e * o * c + e * a * u + n * s * c - i * s * u + i * o * l)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1],
                t[1] = t[4],
                t[4] = e,
                e = t[2],
                t[2] = t[8],
                t[8] = e,
                e = t[6],
                t[6] = t[9],
                t[9] = e,
                e = t[3],
                t[3] = t[12],
                t[12] = e,
                e = t[7],
                t[7] = t[13],
                t[13] = e,
                e = t[11],
                t[11] = t[14],
                t[14] = e,
                this
            }
            setPosition(t, e, i) {
                const n = this.elements;
                return t.isVector3 ? (n[12] = t.x,
                n[13] = t.y,
                n[14] = t.z) : (n[12] = t,
                n[13] = e,
                n[14] = i),
                this
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , i = t[1]
                  , n = t[2]
                  , r = t[3]
                  , s = t[4]
                  , a = t[5]
                  , o = t[6]
                  , h = t[7]
                  , l = t[8]
                  , c = t[9]
                  , u = t[10]
                  , d = t[11]
                  , p = t[12]
                  , f = t[13]
                  , m = t[14]
                  , g = t[15]
                  , v = c * m * h - f * u * h + f * o * d - a * m * d - c * o * g + a * u * g
                  , y = p * u * h - l * m * h - p * o * d + s * m * d + l * o * g - s * u * g
                  , x = l * f * h - p * c * h + p * a * d - s * f * d - l * a * g + s * c * g
                  , _ = p * c * o - l * f * o - p * a * u + s * f * u + l * a * m - s * c * m
                  , b = e * v + i * y + n * x + r * _;
                if (0 === b)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const w = 1 / b;
                return t[0] = v * w,
                t[1] = (f * u * r - c * m * r - f * n * d + i * m * d + c * n * g - i * u * g) * w,
                t[2] = (a * m * r - f * o * r + f * n * h - i * m * h - a * n * g + i * o * g) * w,
                t[3] = (c * o * r - a * u * r - c * n * h + i * u * h + a * n * d - i * o * d) * w,
                t[4] = y * w,
                t[5] = (l * m * r - p * u * r + p * n * d - e * m * d - l * n * g + e * u * g) * w,
                t[6] = (p * o * r - s * m * r - p * n * h + e * m * h + s * n * g - e * o * g) * w,
                t[7] = (s * u * r - l * o * r + l * n * h - e * u * h - s * n * d + e * o * d) * w,
                t[8] = x * w,
                t[9] = (p * c * r - l * f * r - p * i * d + e * f * d + l * i * g - e * c * g) * w,
                t[10] = (s * f * r - p * a * r + p * i * h - e * f * h - s * i * g + e * a * g) * w,
                t[11] = (l * a * r - s * c * r - l * i * h + e * c * h + s * i * d - e * a * d) * w,
                t[12] = _ * w,
                t[13] = (l * f * n - p * c * n + p * i * u - e * f * u - l * i * m + e * c * m) * w,
                t[14] = (p * a * n - s * f * n - p * i * o + e * f * o + s * i * m - e * a * m) * w,
                t[15] = (s * c * n - l * a * n + l * i * o - e * c * o - s * i * u + e * a * u) * w,
                this
            }
            scale(t) {
                const e = this.elements
                  , i = t.x
                  , n = t.y
                  , r = t.z;
                return e[0] *= i,
                e[4] *= n,
                e[8] *= r,
                e[1] *= i,
                e[5] *= n,
                e[9] *= r,
                e[2] *= i,
                e[6] *= n,
                e[10] *= r,
                e[3] *= i,
                e[7] *= n,
                e[11] *= r,
                this
            }
            getMaxScaleOnAxis() {
                const t = this.elements
                  , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                  , i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                  , n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, i, n))
            }
            makeTranslation(t, e, i) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1),
                this
            }
            makeRotationX(t) {
                const e = Math.cos(t)
                  , i = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(t) {
                const e = Math.cos(t)
                  , i = Math.sin(t);
                return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(t) {
                const e = Math.cos(t)
                  , i = Math.sin(t);
                return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(t, e) {
                const i = Math.cos(e)
                  , n = Math.sin(e)
                  , r = 1 - i
                  , s = t.x
                  , a = t.y
                  , o = t.z
                  , h = r * s
                  , l = r * a;
                return this.set(h * s + i, h * a - n * o, h * o + n * a, 0, h * a + n * o, l * a + i, l * o - n * s, 0, h * o - n * a, l * o + n * s, r * o * o + i, 0, 0, 0, 0, 1),
                this
            }
            makeScale(t, e, i) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
                this
            }
            makeShear(t, e, i) {
                return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(t, e, i) {
                const n = this.elements
                  , r = e._x
                  , s = e._y
                  , a = e._z
                  , o = e._w
                  , h = r + r
                  , l = s + s
                  , c = a + a
                  , u = r * h
                  , d = r * l
                  , p = r * c
                  , f = s * l
                  , m = s * c
                  , g = a * c
                  , v = o * h
                  , y = o * l
                  , x = o * c
                  , _ = i.x
                  , b = i.y
                  , w = i.z;
                return n[0] = (1 - (f + g)) * _,
                n[1] = (d + x) * _,
                n[2] = (p - y) * _,
                n[3] = 0,
                n[4] = (d - x) * b,
                n[5] = (1 - (u + g)) * b,
                n[6] = (m + v) * b,
                n[7] = 0,
                n[8] = (p + y) * w,
                n[9] = (m - v) * w,
                n[10] = (1 - (u + f)) * w,
                n[11] = 0,
                n[12] = t.x,
                n[13] = t.y,
                n[14] = t.z,
                n[15] = 1,
                this
            }
            decompose(t, e, i) {
                const n = this.elements;
                let r = Qo.set(n[0], n[1], n[2]).length();
                const s = Qo.set(n[4], n[5], n[6]).length()
                  , a = Qo.set(n[8], n[9], n[10]).length();
                this.determinant() < 0 && (r = -r),
                t.x = n[12],
                t.y = n[13],
                t.z = n[14],
                Ko.copy(this);
                const o = 1 / r
                  , h = 1 / s
                  , l = 1 / a;
                return Ko.elements[0] *= o,
                Ko.elements[1] *= o,
                Ko.elements[2] *= o,
                Ko.elements[4] *= h,
                Ko.elements[5] *= h,
                Ko.elements[6] *= h,
                Ko.elements[8] *= l,
                Ko.elements[9] *= l,
                Ko.elements[10] *= l,
                e.setFromRotationMatrix(Ko),
                i.x = r,
                i.y = s,
                i.z = a,
                this
            }
            makePerspective(t, e, i, n, r, s) {
                void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const a = this.elements
                  , o = 2 * r / (e - t)
                  , h = 2 * r / (i - n)
                  , l = (e + t) / (e - t)
                  , c = (i + n) / (i - n)
                  , u = -(s + r) / (s - r)
                  , d = -2 * s * r / (s - r);
                return a[0] = o,
                a[4] = 0,
                a[8] = l,
                a[12] = 0,
                a[1] = 0,
                a[5] = h,
                a[9] = c,
                a[13] = 0,
                a[2] = 0,
                a[6] = 0,
                a[10] = u,
                a[14] = d,
                a[3] = 0,
                a[7] = 0,
                a[11] = -1,
                a[15] = 0,
                this
            }
            makeOrthographic(t, e, i, n, r, s) {
                const a = this.elements
                  , o = 1 / (e - t)
                  , h = 1 / (i - n)
                  , l = 1 / (s - r)
                  , c = (e + t) * o
                  , u = (i + n) * h
                  , d = (s + r) * l;
                return a[0] = 2 * o,
                a[4] = 0,
                a[8] = 0,
                a[12] = -c,
                a[1] = 0,
                a[5] = 2 * h,
                a[9] = 0,
                a[13] = -u,
                a[2] = 0,
                a[6] = 0,
                a[10] = -2 * l,
                a[14] = -d,
                a[3] = 0,
                a[7] = 0,
                a[11] = 0,
                a[15] = 1,
                this
            }
            equals(t) {
                const e = this.elements
                  , i = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== i[t])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let i = 0; i < 16; i++)
                    this.elements[i] = t[i + e];
                return this
            }
            toArray(t=[], e=0) {
                const i = this.elements;
                return t[e] = i[0],
                t[e + 1] = i[1],
                t[e + 2] = i[2],
                t[e + 3] = i[3],
                t[e + 4] = i[4],
                t[e + 5] = i[5],
                t[e + 6] = i[6],
                t[e + 7] = i[7],
                t[e + 8] = i[8],
                t[e + 9] = i[9],
                t[e + 10] = i[10],
                t[e + 11] = i[11],
                t[e + 12] = i[12],
                t[e + 13] = i[13],
                t[e + 14] = i[14],
                t[e + 15] = i[15],
                t
            }
        }
        $o.prototype.isMatrix4 = !0;
        const Qo = new Mo
          , Ko = new $o
          , th = new Mo(0,0,0)
          , eh = new Mo(1,1,1)
          , ih = new Mo
          , nh = new Mo
          , rh = new Mo
          , sh = new $o
          , ah = new wo;
        class oh {
            constructor(t=0, e=0, i=0, n=oh.DefaultOrder) {
                this._x = t,
                this._y = e,
                this._z = i,
                this._order = n
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t,
                this._onChangeCallback()
            }
            set(t, e, i, n) {
                return this._x = t,
                this._y = e,
                this._z = i,
                this._order = n || this._order,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(t) {
                return this._x = t._x,
                this._y = t._y,
                this._z = t._z,
                this._order = t._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t, e, i) {
                const n = uo.clamp
                  , r = t.elements
                  , s = r[0]
                  , a = r[4]
                  , o = r[8]
                  , h = r[1]
                  , l = r[5]
                  , c = r[9]
                  , u = r[2]
                  , d = r[6]
                  , p = r[10];
                switch (e = e || this._order) {
                case "XYZ":
                    this._y = Math.asin(n(o, -1, 1)),
                    Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, p),
                    this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(d, l),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-n(c, -1, 1)),
                    Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, p),
                    this._z = Math.atan2(h, l)) : (this._y = Math.atan2(-u, s),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(n(d, -1, 1)),
                    Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, p),
                    this._z = Math.atan2(-a, l)) : (this._y = 0,
                    this._z = Math.atan2(h, s));
                    break;
                case "ZYX":
                    this._y = Math.asin(-n(u, -1, 1)),
                    Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, p),
                    this._z = Math.atan2(h, s)) : (this._x = 0,
                    this._z = Math.atan2(-a, l));
                    break;
                case "YZX":
                    this._z = Math.asin(n(h, -1, 1)),
                    Math.abs(h) < .9999999 ? (this._x = Math.atan2(-c, l),
                    this._y = Math.atan2(-u, s)) : (this._x = 0,
                    this._y = Math.atan2(o, p));
                    break;
                case "XZY":
                    this._z = Math.asin(-n(a, -1, 1)),
                    Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l),
                    this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-c, p),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e,
                !1 !== i && this._onChangeCallback(),
                this
            }
            setFromQuaternion(t, e, i) {
                return sh.makeRotationFromQuaternion(t),
                this.setFromRotationMatrix(sh, e, i)
            }
            setFromVector3(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            }
            reorder(t) {
                return ah.setFromEuler(this),
                this.setFromQuaternion(ah, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0],
                this._y = t[1],
                this._z = t[2],
                void 0 !== t[3] && (this._order = t[3]),
                this._onChangeCallback(),
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._order,
                t
            }
            toVector3(t) {
                return t ? t.set(this._x, this._y, this._z) : new Mo(this._x,this._y,this._z)
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
        }
        oh.prototype.isEuler = !0,
        oh.DefaultOrder = "XYZ",
        oh.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class hh {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = 1 << t | 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
        }
        let lh = 0;
        const ch = new Mo
          , uh = new wo
          , dh = new $o
          , ph = new Mo
          , fh = new Mo
          , mh = new Mo
          , gh = new wo
          , vh = new Mo(1,0,0)
          , yh = new Mo(0,1,0)
          , xh = new Mo(0,0,1)
          , _h = {
            type: "added"
        }
          , bh = {
            type: "removed"
        };
        function wh() {
            Object.defineProperty(this, "id", {
                value: lh++
            }),
            this.uuid = uo.generateUUID(),
            this.name = "",
            this.type = "Object3D",
            this.parent = null,
            this.children = [],
            this.up = wh.DefaultUp.clone();
            const t = new Mo
              , e = new oh
              , i = new wo
              , n = new Mo(1,1,1);
            e._onChange((function() {
                i.setFromEuler(e, !1)
            }
            )),
            i._onChange((function() {
                e.setFromQuaternion(i, void 0, !1)
            }
            )),
            Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                modelViewMatrix: {
                    value: new $o
                },
                normalMatrix: {
                    value: new fo
                }
            }),
            this.matrix = new $o,
            this.matrixWorld = new $o,
            this.matrixAutoUpdate = wh.DefaultMatrixAutoUpdate,
            this.matrixWorldNeedsUpdate = !1,
            this.layers = new hh,
            this.visible = !0,
            this.castShadow = !1,
            this.receiveShadow = !1,
            this.frustumCulled = !0,
            this.renderOrder = 0,
            this.animations = [],
            this.userData = {}
        }
        wh.DefaultUp = new Mo(0,1,0),
        wh.DefaultMatrixAutoUpdate = !0,
        wh.prototype = Object.assign(Object.create(ho.prototype), {
            constructor: wh,
            isObject3D: !0,
            onBeforeRender: function() {},
            onAfterRender: function() {},
            applyMatrix4: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(t),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function(t) {
                return this.quaternion.premultiply(t),
                this
            },
            setRotationFromAxisAngle: function(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function(t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function(t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function(t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function(t, e) {
                return uh.setFromAxisAngle(t, e),
                this.quaternion.multiply(uh),
                this
            },
            rotateOnWorldAxis: function(t, e) {
                return uh.setFromAxisAngle(t, e),
                this.quaternion.premultiply(uh),
                this
            },
            rotateX: function(t) {
                return this.rotateOnAxis(vh, t)
            },
            rotateY: function(t) {
                return this.rotateOnAxis(yh, t)
            },
            rotateZ: function(t) {
                return this.rotateOnAxis(xh, t)
            },
            translateOnAxis: function(t, e) {
                return ch.copy(t).applyQuaternion(this.quaternion),
                this.position.add(ch.multiplyScalar(e)),
                this
            },
            translateX: function(t) {
                return this.translateOnAxis(vh, t)
            },
            translateY: function(t) {
                return this.translateOnAxis(yh, t)
            },
            translateZ: function(t) {
                return this.translateOnAxis(xh, t)
            },
            localToWorld: function(t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function(t) {
                return t.applyMatrix4(dh.copy(this.matrixWorld).invert())
            },
            lookAt: function(t, e, i) {
                t.isVector3 ? ph.copy(t) : ph.set(t, e, i);
                const n = this.parent;
                this.updateWorldMatrix(!0, !1),
                fh.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? dh.lookAt(fh, ph, this.up) : dh.lookAt(ph, fh, this.up),
                this.quaternion.setFromRotationMatrix(dh),
                n && (dh.extractRotation(n.matrixWorld),
                uh.setFromRotationMatrix(dh),
                this.quaternion.premultiply(uh.invert()))
            },
            add: function(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
                t.parent = this,
                this.children.push(t),
                t.dispatchEvent(_h)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                this)
            },
            remove: function(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null,
                this.children.splice(e, 1),
                t.dispatchEvent(bh)),
                this
            },
            clear: function() {
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    e.parent = null,
                    e.dispatchEvent(bh)
                }
                return this.children.length = 0,
                this
            },
            attach: function(t) {
                return this.updateWorldMatrix(!0, !1),
                dh.copy(this.matrixWorld).invert(),
                null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
                dh.multiply(t.parent.matrixWorld)),
                t.applyMatrix4(dh),
                this.add(t),
                t.updateWorldMatrix(!1, !0),
                this
            },
            getObjectById: function(t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function(t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function(t, e) {
                if (this[t] === e)
                    return this;
                for (let i = 0, n = this.children.length; i < n; i++) {
                    const n = this.children[i].getObjectByProperty(t, e);
                    if (void 0 !== n)
                        return n
                }
            },
            getWorldPosition: function(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
                t = new Mo),
                this.updateWorldMatrix(!0, !1),
                t.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
                t = new wo),
                this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(fh, t, mh),
                t
            },
            getWorldScale: function(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
                t = new Mo),
                this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(fh, gh, t),
                t
            },
            getWorldDirection: function(t) {
                void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
                t = new Mo),
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            },
            raycast: function() {},
            traverse: function(t) {
                t(this);
                const e = this.children;
                for (let i = 0, n = e.length; i < n; i++)
                    e[i].traverse(t)
            },
            traverseVisible: function(t) {
                if (!1 === this.visible)
                    return;
                t(this);
                const e = this.children;
                for (let i = 0, n = e.length; i < n; i++)
                    e[i].traverseVisible(t)
            },
            traverseAncestors: function(t) {
                const e = this.parent;
                null !== e && (t(e),
                e.traverseAncestors(t))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                t = !0);
                const e = this.children;
                for (let i = 0, n = e.length; i < n; i++)
                    e[i].updateMatrixWorld(t)
            },
            updateWorldMatrix: function(t, e) {
                const i = this.parent;
                if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                !0 === e) {
                    const t = this.children;
                    for (let e = 0, i = t.length; e < i; e++)
                        t[e].updateWorldMatrix(!1, !0)
                }
            },
            toJSON: function(t) {
                const e = void 0 === t || "string" == typeof t
                  , i = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                },
                i.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const n = {};
                function r(e, i) {
                    return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)),
                    i.uuid
                }
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                !0 === this.castShadow && (n.castShadow = !0),
                !0 === this.receiveShadow && (n.receiveShadow = !0),
                !1 === this.visible && (n.visible = !1),
                !1 === this.frustumCulled && (n.frustumCulled = !1),
                0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
                "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
                n.layers = this.layers.mask,
                n.matrix = this.matrix.toArray(),
                !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
                this.isInstancedMesh && (n.type = "InstancedMesh",
                n.count = this.count,
                n.instanceMatrix = this.instanceMatrix.toJSON()),
                this.isMesh || this.isLine || this.isPoints) {
                    n.geometry = r(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const i = e.shapes;
                        if (Array.isArray(i))
                            for (let e = 0, n = i.length; e < n; e++) {
                                const n = i[e];
                                r(t.shapes, n)
                            }
                        else
                            r(t.shapes, i)
                    }
                }
                if (this.isSkinnedMesh && (n.bindMode = this.bindMode,
                n.bindMatrix = this.bindMatrix.toArray(),
                void 0 !== this.skeleton && (r(t.skeletons, this.skeleton),
                n.skeleton = this.skeleton.uuid)),
                void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let i = 0, n = this.material.length; i < n; i++)
                            e.push(r(t.materials, this.material[i]));
                        n.material = e
                    } else
                        n.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    n.children = [];
                    for (let e = 0; e < this.children.length; e++)
                        n.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    n.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const i = this.animations[e];
                        n.animations.push(r(t.animations, i))
                    }
                }
                if (e) {
                    const e = s(t.geometries)
                      , n = s(t.materials)
                      , r = s(t.textures)
                      , a = s(t.images)
                      , o = s(t.shapes)
                      , h = s(t.skeletons)
                      , l = s(t.animations);
                    e.length > 0 && (i.geometries = e),
                    n.length > 0 && (i.materials = n),
                    r.length > 0 && (i.textures = r),
                    a.length > 0 && (i.images = a),
                    o.length > 0 && (i.shapes = o),
                    h.length > 0 && (i.skeletons = h),
                    l.length > 0 && (i.animations = l)
                }
                return i.object = n,
                i;
                function s(t) {
                    const e = [];
                    for (const i in t) {
                        const n = t[i];
                        delete n.metadata,
                        e.push(n)
                    }
                    return e
                }
            },
            clone: function(t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function(t, e=!0) {
                if (this.name = t.name,
                this.up.copy(t.up),
                this.position.copy(t.position),
                this.rotation.order = t.rotation.order,
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.matrix.copy(t.matrix),
                this.matrixWorld.copy(t.matrixWorld),
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                this.layers.mask = t.layers.mask,
                this.visible = t.visible,
                this.castShadow = t.castShadow,
                this.receiveShadow = t.receiveShadow,
                this.frustumCulled = t.frustumCulled,
                this.renderOrder = t.renderOrder,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const i = t.children[e];
                        this.add(i.clone())
                    }
                return this
            }
        });
        const Mh = new Mo
          , Th = new Mo
          , Eh = new fo;
        class Sh {
            constructor(t=new Mo(1,0,0), e=0) {
                this.normal = t,
                this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t),
                this.constant = e,
                this
            }
            setComponents(t, e, i, n) {
                return this.normal.set(t, e, i),
                this.constant = n,
                this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t),
                this.constant = -e.dot(this.normal),
                this
            }
            setFromCoplanarPoints(t, e, i) {
                const n = Mh.subVectors(i, e).cross(Th.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(n, t),
                this
            }
            copy(t) {
                return this.normal.copy(t.normal),
                this.constant = t.constant,
                this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t),
                this.constant *= t,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"),
                e = new Mo),
                e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }
            intersectLine(t, e) {
                void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"),
                e = new Mo);
                const i = t.delta(Mh)
                  , n = this.normal.dot(i);
                if (0 === n)
                    return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
                const r = -(t.start.dot(this.normal) + this.constant) / n;
                return r < 0 || r > 1 ? void 0 : e.copy(i).multiplyScalar(r).add(t.start)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start)
                  , i = this.distanceToPoint(t.end);
                return e < 0 && i > 0 || i < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
                t = new Mo),
                t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const i = e || Eh.getNormalMatrix(t)
                  , n = this.coplanarPoint(Mh).applyMatrix4(t)
                  , r = this.normal.applyMatrix3(i).normalize();
                return this.constant = -n.dot(r),
                this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal),
                this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        Sh.prototype.isPlane = !0;
        const Ah = new Mo
          , Lh = new Mo
          , Ph = new Mo
          , Ch = new Mo
          , Rh = new Mo
          , Oh = new Mo
          , Dh = new Mo
          , Ih = new Mo
          , Nh = new Mo
          , zh = new Mo;
        class Bh {
            constructor(t=new Mo, e=new Mo, i=new Mo) {
                this.a = t,
                this.b = e,
                this.c = i
            }
            static getNormal(t, e, i, n) {
                void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"),
                n = new Mo),
                n.subVectors(i, e),
                Ah.subVectors(t, e),
                n.cross(Ah);
                const r = n.lengthSq();
                return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
            }
            static getBarycoord(t, e, i, n, r) {
                Ah.subVectors(n, e),
                Lh.subVectors(i, e),
                Ph.subVectors(t, e);
                const s = Ah.dot(Ah)
                  , a = Ah.dot(Lh)
                  , o = Ah.dot(Ph)
                  , h = Lh.dot(Lh)
                  , l = Lh.dot(Ph)
                  , c = s * h - a * a;
                if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
                r = new Mo),
                0 === c)
                    return r.set(-2, -1, -1);
                const u = 1 / c
                  , d = (h * o - a * l) * u
                  , p = (s * l - a * o) * u;
                return r.set(1 - d - p, p, d)
            }
            static containsPoint(t, e, i, n) {
                return this.getBarycoord(t, e, i, n, Ch),
                Ch.x >= 0 && Ch.y >= 0 && Ch.x + Ch.y <= 1
            }
            static getUV(t, e, i, n, r, s, a, o) {
                return this.getBarycoord(t, e, i, n, Ch),
                o.set(0, 0),
                o.addScaledVector(r, Ch.x),
                o.addScaledVector(s, Ch.y),
                o.addScaledVector(a, Ch.z),
                o
            }
            static isFrontFacing(t, e, i, n) {
                return Ah.subVectors(i, e),
                Lh.subVectors(t, e),
                Ah.cross(Lh).dot(n) < 0
            }
            set(t, e, i) {
                return this.a.copy(t),
                this.b.copy(e),
                this.c.copy(i),
                this
            }
            setFromPointsAndIndices(t, e, i, n) {
                return this.a.copy(t[e]),
                this.b.copy(t[i]),
                this.c.copy(t[n]),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a),
                this.b.copy(t.b),
                this.c.copy(t.c),
                this
            }
            getArea() {
                return Ah.subVectors(this.c, this.b),
                Lh.subVectors(this.a, this.b),
                .5 * Ah.cross(Lh).length()
            }
            getMidpoint(t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
                t = new Mo),
                t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return Bh.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"),
                t = new Sh),
                t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return Bh.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, i, n, r) {
                return Bh.getUV(t, this.a, this.b, this.c, e, i, n, r)
            }
            containsPoint(t) {
                return Bh.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return Bh.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
                e = new Mo);
                const i = this.a
                  , n = this.b
                  , r = this.c;
                let s, a;
                Rh.subVectors(n, i),
                Oh.subVectors(r, i),
                Ih.subVectors(t, i);
                const o = Rh.dot(Ih)
                  , h = Oh.dot(Ih);
                if (o <= 0 && h <= 0)
                    return e.copy(i);
                Nh.subVectors(t, n);
                const l = Rh.dot(Nh)
                  , c = Oh.dot(Nh);
                if (l >= 0 && c <= l)
                    return e.copy(n);
                const u = o * c - l * h;
                if (u <= 0 && o >= 0 && l <= 0)
                    return s = o / (o - l),
                    e.copy(i).addScaledVector(Rh, s);
                zh.subVectors(t, r);
                const d = Rh.dot(zh)
                  , p = Oh.dot(zh);
                if (p >= 0 && d <= p)
                    return e.copy(r);
                const f = d * h - o * p;
                if (f <= 0 && h >= 0 && p <= 0)
                    return a = h / (h - p),
                    e.copy(i).addScaledVector(Oh, a);
                const m = l * p - d * c;
                if (m <= 0 && c - l >= 0 && d - p >= 0)
                    return Dh.subVectors(r, n),
                    a = (c - l) / (c - l + (d - p)),
                    e.copy(n).addScaledVector(Dh, a);
                const g = 1 / (m + f + u);
                return s = f * g,
                a = u * g,
                e.copy(i).addScaledVector(Rh, s).addScaledVector(Oh, a)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        let kh = 0;
        function Fh() {
            Object.defineProperty(this, "id", {
                value: kh++
            }),
            this.uuid = uo.generateUUID(),
            this.name = "",
            this.type = "Material",
            this.fog = !0,
            this.blending = Cr,
            this.side = Sr,
            this.vertexColors = !1,
            this.opacity = 1,
            this.transparent = !1,
            this.blendSrc = Wr,
            this.blendDst = Vr,
            this.blendEquation = Nr,
            this.blendSrcAlpha = null,
            this.blendDstAlpha = null,
            this.blendEquationAlpha = null,
            this.depthFunc = ts,
            this.depthTest = !0,
            this.depthWrite = !0,
            this.stencilWriteMask = 255,
            this.stencilFunc = ro,
            this.stencilRef = 0,
            this.stencilFuncMask = 255,
            this.stencilFail = no,
            this.stencilZFail = no,
            this.stencilZPass = no,
            this.stencilWrite = !1,
            this.clippingPlanes = null,
            this.clipIntersection = !1,
            this.clipShadows = !1,
            this.shadowSide = null,
            this.colorWrite = !0,
            this.precision = null,
            this.polygonOffset = !1,
            this.polygonOffsetFactor = 0,
            this.polygonOffsetUnits = 0,
            this.dithering = !1,
            this.alphaTest = 0,
            this.premultipliedAlpha = !1,
            this.visible = !0,
            this.toneMapped = !0,
            this.userData = {},
            this.version = 0
        }
        Fh.prototype = Object.assign(Object.create(ho.prototype), {
            constructor: Fh,
            isMaterial: !0,
            onBeforeCompile: function() {},
            customProgramCacheKey: function() {
                return this.onBeforeCompile.toString()
            },
            setValues: function(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const i = t[e];
                        if (void 0 === i) {
                            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                            continue
                        }
                        if ("shading" === e) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                            this.flatShading = 1 === i;
                            continue
                        }
                        const n = this[e];
                        void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    }
            },
            toJSON: function(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const i = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function n(t) {
                    const e = [];
                    for (const i in t) {
                        const n = t[i];
                        delete n.metadata,
                        e.push(n)
                    }
                    return e
                }
                if (i.uuid = this.uuid,
                i.type = this.type,
                "" !== this.name && (i.name = this.name),
                this.color && this.color.isColor && (i.color = this.color.getHex()),
                void 0 !== this.roughness && (i.roughness = this.roughness),
                void 0 !== this.metalness && (i.metalness = this.metalness),
                this.sheen && this.sheen.isColor && (i.sheen = this.sheen.getHex()),
                this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
                this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
                void 0 !== this.shininess && (i.shininess = this.shininess),
                void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
                i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
                this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid),
                this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid),
                this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid,
                i.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid,
                i.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid,
                i.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid,
                i.normalMapType = this.normalMapType,
                i.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid,
                i.displacementScale = this.displacementScale,
                i.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid),
                this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid,
                i.reflectivity = this.reflectivity,
                i.refractionRatio = this.refractionRatio,
                void 0 !== this.combine && (i.combine = this.combine),
                void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)),
                this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid),
                void 0 !== this.size && (i.size = this.size),
                void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
                this.blending !== Cr && (i.blending = this.blending),
                this.side !== Sr && (i.side = this.side),
                this.vertexColors && (i.vertexColors = !0),
                this.opacity < 1 && (i.opacity = this.opacity),
                !0 === this.transparent && (i.transparent = this.transparent),
                i.depthFunc = this.depthFunc,
                i.depthTest = this.depthTest,
                i.depthWrite = this.depthWrite,
                i.stencilWrite = this.stencilWrite,
                i.stencilWriteMask = this.stencilWriteMask,
                i.stencilFunc = this.stencilFunc,
                i.stencilRef = this.stencilRef,
                i.stencilFuncMask = this.stencilFuncMask,
                i.stencilFail = this.stencilFail,
                i.stencilZFail = this.stencilZFail,
                i.stencilZPass = this.stencilZPass,
                this.rotation && 0 !== this.rotation && (i.rotation = this.rotation),
                !0 === this.polygonOffset && (i.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits),
                this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth),
                void 0 !== this.dashSize && (i.dashSize = this.dashSize),
                void 0 !== this.gapSize && (i.gapSize = this.gapSize),
                void 0 !== this.scale && (i.scale = this.scale),
                !0 === this.dithering && (i.dithering = !0),
                this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
                !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha),
                !0 === this.wireframe && (i.wireframe = this.wireframe),
                this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.morphTargets && (i.morphTargets = !0),
                !0 === this.morphNormals && (i.morphNormals = !0),
                !0 === this.skinning && (i.skinning = !0),
                !0 === this.flatShading && (i.flatShading = this.flatShading),
                !1 === this.visible && (i.visible = !1),
                !1 === this.toneMapped && (i.toneMapped = !1),
                "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
                e) {
                    const e = n(t.textures)
                      , r = n(t.images);
                    e.length > 0 && (i.textures = e),
                    r.length > 0 && (i.images = r)
                }
                return i
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.name = t.name,
                this.fog = t.fog,
                this.blending = t.blending,
                this.side = t.side,
                this.vertexColors = t.vertexColors,
                this.opacity = t.opacity,
                this.transparent = t.transparent,
                this.blendSrc = t.blendSrc,
                this.blendDst = t.blendDst,
                this.blendEquation = t.blendEquation,
                this.blendSrcAlpha = t.blendSrcAlpha,
                this.blendDstAlpha = t.blendDstAlpha,
                this.blendEquationAlpha = t.blendEquationAlpha,
                this.depthFunc = t.depthFunc,
                this.depthTest = t.depthTest,
                this.depthWrite = t.depthWrite,
                this.stencilWriteMask = t.stencilWriteMask,
                this.stencilFunc = t.stencilFunc,
                this.stencilRef = t.stencilRef,
                this.stencilFuncMask = t.stencilFuncMask,
                this.stencilFail = t.stencilFail,
                this.stencilZFail = t.stencilZFail,
                this.stencilZPass = t.stencilZPass,
                this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let i = null;
                if (null !== e) {
                    const t = e.length;
                    i = new Array(t);
                    for (let n = 0; n !== t; ++n)
                        i[n] = e[n].clone()
                }
                return this.clippingPlanes = i,
                this.clipIntersection = t.clipIntersection,
                this.clipShadows = t.clipShadows,
                this.shadowSide = t.shadowSide,
                this.colorWrite = t.colorWrite,
                this.precision = t.precision,
                this.polygonOffset = t.polygonOffset,
                this.polygonOffsetFactor = t.polygonOffsetFactor,
                this.polygonOffsetUnits = t.polygonOffsetUnits,
                this.dithering = t.dithering,
                this.alphaTest = t.alphaTest,
                this.premultipliedAlpha = t.premultipliedAlpha,
                this.visible = t.visible,
                this.toneMapped = t.toneMapped,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }),
        Object.defineProperty(Fh.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        });
        const Uh = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Hh = {
            h: 0,
            s: 0,
            l: 0
        }
          , jh = {
            h: 0,
            s: 0,
            l: 0
        };
        function Gh(t, e, i) {
            return i < 0 && (i += 1),
            i > 1 && (i -= 1),
            i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
        }
        function Wh(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }
        function Vh(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        class qh {
            constructor(t, e, i) {
                return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
            }
            set(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
                this
            }
            setScalar(t) {
                return this.r = t,
                this.g = t,
                this.b = t,
                this
            }
            setHex(t) {
                return t = Math.floor(t),
                this.r = (t >> 16 & 255) / 255,
                this.g = (t >> 8 & 255) / 255,
                this.b = (255 & t) / 255,
                this
            }
            setRGB(t, e, i) {
                return this.r = t,
                this.g = e,
                this.b = i,
                this
            }
            setHSL(t, e, i) {
                if (t = uo.euclideanModulo(t, 1),
                e = uo.clamp(e, 0, 1),
                i = uo.clamp(i, 0, 1),
                0 === e)
                    this.r = this.g = this.b = i;
                else {
                    const n = i <= .5 ? i * (1 + e) : i + e - i * e
                      , r = 2 * i - n;
                    this.r = Gh(r, n, t + 1 / 3),
                    this.g = Gh(r, n, t),
                    this.b = Gh(r, n, t - 1 / 3)
                }
                return this
            }
            setStyle(t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                let i;
                if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                    let t;
                    const n = i[1]
                      , r = i[2];
                    switch (n) {
                    case "rgb":
                    case "rgba":
                        if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                            return this.r = Math.min(255, parseInt(t[1], 10)) / 255,
                            this.g = Math.min(255, parseInt(t[2], 10)) / 255,
                            this.b = Math.min(255, parseInt(t[3], 10)) / 255,
                            e(t[4]),
                            this;
                        if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                            return this.r = Math.min(100, parseInt(t[1], 10)) / 100,
                            this.g = Math.min(100, parseInt(t[2], 10)) / 100,
                            this.b = Math.min(100, parseInt(t[3], 10)) / 100,
                            e(t[4]),
                            this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                            const i = parseFloat(t[1]) / 360
                              , n = parseInt(t[2], 10) / 100
                              , r = parseInt(t[3], 10) / 100;
                            return e(t[4]),
                            this.setHSL(i, n, r)
                        }
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const t = i[1]
                      , e = t.length;
                    if (3 === e)
                        return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255,
                        this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255,
                        this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255,
                        this;
                    if (6 === e)
                        return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255,
                        this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255,
                        this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255,
                        this
                }
                return t && t.length > 0 ? this.setColorName(t) : this
            }
            setColorName(t) {
                const e = Uh[t];
                return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(t) {
                return this.r = t.r,
                this.g = t.g,
                this.b = t.b,
                this
            }
            copyGammaToLinear(t, e=2) {
                return this.r = Math.pow(t.r, e),
                this.g = Math.pow(t.g, e),
                this.b = Math.pow(t.b, e),
                this
            }
            copyLinearToGamma(t, e=2) {
                const i = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, i),
                this.g = Math.pow(t.g, i),
                this.b = Math.pow(t.b, i),
                this
            }
            convertGammaToLinear(t) {
                return this.copyGammaToLinear(this, t),
                this
            }
            convertLinearToGamma(t) {
                return this.copyLinearToGamma(this, t),
                this
            }
            copySRGBToLinear(t) {
                return this.r = Wh(t.r),
                this.g = Wh(t.g),
                this.b = Wh(t.b),
                this
            }
            copyLinearToSRGB(t) {
                return this.r = Vh(t.r),
                this.g = Vh(t.g),
                this.b = Vh(t.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }
            getHexString() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }
            getHSL(t) {
                void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"),
                t = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                const e = this.r
                  , i = this.g
                  , n = this.b
                  , r = Math.max(e, i, n)
                  , s = Math.min(e, i, n);
                let a, o;
                const h = (s + r) / 2;
                if (s === r)
                    a = 0,
                    o = 0;
                else {
                    const t = r - s;
                    switch (o = h <= .5 ? t / (r + s) : t / (2 - r - s),
                    r) {
                    case e:
                        a = (i - n) / t + (i < n ? 6 : 0);
                        break;
                    case i:
                        a = (n - e) / t + 2;
                        break;
                    case n:
                        a = (e - i) / t + 4
                    }
                    a /= 6
                }
                return t.h = a,
                t.s = o,
                t.l = h,
                t
            }
            getStyle() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }
            offsetHSL(t, e, i) {
                return this.getHSL(Hh),
                Hh.h += t,
                Hh.s += e,
                Hh.l += i,
                this.setHSL(Hh.h, Hh.s, Hh.l),
                this
            }
            add(t) {
                return this.r += t.r,
                this.g += t.g,
                this.b += t.b,
                this
            }
            addColors(t, e) {
                return this.r = t.r + e.r,
                this.g = t.g + e.g,
                this.b = t.b + e.b,
                this
            }
            addScalar(t) {
                return this.r += t,
                this.g += t,
                this.b += t,
                this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r),
                this.g = Math.max(0, this.g - t.g),
                this.b = Math.max(0, this.b - t.b),
                this
            }
            multiply(t) {
                return this.r *= t.r,
                this.g *= t.g,
                this.b *= t.b,
                this
            }
            multiplyScalar(t) {
                return this.r *= t,
                this.g *= t,
                this.b *= t,
                this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e,
                this.g += (t.g - this.g) * e,
                this.b += (t.b - this.b) * e,
                this
            }
            lerpColors(t, e, i) {
                return this.r = t.r + (e.r - t.r) * i,
                this.g = t.g + (e.g - t.g) * i,
                this.b = t.b + (e.b - t.b) * i,
                this
            }
            lerpHSL(t, e) {
                this.getHSL(Hh),
                t.getHSL(jh);
                const i = uo.lerp(Hh.h, jh.h, e)
                  , n = uo.lerp(Hh.s, jh.s, e)
                  , r = uo.lerp(Hh.l, jh.l, e);
                return this.setHSL(i, n, r),
                this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e=0) {
                return this.r = t[e],
                this.g = t[e + 1],
                this.b = t[e + 2],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.r,
                t[e + 1] = this.g,
                t[e + 2] = this.b,
                t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e),
                this.g = t.getY(e),
                this.b = t.getZ(e),
                !0 === t.normalized && (this.r /= 255,
                this.g /= 255,
                this.b /= 255),
                this
            }
            toJSON() {
                return this.getHex()
            }
        }
        qh.NAMES = Uh,
        qh.prototype.isColor = !0,
        qh.prototype.r = 1,
        qh.prototype.g = 1,
        qh.prototype.b = 1;
        class Xh extends Fh {
            constructor(t) {
                super(),
                this.type = "MeshBasicMaterial",
                this.color = new qh(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = ss,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this
            }
        }
        Xh.prototype.isMeshBasicMaterial = !0;
        const Yh = new Mo
          , Zh = new po;
        function Jh(t, e, i) {
            if (Array.isArray(t))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "",
            this.array = t,
            this.itemSize = e,
            this.count = void 0 !== t ? t.length / e : 0,
            this.normalized = !0 === i,
            this.usage = so,
            this.updateRange = {
                offset: 0,
                count: -1
            },
            this.version = 0
        }
        function $h(t, e, i) {
            Jh.call(this, new Int8Array(t), e, i)
        }
        function Qh(t, e, i) {
            Jh.call(this, new Uint8Array(t), e, i)
        }
        function Kh(t, e, i) {
            Jh.call(this, new Uint8ClampedArray(t), e, i)
        }
        function tl(t, e, i) {
            Jh.call(this, new Int16Array(t), e, i)
        }
        function el(t, e, i) {
            Jh.call(this, new Uint16Array(t), e, i)
        }
        function il(t, e, i) {
            Jh.call(this, new Int32Array(t), e, i)
        }
        function nl(t, e, i) {
            Jh.call(this, new Uint32Array(t), e, i)
        }
        function rl(t, e, i) {
            Jh.call(this, new Uint16Array(t), e, i)
        }
        function sl(t, e, i) {
            Jh.call(this, new Float32Array(t), e, i)
        }
        function al(t, e, i) {
            Jh.call(this, new Float64Array(t), e, i)
        }
        function ol(t) {
            if (0 === t.length)
                return -1 / 0;
            let e = t[0];
            for (let i = 1, n = t.length; i < n; ++i)
                t[i] > e && (e = t[i]);
            return e
        }
        Object.defineProperty(Jh.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }),
        Object.assign(Jh.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function() {},
            setUsage: function(t) {
                return this.usage = t,
                this
            },
            copy: function(t) {
                return this.name = t.name,
                this.array = new t.array.constructor(t.array),
                this.itemSize = t.itemSize,
                this.count = t.count,
                this.normalized = t.normalized,
                this.usage = t.usage,
                this
            },
            copyAt: function(t, e, i) {
                t *= this.itemSize,
                i *= e.itemSize;
                for (let n = 0, r = this.itemSize; n < r; n++)
                    this.array[t + n] = e.array[i + n];
                return this
            },
            copyArray: function(t) {
                return this.array.set(t),
                this
            },
            copyColorsArray: function(t) {
                const e = this.array;
                let i = 0;
                for (let n = 0, r = t.length; n < r; n++) {
                    let r = t[n];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n),
                    r = new qh),
                    e[i++] = r.r,
                    e[i++] = r.g,
                    e[i++] = r.b
                }
                return this
            },
            copyVector2sArray: function(t) {
                const e = this.array;
                let i = 0;
                for (let n = 0, r = t.length; n < r; n++) {
                    let r = t[n];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n),
                    r = new po),
                    e[i++] = r.x,
                    e[i++] = r.y
                }
                return this
            },
            copyVector3sArray: function(t) {
                const e = this.array;
                let i = 0;
                for (let n = 0, r = t.length; n < r; n++) {
                    let r = t[n];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n),
                    r = new Mo),
                    e[i++] = r.x,
                    e[i++] = r.y,
                    e[i++] = r.z
                }
                return this
            },
            copyVector4sArray: function(t) {
                const e = this.array;
                let i = 0;
                for (let n = 0, r = t.length; n < r; n++) {
                    let r = t[n];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n),
                    r = new _o),
                    e[i++] = r.x,
                    e[i++] = r.y,
                    e[i++] = r.z,
                    e[i++] = r.w
                }
                return this
            },
            applyMatrix3: function(t) {
                if (2 === this.itemSize)
                    for (let e = 0, i = this.count; e < i; e++)
                        Zh.fromBufferAttribute(this, e),
                        Zh.applyMatrix3(t),
                        this.setXY(e, Zh.x, Zh.y);
                else if (3 === this.itemSize)
                    for (let e = 0, i = this.count; e < i; e++)
                        Yh.fromBufferAttribute(this, e),
                        Yh.applyMatrix3(t),
                        this.setXYZ(e, Yh.x, Yh.y, Yh.z);
                return this
            },
            applyMatrix4: function(t) {
                for (let e = 0, i = this.count; e < i; e++)
                    Yh.x = this.getX(e),
                    Yh.y = this.getY(e),
                    Yh.z = this.getZ(e),
                    Yh.applyMatrix4(t),
                    this.setXYZ(e, Yh.x, Yh.y, Yh.z);
                return this
            },
            applyNormalMatrix: function(t) {
                for (let e = 0, i = this.count; e < i; e++)
                    Yh.x = this.getX(e),
                    Yh.y = this.getY(e),
                    Yh.z = this.getZ(e),
                    Yh.applyNormalMatrix(t),
                    this.setXYZ(e, Yh.x, Yh.y, Yh.z);
                return this
            },
            transformDirection: function(t) {
                for (let e = 0, i = this.count; e < i; e++)
                    Yh.x = this.getX(e),
                    Yh.y = this.getY(e),
                    Yh.z = this.getZ(e),
                    Yh.transformDirection(t),
                    this.setXYZ(e, Yh.x, Yh.y, Yh.z);
                return this
            },
            set: function(t, e=0) {
                return this.array.set(t, e),
                this
            },
            getX: function(t) {
                return this.array[t * this.itemSize]
            },
            setX: function(t, e) {
                return this.array[t * this.itemSize] = e,
                this
            },
            getY: function(t) {
                return this.array[t * this.itemSize + 1]
            },
            setY: function(t, e) {
                return this.array[t * this.itemSize + 1] = e,
                this
            },
            getZ: function(t) {
                return this.array[t * this.itemSize + 2]
            },
            setZ: function(t, e) {
                return this.array[t * this.itemSize + 2] = e,
                this
            },
            getW: function(t) {
                return this.array[t * this.itemSize + 3]
            },
            setW: function(t, e) {
                return this.array[t * this.itemSize + 3] = e,
                this
            },
            setXY: function(t, e, i) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = i,
                this
            },
            setXYZ: function(t, e, i, n) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = i,
                this.array[t + 2] = n,
                this
            },
            setXYZW: function(t, e, i, n, r) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = i,
                this.array[t + 2] = n,
                this.array[t + 3] = r,
                this
            },
            onUpload: function(t) {
                return this.onUploadCallback = t,
                this
            },
            clone: function() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            },
            toJSON: function() {
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                }
            }
        }),
        $h.prototype = Object.create(Jh.prototype),
        $h.prototype.constructor = $h,
        Qh.prototype = Object.create(Jh.prototype),
        Qh.prototype.constructor = Qh,
        Kh.prototype = Object.create(Jh.prototype),
        Kh.prototype.constructor = Kh,
        tl.prototype = Object.create(Jh.prototype),
        tl.prototype.constructor = tl,
        el.prototype = Object.create(Jh.prototype),
        el.prototype.constructor = el,
        il.prototype = Object.create(Jh.prototype),
        il.prototype.constructor = il,
        nl.prototype = Object.create(Jh.prototype),
        nl.prototype.constructor = nl,
        rl.prototype = Object.create(Jh.prototype),
        rl.prototype.constructor = rl,
        rl.prototype.isFloat16BufferAttribute = !0,
        sl.prototype = Object.create(Jh.prototype),
        sl.prototype.constructor = sl,
        al.prototype = Object.create(Jh.prototype),
        al.prototype.constructor = al,
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
        let hl = 0;
        const ll = new $o
          , cl = new wh
          , ul = new Mo
          , dl = new So
          , pl = new So
          , fl = new Mo;
        function ml() {
            Object.defineProperty(this, "id", {
                value: hl++
            }),
            this.uuid = uo.generateUUID(),
            this.name = "",
            this.type = "BufferGeometry",
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.morphTargetsRelative = !1,
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.drawRange = {
                start: 0,
                count: 1 / 0
            },
            this.userData = {}
        }
        ml.prototype = Object.assign(Object.create(ho.prototype), {
            constructor: ml,
            isBufferGeometry: !0,
            getIndex: function() {
                return this.index
            },
            setIndex: function(t) {
                return Array.isArray(t) ? this.index = new (ol(t) > 65535 ? nl : el)(t,1) : this.index = t,
                this
            },
            getAttribute: function(t) {
                return this.attributes[t]
            },
            setAttribute: function(t, e) {
                return this.attributes[t] = e,
                this
            },
            deleteAttribute: function(t) {
                return delete this.attributes[t],
                this
            },
            hasAttribute: function(t) {
                return void 0 !== this.attributes[t]
            },
            addGroup: function(t, e, i=0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: i
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(t, e) {
                this.drawRange.start = t,
                this.drawRange.count = e
            },
            applyMatrix4: function(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t),
                e.needsUpdate = !0);
                const i = this.attributes.normal;
                if (void 0 !== i) {
                    const e = (new fo).getNormalMatrix(t);
                    i.applyNormalMatrix(e),
                    i.needsUpdate = !0
                }
                const n = this.attributes.tangent;
                return void 0 !== n && (n.transformDirection(t),
                n.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            },
            rotateX: function(t) {
                return ll.makeRotationX(t),
                this.applyMatrix4(ll),
                this
            },
            rotateY: function(t) {
                return ll.makeRotationY(t),
                this.applyMatrix4(ll),
                this
            },
            rotateZ: function(t) {
                return ll.makeRotationZ(t),
                this.applyMatrix4(ll),
                this
            },
            translate: function(t, e, i) {
                return ll.makeTranslation(t, e, i),
                this.applyMatrix4(ll),
                this
            },
            scale: function(t, e, i) {
                return ll.makeScale(t, e, i),
                this.applyMatrix4(ll),
                this
            },
            lookAt: function(t) {
                return cl.lookAt(t),
                cl.updateMatrix(),
                this.applyMatrix4(cl.matrix),
                this
            },
            center: function() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(ul).negate(),
                this.translate(ul.x, ul.y, ul.z),
                this
            },
            setFromPoints: function(t) {
                const e = [];
                for (let i = 0, n = t.length; i < n; i++) {
                    const n = t[i];
                    e.push(n.x, n.y, n.z || 0)
                }
                return this.setAttribute("position", new sl(e,3)),
                this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new So);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingBox.set(new Mo(-1 / 0,-1 / 0,-1 / 0), new Mo(1 / 0,1 / 0,1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, i = e.length; t < i; t++) {
                            const i = e[t];
                            dl.setFromBufferAttribute(i),
                            this.morphTargetsRelative ? (fl.addVectors(this.boundingBox.min, dl.min),
                            this.boundingBox.expandByPoint(fl),
                            fl.addVectors(this.boundingBox.max, dl.max),
                            this.boundingBox.expandByPoint(fl)) : (this.boundingBox.expandByPoint(dl.min),
                            this.boundingBox.expandByPoint(dl.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new jo);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingSphere.set(new Mo, 1 / 0);
                if (t) {
                    const i = this.boundingSphere.center;
                    if (dl.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, i = e.length; t < i; t++) {
                            const i = e[t];
                            pl.setFromBufferAttribute(i),
                            this.morphTargetsRelative ? (fl.addVectors(dl.min, pl.min),
                            dl.expandByPoint(fl),
                            fl.addVectors(dl.max, pl.max),
                            dl.expandByPoint(fl)) : (dl.expandByPoint(pl.min),
                            dl.expandByPoint(pl.max))
                        }
                    dl.getCenter(i);
                    let n = 0;
                    for (let e = 0, r = t.count; e < r; e++)
                        fl.fromBufferAttribute(t, e),
                        n = Math.max(n, i.distanceToSquared(fl));
                    if (e)
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r]
                              , a = this.morphTargetsRelative;
                            for (let e = 0, r = s.count; e < r; e++)
                                fl.fromBufferAttribute(s, e),
                                a && (ul.fromBufferAttribute(t, e),
                                fl.add(ul)),
                                n = Math.max(n, i.distanceToSquared(fl))
                        }
                    this.boundingSphere.radius = Math.sqrt(n),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            },
            computeFaceNormals: function() {},
            computeTangents: function() {
                const t = this.index
                  , e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const i = t.array
                  , n = e.position.array
                  , r = e.normal.array
                  , s = e.uv.array
                  , a = n.length / 3;
                void 0 === e.tangent && this.setAttribute("tangent", new Jh(new Float32Array(4 * a),4));
                const o = e.tangent.array
                  , h = []
                  , l = [];
                for (let t = 0; t < a; t++)
                    h[t] = new Mo,
                    l[t] = new Mo;
                const c = new Mo
                  , u = new Mo
                  , d = new Mo
                  , p = new po
                  , f = new po
                  , m = new po
                  , g = new Mo
                  , v = new Mo;
                function y(t, e, i) {
                    c.fromArray(n, 3 * t),
                    u.fromArray(n, 3 * e),
                    d.fromArray(n, 3 * i),
                    p.fromArray(s, 2 * t),
                    f.fromArray(s, 2 * e),
                    m.fromArray(s, 2 * i),
                    u.sub(c),
                    d.sub(c),
                    f.sub(p),
                    m.sub(p);
                    const r = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r),
                    v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r),
                    h[t].add(g),
                    h[e].add(g),
                    h[i].add(g),
                    l[t].add(v),
                    l[e].add(v),
                    l[i].add(v))
                }
                let x = this.groups;
                0 === x.length && (x = [{
                    start: 0,
                    count: i.length
                }]);
                for (let t = 0, e = x.length; t < e; ++t) {
                    const e = x[t]
                      , n = e.start;
                    for (let t = n, r = n + e.count; t < r; t += 3)
                        y(i[t + 0], i[t + 1], i[t + 2])
                }
                const _ = new Mo
                  , b = new Mo
                  , w = new Mo
                  , M = new Mo;
                function T(t) {
                    w.fromArray(r, 3 * t),
                    M.copy(w);
                    const e = h[t];
                    _.copy(e),
                    _.sub(w.multiplyScalar(w.dot(e))).normalize(),
                    b.crossVectors(M, e);
                    const i = b.dot(l[t]) < 0 ? -1 : 1;
                    o[4 * t] = _.x,
                    o[4 * t + 1] = _.y,
                    o[4 * t + 2] = _.z,
                    o[4 * t + 3] = i
                }
                for (let t = 0, e = x.length; t < e; ++t) {
                    const e = x[t]
                      , n = e.start;
                    for (let t = n, r = n + e.count; t < r; t += 3)
                        T(i[t + 0]),
                        T(i[t + 1]),
                        T(i[t + 2])
                }
            },
            computeVertexNormals: function() {
                const t = this.index
                  , e = this.getAttribute("position");
                if (void 0 !== e) {
                    let i = this.getAttribute("normal");
                    if (void 0 === i)
                        i = new Jh(new Float32Array(3 * e.count),3),
                        this.setAttribute("normal", i);
                    else
                        for (let t = 0, e = i.count; t < e; t++)
                            i.setXYZ(t, 0, 0, 0);
                    const n = new Mo
                      , r = new Mo
                      , s = new Mo
                      , a = new Mo
                      , o = new Mo
                      , h = new Mo
                      , l = new Mo
                      , c = new Mo;
                    if (t)
                        for (let u = 0, d = t.count; u < d; u += 3) {
                            const d = t.getX(u + 0)
                              , p = t.getX(u + 1)
                              , f = t.getX(u + 2);
                            n.fromBufferAttribute(e, d),
                            r.fromBufferAttribute(e, p),
                            s.fromBufferAttribute(e, f),
                            l.subVectors(s, r),
                            c.subVectors(n, r),
                            l.cross(c),
                            a.fromBufferAttribute(i, d),
                            o.fromBufferAttribute(i, p),
                            h.fromBufferAttribute(i, f),
                            a.add(l),
                            o.add(l),
                            h.add(l),
                            i.setXYZ(d, a.x, a.y, a.z),
                            i.setXYZ(p, o.x, o.y, o.z),
                            i.setXYZ(f, h.x, h.y, h.z)
                        }
                    else
                        for (let t = 0, a = e.count; t < a; t += 3)
                            n.fromBufferAttribute(e, t + 0),
                            r.fromBufferAttribute(e, t + 1),
                            s.fromBufferAttribute(e, t + 2),
                            l.subVectors(s, r),
                            c.subVectors(n, r),
                            l.cross(c),
                            i.setXYZ(t + 0, l.x, l.y, l.z),
                            i.setXYZ(t + 1, l.x, l.y, l.z),
                            i.setXYZ(t + 2, l.x, l.y, l.z);
                    this.normalizeNormals(),
                    i.needsUpdate = !0
                }
            },
            merge: function(t, e) {
                if (!t || !t.isBufferGeometry)
                    return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const i = this.attributes;
                for (const n in i) {
                    if (void 0 === t.attributes[n])
                        continue;
                    const r = i[n].array
                      , s = t.attributes[n]
                      , a = s.array
                      , o = s.itemSize * e
                      , h = Math.min(a.length, r.length - o);
                    for (let t = 0, e = o; t < h; t++,
                    e++)
                        r[e] = a[t]
                }
                return this
            },
            normalizeNormals: function() {
                const t = this.attributes.normal;
                for (let e = 0, i = t.count; e < i; e++)
                    fl.fromBufferAttribute(t, e),
                    fl.normalize(),
                    t.setXYZ(e, fl.x, fl.y, fl.z)
            },
            toNonIndexed: function() {
                function t(t, e) {
                    const i = t.array
                      , n = t.itemSize
                      , r = t.normalized
                      , s = new i.constructor(e.length * n);
                    let a = 0
                      , o = 0;
                    for (let t = 0, r = e.length; t < r; t++) {
                        a = e[t] * n;
                        for (let t = 0; t < n; t++)
                            s[o++] = i[a++]
                    }
                    return new Jh(s,n,r)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const e = new ml
                  , i = this.index.array
                  , n = this.attributes;
                for (const r in n) {
                    const s = t(n[r], i);
                    e.setAttribute(r, s)
                }
                const r = this.morphAttributes;
                for (const n in r) {
                    const s = []
                      , a = r[n];
                    for (let e = 0, n = a.length; e < n; e++) {
                        const n = t(a[e], i);
                        s.push(n)
                    }
                    e.morphAttributes[n] = s
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let t = 0, i = s.length; t < i; t++) {
                    const i = s[t];
                    e.addGroup(i.start, i.count, i.materialIndex)
                }
                return e
            },
            toJSON: function() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid,
                t.type = this.type,
                "" !== this.name && (t.name = this.name),
                Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const i in e)
                        void 0 !== e[i] && (t[i] = e[i]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const i = this.attributes;
                for (const e in i) {
                    const n = i[e]
                      , r = n.toJSON(t.data);
                    "" !== n.name && (r.name = n.name),
                    t.data.attributes[e] = r
                }
                const n = {};
                let r = !1;
                for (const e in this.morphAttributes) {
                    const i = this.morphAttributes[e]
                      , s = [];
                    for (let e = 0, n = i.length; e < n; e++) {
                        const n = i[e]
                          , r = n.toJSON(t.data);
                        "" !== n.name && (r.name = n.name),
                        s.push(r)
                    }
                    s.length > 0 && (n[e] = s,
                    r = !0)
                }
                r && (t.data.morphAttributes = n,
                t.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                const a = this.boundingSphere;
                return null !== a && (t.data.boundingSphere = {
                    center: a.center.toArray(),
                    radius: a.radius
                }),
                t
            },
            clone: function() {
                return (new ml).copy(this)
            },
            copy: function(t) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const i = t.index;
                null !== i && this.setIndex(i.clone(e));
                const n = t.attributes;
                for (const t in n) {
                    const i = n[t];
                    this.setAttribute(t, i.clone(e))
                }
                const r = t.morphAttributes;
                for (const t in r) {
                    const i = []
                      , n = r[t];
                    for (let t = 0, r = n.length; t < r; t++)
                        i.push(n[t].clone(e));
                    this.morphAttributes[t] = i
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const s = t.groups;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const a = t.boundingBox;
                null !== a && (this.boundingBox = a.clone());
                const o = t.boundingSphere;
                return null !== o && (this.boundingSphere = o.clone()),
                this.drawRange.start = t.drawRange.start,
                this.drawRange.count = t.drawRange.count,
                this.userData = t.userData,
                this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        const gl = new $o
          , vl = new Jo
          , yl = new jo
          , xl = new Mo
          , _l = new Mo
          , bl = new Mo
          , wl = new Mo
          , Ml = new Mo
          , Tl = new Mo
          , El = new Mo
          , Sl = new Mo
          , Al = new Mo
          , Ll = new po
          , Pl = new po
          , Cl = new po
          , Rl = new Mo
          , Ol = new Mo;
        function Dl(t=new ml, e=new Xh) {
            wh.call(this),
            this.type = "Mesh",
            this.geometry = t,
            this.material = e,
            this.updateMorphTargets()
        }
        function Il(t, e, i, n, r, s, a, o, h, l, c, u) {
            xl.fromBufferAttribute(r, l),
            _l.fromBufferAttribute(r, c),
            bl.fromBufferAttribute(r, u);
            const d = t.morphTargetInfluences;
            if (e.morphTargets && s && d) {
                El.set(0, 0, 0),
                Sl.set(0, 0, 0),
                Al.set(0, 0, 0);
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = d[t]
                      , i = s[t];
                    0 !== e && (wl.fromBufferAttribute(i, l),
                    Ml.fromBufferAttribute(i, c),
                    Tl.fromBufferAttribute(i, u),
                    a ? (El.addScaledVector(wl, e),
                    Sl.addScaledVector(Ml, e),
                    Al.addScaledVector(Tl, e)) : (El.addScaledVector(wl.sub(xl), e),
                    Sl.addScaledVector(Ml.sub(_l), e),
                    Al.addScaledVector(Tl.sub(bl), e)))
                }
                xl.add(El),
                _l.add(Sl),
                bl.add(Al)
            }
            t.isSkinnedMesh && e.skinning && (t.boneTransform(l, xl),
            t.boneTransform(c, _l),
            t.boneTransform(u, bl));
            const p = function(t, e, i, n, r, s, a, o) {
                let h;
                if (h = e.side === Ar ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, e.side !== Lr, o),
                null === h)
                    return null;
                Ol.copy(o),
                Ol.applyMatrix4(t.matrixWorld);
                const l = i.ray.origin.distanceTo(Ol);
                return l < i.near || l > i.far ? null : {
                    distance: l,
                    point: Ol.clone(),
                    object: t
                }
            }(t, e, i, n, xl, _l, bl, Rl);
            if (p) {
                o && (Ll.fromBufferAttribute(o, l),
                Pl.fromBufferAttribute(o, c),
                Cl.fromBufferAttribute(o, u),
                p.uv = Bh.getUV(Rl, xl, _l, bl, Ll, Pl, Cl, new po)),
                h && (Ll.fromBufferAttribute(h, l),
                Pl.fromBufferAttribute(h, c),
                Cl.fromBufferAttribute(h, u),
                p.uv2 = Bh.getUV(Rl, xl, _l, bl, Ll, Pl, Cl, new po));
                const t = {
                    a: l,
                    b: c,
                    c: u,
                    normal: new Mo,
                    materialIndex: 0
                };
                Bh.getNormal(xl, _l, bl, t.normal),
                p.face = t
            }
            return p
        }
        Dl.prototype = Object.assign(Object.create(wh.prototype), {
            constructor: Dl,
            isMesh: !0,
            copy: function(t) {
                return wh.prototype.copy.call(this, t),
                void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
                void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            },
            updateMorphTargets: function() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , i = Object.keys(e);
                    if (i.length > 0) {
                        const t = e[i[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[i] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            },
            raycast: function(t, e) {
                const i = this.geometry
                  , n = this.material
                  , r = this.matrixWorld;
                if (void 0 === n)
                    return;
                if (null === i.boundingSphere && i.computeBoundingSphere(),
                yl.copy(i.boundingSphere),
                yl.applyMatrix4(r),
                !1 === t.ray.intersectsSphere(yl))
                    return;
                if (gl.copy(r).invert(),
                vl.copy(t.ray).applyMatrix4(gl),
                null !== i.boundingBox && !1 === vl.intersectsBox(i.boundingBox))
                    return;
                let s;
                if (i.isBufferGeometry) {
                    const r = i.index
                      , a = i.attributes.position
                      , o = i.morphAttributes.position
                      , h = i.morphTargetsRelative
                      , l = i.attributes.uv
                      , c = i.attributes.uv2
                      , u = i.groups
                      , d = i.drawRange;
                    if (null !== r)
                        if (Array.isArray(n))
                            for (let i = 0, p = u.length; i < p; i++) {
                                const p = u[i]
                                  , f = n[p.materialIndex];
                                for (let i = Math.max(p.start, d.start), n = Math.min(p.start + p.count, d.start + d.count); i < n; i += 3) {
                                    const n = r.getX(i)
                                      , u = r.getX(i + 1)
                                      , d = r.getX(i + 2);
                                    s = Il(this, f, t, vl, a, o, h, l, c, n, u, d),
                                    s && (s.faceIndex = Math.floor(i / 3),
                                    s.face.materialIndex = p.materialIndex,
                                    e.push(s))
                                }
                            }
                        else
                            for (let i = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); i < u; i += 3) {
                                const u = r.getX(i)
                                  , d = r.getX(i + 1)
                                  , p = r.getX(i + 2);
                                s = Il(this, n, t, vl, a, o, h, l, c, u, d, p),
                                s && (s.faceIndex = Math.floor(i / 3),
                                e.push(s))
                            }
                    else if (void 0 !== a)
                        if (Array.isArray(n))
                            for (let i = 0, r = u.length; i < r; i++) {
                                const r = u[i]
                                  , p = n[r.materialIndex];
                                for (let i = Math.max(r.start, d.start), n = Math.min(r.start + r.count, d.start + d.count); i < n; i += 3)
                                    s = Il(this, p, t, vl, a, o, h, l, c, i, i + 1, i + 2),
                                    s && (s.faceIndex = Math.floor(i / 3),
                                    s.face.materialIndex = r.materialIndex,
                                    e.push(s))
                            }
                        else
                            for (let i = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); i < r; i += 3)
                                s = Il(this, n, t, vl, a, o, h, l, c, i, i + 1, i + 2),
                                s && (s.faceIndex = Math.floor(i / 3),
                                e.push(s))
                } else
                    i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        });
        class Nl extends ml {
            constructor(t=1, e=1, i=1, n=1, r=1, s=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    depth: i,
                    widthSegments: n,
                    heightSegments: r,
                    depthSegments: s
                };
                const a = this;
                n = Math.floor(n),
                r = Math.floor(r),
                s = Math.floor(s);
                const o = []
                  , h = []
                  , l = []
                  , c = [];
                let u = 0
                  , d = 0;
                function p(t, e, i, n, r, s, p, f, m, g, v) {
                    const y = s / m
                      , x = p / g
                      , _ = s / 2
                      , b = p / 2
                      , w = f / 2
                      , M = m + 1
                      , T = g + 1;
                    let E = 0
                      , S = 0;
                    const A = new Mo;
                    for (let s = 0; s < T; s++) {
                        const a = s * x - b;
                        for (let o = 0; o < M; o++) {
                            const u = o * y - _;
                            A[t] = u * n,
                            A[e] = a * r,
                            A[i] = w,
                            h.push(A.x, A.y, A.z),
                            A[t] = 0,
                            A[e] = 0,
                            A[i] = f > 0 ? 1 : -1,
                            l.push(A.x, A.y, A.z),
                            c.push(o / m),
                            c.push(1 - s / g),
                            E += 1
                        }
                    }
                    for (let t = 0; t < g; t++)
                        for (let e = 0; e < m; e++) {
                            const i = u + e + M * t
                              , n = u + e + M * (t + 1)
                              , r = u + (e + 1) + M * (t + 1)
                              , s = u + (e + 1) + M * t;
                            o.push(i, n, s),
                            o.push(n, r, s),
                            S += 6
                        }
                    a.addGroup(d, S, v),
                    d += S,
                    u += E
                }
                p("z", "y", "x", -1, -1, i, e, t, s, r, 0),
                p("z", "y", "x", 1, -1, i, e, -t, s, r, 1),
                p("x", "z", "y", 1, 1, t, i, e, n, s, 2),
                p("x", "z", "y", 1, -1, t, i, -e, n, s, 3),
                p("x", "y", "z", 1, -1, t, e, i, n, r, 4),
                p("x", "y", "z", -1, -1, t, e, -i, n, r, 5),
                this.setIndex(o),
                this.setAttribute("position", new sl(h,3)),
                this.setAttribute("normal", new sl(l,3)),
                this.setAttribute("uv", new sl(c,2))
            }
        }
        function zl(t) {
            const e = {};
            for (const i in t) {
                e[i] = {};
                for (const n in t[i]) {
                    const r = t[i][n];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                }
            }
            return e
        }
        function Bl(t) {
            const e = {};
            for (let i = 0; i < t.length; i++) {
                const n = zl(t[i]);
                for (const t in n)
                    e[t] = n[t]
            }
            return e
        }
        const kl = {
            clone: zl,
            merge: Bl
        };
        var Fl = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"
          , Ul = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        function Hl(t) {
            Fh.call(this),
            this.type = "ShaderMaterial",
            this.defines = {},
            this.uniforms = {},
            this.vertexShader = Fl,
            this.fragmentShader = Ul,
            this.linewidth = 1,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.fog = !1,
            this.lights = !1,
            this.clipping = !1,
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            },
            this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            },
            this.index0AttributeName = void 0,
            this.uniformsNeedUpdate = !1,
            this.glslVersion = null,
            void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
            this.setValues(t))
        }
        function jl() {
            wh.call(this),
            this.type = "Camera",
            this.matrixWorldInverse = new $o,
            this.projectionMatrix = new $o,
            this.projectionMatrixInverse = new $o
        }
        function Gl(t=50, e=1, i=.1, n=2e3) {
            jl.call(this),
            this.type = "PerspectiveCamera",
            this.fov = t,
            this.zoom = 1,
            this.near = i,
            this.far = n,
            this.focus = 10,
            this.aspect = e,
            this.view = null,
            this.filmGauge = 35,
            this.filmOffset = 0,
            this.updateProjectionMatrix()
        }
        Hl.prototype = Object.create(Fh.prototype),
        Hl.prototype.constructor = Hl,
        Hl.prototype.isShaderMaterial = !0,
        Hl.prototype.copy = function(t) {
            return Fh.prototype.copy.call(this, t),
            this.fragmentShader = t.fragmentShader,
            this.vertexShader = t.vertexShader,
            this.uniforms = zl(t.uniforms),
            this.defines = Object.assign({}, t.defines),
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.lights = t.lights,
            this.clipping = t.clipping,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this.extensions = Object.assign({}, t.extensions),
            this.glslVersion = t.glslVersion,
            this
        }
        ,
        Hl.prototype.toJSON = function(t) {
            const e = Fh.prototype.toJSON.call(this, t);
            e.glslVersion = this.glslVersion,
            e.uniforms = {};
            for (const i in this.uniforms) {
                const n = this.uniforms[i].value;
                n && n.isTexture ? e.uniforms[i] = {
                    type: "t",
                    value: n.toJSON(t).uuid
                } : n && n.isColor ? e.uniforms[i] = {
                    type: "c",
                    value: n.getHex()
                } : n && n.isVector2 ? e.uniforms[i] = {
                    type: "v2",
                    value: n.toArray()
                } : n && n.isVector3 ? e.uniforms[i] = {
                    type: "v3",
                    value: n.toArray()
                } : n && n.isVector4 ? e.uniforms[i] = {
                    type: "v4",
                    value: n.toArray()
                } : n && n.isMatrix3 ? e.uniforms[i] = {
                    type: "m3",
                    value: n.toArray()
                } : n && n.isMatrix4 ? e.uniforms[i] = {
                    type: "m4",
                    value: n.toArray()
                } : e.uniforms[i] = {
                    value: n
                }
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            e.vertexShader = this.vertexShader,
            e.fragmentShader = this.fragmentShader;
            const i = {};
            for (const t in this.extensions)
                !0 === this.extensions[t] && (i[t] = !0);
            return Object.keys(i).length > 0 && (e.extensions = i),
            e
        }
        ,
        jl.prototype = Object.assign(Object.create(wh.prototype), {
            constructor: jl,
            isCamera: !0,
            copy: function(t, e) {
                return wh.prototype.copy.call(this, t, e),
                this.matrixWorldInverse.copy(t.matrixWorldInverse),
                this.projectionMatrix.copy(t.projectionMatrix),
                this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                this
            },
            getWorldDirection: function(t) {
                void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
                t = new Mo),
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            },
            updateMatrixWorld: function(t) {
                wh.prototype.updateMatrixWorld.call(this, t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            },
            updateWorldMatrix: function(t, e) {
                wh.prototype.updateWorldMatrix.call(this, t, e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }),
        Gl.prototype = Object.assign(Object.create(jl.prototype), {
            constructor: Gl,
            isPerspectiveCamera: !0,
            copy: function(t, e) {
                return jl.prototype.copy.call(this, t, e),
                this.fov = t.fov,
                this.zoom = t.zoom,
                this.near = t.near,
                this.far = t.far,
                this.focus = t.focus,
                this.aspect = t.aspect,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this.filmGauge = t.filmGauge,
                this.filmOffset = t.filmOffset,
                this
            },
            setFocalLength: function(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * uo.RAD2DEG * Math.atan(e),
                this.updateProjectionMatrix()
            },
            getFocalLength: function() {
                const t = Math.tan(.5 * uo.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            },
            getEffectiveFOV: function() {
                return 2 * uo.RAD2DEG * Math.atan(Math.tan(.5 * uo.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function() {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function() {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function(t, e, i, n, r, s) {
                this.aspect = t / e,
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = i,
                this.view.offsetY = n,
                this.view.width = r,
                this.view.height = s,
                this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                const t = this.near;
                let e = t * Math.tan(.5 * uo.DEG2RAD * this.fov) / this.zoom
                  , i = 2 * e
                  , n = this.aspect * i
                  , r = -.5 * n;
                const s = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = s.fullWidth
                      , a = s.fullHeight;
                    r += s.offsetX * n / t,
                    e -= s.offsetY * i / a,
                    n *= s.width / t,
                    i *= s.height / a
                }
                const a = this.filmOffset;
                0 !== a && (r += t * a / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            },
            toJSON: function(t) {
                const e = wh.prototype.toJSON.call(this, t);
                return e.object.fov = this.fov,
                e.object.zoom = this.zoom,
                e.object.near = this.near,
                e.object.far = this.far,
                e.object.focus = this.focus,
                e.object.aspect = this.aspect,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e.object.filmGauge = this.filmGauge,
                e.object.filmOffset = this.filmOffset,
                e
            }
        });
        const Wl = 90;
        class Vl extends wh {
            constructor(t, e, i) {
                if (super(),
                this.type = "CubeCamera",
                !0 !== i.isWebGLCubeRenderTarget)
                    return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = i;
                const n = new Gl(Wl,1,t,e);
                n.layers = this.layers,
                n.up.set(0, -1, 0),
                n.lookAt(new Mo(1,0,0)),
                this.add(n);
                const r = new Gl(Wl,1,t,e);
                r.layers = this.layers,
                r.up.set(0, -1, 0),
                r.lookAt(new Mo(-1,0,0)),
                this.add(r);
                const s = new Gl(Wl,1,t,e);
                s.layers = this.layers,
                s.up.set(0, 0, 1),
                s.lookAt(new Mo(0,1,0)),
                this.add(s);
                const a = new Gl(Wl,1,t,e);
                a.layers = this.layers,
                a.up.set(0, 0, -1),
                a.lookAt(new Mo(0,-1,0)),
                this.add(a);
                const o = new Gl(Wl,1,t,e);
                o.layers = this.layers,
                o.up.set(0, -1, 0),
                o.lookAt(new Mo(0,0,1)),
                this.add(o);
                const h = new Gl(Wl,1,t,e);
                h.layers = this.layers,
                h.up.set(0, -1, 0),
                h.lookAt(new Mo(0,0,-1)),
                this.add(h)
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const i = this.renderTarget
                  , [n,r,s,a,o,h] = this.children
                  , l = t.xr.enabled
                  , c = t.getRenderTarget();
                t.xr.enabled = !1;
                const u = i.texture.generateMipmaps;
                i.texture.generateMipmaps = !1,
                t.setRenderTarget(i, 0),
                t.render(e, n),
                t.setRenderTarget(i, 1),
                t.render(e, r),
                t.setRenderTarget(i, 2),
                t.render(e, s),
                t.setRenderTarget(i, 3),
                t.render(e, a),
                t.setRenderTarget(i, 4),
                t.render(e, o),
                i.texture.generateMipmaps = u,
                t.setRenderTarget(i, 5),
                t.render(e, h),
                t.setRenderTarget(c),
                t.xr.enabled = l
            }
        }
        class ql extends yo {
            constructor(t, e, i, n, r, s, a, o, h, l) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : fs, i, n, r, s, a = void 0 !== a ? a : js, o, h, l),
                this._needsFlipEnvMap = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        ql.prototype.isCubeTexture = !0;
        class Xl extends bo {
            constructor(t, e, i) {
                Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
                e = i),
                super(t, t, e),
                e = e || {},
                this.texture = new ql(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),
                this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps,
                this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Ss,
                this.texture._needsFlipEnvMap = !1
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type,
                this.texture.format = Gs,
                this.texture.encoding = e.encoding,
                this.texture.generateMipmaps = e.generateMipmaps,
                this.texture.minFilter = e.minFilter,
                this.texture.magFilter = e.magFilter;
                const i = {
                    tEquirect: {
                        value: null
                    }
                }
                  , n = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t"
                  , r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                  , s = new Nl(5,5,5)
                  , a = new Hl({
                    name: "CubemapFromEquirect",
                    uniforms: zl(i),
                    vertexShader: n,
                    fragmentShader: r,
                    side: Ar,
                    blending: Pr
                });
                a.uniforms.tEquirect.value = e;
                const o = new Dl(s,a)
                  , h = e.minFilter;
                return e.minFilter === Ls && (e.minFilter = Ss),
                new Vl(1,10,this).update(t, o),
                e.minFilter = h,
                o.geometry.dispose(),
                o.material.dispose(),
                this
            }
            clear(t, e, i, n) {
                const r = t.getRenderTarget();
                for (let r = 0; r < 6; r++)
                    t.setRenderTarget(this, r),
                    t.clear(e, i, n);
                t.setRenderTarget(r)
            }
        }
        Xl.prototype.isWebGLCubeRenderTarget = !0;
        class Yl extends yo {
            constructor(t, e, i, n, r, s, a, o, h, l, c, u) {
                super(null, s, a, o, h, l, n, r, c, u),
                this.image = {
                    data: t || null,
                    width: e || 1,
                    height: i || 1
                },
                this.magFilter = void 0 !== h ? h : Ms,
                this.minFilter = void 0 !== l ? l : Ms,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1,
                this.needsUpdate = !0
            }
        }
        Yl.prototype.isDataTexture = !0;
        const Zl = new jo
          , Jl = new Mo;
        class $l {
            constructor(t=new Sh, e=new Sh, i=new Sh, n=new Sh, r=new Sh, s=new Sh) {
                this.planes = [t, e, i, n, r, s]
            }
            set(t, e, i, n, r, s) {
                const a = this.planes;
                return a[0].copy(t),
                a[1].copy(e),
                a[2].copy(i),
                a[3].copy(n),
                a[4].copy(r),
                a[5].copy(s),
                this
            }
            copy(t) {
                const e = this.planes;
                for (let i = 0; i < 6; i++)
                    e[i].copy(t.planes[i]);
                return this
            }
            setFromProjectionMatrix(t) {
                const e = this.planes
                  , i = t.elements
                  , n = i[0]
                  , r = i[1]
                  , s = i[2]
                  , a = i[3]
                  , o = i[4]
                  , h = i[5]
                  , l = i[6]
                  , c = i[7]
                  , u = i[8]
                  , d = i[9]
                  , p = i[10]
                  , f = i[11]
                  , m = i[12]
                  , g = i[13]
                  , v = i[14]
                  , y = i[15];
                return e[0].setComponents(a - n, c - o, f - u, y - m).normalize(),
                e[1].setComponents(a + n, c + o, f + u, y + m).normalize(),
                e[2].setComponents(a + r, c + h, f + d, y + g).normalize(),
                e[3].setComponents(a - r, c - h, f - d, y - g).normalize(),
                e[4].setComponents(a - s, c - l, f - p, y - v).normalize(),
                e[5].setComponents(a + s, c + l, f + p, y + v).normalize(),
                this
            }
            intersectsObject(t) {
                const e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(),
                Zl.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
                this.intersectsSphere(Zl)
            }
            intersectsSprite(t) {
                return Zl.center.set(0, 0, 0),
                Zl.radius = .7071067811865476,
                Zl.applyMatrix4(t.matrixWorld),
                this.intersectsSphere(Zl)
            }
            intersectsSphere(t) {
                const e = this.planes
                  , i = t.center
                  , n = -t.radius;
                for (let t = 0; t < 6; t++)
                    if (e[t].distanceToPoint(i) < n)
                        return !1;
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let i = 0; i < 6; i++) {
                    const n = e[i];
                    if (Jl.x = n.normal.x > 0 ? t.max.x : t.min.x,
                    Jl.y = n.normal.y > 0 ? t.max.y : t.min.y,
                    Jl.z = n.normal.z > 0 ? t.max.z : t.min.z,
                    n.distanceToPoint(Jl) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let i = 0; i < 6; i++)
                    if (e[i].distanceToPoint(t) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        function Ql() {
            let t = null
              , e = !1
              , i = null
              , n = null;
            function r(e, s) {
                i(e, s),
                n = t.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== e && null !== i && (n = t.requestAnimationFrame(r),
                    e = !0)
                },
                stop: function() {
                    t.cancelAnimationFrame(n),
                    e = !1
                },
                setAnimationLoop: function(t) {
                    i = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }
        function Kl(t, e) {
            const i = e.isWebGL2
              , n = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data),
                    n.get(t)
                },
                remove: function(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const i = n.get(e);
                    i && (t.deleteBuffer(i.buffer),
                    n.delete(e))
                },
                update: function(e, r) {
                    if (e.isGLBufferAttribute) {
                        const t = n.get(e);
                        return void ((!t || t.version < e.version) && n.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const s = n.get(e);
                    void 0 === s ? n.set(e, function(e, n) {
                        const r = e.array
                          , s = e.usage
                          , a = t.createBuffer();
                        t.bindBuffer(n, a),
                        t.bufferData(n, r, s),
                        e.onUploadCallback();
                        let o = 5126;
                        return r instanceof Float32Array ? o = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? i ? o = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = 5123 : r instanceof Int16Array ? o = 5122 : r instanceof Uint32Array ? o = 5125 : r instanceof Int32Array ? o = 5124 : r instanceof Int8Array ? o = 5120 : r instanceof Uint8Array && (o = 5121),
                        {
                            buffer: a,
                            type: o,
                            bytesPerElement: r.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, r)) : s.version < e.version && (function(e, n, r) {
                        const s = n.array
                          , a = n.updateRange;
                        t.bindBuffer(r, e),
                        -1 === a.count ? t.bufferSubData(r, 0, s) : (i ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)),
                        a.count = -1)
                    }(s.buffer, e, r),
                    s.version = e.version)
                }
            }
        }
        class tc extends ml {
            constructor(t=1, e=1, i=1, n=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: i,
                    heightSegments: n
                };
                const r = t / 2
                  , s = e / 2
                  , a = Math.floor(i)
                  , o = Math.floor(n)
                  , h = a + 1
                  , l = o + 1
                  , c = t / a
                  , u = e / o
                  , d = []
                  , p = []
                  , f = []
                  , m = [];
                for (let t = 0; t < l; t++) {
                    const e = t * u - s;
                    for (let i = 0; i < h; i++) {
                        const n = i * c - r;
                        p.push(n, -e, 0),
                        f.push(0, 0, 1),
                        m.push(i / a),
                        m.push(1 - t / o)
                    }
                }
                for (let t = 0; t < o; t++)
                    for (let e = 0; e < a; e++) {
                        const i = e + h * t
                          , n = e + h * (t + 1)
                          , r = e + 1 + h * (t + 1)
                          , s = e + 1 + h * t;
                        d.push(i, n, s),
                        d.push(n, r, s)
                    }
                this.setIndex(d),
                this.setAttribute("position", new sl(p,3)),
                this.setAttribute("normal", new sl(f,3)),
                this.setAttribute("uv", new sl(m,2))
            }
        }
        const ec = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
            transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
            uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        }
          , ic = {
            common: {
                diffuse: {
                    value: new qh(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new fo
                },
                uv2Transform: {
                    value: new fo
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new po(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new qh(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new qh(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new fo
                }
            },
            sprite: {
                diffuse: {
                    value: new qh(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new po(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new fo
                }
            }
        }
          , nc = {
            basic: {
                uniforms: Bl([ic.common, ic.specularmap, ic.envmap, ic.aomap, ic.lightmap, ic.fog]),
                vertexShader: ec.meshbasic_vert,
                fragmentShader: ec.meshbasic_frag
            },
            lambert: {
                uniforms: Bl([ic.common, ic.specularmap, ic.envmap, ic.aomap, ic.lightmap, ic.emissivemap, ic.fog, ic.lights, {
                    emissive: {
                        value: new qh(0)
                    }
                }]),
                vertexShader: ec.meshlambert_vert,
                fragmentShader: ec.meshlambert_frag
            },
            phong: {
                uniforms: Bl([ic.common, ic.specularmap, ic.envmap, ic.aomap, ic.lightmap, ic.emissivemap, ic.bumpmap, ic.normalmap, ic.displacementmap, ic.fog, ic.lights, {
                    emissive: {
                        value: new qh(0)
                    },
                    specular: {
                        value: new qh(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: ec.meshphong_vert,
                fragmentShader: ec.meshphong_frag
            },
            standard: {
                uniforms: Bl([ic.common, ic.envmap, ic.aomap, ic.lightmap, ic.emissivemap, ic.bumpmap, ic.normalmap, ic.displacementmap, ic.roughnessmap, ic.metalnessmap, ic.fog, ic.lights, {
                    emissive: {
                        value: new qh(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: ec.meshphysical_vert,
                fragmentShader: ec.meshphysical_frag
            },
            toon: {
                uniforms: Bl([ic.common, ic.aomap, ic.lightmap, ic.emissivemap, ic.bumpmap, ic.normalmap, ic.displacementmap, ic.gradientmap, ic.fog, ic.lights, {
                    emissive: {
                        value: new qh(0)
                    }
                }]),
                vertexShader: ec.meshtoon_vert,
                fragmentShader: ec.meshtoon_frag
            },
            matcap: {
                uniforms: Bl([ic.common, ic.bumpmap, ic.normalmap, ic.displacementmap, ic.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: ec.meshmatcap_vert,
                fragmentShader: ec.meshmatcap_frag
            },
            points: {
                uniforms: Bl([ic.points, ic.fog]),
                vertexShader: ec.points_vert,
                fragmentShader: ec.points_frag
            },
            dashed: {
                uniforms: Bl([ic.common, ic.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: ec.linedashed_vert,
                fragmentShader: ec.linedashed_frag
            },
            depth: {
                uniforms: Bl([ic.common, ic.displacementmap]),
                vertexShader: ec.depth_vert,
                fragmentShader: ec.depth_frag
            },
            normal: {
                uniforms: Bl([ic.common, ic.bumpmap, ic.normalmap, ic.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ec.normal_vert,
                fragmentShader: ec.normal_frag
            },
            sprite: {
                uniforms: Bl([ic.sprite, ic.fog]),
                vertexShader: ec.sprite_vert,
                fragmentShader: ec.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new fo
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: ec.background_vert,
                fragmentShader: ec.background_frag
            },
            cube: {
                uniforms: Bl([ic.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ec.cube_vert,
                fragmentShader: ec.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ec.equirect_vert,
                fragmentShader: ec.equirect_frag
            },
            distanceRGBA: {
                uniforms: Bl([ic.common, ic.displacementmap, {
                    referencePosition: {
                        value: new Mo
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: ec.distanceRGBA_vert,
                fragmentShader: ec.distanceRGBA_frag
            },
            shadow: {
                uniforms: Bl([ic.lights, ic.fog, {
                    color: {
                        value: new qh(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ec.shadow_vert,
                fragmentShader: ec.shadow_frag
            }
        };
        function rc(t, e, i, n, r) {
            const s = new qh(0);
            let a, o, h = 0, l = null, c = 0, u = null;
            function d(t, e) {
                i.buffers.color.setClear(t.r, t.g, t.b, e, r)
            }
            return {
                getClearColor: function() {
                    return s
                },
                setClearColor: function(t, e=1) {
                    s.set(t),
                    h = e,
                    d(s, h)
                },
                getClearAlpha: function() {
                    return h
                },
                setClearAlpha: function(t) {
                    h = t,
                    d(s, h)
                },
                render: function(i, r, p, f) {
                    let m = !0 === r.isScene ? r.background : null;
                    m && m.isTexture && (m = e.get(m));
                    const g = t.xr
                      , v = g.getSession && g.getSession();
                    v && "additive" === v.environmentBlendMode && (m = null),
                    null === m ? d(s, h) : m && m.isColor && (d(m, 1),
                    f = !0),
                    (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                    m && (m.isCubeTexture || m.isWebGLCubeRenderTarget || m.mapping === ys) ? (void 0 === o && (o = new Dl(new Nl(1,1,1),new Hl({
                        name: "BackgroundCubeMaterial",
                        uniforms: zl(nc.cube.uniforms),
                        vertexShader: nc.cube.vertexShader,
                        fragmentShader: nc.cube.fragmentShader,
                        side: Ar,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    o.geometry.deleteAttribute("normal"),
                    o.geometry.deleteAttribute("uv"),
                    o.onBeforeRender = function(t, e, i) {
                        this.matrixWorld.copyPosition(i.matrixWorld)
                    }
                    ,
                    Object.defineProperty(o.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    n.update(o)),
                    m.isWebGLCubeRenderTarget && (m = m.texture),
                    o.material.uniforms.envMap.value = m,
                    o.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1,
                    l === m && c === m.version && u === t.toneMapping || (o.material.needsUpdate = !0,
                    l = m,
                    c = m.version,
                    u = t.toneMapping),
                    i.unshift(o, o.geometry, o.material, 0, 0, null)) : m && m.isTexture && (void 0 === a && (a = new Dl(new tc(2,2),new Hl({
                        name: "BackgroundMaterial",
                        uniforms: zl(nc.background.uniforms),
                        vertexShader: nc.background.vertexShader,
                        fragmentShader: nc.background.fragmentShader,
                        side: Sr,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    a.geometry.deleteAttribute("normal"),
                    Object.defineProperty(a.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    n.update(a)),
                    a.material.uniforms.t2D.value = m,
                    !0 === m.matrixAutoUpdate && m.updateMatrix(),
                    a.material.uniforms.uvTransform.value.copy(m.matrix),
                    l === m && c === m.version && u === t.toneMapping || (a.material.needsUpdate = !0,
                    l = m,
                    c = m.version,
                    u = t.toneMapping),
                    i.unshift(a, a.geometry, a.material, 0, 0, null))
                }
            }
        }
        function sc(t, e, i, n) {
            const r = t.getParameter(34921)
              , s = n.isWebGL2 ? null : e.get("OES_vertex_array_object")
              , a = n.isWebGL2 || null !== s
              , o = {}
              , h = d(null);
            let l = h;
            function c(e) {
                return n.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
            }
            function u(e) {
                return n.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
            }
            function d(t) {
                const e = []
                  , i = []
                  , n = [];
                for (let t = 0; t < r; t++)
                    e[t] = 0,
                    i[t] = 0,
                    n[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: i,
                    attributeDivisors: n,
                    object: t,
                    attributes: {},
                    index: null
                }
            }
            function p() {
                const t = l.newAttributes;
                for (let e = 0, i = t.length; e < i; e++)
                    t[e] = 0
            }
            function f(t) {
                m(t, 0)
            }
            function m(i, r) {
                const s = l.newAttributes
                  , a = l.enabledAttributes
                  , o = l.attributeDivisors;
                s[i] = 1,
                0 === a[i] && (t.enableVertexAttribArray(i),
                a[i] = 1),
                o[i] !== r && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r),
                o[i] = r)
            }
            function g() {
                const e = l.newAttributes
                  , i = l.enabledAttributes;
                for (let n = 0, r = i.length; n < r; n++)
                    i[n] !== e[n] && (t.disableVertexAttribArray(n),
                    i[n] = 0)
            }
            function v(e, i, r, s, a, o) {
                !0 !== n.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, i, r, s, a, o) : t.vertexAttribIPointer(e, i, r, a, o)
            }
            function y() {
                x(),
                l !== h && (l = h,
                c(l.object))
            }
            function x() {
                h.geometry = null,
                h.program = null,
                h.wireframe = !1
            }
            return {
                setup: function(r, h, u, y, x) {
                    let _ = !1;
                    if (a) {
                        const e = function(e, i, r) {
                            const a = !0 === r.wireframe;
                            let h = o[e.id];
                            void 0 === h && (h = {},
                            o[e.id] = h);
                            let l = h[i.id];
                            void 0 === l && (l = {},
                            h[i.id] = l);
                            let c = l[a];
                            return void 0 === c && (c = d(n.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()),
                            l[a] = c),
                            c
                        }(y, u, h);
                        l !== e && (l = e,
                        c(l.object)),
                        _ = function(t, e) {
                            const i = l.attributes
                              , n = t.attributes;
                            let r = 0;
                            for (const t in n) {
                                const e = i[t]
                                  , s = n[t];
                                if (void 0 === e)
                                    return !0;
                                if (e.attribute !== s)
                                    return !0;
                                if (e.data !== s.data)
                                    return !0;
                                r++
                            }
                            return l.attributesNum !== r || l.index !== e
                        }(y, x),
                        _ && function(t, e) {
                            const i = {}
                              , n = t.attributes;
                            let r = 0;
                            for (const t in n) {
                                const e = n[t]
                                  , s = {};
                                s.attribute = e,
                                e.data && (s.data = e.data),
                                i[t] = s,
                                r++
                            }
                            l.attributes = i,
                            l.attributesNum = r,
                            l.index = e
                        }(y, x)
                    } else {
                        const t = !0 === h.wireframe;
                        l.geometry === y.id && l.program === u.id && l.wireframe === t || (l.geometry = y.id,
                        l.program = u.id,
                        l.wireframe = t,
                        _ = !0)
                    }
                    !0 === r.isInstancedMesh && (_ = !0),
                    null !== x && i.update(x, 34963),
                    _ && (function(r, s, a, o) {
                        if (!1 === n.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays"))
                            return;
                        p();
                        const h = o.attributes
                          , l = a.getAttributes()
                          , c = s.defaultAttributeValues;
                        for (const e in l) {
                            const n = l[e];
                            if (n >= 0) {
                                const s = h[e];
                                if (void 0 !== s) {
                                    const e = s.normalized
                                      , r = s.itemSize
                                      , a = i.get(s);
                                    if (void 0 === a)
                                        continue;
                                    const h = a.buffer
                                      , l = a.type
                                      , c = a.bytesPerElement;
                                    if (s.isInterleavedBufferAttribute) {
                                        const i = s.data
                                          , a = i.stride
                                          , u = s.offset;
                                        i && i.isInstancedInterleavedBuffer ? (m(n, i.meshPerAttribute),
                                        void 0 === o._maxInstanceCount && (o._maxInstanceCount = i.meshPerAttribute * i.count)) : f(n),
                                        t.bindBuffer(34962, h),
                                        v(n, r, l, e, a * c, u * c)
                                    } else
                                        s.isInstancedBufferAttribute ? (m(n, s.meshPerAttribute),
                                        void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)) : f(n),
                                        t.bindBuffer(34962, h),
                                        v(n, r, l, e, 0, 0)
                                } else if ("instanceMatrix" === e) {
                                    const e = i.get(r.instanceMatrix);
                                    if (void 0 === e)
                                        continue;
                                    const s = e.buffer
                                      , a = e.type;
                                    m(n + 0, 1),
                                    m(n + 1, 1),
                                    m(n + 2, 1),
                                    m(n + 3, 1),
                                    t.bindBuffer(34962, s),
                                    t.vertexAttribPointer(n + 0, 4, a, !1, 64, 0),
                                    t.vertexAttribPointer(n + 1, 4, a, !1, 64, 16),
                                    t.vertexAttribPointer(n + 2, 4, a, !1, 64, 32),
                                    t.vertexAttribPointer(n + 3, 4, a, !1, 64, 48)
                                } else if ("instanceColor" === e) {
                                    const e = i.get(r.instanceColor);
                                    if (void 0 === e)
                                        continue;
                                    const s = e.buffer
                                      , a = e.type;
                                    m(n, 1),
                                    t.bindBuffer(34962, s),
                                    t.vertexAttribPointer(n, 3, a, !1, 12, 0)
                                } else if (void 0 !== c) {
                                    const i = c[e];
                                    if (void 0 !== i)
                                        switch (i.length) {
                                        case 2:
                                            t.vertexAttrib2fv(n, i);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(n, i);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(n, i);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(n, i)
                                        }
                                }
                            }
                        }
                        g()
                    }(r, h, u, y),
                    null !== x && t.bindBuffer(34963, i.get(x).buffer))
                },
                reset: y,
                resetDefaultState: x,
                dispose: function() {
                    y();
                    for (const t in o) {
                        const e = o[t];
                        for (const t in e) {
                            const i = e[t];
                            for (const t in i)
                                u(i[t].object),
                                delete i[t];
                            delete e[t]
                        }
                        delete o[t]
                    }
                },
                releaseStatesOfGeometry: function(t) {
                    if (void 0 === o[t.id])
                        return;
                    const e = o[t.id];
                    for (const t in e) {
                        const i = e[t];
                        for (const t in i)
                            u(i[t].object),
                            delete i[t];
                        delete e[t]
                    }
                    delete o[t.id]
                },
                releaseStatesOfProgram: function(t) {
                    for (const e in o) {
                        const i = o[e];
                        if (void 0 === i[t.id])
                            continue;
                        const n = i[t.id];
                        for (const t in n)
                            u(n[t].object),
                            delete n[t];
                        delete i[t.id]
                    }
                },
                initAttributes: p,
                enableAttribute: f,
                disableUnusedAttributes: g
            }
        }
        function ac(t, e, i, n) {
            const r = n.isWebGL2;
            let s;
            this.setMode = function(t) {
                s = t
            }
            ,
            this.render = function(e, n) {
                t.drawArrays(s, e, n),
                i.update(n, s, 1)
            }
            ,
            this.renderInstances = function(n, a, o) {
                if (0 === o)
                    return;
                let h, l;
                if (r)
                    h = t,
                    l = "drawArraysInstanced";
                else if (h = e.get("ANGLE_instanced_arrays"),
                l = "drawArraysInstancedANGLE",
                null === h)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                h[l](s, n, a, o),
                i.update(a, s, o)
            }
        }
        function oc(t, e, i) {
            let n;
            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
                        return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
            let a = void 0 !== i.precision ? i.precision : "highp";
            const o = r(a);
            o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
            a = o);
            const h = !0 === i.logarithmicDepthBuffer
              , l = t.getParameter(34930)
              , c = t.getParameter(35660)
              , u = t.getParameter(3379)
              , d = t.getParameter(34076)
              , p = t.getParameter(34921)
              , f = t.getParameter(36347)
              , m = t.getParameter(36348)
              , g = t.getParameter(36349)
              , v = c > 0
              , y = s || e.has("OES_texture_float");
            return {
                isWebGL2: s,
                getMaxAnisotropy: function() {
                    if (void 0 !== n)
                        return n;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const i = e.get("EXT_texture_filter_anisotropic");
                        n = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        n = 0;
                    return n
                },
                getMaxPrecision: r,
                precision: a,
                logarithmicDepthBuffer: h,
                maxTextures: l,
                maxVertexTextures: c,
                maxTextureSize: u,
                maxCubemapSize: d,
                maxAttributes: p,
                maxVertexUniforms: f,
                maxVaryings: m,
                maxFragmentUniforms: g,
                vertexTextures: v,
                floatFragmentTextures: y,
                floatVertexTextures: v && y,
                maxSamples: s ? t.getParameter(36183) : 0
            }
        }
        function hc(t) {
            const e = this;
            let i = null
              , n = 0
              , r = !1
              , s = !1;
            const a = new Sh
              , o = new fo
              , h = {
                value: null,
                needsUpdate: !1
            };
            function l() {
                h.value !== i && (h.value = i,
                h.needsUpdate = n > 0),
                e.numPlanes = n,
                e.numIntersection = 0
            }
            function c(t, i, n, r) {
                const s = null !== t ? t.length : 0;
                let l = null;
                if (0 !== s) {
                    if (l = h.value,
                    !0 !== r || null === l) {
                        const e = n + 4 * s
                          , r = i.matrixWorldInverse;
                        o.getNormalMatrix(r),
                        (null === l || l.length < e) && (l = new Float32Array(e));
                        for (let e = 0, i = n; e !== s; ++e,
                        i += 4)
                            a.copy(t[e]).applyMatrix4(r, o),
                            a.normal.toArray(l, i),
                            l[i + 3] = a.constant
                    }
                    h.value = l,
                    h.needsUpdate = !0
                }
                return e.numPlanes = s,
                e.numIntersection = 0,
                l
            }
            this.uniform = h,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(t, e, s) {
                const a = 0 !== t.length || e || 0 !== n || r;
                return r = e,
                i = c(t, s, 0),
                n = t.length,
                a
            }
            ,
            this.beginShadows = function() {
                s = !0,
                c(null)
            }
            ,
            this.endShadows = function() {
                s = !1,
                l()
            }
            ,
            this.setState = function(e, a, o) {
                const u = e.clippingPlanes
                  , d = e.clipIntersection
                  , p = e.clipShadows
                  , f = t.get(e);
                if (!r || null === u || 0 === u.length || s && !p)
                    s ? c(null) : l();
                else {
                    const t = s ? 0 : n
                      , e = 4 * t;
                    let r = f.clippingState || null;
                    h.value = r,
                    r = c(u, a, e, o);
                    for (let t = 0; t !== e; ++t)
                        r[t] = i[t];
                    f.clippingState = r,
                    this.numIntersection = d ? this.numPlanes : 0,
                    this.numPlanes += t
                }
            }
        }
        function lc(t) {
            let e = new WeakMap;
            function i(t, e) {
                return e === gs ? t.mapping = fs : e === vs && (t.mapping = ms),
                t
            }
            function n(t) {
                const i = t.target;
                i.removeEventListener("dispose", n);
                const r = e.get(i);
                void 0 !== r && (e.delete(i),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const s = r.mapping;
                        if (s === gs || s === vs) {
                            if (e.has(r))
                                return i(e.get(r).texture, r.mapping);
                            {
                                const s = r.image;
                                if (s && s.height > 0) {
                                    const a = t.getRenderTarget()
                                      , o = new Xl(s.height / 2);
                                    return o.fromEquirectangularTexture(t, r),
                                    e.set(r, o),
                                    t.setRenderTarget(a),
                                    r.addEventListener("dispose", n),
                                    i(o.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function cc(t) {
            const e = {};
            function i(i) {
                if (void 0 !== e[i])
                    return e[i];
                let n;
                switch (i) {
                case "WEBGL_depth_texture":
                    n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    n = t.getExtension(i)
                }
                return e[i] = n,
                n
            }
            return {
                has: function(t) {
                    return null !== i(t)
                },
                init: function(t) {
                    t.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"),
                    i("OES_texture_float"),
                    i("OES_texture_half_float"),
                    i("OES_texture_half_float_linear"),
                    i("OES_standard_derivatives"),
                    i("OES_element_index_uint"),
                    i("OES_vertex_array_object"),
                    i("ANGLE_instanced_arrays")),
                    i("OES_texture_float_linear"),
                    i("EXT_color_buffer_half_float")
                },
                get: function(t) {
                    const e = i(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                    e
                }
            }
        }
        function uc(t, e, i, n) {
            const r = {}
              , s = new WeakMap;
            function a(t) {
                const o = t.target;
                null !== o.index && e.remove(o.index);
                for (const t in o.attributes)
                    e.remove(o.attributes[t]);
                o.removeEventListener("dispose", a),
                delete r[o.id];
                const h = s.get(o);
                h && (e.remove(h),
                s.delete(o)),
                n.releaseStatesOfGeometry(o),
                !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
                i.memory.geometries--
            }
            function o(t) {
                const i = []
                  , n = t.index
                  , r = t.attributes.position;
                let a = 0;
                if (null !== n) {
                    const t = n.array;
                    a = n.version;
                    for (let e = 0, n = t.length; e < n; e += 3) {
                        const n = t[e + 0]
                          , r = t[e + 1]
                          , s = t[e + 2];
                        i.push(n, r, r, s, s, n)
                    }
                } else {
                    const t = r.array;
                    a = r.version;
                    for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
                        const t = e + 0
                          , n = e + 1
                          , r = e + 2;
                        i.push(t, n, n, r, r, t)
                    }
                }
                const o = new (ol(i) > 65535 ? nl : el)(i,1);
                o.version = a;
                const h = s.get(t);
                h && e.remove(h),
                s.set(t, o)
            }
            return {
                get: function(t, e) {
                    return !0 === r[e.id] || (e.addEventListener("dispose", a),
                    r[e.id] = !0,
                    i.memory.geometries++),
                    e
                },
                update: function(t) {
                    const i = t.attributes;
                    for (const t in i)
                        e.update(i[t], 34962);
                    const n = t.morphAttributes;
                    for (const t in n) {
                        const i = n[t];
                        for (let t = 0, n = i.length; t < n; t++)
                            e.update(i[t], 34962)
                    }
                },
                getWireframeAttribute: function(t) {
                    const e = s.get(t);
                    if (e) {
                        const i = t.index;
                        null !== i && e.version < i.version && o(t)
                    } else
                        o(t);
                    return s.get(t)
                }
            }
        }
        function dc(t, e, i, n) {
            const r = n.isWebGL2;
            let s, a, o;
            this.setMode = function(t) {
                s = t
            }
            ,
            this.setIndex = function(t) {
                a = t.type,
                o = t.bytesPerElement
            }
            ,
            this.render = function(e, n) {
                t.drawElements(s, n, a, e * o),
                i.update(n, s, 1)
            }
            ,
            this.renderInstances = function(n, h, l) {
                if (0 === l)
                    return;
                let c, u;
                if (r)
                    c = t,
                    u = "drawElementsInstanced";
                else if (c = e.get("ANGLE_instanced_arrays"),
                u = "drawElementsInstancedANGLE",
                null === c)
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                c[u](s, h, a, n * o, l),
                i.update(h, s, l)
            }
        }
        function pc(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.frame++,
                    e.calls = 0,
                    e.triangles = 0,
                    e.points = 0,
                    e.lines = 0
                },
                update: function(t, i, n) {
                    switch (e.calls++,
                    i) {
                    case 4:
                        e.triangles += n * (t / 3);
                        break;
                    case 1:
                        e.lines += n * (t / 2);
                        break;
                    case 3:
                        e.lines += n * (t - 1);
                        break;
                    case 2:
                        e.lines += n * t;
                        break;
                    case 0:
                        e.points += n * t;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                    }
                }
            }
        }
        function fc(t, e) {
            return t[0] - e[0]
        }
        function mc(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }
        function gc(t) {
            const e = {}
              , i = new Float32Array(8)
              , n = [];
            for (let t = 0; t < 8; t++)
                n[t] = [t, 0];
            return {
                update: function(r, s, a, o) {
                    const h = r.morphTargetInfluences
                      , l = void 0 === h ? 0 : h.length;
                    let c = e[s.id];
                    if (void 0 === c) {
                        c = [];
                        for (let t = 0; t < l; t++)
                            c[t] = [t, 0];
                        e[s.id] = c
                    }
                    for (let t = 0; t < l; t++) {
                        const e = c[t];
                        e[0] = t,
                        e[1] = h[t]
                    }
                    c.sort(mc);
                    for (let t = 0; t < 8; t++)
                        t < l && c[t][1] ? (n[t][0] = c[t][0],
                        n[t][1] = c[t][1]) : (n[t][0] = Number.MAX_SAFE_INTEGER,
                        n[t][1] = 0);
                    n.sort(fc);
                    const u = a.morphTargets && s.morphAttributes.position
                      , d = a.morphNormals && s.morphAttributes.normal;
                    let p = 0;
                    for (let t = 0; t < 8; t++) {
                        const e = n[t]
                          , r = e[0]
                          , a = e[1];
                        r !== Number.MAX_SAFE_INTEGER && a ? (u && s.getAttribute("morphTarget" + t) !== u[r] && s.setAttribute("morphTarget" + t, u[r]),
                        d && s.getAttribute("morphNormal" + t) !== d[r] && s.setAttribute("morphNormal" + t, d[r]),
                        i[t] = a,
                        p += a) : (u && !0 === s.hasAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t),
                        d && !0 === s.hasAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t),
                        i[t] = 0)
                    }
                    const f = s.morphTargetsRelative ? 1 : 1 - p;
                    o.getUniforms().setValue(t, "morphTargetBaseInfluence", f),
                    o.getUniforms().setValue(t, "morphTargetInfluences", i)
                }
            }
        }
        function vc(t, e, i, n) {
            let r = new WeakMap;
            function s(t) {
                const e = t.target;
                e.removeEventListener("dispose", s),
                i.remove(e.instanceMatrix),
                null !== e.instanceColor && i.remove(e.instanceColor)
            }
            return {
                update: function(t) {
                    const a = n.render.frame
                      , o = t.geometry
                      , h = e.get(t, o);
                    return r.get(h) !== a && (e.update(h),
                    r.set(h, a)),
                    t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s),
                    i.update(t.instanceMatrix, 34962),
                    null !== t.instanceColor && i.update(t.instanceColor, 34962)),
                    h
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        nc.physical = {
            uniforms: Bl([nc.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new po(1,1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new qh(0)
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                }
            }]),
            vertexShader: ec.meshphysical_vert,
            fragmentShader: ec.meshphysical_frag
        };
        class yc extends yo {
            constructor(t=null, e=1, i=1, n=1) {
                super(null),
                this.image = {
                    data: t,
                    width: e,
                    height: i,
                    depth: n
                },
                this.magFilter = Ms,
                this.minFilter = Ms,
                this.wrapR = bs,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.needsUpdate = !0
            }
        }
        yc.prototype.isDataTexture2DArray = !0;
        class xc extends yo {
            constructor(t=null, e=1, i=1, n=1) {
                super(null),
                this.image = {
                    data: t,
                    width: e,
                    height: i,
                    depth: n
                },
                this.magFilter = Ms,
                this.minFilter = Ms,
                this.wrapR = bs,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.needsUpdate = !0
            }
        }
        xc.prototype.isDataTexture3D = !0;
        const _c = new yo
          , bc = new yc
          , wc = new xc
          , Mc = new ql
          , Tc = []
          , Ec = []
          , Sc = new Float32Array(16)
          , Ac = new Float32Array(9)
          , Lc = new Float32Array(4);
        function Pc(t, e, i) {
            const n = t[0];
            if (n <= 0 || n > 0)
                return t;
            const r = e * i;
            let s = Tc[r];
            if (void 0 === s && (s = new Float32Array(r),
            Tc[r] = s),
            0 !== e) {
                n.toArray(s, 0);
                for (let n = 1, r = 0; n !== e; ++n)
                    r += i,
                    t[n].toArray(s, r)
            }
            return s
        }
        function Cc(t, e) {
            if (t.length !== e.length)
                return !1;
            for (let i = 0, n = t.length; i < n; i++)
                if (t[i] !== e[i])
                    return !1;
            return !0
        }
        function Rc(t, e) {
            for (let i = 0, n = e.length; i < n; i++)
                t[i] = e[i]
        }
        function Oc(t, e) {
            let i = Ec[e];
            void 0 === i && (i = new Int32Array(e),
            Ec[e] = i);
            for (let n = 0; n !== e; ++n)
                i[n] = t.allocateTextureUnit();
            return i
        }
        function Dc(t, e) {
            const i = this.cache;
            i[0] !== e && (t.uniform1f(this.addr, e),
            i[0] = e)
        }
        function Ic(t, e) {
            const i = this.cache;
            if (void 0 !== e.x)
                i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
                i[0] = e.x,
                i[1] = e.y);
            else {
                if (Cc(i, e))
                    return;
                t.uniform2fv(this.addr, e),
                Rc(i, e)
            }
        }
        function Nc(t, e) {
            const i = this.cache;
            if (void 0 !== e.x)
                i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
                i[0] = e.x,
                i[1] = e.y,
                i[2] = e.z);
            else if (void 0 !== e.r)
                i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
                i[0] = e.r,
                i[1] = e.g,
                i[2] = e.b);
            else {
                if (Cc(i, e))
                    return;
                t.uniform3fv(this.addr, e),
                Rc(i, e)
            }
        }
        function zc(t, e) {
            const i = this.cache;
            if (void 0 !== e.x)
                i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                i[0] = e.x,
                i[1] = e.y,
                i[2] = e.z,
                i[3] = e.w);
            else {
                if (Cc(i, e))
                    return;
                t.uniform4fv(this.addr, e),
                Rc(i, e)
            }
        }
        function Bc(t, e) {
            const i = this.cache
              , n = e.elements;
            if (void 0 === n) {
                if (Cc(i, e))
                    return;
                t.uniformMatrix2fv(this.addr, !1, e),
                Rc(i, e)
            } else {
                if (Cc(i, n))
                    return;
                Lc.set(n),
                t.uniformMatrix2fv(this.addr, !1, Lc),
                Rc(i, n)
            }
        }
        function kc(t, e) {
            const i = this.cache
              , n = e.elements;
            if (void 0 === n) {
                if (Cc(i, e))
                    return;
                t.uniformMatrix3fv(this.addr, !1, e),
                Rc(i, e)
            } else {
                if (Cc(i, n))
                    return;
                Ac.set(n),
                t.uniformMatrix3fv(this.addr, !1, Ac),
                Rc(i, n)
            }
        }
        function Fc(t, e) {
            const i = this.cache
              , n = e.elements;
            if (void 0 === n) {
                if (Cc(i, e))
                    return;
                t.uniformMatrix4fv(this.addr, !1, e),
                Rc(i, e)
            } else {
                if (Cc(i, n))
                    return;
                Sc.set(n),
                t.uniformMatrix4fv(this.addr, !1, Sc),
                Rc(i, n)
            }
        }
        function Uc(t, e, i) {
            const n = this.cache
              , r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r),
            n[0] = r),
            i.safeSetTexture2D(e || _c, r)
        }
        function Hc(t, e, i) {
            const n = this.cache
              , r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r),
            n[0] = r),
            i.setTexture2DArray(e || bc, r)
        }
        function jc(t, e, i) {
            const n = this.cache
              , r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r),
            n[0] = r),
            i.setTexture3D(e || wc, r)
        }
        function Gc(t, e, i) {
            const n = this.cache
              , r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r),
            n[0] = r),
            i.safeSetTextureCube(e || Mc, r)
        }
        function Wc(t, e) {
            const i = this.cache;
            i[0] !== e && (t.uniform1i(this.addr, e),
            i[0] = e)
        }
        function Vc(t, e) {
            const i = this.cache;
            Cc(i, e) || (t.uniform2iv(this.addr, e),
            Rc(i, e))
        }
        function qc(t, e) {
            const i = this.cache;
            Cc(i, e) || (t.uniform3iv(this.addr, e),
            Rc(i, e))
        }
        function Xc(t, e) {
            const i = this.cache;
            Cc(i, e) || (t.uniform4iv(this.addr, e),
            Rc(i, e))
        }
        function Yc(t, e) {
            const i = this.cache;
            i[0] !== e && (t.uniform1ui(this.addr, e),
            i[0] = e)
        }
        function Zc(t, e) {
            t.uniform1fv(this.addr, e)
        }
        function Jc(t, e) {
            t.uniform1iv(this.addr, e)
        }
        function $c(t, e) {
            t.uniform2iv(this.addr, e)
        }
        function Qc(t, e) {
            t.uniform3iv(this.addr, e)
        }
        function Kc(t, e) {
            t.uniform4iv(this.addr, e)
        }
        function tu(t, e) {
            const i = Pc(e, this.size, 2);
            t.uniform2fv(this.addr, i)
        }
        function eu(t, e) {
            const i = Pc(e, this.size, 3);
            t.uniform3fv(this.addr, i)
        }
        function iu(t, e) {
            const i = Pc(e, this.size, 4);
            t.uniform4fv(this.addr, i)
        }
        function nu(t, e) {
            const i = Pc(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, i)
        }
        function ru(t, e) {
            const i = Pc(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, i)
        }
        function su(t, e) {
            const i = Pc(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, i)
        }
        function au(t, e, i) {
            const n = e.length
              , r = Oc(i, n);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== n; ++t)
                i.safeSetTexture2D(e[t] || _c, r[t])
        }
        function ou(t, e, i) {
            const n = e.length
              , r = Oc(i, n);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== n; ++t)
                i.safeSetTextureCube(e[t] || Mc, r[t])
        }
        function hu(t, e, i) {
            this.id = t,
            this.addr = i,
            this.cache = [],
            this.setValue = function(t) {
                switch (t) {
                case 5126:
                    return Dc;
                case 35664:
                    return Ic;
                case 35665:
                    return Nc;
                case 35666:
                    return zc;
                case 35674:
                    return Bc;
                case 35675:
                    return kc;
                case 35676:
                    return Fc;
                case 5124:
                case 35670:
                    return Wc;
                case 35667:
                case 35671:
                    return Vc;
                case 35668:
                case 35672:
                    return qc;
                case 35669:
                case 35673:
                    return Xc;
                case 5125:
                    return Yc;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Uc;
                case 35679:
                case 36299:
                case 36307:
                    return jc;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Gc;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return Hc
                }
            }(e.type)
        }
        function lu(t, e, i) {
            this.id = t,
            this.addr = i,
            this.cache = [],
            this.size = e.size,
            this.setValue = function(t) {
                switch (t) {
                case 5126:
                    return Zc;
                case 35664:
                    return tu;
                case 35665:
                    return eu;
                case 35666:
                    return iu;
                case 35674:
                    return nu;
                case 35675:
                    return ru;
                case 35676:
                    return su;
                case 5124:
                case 35670:
                    return Jc;
                case 35667:
                case 35671:
                    return $c;
                case 35668:
                case 35672:
                    return Qc;
                case 35669:
                case 35673:
                    return Kc;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return au;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return ou
                }
            }(e.type)
        }
        function cu(t) {
            this.id = t,
            this.seq = [],
            this.map = {}
        }
        lu.prototype.updateCache = function(t) {
            const e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
            Rc(e, t)
        }
        ,
        cu.prototype.setValue = function(t, e, i) {
            const n = this.seq;
            for (let r = 0, s = n.length; r !== s; ++r) {
                const s = n[r];
                s.setValue(t, e[s.id], i)
            }
        }
        ;
        const uu = /(\w+)(\])?(\[|\.)?/g;
        function du(t, e) {
            t.seq.push(e),
            t.map[e.id] = e
        }
        function pu(t, e, i) {
            const n = t.name
              , r = n.length;
            for (uu.lastIndex = 0; ; ) {
                const s = uu.exec(n)
                  , a = uu.lastIndex;
                let o = s[1];
                const h = "]" === s[2]
                  , l = s[3];
                if (h && (o |= 0),
                void 0 === l || "[" === l && a + 2 === r) {
                    du(i, void 0 === l ? new hu(o,t,e) : new lu(o,t,e));
                    break
                }
                {
                    let t = i.map[o];
                    void 0 === t && (t = new cu(o),
                    du(i, t)),
                    i = t
                }
            }
        }
        function fu(t, e) {
            this.seq = [],
            this.map = {};
            const i = t.getProgramParameter(e, 35718);
            for (let n = 0; n < i; ++n) {
                const i = t.getActiveUniform(e, n);
                pu(i, t.getUniformLocation(e, i.name), this)
            }
        }
        function mu(t, e, i) {
            const n = t.createShader(e);
            return t.shaderSource(n, i),
            t.compileShader(n),
            n
        }
        fu.prototype.setValue = function(t, e, i, n) {
            const r = this.map[e];
            void 0 !== r && r.setValue(t, i, n)
        }
        ,
        fu.prototype.setOptional = function(t, e, i) {
            const n = e[i];
            void 0 !== n && this.setValue(t, i, n)
        }
        ,
        fu.upload = function(t, e, i, n) {
            for (let r = 0, s = e.length; r !== s; ++r) {
                const s = e[r]
                  , a = i[s.id];
                !1 !== a.needsUpdate && s.setValue(t, a.value, n)
            }
        }
        ,
        fu.seqWithValue = function(t, e) {
            const i = [];
            for (let n = 0, r = t.length; n !== r; ++n) {
                const r = t[n];
                r.id in e && i.push(r)
            }
            return i
        }
        ;
        let gu = 0;
        function vu(t) {
            switch (t) {
            case qa:
                return ["Linear", "( value )"];
            case Xa:
                return ["sRGB", "( value )"];
            case Za:
                return ["RGBE", "( value )"];
            case $a:
                return ["RGBM", "( value, 7.0 )"];
            case Qa:
                return ["RGBM", "( value, 16.0 )"];
            case Ka:
                return ["RGBD", "( value, 256.0 )"];
            case Ya:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case Ja:
                return ["LogLuv", "( value )"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
                ["Linear", "( value )"]
            }
        }
        function yu(t, e, i) {
            const n = t.getShaderParameter(e, 35713)
              , r = t.getShaderInfoLog(e).trim();
            return n && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + i + "\n" + r + function(t) {
                const e = t.split("\n");
                for (let t = 0; t < e.length; t++)
                    e[t] = t + 1 + ": " + e[t];
                return e.join("\n")
            }(t.getShaderSource(e))
        }
        function xu(t, e) {
            const i = vu(e);
            return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
        }
        function _u(t, e) {
            const i = vu(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
        }
        function bu(t, e) {
            let i;
            switch (e) {
            case ls:
                i = "Linear";
                break;
            case cs:
                i = "Reinhard";
                break;
            case us:
                i = "OptimizedCineon";
                break;
            case ds:
                i = "ACESFilmic";
                break;
            case ps:
                i = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                i = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
        }
        function wu(t) {
            return "" !== t
        }
        function Mu(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }
        function Tu(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const Eu = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function Su(t) {
            return t.replace(Eu, Au)
        }
        function Au(t, e) {
            const i = ec[e];
            if (void 0 === i)
                throw new Error("Can not resolve #include <" + e + ">");
            return Su(i)
        }
        const Lu = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
          , Pu = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function Cu(t) {
            return t.replace(Pu, Ou).replace(Lu, Ru)
        }
        function Ru(t, e, i, n) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
            Ou(0, e, i, n)
        }
        function Ou(t, e, i, n) {
            let r = "";
            for (let t = parseInt(e); t < parseInt(i); t++)
                r += n.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return r
        }
        function Du(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
        }
        function Iu(t, e, i, n) {
            const r = t.getContext()
              , s = i.defines;
            let a = i.vertexShader
              , o = i.fragmentShader;
            const h = function(t) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return t.shadowMapType === Mr ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === Tr ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === Er && (e = "SHADOWMAP_TYPE_VSM"),
                e
            }(i)
              , l = function(t) {
                let e = "ENVMAP_TYPE_CUBE";
                if (t.envMap)
                    switch (t.envMapMode) {
                    case fs:
                    case ms:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case ys:
                    case xs:
                        e = "ENVMAP_TYPE_CUBE_UV"
                    }
                return e
            }(i)
              , c = function(t) {
                let e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap)
                    switch (t.envMapMode) {
                    case ms:
                    case xs:
                        e = "ENVMAP_MODE_REFRACTION"
                    }
                return e
            }(i)
              , u = function(t) {
                let e = "ENVMAP_BLENDING_NONE";
                if (t.envMap)
                    switch (t.combine) {
                    case ss:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case as:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case os:
                        e = "ENVMAP_BLENDING_ADD"
                    }
                return e
            }(i)
              , d = t.gammaFactor > 0 ? t.gammaFactor : 1
              , p = i.isWebGL2 ? "" : function(t) {
                return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(wu).join("\n")
            }(i)
              , f = function(t) {
                const e = [];
                for (const i in t) {
                    const n = t[i];
                    !1 !== n && e.push("#define " + i + " " + n)
                }
                return e.join("\n")
            }(s)
              , m = r.createProgram();
            let g, v, y = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
            i.isRawShaderMaterial ? (g = [f].filter(wu).join("\n"),
            g.length > 0 && (g += "\n"),
            v = [p, f].filter(wu).join("\n"),
            v.length > 0 && (v += "\n")) : (g = [Du(i), "#define SHADER_NAME " + i.shaderName, f, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + c : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + h : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(wu).join("\n"),
            v = [p, Du(i), "#define SHADER_NAME " + i.shaderName, f, i.alphaTest ? "#define ALPHATEST " + i.alphaTest + (i.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + l : "", i.envMap ? "#define " + c : "", i.envMap ? "#define " + u : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.sheen ? "#define USE_SHEEN" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + h : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== hs ? "#define TONE_MAPPING" : "", i.toneMapping !== hs ? ec.tonemapping_pars_fragment : "", i.toneMapping !== hs ? bu("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", ec.encodings_pars_fragment, i.map ? xu("mapTexelToLinear", i.mapEncoding) : "", i.matcap ? xu("matcapTexelToLinear", i.matcapEncoding) : "", i.envMap ? xu("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMap ? xu("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.lightMap ? xu("lightMapTexelToLinear", i.lightMapEncoding) : "", _u("linearToOutputTexel", i.outputEncoding), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(wu).join("\n")),
            a = Su(a),
            a = Mu(a, i),
            a = Tu(a, i),
            o = Su(o),
            o = Mu(o, i),
            o = Tu(o, i),
            a = Cu(a),
            o = Cu(o),
            i.isWebGL2 && !0 !== i.isRawShaderMaterial && (y = "#version 300 es\n",
            g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
            v = ["#define varying in", i.glslVersion === oo ? "" : "out highp vec4 pc_fragColor;", i.glslVersion === oo ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
            const x = y + v + o
              , _ = mu(r, 35633, y + g + a)
              , b = mu(r, 35632, x);
            if (r.attachShader(m, _),
            r.attachShader(m, b),
            void 0 !== i.index0AttributeName ? r.bindAttribLocation(m, 0, i.index0AttributeName) : !0 === i.morphTargets && r.bindAttribLocation(m, 0, "position"),
            r.linkProgram(m),
            t.debug.checkShaderErrors) {
                const t = r.getProgramInfoLog(m).trim()
                  , e = r.getShaderInfoLog(_).trim()
                  , i = r.getShaderInfoLog(b).trim();
                let n = !0
                  , s = !0;
                if (!1 === r.getProgramParameter(m, 35714)) {
                    n = !1;
                    const e = yu(r, _, "vertex")
                      , i = yu(r, b, "fragment");
                    console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, i)
                } else
                    "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== i || (s = !1);
                s && (this.diagnostics = {
                    runnable: n,
                    programLog: t,
                    vertexShader: {
                        log: e,
                        prefix: g
                    },
                    fragmentShader: {
                        log: i,
                        prefix: v
                    }
                })
            }
            let w, M;
            return r.deleteShader(_),
            r.deleteShader(b),
            this.getUniforms = function() {
                return void 0 === w && (w = new fu(r,m)),
                w
            }
            ,
            this.getAttributes = function() {
                return void 0 === M && (M = function(t, e) {
                    const i = {}
                      , n = t.getProgramParameter(e, 35721);
                    for (let r = 0; r < n; r++) {
                        const n = t.getActiveAttrib(e, r).name;
                        i[n] = t.getAttribLocation(e, n)
                    }
                    return i
                }(r, m)),
                M
            }
            ,
            this.destroy = function() {
                n.releaseStatesOfProgram(this),
                r.deleteProgram(m),
                this.program = void 0
            }
            ,
            this.name = i.shaderName,
            this.id = gu++,
            this.cacheKey = e,
            this.usedTimes = 1,
            this.program = m,
            this.vertexShader = _,
            this.fragmentShader = b,
            this
        }
        function Nu(t, e, i, n, r, s) {
            const a = []
              , o = n.isWebGL2
              , h = n.logarithmicDepthBuffer
              , l = n.floatVertexTextures
              , c = n.maxVertexUniforms
              , u = n.vertexTextures;
            let d = n.precision;
            const p = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            }
              , f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
            function m(t) {
                let e;
                return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
                e = t.texture.encoding) : e = qa,
                e
            }
            return {
                getParameters: function(r, a, f, g, v) {
                    const y = g.fog
                      , x = r.isMeshStandardMaterial ? g.environment : null
                      , _ = e.get(r.envMap || x)
                      , b = p[r.type]
                      , w = v.isSkinnedMesh ? function(t) {
                        const e = t.skeleton.bones;
                        if (l)
                            return 1024;
                        {
                            const t = c
                              , i = Math.floor((t - 20) / 4)
                              , n = Math.min(i, e.length);
                            return n < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + n + "."),
                            0) : n
                        }
                    }(v) : 0;
                    let M, T;
                    if (null !== r.precision && (d = n.getMaxPrecision(r.precision),
                    d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")),
                    b) {
                        const t = nc[b];
                        M = t.vertexShader,
                        T = t.fragmentShader
                    } else
                        M = r.vertexShader,
                        T = r.fragmentShader;
                    const E = t.getRenderTarget();
                    return {
                        isWebGL2: o,
                        shaderID: b,
                        shaderName: r.type,
                        vertexShader: M,
                        fragmentShader: T,
                        defines: r.defines,
                        isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                        glslVersion: r.glslVersion,
                        precision: d,
                        instancing: !0 === v.isInstancedMesh,
                        instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                        supportsVertexTextures: u,
                        outputEncoding: null !== E ? m(E.texture) : t.outputEncoding,
                        map: !!r.map,
                        mapEncoding: m(r.map),
                        matcap: !!r.matcap,
                        matcapEncoding: m(r.matcap),
                        envMap: !!_,
                        envMapMode: _ && _.mapping,
                        envMapEncoding: m(_),
                        envMapCubeUV: !!_ && (_.mapping === ys || _.mapping === xs),
                        lightMap: !!r.lightMap,
                        lightMapEncoding: m(r.lightMap),
                        aoMap: !!r.aoMap,
                        emissiveMap: !!r.emissiveMap,
                        emissiveMapEncoding: m(r.emissiveMap),
                        bumpMap: !!r.bumpMap,
                        normalMap: !!r.normalMap,
                        objectSpaceNormalMap: r.normalMapType === io,
                        tangentSpaceNormalMap: r.normalMapType === eo,
                        clearcoatMap: !!r.clearcoatMap,
                        clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                        clearcoatNormalMap: !!r.clearcoatNormalMap,
                        displacementMap: !!r.displacementMap,
                        roughnessMap: !!r.roughnessMap,
                        metalnessMap: !!r.metalnessMap,
                        specularMap: !!r.specularMap,
                        alphaMap: !!r.alphaMap,
                        gradientMap: !!r.gradientMap,
                        sheen: !!r.sheen,
                        transmissionMap: !!r.transmissionMap,
                        combine: r.combine,
                        vertexTangents: r.normalMap && r.vertexTangents,
                        vertexColors: r.vertexColors,
                        vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap),
                        uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap || !r.displacementMap),
                        fog: !!y,
                        useFog: r.fog,
                        fogExp2: y && y.isFogExp2,
                        flatShading: !!r.flatShading,
                        sizeAttenuation: r.sizeAttenuation,
                        logarithmicDepthBuffer: h,
                        skinning: r.skinning && w > 0,
                        maxBones: w,
                        useVertexTexture: l,
                        morphTargets: r.morphTargets,
                        morphNormals: r.morphNormals,
                        maxMorphTargets: t.maxMorphTargets,
                        maxMorphNormals: t.maxMorphNormals,
                        numDirLights: a.directional.length,
                        numPointLights: a.point.length,
                        numSpotLights: a.spot.length,
                        numRectAreaLights: a.rectArea.length,
                        numHemiLights: a.hemi.length,
                        numDirLightShadows: a.directionalShadowMap.length,
                        numPointLightShadows: a.pointShadowMap.length,
                        numSpotLightShadows: a.spotShadowMap.length,
                        numClippingPlanes: s.numPlanes,
                        numClipIntersection: s.numIntersection,
                        dithering: r.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: r.toneMapped ? t.toneMapping : hs,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: r.premultipliedAlpha,
                        alphaTest: r.alphaTest,
                        doubleSided: r.side === Lr,
                        flipSided: r.side === Ar,
                        depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                        index0AttributeName: r.index0AttributeName,
                        extensionDerivatives: r.extensions && r.extensions.derivatives,
                        extensionFragDepth: r.extensions && r.extensions.fragDepth,
                        extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                        extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: o || i.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: o || i.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: o || i.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: r.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(e) {
                    const i = [];
                    if (e.shaderID ? i.push(e.shaderID) : (i.push(e.fragmentShader),
                    i.push(e.vertexShader)),
                    void 0 !== e.defines)
                        for (const t in e.defines)
                            i.push(t),
                            i.push(e.defines[t]);
                    if (!1 === e.isRawShaderMaterial) {
                        for (let t = 0; t < f.length; t++)
                            i.push(e[f[t]]);
                        i.push(t.outputEncoding),
                        i.push(t.gammaFactor)
                    }
                    return i.push(e.customProgramCacheKey),
                    i.join()
                },
                getUniforms: function(t) {
                    const e = p[t.type];
                    let i;
                    if (e) {
                        const t = nc[e];
                        i = kl.clone(t.uniforms)
                    } else
                        i = t.uniforms;
                    return i
                },
                acquireProgram: function(e, i) {
                    let n;
                    for (let t = 0, e = a.length; t < e; t++) {
                        const e = a[t];
                        if (e.cacheKey === i) {
                            n = e,
                            ++n.usedTimes;
                            break
                        }
                    }
                    return void 0 === n && (n = new Iu(t,i,e,r),
                    a.push(n)),
                    n
                },
                releaseProgram: function(t) {
                    if (0 == --t.usedTimes) {
                        const e = a.indexOf(t);
                        a[e] = a[a.length - 1],
                        a.pop(),
                        t.destroy()
                    }
                },
                programs: a
            }
        }
        function zu() {
            let t = new WeakMap;
            return {
                get: function(e) {
                    let i = t.get(e);
                    return void 0 === i && (i = {},
                    t.set(e, i)),
                    i
                },
                remove: function(e) {
                    t.delete(e)
                },
                update: function(e, i, n) {
                    t.get(e)[i] = n
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        function Bu(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }
        function ku(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }
        function Fu(t) {
            const e = [];
            let i = 0;
            const n = []
              , r = []
              , s = {
                id: -1
            };
            function a(n, r, a, o, h, l) {
                let c = e[i];
                const u = t.get(a);
                return void 0 === c ? (c = {
                    id: n.id,
                    object: n,
                    geometry: r,
                    material: a,
                    program: u.program || s,
                    groupOrder: o,
                    renderOrder: n.renderOrder,
                    z: h,
                    group: l
                },
                e[i] = c) : (c.id = n.id,
                c.object = n,
                c.geometry = r,
                c.material = a,
                c.program = u.program || s,
                c.groupOrder = o,
                c.renderOrder = n.renderOrder,
                c.z = h,
                c.group = l),
                i++,
                c
            }
            return {
                opaque: n,
                transparent: r,
                init: function() {
                    i = 0,
                    n.length = 0,
                    r.length = 0
                },
                push: function(t, e, i, s, o, h) {
                    const l = a(t, e, i, s, o, h);
                    (!0 === i.transparent ? r : n).push(l)
                },
                unshift: function(t, e, i, s, o, h) {
                    const l = a(t, e, i, s, o, h);
                    (!0 === i.transparent ? r : n).unshift(l)
                },
                finish: function() {
                    for (let t = i, n = e.length; t < n; t++) {
                        const i = e[t];
                        if (null === i.id)
                            break;
                        i.id = null,
                        i.object = null,
                        i.geometry = null,
                        i.material = null,
                        i.program = null,
                        i.group = null
                    }
                },
                sort: function(t, e) {
                    n.length > 1 && n.sort(t || Bu),
                    r.length > 1 && r.sort(e || ku)
                }
            }
        }
        function Uu(t) {
            let e = new WeakMap;
            return {
                get: function(i, n) {
                    let r;
                    return !1 === e.has(i) ? (r = new Fu(t),
                    e.set(i, [r])) : n >= e.get(i).length ? (r = new Fu(t),
                    e.get(i).push(r)) : r = e.get(i)[n],
                    r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function Hu() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let i;
                    switch (e.type) {
                    case "DirectionalLight":
                        i = {
                            direction: new Mo,
                            color: new qh
                        };
                        break;
                    case "SpotLight":
                        i = {
                            position: new Mo,
                            direction: new Mo,
                            color: new qh,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        i = {
                            position: new Mo,
                            color: new qh,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        i = {
                            direction: new Mo,
                            skyColor: new qh,
                            groundColor: new qh
                        };
                        break;
                    case "RectAreaLight":
                        i = {
                            color: new qh,
                            position: new Mo,
                            halfWidth: new Mo,
                            halfHeight: new Mo
                        }
                    }
                    return t[e.id] = i,
                    i
                }
            }
        }
        let ju = 0;
        function Gu(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }
        function Wu(t, e) {
            const i = new Hu
              , n = function() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id])
                            return t[e.id];
                        let i;
                        switch (e.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            i = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new po
                            };
                            break;
                        case "PointLight":
                            i = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new po,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return t[e.id] = i,
                        i
                    }
                }
            }()
              , r = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            };
            for (let t = 0; t < 9; t++)
                r.probe.push(new Mo);
            const s = new Mo
              , a = new $o
              , o = new $o;
            return {
                setup: function(s) {
                    let a = 0
                      , o = 0
                      , h = 0;
                    for (let t = 0; t < 9; t++)
                        r.probe[t].set(0, 0, 0);
                    let l = 0
                      , c = 0
                      , u = 0
                      , d = 0
                      , p = 0
                      , f = 0
                      , m = 0
                      , g = 0;
                    s.sort(Gu);
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t]
                          , v = e.color
                          , y = e.intensity
                          , x = e.distance
                          , _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight)
                            a += v.r * y,
                            o += v.g * y,
                            h += v.b * y;
                        else if (e.isLightProbe)
                            for (let t = 0; t < 9; t++)
                                r.probe[t].addScaledVector(e.sh.coefficients[t], y);
                        else if (e.isDirectionalLight) {
                            const t = i.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity),
                            e.castShadow) {
                                const t = e.shadow
                                  , i = n.get(e);
                                i.shadowBias = t.bias,
                                i.shadowNormalBias = t.normalBias,
                                i.shadowRadius = t.radius,
                                i.shadowMapSize = t.mapSize,
                                r.directionalShadow[l] = i,
                                r.directionalShadowMap[l] = _,
                                r.directionalShadowMatrix[l] = e.shadow.matrix,
                                f++
                            }
                            r.directional[l] = t,
                            l++
                        } else if (e.isSpotLight) {
                            const t = i.get(e);
                            if (t.position.setFromMatrixPosition(e.matrixWorld),
                            t.color.copy(v).multiplyScalar(y),
                            t.distance = x,
                            t.coneCos = Math.cos(e.angle),
                            t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
                            t.decay = e.decay,
                            e.castShadow) {
                                const t = e.shadow
                                  , i = n.get(e);
                                i.shadowBias = t.bias,
                                i.shadowNormalBias = t.normalBias,
                                i.shadowRadius = t.radius,
                                i.shadowMapSize = t.mapSize,
                                r.spotShadow[u] = i,
                                r.spotShadowMap[u] = _,
                                r.spotShadowMatrix[u] = e.shadow.matrix,
                                g++
                            }
                            r.spot[u] = t,
                            u++
                        } else if (e.isRectAreaLight) {
                            const t = i.get(e);
                            t.color.copy(v).multiplyScalar(y),
                            t.halfWidth.set(.5 * e.width, 0, 0),
                            t.halfHeight.set(0, .5 * e.height, 0),
                            r.rectArea[d] = t,
                            d++
                        } else if (e.isPointLight) {
                            const t = i.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity),
                            t.distance = e.distance,
                            t.decay = e.decay,
                            e.castShadow) {
                                const t = e.shadow
                                  , i = n.get(e);
                                i.shadowBias = t.bias,
                                i.shadowNormalBias = t.normalBias,
                                i.shadowRadius = t.radius,
                                i.shadowMapSize = t.mapSize,
                                i.shadowCameraNear = t.camera.near,
                                i.shadowCameraFar = t.camera.far,
                                r.pointShadow[c] = i,
                                r.pointShadowMap[c] = _,
                                r.pointShadowMatrix[c] = e.shadow.matrix,
                                m++
                            }
                            r.point[c] = t,
                            c++
                        } else if (e.isHemisphereLight) {
                            const t = i.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(y),
                            t.groundColor.copy(e.groundColor).multiplyScalar(y),
                            r.hemi[p] = t,
                            p++
                        }
                    }
                    d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = ic.LTC_FLOAT_1,
                    r.rectAreaLTC2 = ic.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = ic.LTC_HALF_1,
                    r.rectAreaLTC2 = ic.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                    r.ambient[0] = a,
                    r.ambient[1] = o,
                    r.ambient[2] = h;
                    const v = r.hash;
                    v.directionalLength === l && v.pointLength === c && v.spotLength === u && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (r.directional.length = l,
                    r.spot.length = u,
                    r.rectArea.length = d,
                    r.point.length = c,
                    r.hemi.length = p,
                    r.directionalShadow.length = f,
                    r.directionalShadowMap.length = f,
                    r.pointShadow.length = m,
                    r.pointShadowMap.length = m,
                    r.spotShadow.length = g,
                    r.spotShadowMap.length = g,
                    r.directionalShadowMatrix.length = f,
                    r.pointShadowMatrix.length = m,
                    r.spotShadowMatrix.length = g,
                    v.directionalLength = l,
                    v.pointLength = c,
                    v.spotLength = u,
                    v.rectAreaLength = d,
                    v.hemiLength = p,
                    v.numDirectionalShadows = f,
                    v.numPointShadows = m,
                    v.numSpotShadows = g,
                    r.version = ju++)
                },
                setupView: function(t, e) {
                    let i = 0
                      , n = 0
                      , h = 0
                      , l = 0
                      , c = 0;
                    const u = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = r.directional[i];
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            s.setFromMatrixPosition(d.target.matrixWorld),
                            t.direction.sub(s),
                            t.direction.transformDirection(u),
                            i++
                        } else if (d.isSpotLight) {
                            const t = r.spot[h];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(u),
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            s.setFromMatrixPosition(d.target.matrixWorld),
                            t.direction.sub(s),
                            t.direction.transformDirection(u),
                            h++
                        } else if (d.isRectAreaLight) {
                            const t = r.rectArea[l];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(u),
                            o.identity(),
                            a.copy(d.matrixWorld),
                            a.premultiply(u),
                            o.extractRotation(a),
                            t.halfWidth.set(.5 * d.width, 0, 0),
                            t.halfHeight.set(0, .5 * d.height, 0),
                            t.halfWidth.applyMatrix4(o),
                            t.halfHeight.applyMatrix4(o),
                            l++
                        } else if (d.isPointLight) {
                            const t = r.point[n];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(u),
                            n++
                        } else if (d.isHemisphereLight) {
                            const t = r.hemi[c];
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            t.direction.transformDirection(u),
                            t.direction.normalize(),
                            c++
                        }
                    }
                },
                state: r
            }
        }
        function Vu(t, e) {
            const i = new Wu(t,e)
              , n = []
              , r = [];
            return {
                init: function() {
                    n.length = 0,
                    r.length = 0
                },
                state: {
                    lightsArray: n,
                    shadowsArray: r,
                    lights: i
                },
                setupLights: function() {
                    i.setup(n)
                },
                setupLightsView: function(t) {
                    i.setupView(n, t)
                },
                pushLight: function(t) {
                    n.push(t)
                },
                pushShadow: function(t) {
                    r.push(t)
                }
            }
        }
        function qu(t, e) {
            let i = new WeakMap;
            return {
                get: function(n, r=0) {
                    let s;
                    return !1 === i.has(n) ? (s = new Vu(t,e),
                    i.set(n, [s])) : r >= i.get(n).length ? (s = new Vu(t,e),
                    i.get(n).push(s)) : s = i.get(n)[r],
                    s
                },
                dispose: function() {
                    i = new WeakMap
                }
            }
        }
        class Xu extends Fh {
            constructor(t) {
                super(),
                this.type = "MeshDepthMaterial",
                this.depthPacking = 3200,
                this.skinning = !1,
                this.morphTargets = !1,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.depthPacking = t.depthPacking,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this
            }
        }
        Xu.prototype.isMeshDepthMaterial = !0;
        class Yu extends Fh {
            constructor(t) {
                super(),
                this.type = "MeshDistanceMaterial",
                this.referencePosition = new Mo,
                this.nearDistance = 1,
                this.farDistance = 1e3,
                this.skinning = !1,
                this.morphTargets = !1,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.fog = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.referencePosition.copy(t.referencePosition),
                this.nearDistance = t.nearDistance,
                this.farDistance = t.farDistance,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this
            }
        }
        Yu.prototype.isMeshDistanceMaterial = !0;
        var Zu = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
          , Ju = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
        function $u(t, e, i) {
            let n = new $l;
            const r = new po
              , s = new po
              , a = new _o
              , o = []
              , h = []
              , l = {}
              , c = {
                0: Ar,
                1: Sr,
                2: Lr
            }
              , u = new Hl({
                defines: {
                    SAMPLE_RATE: 2 / 8,
                    HALF_SAMPLE_RATE: 1 / 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new po
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: Ju,
                fragmentShader: Zu
            })
              , d = u.clone();
            d.defines.HORIZONTAL_PASS = 1;
            const p = new ml;
            p.setAttribute("position", new Jh(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const f = new Dl(p,u)
              , m = this;
            function g(i, n) {
                const r = e.update(f);
                u.uniforms.shadow_pass.value = i.map.texture,
                u.uniforms.resolution.value = i.mapSize,
                u.uniforms.radius.value = i.radius,
                t.setRenderTarget(i.mapPass),
                t.clear(),
                t.renderBufferDirect(n, null, r, u, f, null),
                d.uniforms.shadow_pass.value = i.mapPass.texture,
                d.uniforms.resolution.value = i.mapSize,
                d.uniforms.radius.value = i.radius,
                t.setRenderTarget(i.map),
                t.clear(),
                t.renderBufferDirect(n, null, r, d, f, null)
            }
            function v(t, e, i) {
                const n = t << 0 | e << 1 | i << 2;
                let r = o[n];
                return void 0 === r && (r = new Xu({
                    depthPacking: to,
                    morphTargets: t,
                    skinning: e
                }),
                o[n] = r),
                r
            }
            function y(t, e, i) {
                const n = t << 0 | e << 1 | i << 2;
                let r = h[n];
                return void 0 === r && (r = new Yu({
                    morphTargets: t,
                    skinning: e
                }),
                h[n] = r),
                r
            }
            function x(e, i, n, r, s, a, o) {
                let h = null
                  , u = v
                  , d = e.customDepthMaterial;
                if (!0 === r.isPointLight && (u = y,
                d = e.customDistanceMaterial),
                void 0 === d) {
                    let t = !1;
                    !0 === n.morphTargets && (t = i.morphAttributes && i.morphAttributes.position && i.morphAttributes.position.length > 0);
                    let r = !1;
                    !0 === e.isSkinnedMesh && (!0 === n.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)),
                    h = u(t, r, !0 === e.isInstancedMesh)
                } else
                    h = d;
                if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                    const t = h.uuid
                      , e = n.uuid;
                    let i = l[t];
                    void 0 === i && (i = {},
                    l[t] = i);
                    let r = i[e];
                    void 0 === r && (r = h.clone(),
                    i[e] = r),
                    h = r
                }
                return h.visible = n.visible,
                h.wireframe = n.wireframe,
                h.side = o === Er ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : c[n.side],
                h.clipShadows = n.clipShadows,
                h.clippingPlanes = n.clippingPlanes,
                h.clipIntersection = n.clipIntersection,
                h.wireframeLinewidth = n.wireframeLinewidth,
                h.linewidth = n.linewidth,
                !0 === r.isPointLight && !0 === h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(r.matrixWorld),
                h.nearDistance = s,
                h.farDistance = a),
                h
            }
            function _(i, r, s, a, o) {
                if (!1 === i.visible)
                    return;
                if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && o === Er) && (!i.frustumCulled || n.intersectsObject(i))) {
                    i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, i.matrixWorld);
                    const n = e.update(i)
                      , r = i.material;
                    if (Array.isArray(r)) {
                        const e = n.groups;
                        for (let h = 0, l = e.length; h < l; h++) {
                            const l = e[h]
                              , c = r[l.materialIndex];
                            if (c && c.visible) {
                                const e = x(i, n, c, a, s.near, s.far, o);
                                t.renderBufferDirect(s, null, n, e, i, l)
                            }
                        }
                    } else if (r.visible) {
                        const e = x(i, n, r, a, s.near, s.far, o);
                        t.renderBufferDirect(s, null, n, e, i, null)
                    }
                }
                const h = i.children;
                for (let t = 0, e = h.length; t < e; t++)
                    _(h[t], r, s, a, o)
            }
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = Mr,
            this.render = function(e, o, h) {
                if (!1 === m.enabled)
                    return;
                if (!1 === m.autoUpdate && !1 === m.needsUpdate)
                    return;
                if (0 === e.length)
                    return;
                const l = t.getRenderTarget()
                  , c = t.getActiveCubeFace()
                  , u = t.getActiveMipmapLevel()
                  , d = t.state;
                d.setBlending(Pr),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
                for (let l = 0, c = e.length; l < c; l++) {
                    const c = e[l]
                      , u = c.shadow;
                    if (void 0 === u) {
                        console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                        continue
                    }
                    if (!1 === u.autoUpdate && !1 === u.needsUpdate)
                        continue;
                    r.copy(u.mapSize);
                    const p = u.getFrameExtents();
                    if (r.multiply(p),
                    s.copy(u.mapSize),
                    (r.x > i || r.y > i) && (r.x > i && (s.x = Math.floor(i / p.x),
                    r.x = s.x * p.x,
                    u.mapSize.x = s.x),
                    r.y > i && (s.y = Math.floor(i / p.y),
                    r.y = s.y * p.y,
                    u.mapSize.y = s.y)),
                    null === u.map && !u.isPointLightShadow && this.type === Er) {
                        const t = {
                            minFilter: Ss,
                            magFilter: Ss,
                            format: Gs
                        };
                        u.map = new bo(r.x,r.y,t),
                        u.map.texture.name = c.name + ".shadowMap",
                        u.mapPass = new bo(r.x,r.y,t),
                        u.camera.updateProjectionMatrix()
                    }
                    if (null === u.map) {
                        const t = {
                            minFilter: Ms,
                            magFilter: Ms,
                            format: Gs
                        };
                        u.map = new bo(r.x,r.y,t),
                        u.map.texture.name = c.name + ".shadowMap",
                        u.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(u.map),
                    t.clear();
                    const f = u.getViewportCount();
                    for (let t = 0; t < f; t++) {
                        const e = u.getViewport(t);
                        a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                        d.viewport(a),
                        u.updateMatrices(c, t),
                        n = u.getFrustum(),
                        _(o, h, u.camera, c, this.type)
                    }
                    u.isPointLightShadow || this.type !== Er || g(u, h),
                    u.needsUpdate = !1
                }
                m.needsUpdate = !1,
                t.setRenderTarget(l, c, u)
            }
        }
        function Qu(t, e, i) {
            const n = i.isWebGL2
              , r = new function() {
                let e = !1;
                const i = new _o;
                let n = null;
                const r = new _o(0,0,0,0);
                return {
                    setMask: function(i) {
                        n === i || e || (t.colorMask(i, i, i, i),
                        n = i)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e, n, s, a, o) {
                        !0 === o && (e *= a,
                        n *= a,
                        s *= a),
                        i.set(e, n, s, a),
                        !1 === r.equals(i) && (t.clearColor(e, n, s, a),
                        r.copy(i))
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        r.set(-1, 0, 0, 0)
                    }
                }
            }
              , s = new function() {
                let e = !1
                  , i = null
                  , n = null
                  , r = null;
                return {
                    setTest: function(t) {
                        t ? D(2929) : I(2929)
                    },
                    setMask: function(n) {
                        i === n || e || (t.depthMask(n),
                        i = n)
                    },
                    setFunc: function(e) {
                        if (n !== e) {
                            if (e)
                                switch (e) {
                                case $r:
                                    t.depthFunc(512);
                                    break;
                                case Qr:
                                    t.depthFunc(519);
                                    break;
                                case Kr:
                                    t.depthFunc(513);
                                    break;
                                case ts:
                                    t.depthFunc(515);
                                    break;
                                case es:
                                    t.depthFunc(514);
                                    break;
                                case is:
                                    t.depthFunc(518);
                                    break;
                                case ns:
                                    t.depthFunc(516);
                                    break;
                                case rs:
                                    t.depthFunc(517);
                                    break;
                                default:
                                    t.depthFunc(515)
                                }
                            else
                                t.depthFunc(515);
                            n = e
                        }
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        r !== e && (t.clearDepth(e),
                        r = e)
                    },
                    reset: function() {
                        e = !1,
                        i = null,
                        n = null,
                        r = null
                    }
                }
            }
              , a = new function() {
                let e = !1
                  , i = null
                  , n = null
                  , r = null
                  , s = null
                  , a = null
                  , o = null
                  , h = null
                  , l = null;
                return {
                    setTest: function(t) {
                        e || (t ? D(2960) : I(2960))
                    },
                    setMask: function(n) {
                        i === n || e || (t.stencilMask(n),
                        i = n)
                    },
                    setFunc: function(e, i, a) {
                        n === e && r === i && s === a || (t.stencilFunc(e, i, a),
                        n = e,
                        r = i,
                        s = a)
                    },
                    setOp: function(e, i, n) {
                        a === e && o === i && h === n || (t.stencilOp(e, i, n),
                        a = e,
                        o = i,
                        h = n)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        l !== e && (t.clearStencil(e),
                        l = e)
                    },
                    reset: function() {
                        e = !1,
                        i = null,
                        n = null,
                        r = null,
                        s = null,
                        a = null,
                        o = null,
                        h = null,
                        l = null
                    }
                }
            }
            ;
            let o = {}
              , h = null
              , l = !1
              , c = null
              , u = null
              , d = null
              , p = null
              , f = null
              , m = null
              , g = null
              , v = !1
              , y = null
              , x = null
              , _ = null
              , b = null
              , w = null;
            const M = t.getParameter(35661);
            let T = !1
              , E = 0;
            const S = t.getParameter(7938);
            -1 !== S.indexOf("WebGL") ? (E = parseFloat(/^WebGL (\d)/.exec(S)[1]),
            T = E >= 1) : -1 !== S.indexOf("OpenGL ES") && (E = parseFloat(/^OpenGL ES (\d)/.exec(S)[1]),
            T = E >= 2);
            let A = null
              , L = {};
            const P = new _o
              , C = new _o;
            function R(e, i, n) {
                const r = new Uint8Array(4)
                  , s = t.createTexture();
                t.bindTexture(e, s),
                t.texParameteri(e, 10241, 9728),
                t.texParameteri(e, 10240, 9728);
                for (let e = 0; e < n; e++)
                    t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return s
            }
            const O = {};
            function D(e) {
                !0 !== o[e] && (t.enable(e),
                o[e] = !0)
            }
            function I(e) {
                !1 !== o[e] && (t.disable(e),
                o[e] = !1)
            }
            O[3553] = R(3553, 3553, 1),
            O[34067] = R(34067, 34069, 6),
            r.setClear(0, 0, 0, 1),
            s.setClear(1),
            a.setClear(0),
            D(2929),
            s.setFunc(ts),
            k(!1),
            F(br),
            D(2884),
            B(Pr);
            const N = {
                [Nr]: 32774,
                [zr]: 32778,
                [Br]: 32779
            };
            if (n)
                N[kr] = 32775,
                N[Fr] = 32776;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (N[kr] = t.MIN_EXT,
                N[Fr] = t.MAX_EXT)
            }
            const z = {
                [Ur]: 0,
                [Hr]: 1,
                [jr]: 768,
                [Wr]: 770,
                [Jr]: 776,
                [Yr]: 774,
                [qr]: 772,
                [Gr]: 769,
                [Vr]: 771,
                [Zr]: 775,
                [Xr]: 773
            };
            function B(e, i, n, r, s, a, o, h) {
                if (e !== Pr) {
                    if (!1 === l && (D(3042),
                    l = !0),
                    e === Ir)
                        s = s || i,
                        a = a || n,
                        o = o || r,
                        i === u && s === f || (t.blendEquationSeparate(N[i], N[s]),
                        u = i,
                        f = s),
                        n === d && r === p && a === m && o === g || (t.blendFuncSeparate(z[n], z[r], z[a], z[o]),
                        d = n,
                        p = r,
                        m = a,
                        g = o),
                        c = e,
                        v = null;
                    else if (e !== c || h !== v) {
                        if (u === Nr && f === Nr || (t.blendEquation(32774),
                        u = Nr,
                        f = Nr),
                        h)
                            switch (e) {
                            case Cr:
                                t.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case Rr:
                                t.blendFunc(1, 1);
                                break;
                            case Or:
                                t.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case Dr:
                                t.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                        else
                            switch (e) {
                            case Cr:
                                t.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case Rr:
                                t.blendFunc(770, 1);
                                break;
                            case Or:
                                t.blendFunc(0, 769);
                                break;
                            case Dr:
                                t.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                        d = null,
                        p = null,
                        m = null,
                        g = null,
                        c = e,
                        v = h
                    }
                } else
                    !0 === l && (I(3042),
                    l = !1)
            }
            function k(e) {
                y !== e && (e ? t.frontFace(2304) : t.frontFace(2305),
                y = e)
            }
            function F(e) {
                e !== _r ? (D(2884),
                e !== x && (e === br ? t.cullFace(1029) : e === wr ? t.cullFace(1028) : t.cullFace(1032))) : I(2884),
                x = e
            }
            function U(e, i, n) {
                e ? (D(32823),
                b === i && w === n || (t.polygonOffset(i, n),
                b = i,
                w = n)) : I(32823)
            }
            function H(e) {
                void 0 === e && (e = 33984 + M - 1),
                A !== e && (t.activeTexture(e),
                A = e)
            }
            return {
                buffers: {
                    color: r,
                    depth: s,
                    stencil: a
                },
                enable: D,
                disable: I,
                useProgram: function(e) {
                    return h !== e && (t.useProgram(e),
                    h = e,
                    !0)
                },
                setBlending: B,
                setMaterial: function(t, e) {
                    t.side === Lr ? I(2884) : D(2884);
                    let i = t.side === Ar;
                    e && (i = !i),
                    k(i),
                    t.blending === Cr && !1 === t.transparent ? B(Pr) : B(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha),
                    s.setFunc(t.depthFunc),
                    s.setTest(t.depthTest),
                    s.setMask(t.depthWrite),
                    r.setMask(t.colorWrite);
                    const n = t.stencilWrite;
                    a.setTest(n),
                    n && (a.setMask(t.stencilWriteMask),
                    a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                    a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                    U(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                },
                setFlipSided: k,
                setCullFace: F,
                setLineWidth: function(e) {
                    e !== _ && (T && t.lineWidth(e),
                    _ = e)
                },
                setPolygonOffset: U,
                setScissorTest: function(t) {
                    t ? D(3089) : I(3089)
                },
                activeTexture: H,
                bindTexture: function(e, i) {
                    null === A && H();
                    let n = L[A];
                    void 0 === n && (n = {
                        type: void 0,
                        texture: void 0
                    },
                    L[A] = n),
                    n.type === e && n.texture === i || (t.bindTexture(e, i || O[e]),
                    n.type = e,
                    n.texture = i)
                },
                unbindTexture: function() {
                    const e = L[A];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                    e.type = void 0,
                    e.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === P.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                    P.copy(e))
                },
                viewport: function(e) {
                    !1 === C.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                    C.copy(e))
                },
                reset: function() {
                    t.disable(3042),
                    t.disable(2884),
                    t.disable(2929),
                    t.disable(32823),
                    t.disable(3089),
                    t.disable(2960),
                    t.blendEquation(32774),
                    t.blendFunc(1, 0),
                    t.blendFuncSeparate(1, 0, 1, 0),
                    t.colorMask(!0, !0, !0, !0),
                    t.clearColor(0, 0, 0, 0),
                    t.depthMask(!0),
                    t.depthFunc(513),
                    t.clearDepth(1),
                    t.stencilMask(4294967295),
                    t.stencilFunc(519, 0, 4294967295),
                    t.stencilOp(7680, 7680, 7680),
                    t.clearStencil(0),
                    t.cullFace(1029),
                    t.frontFace(2305),
                    t.polygonOffset(0, 0),
                    t.activeTexture(33984),
                    t.useProgram(null),
                    t.lineWidth(1),
                    t.scissor(0, 0, t.canvas.width, t.canvas.height),
                    t.viewport(0, 0, t.canvas.width, t.canvas.height),
                    o = {},
                    A = null,
                    L = {},
                    h = null,
                    l = !1,
                    c = null,
                    u = null,
                    d = null,
                    p = null,
                    f = null,
                    m = null,
                    g = null,
                    v = !1,
                    y = null,
                    x = null,
                    _ = null,
                    b = null,
                    w = null,
                    r.reset(),
                    s.reset(),
                    a.reset()
                }
            }
        }
        function Ku(t, e, i, n, r, s, a) {
            const o = r.isWebGL2
              , h = r.maxTextures
              , l = r.maxCubemapSize
              , c = r.maxTextureSize
              , u = r.maxSamples
              , d = new WeakMap;
            let p, f = !1;
            try {
                f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch (t) {}
            function m(t, e) {
                return f ? new OffscreenCanvas(t,e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }
            function g(t, e, i, n) {
                let r = 1;
                if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)),
                r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const n = e ? uo.floorPowerOfTwo : Math.floor
                          , s = n(r * t.width)
                          , a = n(r * t.height);
                        void 0 === p && (p = m(s, a));
                        const o = i ? m(s, a) : p;
                        return o.width = s,
                        o.height = a,
                        o.getContext("2d").drawImage(t, 0, 0, s, a),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."),
                        o
                    }
                    return "data"in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."),
                    t
                }
                return t
            }
            function v(t) {
                return uo.isPowerOfTwo(t.width) && uo.isPowerOfTwo(t.height)
            }
            function y(t, e) {
                return t.generateMipmaps && e && t.minFilter !== Ms && t.minFilter !== Ss
            }
            function x(e, i, r, s) {
                t.generateMipmap(e),
                n.get(i).__maxMipLevel = Math.log2(Math.max(r, s))
            }
            function _(i, n, r) {
                if (!1 === o)
                    return n;
                if (null !== i) {
                    if (void 0 !== t[i])
                        return t[i];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'")
                }
                let s = n;
                return 6403 === n && (5126 === r && (s = 33326),
                5131 === r && (s = 33325),
                5121 === r && (s = 33321)),
                6407 === n && (5126 === r && (s = 34837),
                5131 === r && (s = 34843),
                5121 === r && (s = 32849)),
                6408 === n && (5126 === r && (s = 34836),
                5131 === r && (s = 34842),
                5121 === r && (s = 32856)),
                33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"),
                s
            }
            function b(t) {
                return t === Ms || t === Ts || t === Es ? 9728 : 9729
            }
            function w(e) {
                const i = e.target;
                i.removeEventListener("dispose", w),
                function(e) {
                    const i = n.get(e);
                    void 0 !== i.__webglInit && (t.deleteTexture(i.__webglTexture),
                    n.remove(e))
                }(i),
                i.isVideoTexture && d.delete(i),
                a.memory.textures--
            }
            function M(e) {
                const i = e.target;
                i.removeEventListener("dispose", M),
                function(e) {
                    const i = e.texture
                      , r = n.get(e)
                      , s = n.get(i);
                    if (e) {
                        if (void 0 !== s.__webglTexture && t.deleteTexture(s.__webglTexture),
                        e.depthTexture && e.depthTexture.dispose(),
                        e.isWebGLCubeRenderTarget)
                            for (let e = 0; e < 6; e++)
                                t.deleteFramebuffer(r.__webglFramebuffer[e]),
                                r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                        else
                            t.deleteFramebuffer(r.__webglFramebuffer),
                            r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                            r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                            r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                            r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                        n.remove(i),
                        n.remove(e)
                    }
                }(i),
                a.memory.textures--
            }
            let T = 0;
            function E(t, e) {
                const r = n.get(t);
                if (t.isVideoTexture && function(t) {
                    const e = a.render.frame;
                    d.get(t) !== e && (d.set(t, e),
                    t.update())
                }(t),
                t.version > 0 && r.__version !== t.version) {
                    const i = t.image;
                    if (void 0 === i)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (!1 !== i.complete)
                            return void R(r, t, e);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                i.activeTexture(33984 + e),
                i.bindTexture(3553, r.__webglTexture)
            }
            function S(e, r) {
                const a = n.get(e);
                e.version > 0 && a.__version !== e.version ? function(e, n, r) {
                    if (6 !== n.image.length)
                        return;
                    C(e, n),
                    i.activeTexture(33984 + r),
                    i.bindTexture(34067, e.__webglTexture),
                    t.pixelStorei(37440, n.flipY),
                    t.pixelStorei(37441, n.premultiplyAlpha),
                    t.pixelStorei(3317, n.unpackAlignment),
                    t.pixelStorei(37443, 0);
                    const a = n && (n.isCompressedTexture || n.image[0].isCompressedTexture)
                      , h = n.image[0] && n.image[0].isDataTexture
                      , c = [];
                    for (let t = 0; t < 6; t++)
                        c[t] = a || h ? h ? n.image[t].image : n.image[t] : g(n.image[t], !1, !0, l);
                    const u = c[0]
                      , d = v(u) || o
                      , p = s.convert(n.format)
                      , f = s.convert(n.type)
                      , m = _(n.internalFormat, p, f);
                    let b;
                    if (P(34067, n, d),
                    a) {
                        for (let t = 0; t < 6; t++) {
                            b = c[t].mipmaps;
                            for (let e = 0; e < b.length; e++) {
                                const r = b[e];
                                n.format !== Gs && n.format !== js ? null !== p ? i.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data)
                            }
                        }
                        e.__maxMipLevel = b.length - 1
                    } else {
                        b = n.mipmaps;
                        for (let t = 0; t < 6; t++)
                            if (h) {
                                i.texImage2D(34069 + t, 0, m, c[t].width, c[t].height, 0, p, f, c[t].data);
                                for (let e = 0; e < b.length; e++) {
                                    const n = b[e].image[t].image;
                                    i.texImage2D(34069 + t, e + 1, m, n.width, n.height, 0, p, f, n.data)
                                }
                            } else {
                                i.texImage2D(34069 + t, 0, m, p, f, c[t]);
                                for (let e = 0; e < b.length; e++) {
                                    const n = b[e];
                                    i.texImage2D(34069 + t, e + 1, m, p, f, n.image[t])
                                }
                            }
                        e.__maxMipLevel = b.length
                    }
                    y(n, d) && x(34067, n, u.width, u.height),
                    e.__version = n.version,
                    n.onUpdate && n.onUpdate(n)
                }(a, e, r) : (i.activeTexture(33984 + r),
                i.bindTexture(34067, a.__webglTexture))
            }
            const A = {
                [_s]: 10497,
                [bs]: 33071,
                [ws]: 33648
            }
              , L = {
                [Ms]: 9728,
                [Ts]: 9984,
                [Es]: 9986,
                [Ss]: 9729,
                [As]: 9985,
                [Ls]: 9987
            };
            function P(i, s, a) {
                if (a ? (t.texParameteri(i, 10242, A[s.wrapS]),
                t.texParameteri(i, 10243, A[s.wrapT]),
                32879 !== i && 35866 !== i || t.texParameteri(i, 32882, A[s.wrapR]),
                t.texParameteri(i, 10240, L[s.magFilter]),
                t.texParameteri(i, 10241, L[s.minFilter])) : (t.texParameteri(i, 10242, 33071),
                t.texParameteri(i, 10243, 33071),
                32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071),
                s.wrapS === bs && s.wrapT === bs || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                t.texParameteri(i, 10240, b(s.magFilter)),
                t.texParameteri(i, 10241, b(s.minFilter)),
                s.minFilter !== Ms && s.minFilter !== Ss && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const a = e.get("EXT_texture_filter_anisotropic");
                    if (s.type === Ns && !1 === e.has("OES_texture_float_linear"))
                        return;
                    if (!1 === o && s.type === zs && !1 === e.has("OES_texture_half_float_linear"))
                        return;
                    (s.anisotropy > 1 || n.get(s).__currentAnisotropy) && (t.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
                    n.get(s).__currentAnisotropy = s.anisotropy)
                }
            }
            function C(e, i) {
                void 0 === e.__webglInit && (e.__webglInit = !0,
                i.addEventListener("dispose", w),
                e.__webglTexture = t.createTexture(),
                a.memory.textures++)
            }
            function R(e, n, r) {
                let a = 3553;
                n.isDataTexture2DArray && (a = 35866),
                n.isDataTexture3D && (a = 32879),
                C(e, n),
                i.activeTexture(33984 + r),
                i.bindTexture(a, e.__webglTexture),
                t.pixelStorei(37440, n.flipY),
                t.pixelStorei(37441, n.premultiplyAlpha),
                t.pixelStorei(3317, n.unpackAlignment),
                t.pixelStorei(37443, 0);
                const h = function(t) {
                    return !o && (t.wrapS !== bs || t.wrapT !== bs || t.minFilter !== Ms && t.minFilter !== Ss)
                }(n) && !1 === v(n.image)
                  , l = g(n.image, h, !1, c)
                  , u = v(l) || o
                  , d = s.convert(n.format);
                let p, f = s.convert(n.type), m = _(n.internalFormat, d, f);
                P(a, n, u);
                const b = n.mipmaps;
                if (n.isDepthTexture)
                    m = 6402,
                    o ? m = n.type === Ns ? 36012 : n.type === Is ? 33190 : n.type === Us ? 35056 : 33189 : n.type === Ns && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                    n.format === qs && 6402 === m && n.type !== Os && n.type !== Is && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                    n.type = Os,
                    f = s.convert(n.type)),
                    n.format === Xs && 6402 === m && (m = 34041,
                    n.type !== Us && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                    n.type = Us,
                    f = s.convert(n.type))),
                    i.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);
                else if (n.isDataTexture)
                    if (b.length > 0 && u) {
                        for (let t = 0, e = b.length; t < e; t++)
                            p = b[t],
                            i.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                        n.generateMipmaps = !1,
                        e.__maxMipLevel = b.length - 1
                    } else
                        i.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data),
                        e.__maxMipLevel = 0;
                else if (n.isCompressedTexture) {
                    for (let t = 0, e = b.length; t < e; t++)
                        p = b[t],
                        n.format !== Gs && n.format !== js ? null !== d ? i.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                    e.__maxMipLevel = b.length - 1
                } else if (n.isDataTexture2DArray)
                    i.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, d, f, l.data),
                    e.__maxMipLevel = 0;
                else if (n.isDataTexture3D)
                    i.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, d, f, l.data),
                    e.__maxMipLevel = 0;
                else if (b.length > 0 && u) {
                    for (let t = 0, e = b.length; t < e; t++)
                        p = b[t],
                        i.texImage2D(3553, t, m, d, f, p);
                    n.generateMipmaps = !1,
                    e.__maxMipLevel = b.length - 1
                } else
                    i.texImage2D(3553, 0, m, d, f, l),
                    e.__maxMipLevel = 0;
                y(n, u) && x(a, n, l.width, l.height),
                e.__version = n.version,
                n.onUpdate && n.onUpdate(n)
            }
            function O(e, r, a, o) {
                const h = r.texture
                  , l = s.convert(h.format)
                  , c = s.convert(h.type)
                  , u = _(h.internalFormat, l, c);
                32879 === o || 35866 === o ? i.texImage3D(o, 0, u, r.width, r.height, r.depth, 0, l, c, null) : i.texImage2D(o, 0, u, r.width, r.height, 0, l, c, null),
                t.bindFramebuffer(36160, e),
                t.framebufferTexture2D(36160, a, o, n.get(h).__webglTexture, 0),
                t.bindFramebuffer(36160, null)
            }
            function D(e, i, n) {
                if (t.bindRenderbuffer(36161, e),
                i.depthBuffer && !i.stencilBuffer) {
                    let r = 33189;
                    if (n) {
                        const e = i.depthTexture;
                        e && e.isDepthTexture && (e.type === Ns ? r = 36012 : e.type === Is && (r = 33190));
                        const n = I(i);
                        t.renderbufferStorageMultisample(36161, n, r, i.width, i.height)
                    } else
                        t.renderbufferStorage(36161, r, i.width, i.height);
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (i.depthBuffer && i.stencilBuffer) {
                    if (n) {
                        const e = I(i);
                        t.renderbufferStorageMultisample(36161, e, 35056, i.width, i.height)
                    } else
                        t.renderbufferStorage(36161, 34041, i.width, i.height);
                    t.framebufferRenderbuffer(36160, 33306, 36161, e)
                } else {
                    const e = i.texture
                      , r = s.convert(e.format)
                      , a = s.convert(e.type)
                      , o = _(e.internalFormat, r, a);
                    if (n) {
                        const e = I(i);
                        t.renderbufferStorageMultisample(36161, e, o, i.width, i.height)
                    } else
                        t.renderbufferStorage(36161, o, i.width, i.height)
                }
                t.bindRenderbuffer(36161, null)
            }
            function I(t) {
                return o && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0
            }
            let N = !1
              , z = !1;
            this.allocateTextureUnit = function() {
                const t = T;
                return t >= h && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + h),
                T += 1,
                t
            }
            ,
            this.resetTextureUnits = function() {
                T = 0
            }
            ,
            this.setTexture2D = E,
            this.setTexture2DArray = function(t, e) {
                const r = n.get(t);
                t.version > 0 && r.__version !== t.version ? R(r, t, e) : (i.activeTexture(33984 + e),
                i.bindTexture(35866, r.__webglTexture))
            }
            ,
            this.setTexture3D = function(t, e) {
                const r = n.get(t);
                t.version > 0 && r.__version !== t.version ? R(r, t, e) : (i.activeTexture(33984 + e),
                i.bindTexture(32879, r.__webglTexture))
            }
            ,
            this.setTextureCube = S,
            this.setupRenderTarget = function(e) {
                const r = e.texture
                  , h = n.get(e)
                  , l = n.get(r);
                e.addEventListener("dispose", M),
                l.__webglTexture = t.createTexture(),
                a.memory.textures++;
                const c = !0 === e.isWebGLCubeRenderTarget
                  , u = !0 === e.isWebGLMultisampleRenderTarget
                  , d = r.isDataTexture3D || r.isDataTexture2DArray
                  , p = v(e) || o;
                if (!o || r.format !== js || r.type !== Ns && r.type !== zs || (r.format = Gs,
                console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),
                c) {
                    h.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++)
                        h.__webglFramebuffer[e] = t.createFramebuffer()
                } else if (h.__webglFramebuffer = t.createFramebuffer(),
                u)
                    if (o) {
                        h.__webglMultisampledFramebuffer = t.createFramebuffer(),
                        h.__webglColorRenderbuffer = t.createRenderbuffer(),
                        t.bindRenderbuffer(36161, h.__webglColorRenderbuffer);
                        const i = s.convert(r.format)
                          , n = s.convert(r.type)
                          , a = _(r.internalFormat, i, n)
                          , o = I(e);
                        t.renderbufferStorageMultisample(36161, o, a, e.width, e.height),
                        t.bindFramebuffer(36160, h.__webglMultisampledFramebuffer),
                        t.framebufferRenderbuffer(36160, 36064, 36161, h.__webglColorRenderbuffer),
                        t.bindRenderbuffer(36161, null),
                        e.depthBuffer && (h.__webglDepthRenderbuffer = t.createRenderbuffer(),
                        D(h.__webglDepthRenderbuffer, e, !0)),
                        t.bindFramebuffer(36160, null)
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (c) {
                    i.bindTexture(34067, l.__webglTexture),
                    P(34067, r, p);
                    for (let t = 0; t < 6; t++)
                        O(h.__webglFramebuffer[t], e, 36064, 34069 + t);
                    y(r, p) && x(34067, r, e.width, e.height),
                    i.bindTexture(34067, null)
                } else {
                    let t = 3553;
                    d && (o ? t = r.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),
                    i.bindTexture(t, l.__webglTexture),
                    P(t, r, p),
                    O(h.__webglFramebuffer, e, 36064, t),
                    y(r, p) && x(3553, r, e.width, e.height),
                    i.bindTexture(3553, null)
                }
                e.depthBuffer && function(e) {
                    const i = n.get(e)
                      , r = !0 === e.isWebGLCubeRenderTarget;
                    if (e.depthTexture) {
                        if (r)
                            throw new Error("target.depthTexture not supported in Cube render targets");
                        !function(e, i) {
                            if (i && i.isWebGLCubeRenderTarget)
                                throw new Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(36160, e),
                            !i.depthTexture || !i.depthTexture.isDepthTexture)
                                throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width,
                            i.depthTexture.image.height = i.height,
                            i.depthTexture.needsUpdate = !0),
                            E(i.depthTexture, 0);
                            const r = n.get(i.depthTexture).__webglTexture;
                            if (i.depthTexture.format === qs)
                                t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                            else {
                                if (i.depthTexture.format !== Xs)
                                    throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                            }
                        }(i.__webglFramebuffer, e)
                    } else if (r) {
                        i.__webglDepthbuffer = [];
                        for (let n = 0; n < 6; n++)
                            t.bindFramebuffer(36160, i.__webglFramebuffer[n]),
                            i.__webglDepthbuffer[n] = t.createRenderbuffer(),
                            D(i.__webglDepthbuffer[n], e, !1)
                    } else
                        t.bindFramebuffer(36160, i.__webglFramebuffer),
                        i.__webglDepthbuffer = t.createRenderbuffer(),
                        D(i.__webglDepthbuffer, e, !1);
                    t.bindFramebuffer(36160, null)
                }(e)
            }
            ,
            this.updateRenderTargetMipmap = function(t) {
                const e = t.texture;
                if (y(e, v(t) || o)) {
                    const r = t.isWebGLCubeRenderTarget ? 34067 : 3553
                      , s = n.get(e).__webglTexture;
                    i.bindTexture(r, s),
                    x(r, e, t.width, t.height),
                    i.bindTexture(r, null)
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(e) {
                if (e.isWebGLMultisampleRenderTarget)
                    if (o) {
                        const i = n.get(e);
                        t.bindFramebuffer(36008, i.__webglMultisampledFramebuffer),
                        t.bindFramebuffer(36009, i.__webglFramebuffer);
                        const r = e.width
                          , s = e.height;
                        let a = 16384;
                        e.depthBuffer && (a |= 256),
                        e.stencilBuffer && (a |= 1024),
                        t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728),
                        t.bindFramebuffer(36160, i.__webglMultisampledFramebuffer)
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }
            ,
            this.safeSetTexture2D = function(t, e) {
                t && t.isWebGLRenderTarget && (!1 === N && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
                N = !0),
                t = t.texture),
                E(t, e)
            }
            ,
            this.safeSetTextureCube = function(t, e) {
                t && t.isWebGLCubeRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                z = !0),
                t = t.texture),
                S(t, e)
            }
        }
        function td(t, e, i) {
            const n = i.isWebGL2;
            return {
                convert: function(t) {
                    let i;
                    if (t === Ps)
                        return 5121;
                    if (t === Bs)
                        return 32819;
                    if (t === ks)
                        return 32820;
                    if (t === Fs)
                        return 33635;
                    if (t === Cs)
                        return 5120;
                    if (t === Rs)
                        return 5122;
                    if (t === Os)
                        return 5123;
                    if (t === Ds)
                        return 5124;
                    if (t === Is)
                        return 5125;
                    if (t === Ns)
                        return 5126;
                    if (t === zs)
                        return n ? 5131 : (i = e.get("OES_texture_half_float"),
                        null !== i ? i.HALF_FLOAT_OES : null);
                    if (t === Hs)
                        return 6406;
                    if (t === js)
                        return 6407;
                    if (t === Gs)
                        return 6408;
                    if (t === Ws)
                        return 6409;
                    if (t === Vs)
                        return 6410;
                    if (t === qs)
                        return 6402;
                    if (t === Xs)
                        return 34041;
                    if (t === Ys)
                        return 6403;
                    if (t === Zs)
                        return 36244;
                    if (t === Js)
                        return 33319;
                    if (t === $s)
                        return 33320;
                    if (t === Qs)
                        return 36248;
                    if (t === Ks)
                        return 36249;
                    if (t === ta || t === ea || t === ia || t === na) {
                        if (i = e.get("WEBGL_compressed_texture_s3tc"),
                        null === i)
                            return null;
                        if (t === ta)
                            return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (t === ea)
                            return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (t === ia)
                            return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (t === na)
                            return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (t === ra || t === sa || t === aa || t === oa) {
                        if (i = e.get("WEBGL_compressed_texture_pvrtc"),
                        null === i)
                            return null;
                        if (t === ra)
                            return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (t === sa)
                            return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (t === aa)
                            return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (t === oa)
                            return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (t === ha)
                        return i = e.get("WEBGL_compressed_texture_etc1"),
                        null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((t === la || t === ca) && (i = e.get("WEBGL_compressed_texture_etc"),
                    null !== i)) {
                        if (t === la)
                            return i.COMPRESSED_RGB8_ETC2;
                        if (t === ca)
                            return i.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return t === ua || t === da || t === pa || t === fa || t === ma || t === ga || t === va || t === ya || t === xa || t === _a || t === ba || t === wa || t === Ma || t === Ta || t === Sa || t === Aa || t === La || t === Pa || t === Ca || t === Ra || t === Oa || t === Da || t === Ia || t === Na || t === za || t === Ba || t === ka || t === Fa ? (i = e.get("WEBGL_compressed_texture_astc"),
                    null !== i ? t : null) : t === Ea ? (i = e.get("EXT_texture_compression_bptc"),
                    null !== i ? t : null) : t === Us ? n ? 34042 : (i = e.get("WEBGL_depth_texture"),
                    null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                }
            }
        }
        function ed(t=[]) {
            Gl.call(this),
            this.cameras = t
        }
        ed.prototype = Object.assign(Object.create(Gl.prototype), {
            constructor: ed,
            isArrayCamera: !0
        });
        class id extends wh {
            constructor() {
                super(),
                this.type = "Group"
            }
        }
        function nd() {
            this._targetRay = null,
            this._grip = null,
            this._hand = null
        }
        function rd(t, e) {
            const i = this;
            let n = null
              , r = 1
              , s = null
              , a = "local-floor"
              , o = null;
            const h = []
              , l = new Map
              , c = new Gl;
            c.layers.enable(1),
            c.viewport = new _o;
            const u = new Gl;
            u.layers.enable(2),
            u.viewport = new _o;
            const d = [c, u]
              , p = new ed;
            p.layers.enable(1),
            p.layers.enable(2);
            let f = null
              , m = null;
            function g(t) {
                const e = l.get(t.inputSource);
                e && e.dispatchEvent({
                    type: t.type,
                    data: t.inputSource
                })
            }
            function v() {
                l.forEach((function(t, e) {
                    t.disconnect(e)
                }
                )),
                l.clear(),
                f = null,
                m = null,
                t.setFramebuffer(null),
                t.setRenderTarget(t.getRenderTarget()),
                M.stop(),
                i.isPresenting = !1,
                i.dispatchEvent({
                    type: "sessionend"
                })
            }
            function y(t) {
                const e = n.inputSources;
                for (let t = 0; t < h.length; t++)
                    l.set(e[t], h[t]);
                for (let e = 0; e < t.removed.length; e++) {
                    const i = t.removed[e]
                      , n = l.get(i);
                    n && (n.dispatchEvent({
                        type: "disconnected",
                        data: i
                    }),
                    l.delete(i))
                }
                for (let e = 0; e < t.added.length; e++) {
                    const i = t.added[e]
                      , n = l.get(i);
                    n && n.dispatchEvent({
                        type: "connected",
                        data: i
                    })
                }
            }
            this.enabled = !1,
            this.isPresenting = !1,
            this.getController = function(t) {
                let e = h[t];
                return void 0 === e && (e = new nd,
                h[t] = e),
                e.getTargetRaySpace()
            }
            ,
            this.getControllerGrip = function(t) {
                let e = h[t];
                return void 0 === e && (e = new nd,
                h[t] = e),
                e.getGripSpace()
            }
            ,
            this.getHand = function(t) {
                let e = h[t];
                return void 0 === e && (e = new nd,
                h[t] = e),
                e.getHandSpace()
            }
            ,
            this.setFramebufferScaleFactor = function(t) {
                r = t,
                !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }
            ,
            this.setReferenceSpaceType = function(t) {
                a = t,
                !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }
            ,
            this.getReferenceSpace = function() {
                return s
            }
            ,
            this.getSession = function() {
                return n
            }
            ,
            this.setSession = async function(t) {
                if (n = t,
                null !== n) {
                    n.addEventListener("select", g),
                    n.addEventListener("selectstart", g),
                    n.addEventListener("selectend", g),
                    n.addEventListener("squeeze", g),
                    n.addEventListener("squeezestart", g),
                    n.addEventListener("squeezeend", g),
                    n.addEventListener("end", v),
                    n.addEventListener("inputsourceschange", y);
                    const t = e.getContextAttributes();
                    !0 !== t.xrCompatible && await e.makeXRCompatible();
                    const o = {
                        antialias: t.antialias,
                        alpha: t.alpha,
                        depth: t.depth,
                        stencil: t.stencil,
                        framebufferScaleFactor: r
                    }
                      , h = new XRWebGLLayer(n,e,o);
                    n.updateRenderState({
                        baseLayer: h
                    }),
                    s = await n.requestReferenceSpace(a),
                    M.setContext(n),
                    M.start(),
                    i.isPresenting = !0,
                    i.dispatchEvent({
                        type: "sessionstart"
                    })
                }
            }
            ;
            const x = new Mo
              , _ = new Mo;
            function b(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                t.matrixWorldInverse.copy(t.matrixWorld).invert()
            }
            this.getCamera = function(t) {
                p.near = u.near = c.near = t.near,
                p.far = u.far = c.far = t.far,
                f === p.near && m === p.far || (n.updateRenderState({
                    depthNear: p.near,
                    depthFar: p.far
                }),
                f = p.near,
                m = p.far);
                const e = t.parent
                  , i = p.cameras;
                b(p, e);
                for (let t = 0; t < i.length; t++)
                    b(i[t], e);
                t.matrixWorld.copy(p.matrixWorld),
                t.matrix.copy(p.matrix),
                t.matrix.decompose(t.position, t.quaternion, t.scale);
                const r = t.children;
                for (let t = 0, e = r.length; t < e; t++)
                    r[t].updateMatrixWorld(!0);
                return 2 === i.length ? function(t, e, i) {
                    x.setFromMatrixPosition(e.matrixWorld),
                    _.setFromMatrixPosition(i.matrixWorld);
                    const n = x.distanceTo(_)
                      , r = e.projectionMatrix.elements
                      , s = i.projectionMatrix.elements
                      , a = r[14] / (r[10] - 1)
                      , o = r[14] / (r[10] + 1)
                      , h = (r[9] + 1) / r[5]
                      , l = (r[9] - 1) / r[5]
                      , c = (r[8] - 1) / r[0]
                      , u = (s[8] + 1) / s[0]
                      , d = a * c
                      , p = a * u
                      , f = n / (-c + u)
                      , m = f * -c;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(m),
                    t.translateZ(f),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = a + f
                      , v = o + f
                      , y = d - m
                      , b = p + (n - m)
                      , w = h * o / v * g
                      , M = l * o / v * g;
                    t.projectionMatrix.makePerspective(y, b, w, M, g, v)
                }(p, c, u) : p.projectionMatrix.copy(c.projectionMatrix),
                p
            }
            ;
            let w = null;
            const M = new Ql;
            M.setAnimationLoop((function(e, i) {
                if (o = i.getViewerPose(s),
                null !== o) {
                    const e = o.views
                      , i = n.renderState.baseLayer;
                    t.setFramebuffer(i.framebuffer);
                    let r = !1;
                    e.length !== p.cameras.length && (p.cameras.length = 0,
                    r = !0);
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t]
                          , s = i.getViewport(n)
                          , a = d[t];
                        a.matrix.fromArray(n.transform.matrix),
                        a.projectionMatrix.fromArray(n.projectionMatrix),
                        a.viewport.set(s.x, s.y, s.width, s.height),
                        0 === t && p.matrix.copy(a.matrix),
                        !0 === r && p.cameras.push(a)
                    }
                }
                const r = n.inputSources;
                for (let t = 0; t < h.length; t++) {
                    const e = h[t]
                      , n = r[t];
                    e.update(n, i, s)
                }
                w && w(e, i)
            }
            )),
            this.setAnimationLoop = function(t) {
                w = t
            }
            ,
            this.dispose = function() {}
        }
        function sd(t) {
            function e(e, i) {
                e.opacity.value = i.opacity,
                i.color && e.diffuse.value.copy(i.color),
                i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
                i.map && (e.map.value = i.map),
                i.alphaMap && (e.alphaMap.value = i.alphaMap),
                i.specularMap && (e.specularMap.value = i.specularMap);
                const n = t.get(i).envMap;
                if (n) {
                    e.envMap.value = n,
                    e.flipEnvMap.value = n.isCubeTexture && n._needsFlipEnvMap ? -1 : 1,
                    e.reflectivity.value = i.reflectivity,
                    e.refractionRatio.value = i.refractionRatio;
                    const r = t.get(n).__maxMipLevel;
                    void 0 !== r && (e.maxMipLevel.value = r)
                }
                let r, s;
                i.lightMap && (e.lightMap.value = i.lightMap,
                e.lightMapIntensity.value = i.lightMapIntensity),
                i.aoMap && (e.aoMap.value = i.aoMap,
                e.aoMapIntensity.value = i.aoMapIntensity),
                i.map ? r = i.map : i.specularMap ? r = i.specularMap : i.displacementMap ? r = i.displacementMap : i.normalMap ? r = i.normalMap : i.bumpMap ? r = i.bumpMap : i.roughnessMap ? r = i.roughnessMap : i.metalnessMap ? r = i.metalnessMap : i.alphaMap ? r = i.alphaMap : i.emissiveMap ? r = i.emissiveMap : i.clearcoatMap ? r = i.clearcoatMap : i.clearcoatNormalMap ? r = i.clearcoatNormalMap : i.clearcoatRoughnessMap && (r = i.clearcoatRoughnessMap),
                void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture),
                !0 === r.matrixAutoUpdate && r.updateMatrix(),
                e.uvTransform.value.copy(r.matrix)),
                i.aoMap ? s = i.aoMap : i.lightMap && (s = i.lightMap),
                void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture),
                !0 === s.matrixAutoUpdate && s.updateMatrix(),
                e.uv2Transform.value.copy(s.matrix))
            }
            function i(e, i) {
                e.roughness.value = i.roughness,
                e.metalness.value = i.metalness,
                i.roughnessMap && (e.roughnessMap.value = i.roughnessMap),
                i.metalnessMap && (e.metalnessMap.value = i.metalnessMap),
                i.emissiveMap && (e.emissiveMap.value = i.emissiveMap),
                i.bumpMap && (e.bumpMap.value = i.bumpMap,
                e.bumpScale.value = i.bumpScale,
                i.side === Ar && (e.bumpScale.value *= -1)),
                i.normalMap && (e.normalMap.value = i.normalMap,
                e.normalScale.value.copy(i.normalScale),
                i.side === Ar && e.normalScale.value.negate()),
                i.displacementMap && (e.displacementMap.value = i.displacementMap,
                e.displacementScale.value = i.displacementScale,
                e.displacementBias.value = i.displacementBias),
                t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity)
            }
            return {
                refreshFogUniforms: function(t, e) {
                    t.fogColor.value.copy(e.color),
                    e.isFog ? (t.fogNear.value = e.near,
                    t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                },
                refreshMaterialUniforms: function(t, n, r, s) {
                    n.isMeshBasicMaterial ? e(t, n) : n.isMeshLambertMaterial ? (e(t, n),
                    function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(t, n)) : n.isMeshToonMaterial ? (e(t, n),
                    function(t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap),
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        e.side === Ar && (t.bumpScale.value *= -1)),
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        e.side === Ar && t.normalScale.value.negate()),
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, n)) : n.isMeshPhongMaterial ? (e(t, n),
                    function(t, e) {
                        t.specular.value.copy(e.specular),
                        t.shininess.value = Math.max(e.shininess, 1e-4),
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        e.side === Ar && (t.bumpScale.value *= -1)),
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        e.side === Ar && t.normalScale.value.negate()),
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, n)) : n.isMeshStandardMaterial ? (e(t, n),
                    n.isMeshPhysicalMaterial ? function(t, e) {
                        i(t, e),
                        t.reflectivity.value = e.reflectivity,
                        t.clearcoat.value = e.clearcoat,
                        t.clearcoatRoughness.value = e.clearcoatRoughness,
                        e.sheen && t.sheen.value.copy(e.sheen),
                        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                        e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                        e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                        t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                        e.side === Ar && t.clearcoatNormalScale.value.negate()),
                        t.transmission.value = e.transmission,
                        e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                    }(t, n) : i(t, n)) : n.isMeshMatcapMaterial ? (e(t, n),
                    function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap),
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        e.side === Ar && (t.bumpScale.value *= -1)),
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        e.side === Ar && t.normalScale.value.negate()),
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, n)) : n.isMeshDepthMaterial ? (e(t, n),
                    function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, n)) : n.isMeshDistanceMaterial ? (e(t, n),
                    function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias),
                        t.referencePosition.value.copy(e.referencePosition),
                        t.nearDistance.value = e.nearDistance,
                        t.farDistance.value = e.farDistance
                    }(t, n)) : n.isMeshNormalMaterial ? (e(t, n),
                    function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        e.side === Ar && (t.bumpScale.value *= -1)),
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        e.side === Ar && t.normalScale.value.negate()),
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, n)) : n.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity
                    }(t, n),
                    n.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize,
                        t.totalSize.value = e.dashSize + e.gapSize,
                        t.scale.value = e.scale
                    }(t, n)) : n.isPointsMaterial ? function(t, e, i, n) {
                        let r;
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.size.value = e.size * i,
                        t.scale.value = .5 * n,
                        e.map && (t.map.value = e.map),
                        e.alphaMap && (t.alphaMap.value = e.alphaMap),
                        e.map ? r = e.map : e.alphaMap && (r = e.alphaMap),
                        void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                        t.uvTransform.value.copy(r.matrix))
                    }(t, n, r, s) : n.isSpriteMaterial ? function(t, e) {
                        let i;
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.rotation.value = e.rotation,
                        e.map && (t.map.value = e.map),
                        e.alphaMap && (t.alphaMap.value = e.alphaMap),
                        e.map ? i = e.map : e.alphaMap && (i = e.alphaMap),
                        void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                        t.uvTransform.value.copy(i.matrix))
                    }(t, n) : n.isShadowMaterial ? (t.color.value.copy(n.color),
                    t.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1)
                }
            }
        }
        function ad(t) {
            const e = void 0 !== (t = t || {}).canvas ? t.canvas : function() {
                const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                return t.style.display = "block",
                t
            }()
              , i = void 0 !== t.context ? t.context : null
              , n = void 0 !== t.alpha && t.alpha
              , r = void 0 === t.depth || t.depth
              , s = void 0 === t.stencil || t.stencil
              , a = void 0 !== t.antialias && t.antialias
              , o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
              , h = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
              , l = void 0 !== t.powerPreference ? t.powerPreference : "default"
              , c = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
            let u = null
              , d = null;
            const p = []
              , f = [];
            this.domElement = e,
            this.debug = {
                checkShaderErrors: !0
            },
            this.autoClear = !0,
            this.autoClearColor = !0,
            this.autoClearDepth = !0,
            this.autoClearStencil = !0,
            this.sortObjects = !0,
            this.clippingPlanes = [],
            this.localClippingEnabled = !1,
            this.gammaFactor = 2,
            this.outputEncoding = qa,
            this.physicallyCorrectLights = !1,
            this.toneMapping = hs,
            this.toneMappingExposure = 1,
            this.maxMorphTargets = 8,
            this.maxMorphNormals = 4;
            const m = this;
            let g = !1
              , v = null
              , y = 0
              , x = 0
              , _ = null
              , b = null
              , w = -1
              , M = null;
            const T = new _o
              , E = new _o;
            let S = null
              , A = e.width
              , L = e.height
              , P = 1
              , C = null
              , R = null;
            const O = new _o(0,0,A,L)
              , D = new _o(0,0,A,L);
            let I = !1;
            const N = new $l;
            let z = !1
              , B = !1;
            const k = new $o
              , F = new Mo
              , U = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            function H() {
                return null === _ ? P : 1
            }
            let j, G, W, V, q, X, Y, Z, J, $, Q, K, tt, et, it, nt, rt, st, at, ot, ht, lt = i;
            function ct(t, i) {
                for (let n = 0; n < t.length; n++) {
                    const r = t[n]
                      , s = e.getContext(r, i);
                    if (null !== s)
                        return s
                }
                return null
            }
            try {
                const t = {
                    alpha: n,
                    depth: r,
                    stencil: s,
                    antialias: a,
                    premultipliedAlpha: o,
                    preserveDrawingBuffer: h,
                    powerPreference: l,
                    failIfMajorPerformanceCaveat: c
                };
                if (e.addEventListener("webglcontextlost", ft, !1),
                e.addEventListener("webglcontextrestored", mt, !1),
                null === lt) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === m.isWebGL1Renderer && e.shift(),
                    lt = ct(e, t),
                    null === lt)
                        throw ct(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === lt.getShaderPrecisionFormat && (lt.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                }
                )
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message),
                t
            }
            function ut() {
                j = new cc(lt),
                G = new oc(lt,j,t),
                j.init(G),
                ot = new td(lt,j,G),
                W = new Qu(lt,j,G),
                W.scissor(E.copy(D).multiplyScalar(P).floor()),
                W.viewport(T.copy(O).multiplyScalar(P).floor()),
                V = new pc(lt),
                q = new zu,
                X = new Ku(lt,j,W,q,G,ot,V),
                Y = new lc(m),
                Z = new Kl(lt,G),
                ht = new sc(lt,j,Z,G),
                J = new uc(lt,Z,V,ht),
                $ = new vc(lt,J,Z,V),
                rt = new gc(lt),
                it = new hc(q),
                Q = new Nu(m,Y,j,G,ht,it),
                K = new sd(q),
                tt = new Uu(q),
                et = new qu(j,G),
                nt = new rc(m,Y,W,$,o),
                st = new ac(lt,j,V,G),
                at = new dc(lt,j,V,G),
                V.programs = Q.programs,
                m.capabilities = G,
                m.extensions = j,
                m.properties = q,
                m.renderLists = tt,
                m.state = W,
                m.info = V
            }
            ut();
            const dt = new rd(m,lt);
            this.xr = dt;
            const pt = new $u(m,$,G.maxTextureSize);
            function ft(t) {
                t.preventDefault(),
                console.log("THREE.WebGLRenderer: Context Lost."),
                g = !0
            }
            function mt() {
                console.log("THREE.WebGLRenderer: Context Restored."),
                g = !1,
                ut()
            }
            function gt(t) {
                const e = t.target;
                e.removeEventListener("dispose", gt),
                function(t) {
                    vt(t),
                    q.remove(t)
                }(e)
            }
            function vt(t) {
                const e = q.get(t).program;
                void 0 !== e && Q.releaseProgram(e)
            }
            this.shadowMap = pt,
            this.getContext = function() {
                return lt
            }
            ,
            this.getContextAttributes = function() {
                return lt.getContextAttributes()
            }
            ,
            this.forceContextLoss = function() {
                const t = j.get("WEBGL_lose_context");
                t && t.loseContext()
            }
            ,
            this.forceContextRestore = function() {
                const t = j.get("WEBGL_lose_context");
                t && t.restoreContext()
            }
            ,
            this.getPixelRatio = function() {
                return P
            }
            ,
            this.setPixelRatio = function(t) {
                void 0 !== t && (P = t,
                this.setSize(A, L, !1))
            }
            ,
            this.getSize = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),
                t = new po),
                t.set(A, L)
            }
            ,
            this.setSize = function(t, i, n) {
                dt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (A = t,
                L = i,
                e.width = Math.floor(t * P),
                e.height = Math.floor(i * P),
                !1 !== n && (e.style.width = t + "px",
                e.style.height = i + "px"),
                this.setViewport(0, 0, t, i))
            }
            ,
            this.getDrawingBufferSize = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
                t = new po),
                t.set(A * P, L * P).floor()
            }
            ,
            this.setDrawingBufferSize = function(t, i, n) {
                A = t,
                L = i,
                P = n,
                e.width = Math.floor(t * n),
                e.height = Math.floor(i * n),
                this.setViewport(0, 0, t, i)
            }
            ,
            this.getCurrentViewport = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
                t = new _o),
                t.copy(T)
            }
            ,
            this.getViewport = function(t) {
                return t.copy(O)
            }
            ,
            this.setViewport = function(t, e, i, n) {
                t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, i, n),
                W.viewport(T.copy(O).multiplyScalar(P).floor())
            }
            ,
            this.getScissor = function(t) {
                return t.copy(D)
            }
            ,
            this.setScissor = function(t, e, i, n) {
                t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, i, n),
                W.scissor(E.copy(D).multiplyScalar(P).floor())
            }
            ,
            this.getScissorTest = function() {
                return I
            }
            ,
            this.setScissorTest = function(t) {
                W.setScissorTest(I = t)
            }
            ,
            this.setOpaqueSort = function(t) {
                C = t
            }
            ,
            this.setTransparentSort = function(t) {
                R = t
            }
            ,
            this.getClearColor = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),
                t = new qh),
                t.copy(nt.getClearColor())
            }
            ,
            this.setClearColor = function() {
                nt.setClearColor.apply(nt, arguments)
            }
            ,
            this.getClearAlpha = function() {
                return nt.getClearAlpha()
            }
            ,
            this.setClearAlpha = function() {
                nt.setClearAlpha.apply(nt, arguments)
            }
            ,
            this.clear = function(t, e, i) {
                let n = 0;
                (void 0 === t || t) && (n |= 16384),
                (void 0 === e || e) && (n |= 256),
                (void 0 === i || i) && (n |= 1024),
                lt.clear(n)
            }
            ,
            this.clearColor = function() {
                this.clear(!0, !1, !1)
            }
            ,
            this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }
            ,
            this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }
            ,
            this.dispose = function() {
                e.removeEventListener("webglcontextlost", ft, !1),
                e.removeEventListener("webglcontextrestored", mt, !1),
                tt.dispose(),
                et.dispose(),
                q.dispose(),
                Y.dispose(),
                $.dispose(),
                ht.dispose(),
                dt.dispose(),
                xt.stop()
            }
            ,
            this.renderBufferImmediate = function(t, e) {
                ht.initAttributes();
                const i = q.get(t);
                t.hasPositions && !i.position && (i.position = lt.createBuffer()),
                t.hasNormals && !i.normal && (i.normal = lt.createBuffer()),
                t.hasUvs && !i.uv && (i.uv = lt.createBuffer()),
                t.hasColors && !i.color && (i.color = lt.createBuffer());
                const n = e.getAttributes();
                t.hasPositions && (lt.bindBuffer(34962, i.position),
                lt.bufferData(34962, t.positionArray, 35048),
                ht.enableAttribute(n.position),
                lt.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)),
                t.hasNormals && (lt.bindBuffer(34962, i.normal),
                lt.bufferData(34962, t.normalArray, 35048),
                ht.enableAttribute(n.normal),
                lt.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)),
                t.hasUvs && (lt.bindBuffer(34962, i.uv),
                lt.bufferData(34962, t.uvArray, 35048),
                ht.enableAttribute(n.uv),
                lt.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)),
                t.hasColors && (lt.bindBuffer(34962, i.color),
                lt.bufferData(34962, t.colorArray, 35048),
                ht.enableAttribute(n.color),
                lt.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)),
                ht.disableUnusedAttributes(),
                lt.drawArrays(4, 0, t.count),
                t.count = 0
            }
            ,
            this.renderBufferDirect = function(t, e, i, n, r, s) {
                null === e && (e = U);
                const a = r.isMesh && r.matrixWorld.determinant() < 0
                  , o = Tt(t, e, n, r);
                W.setMaterial(n, a);
                let h = i.index;
                const l = i.attributes.position;
                if (null === h) {
                    if (void 0 === l || 0 === l.count)
                        return
                } else if (0 === h.count)
                    return;
                let c, u = 1;
                !0 === n.wireframe && (h = J.getWireframeAttribute(i),
                u = 2),
                (n.morphTargets || n.morphNormals) && rt.update(r, i, n, o),
                ht.setup(r, n, o, i, h);
                let d = st;
                null !== h && (c = Z.get(h),
                d = at,
                d.setIndex(c));
                const p = null !== h ? h.count : l.count
                  , f = i.drawRange.start * u
                  , m = i.drawRange.count * u
                  , g = null !== s ? s.start * u : 0
                  , v = null !== s ? s.count * u : 1 / 0
                  , y = Math.max(f, g)
                  , x = Math.min(p, f + m, g + v) - 1
                  , _ = Math.max(0, x - y + 1);
                if (0 !== _) {
                    if (r.isMesh)
                        !0 === n.wireframe ? (W.setLineWidth(n.wireframeLinewidth * H()),
                        d.setMode(1)) : d.setMode(4);
                    else if (r.isLine) {
                        let t = n.linewidth;
                        void 0 === t && (t = 1),
                        W.setLineWidth(t * H()),
                        r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                    } else
                        r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                    if (r.isInstancedMesh)
                        d.renderInstances(y, _, r.count);
                    else if (i.isInstancedBufferGeometry) {
                        const t = Math.min(i.instanceCount, i._maxInstanceCount);
                        d.renderInstances(y, _, t)
                    } else
                        d.render(y, _)
                }
            }
            ,
            this.compile = function(t, e) {
                d = et.get(t),
                d.init(),
                t.traverseVisible((function(t) {
                    t.isLight && t.layers.test(e.layers) && (d.pushLight(t),
                    t.castShadow && d.pushShadow(t))
                }
                )),
                d.setupLights();
                const i = new WeakMap;
                t.traverse((function(e) {
                    const n = e.material;
                    if (n)
                        if (Array.isArray(n))
                            for (let r = 0; r < n.length; r++) {
                                const s = n[r];
                                !1 === i.has(s) && (Mt(s, t, e),
                                i.set(s))
                            }
                        else
                            !1 === i.has(n) && (Mt(n, t, e),
                            i.set(n))
                }
                ))
            }
            ;
            let yt = null;
            const xt = new Ql;
            function _t(t, e, i, n) {
                if (!1 === t.visible)
                    return;
                if (t.layers.test(e.layers))
                    if (t.isGroup)
                        i = t.renderOrder;
                    else if (t.isLOD)
                        !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight)
                        d.pushLight(t),
                        t.castShadow && d.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || N.intersectsSprite(t)) {
                            n && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
                            const e = $.update(t)
                              , r = t.material;
                            r.visible && u.push(t, e, r, i, F.z, null)
                        }
                    } else if (t.isImmediateRenderObject)
                        n && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k),
                        u.push(t, null, t.material, i, F.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== V.render.frame && (t.skeleton.update(),
                    t.skeleton.frame = V.render.frame),
                    !t.frustumCulled || N.intersectsObject(t))) {
                        n && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
                        const e = $.update(t)
                          , r = t.material;
                        if (Array.isArray(r)) {
                            const n = e.groups;
                            for (let s = 0, a = n.length; s < a; s++) {
                                const a = n[s]
                                  , o = r[a.materialIndex];
                                o && o.visible && u.push(t, e, o, i, F.z, a)
                            }
                        } else
                            r.visible && u.push(t, e, r, i, F.z, null)
                    }
                const r = t.children;
                for (let t = 0, s = r.length; t < s; t++)
                    _t(r[t], e, i, n)
            }
            function bt(t, e, i) {
                const n = !0 === e.isScene ? e.overrideMaterial : null;
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r]
                      , a = s.object
                      , o = s.geometry
                      , h = null === n ? s.material : n
                      , l = s.group;
                    if (i.isArrayCamera) {
                        const t = i.cameras;
                        for (let i = 0, n = t.length; i < n; i++) {
                            const n = t[i];
                            a.layers.test(n.layers) && (W.viewport(T.copy(n.viewport)),
                            d.setupLightsView(n),
                            wt(a, e, n, o, h, l))
                        }
                    } else
                        wt(a, e, i, o, h, l)
                }
            }
            function wt(t, e, i, n, r, s) {
                if (t.onBeforeRender(m, e, i, n, r, s),
                t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld),
                t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                t.isImmediateRenderObject) {
                    const n = Tt(i, e, r, t);
                    W.setMaterial(r),
                    ht.reset(),
                    function(t, e) {
                        t.render((function(t) {
                            m.renderBufferImmediate(t, e)
                        }
                        ))
                    }(t, n)
                } else
                    m.renderBufferDirect(i, e, n, r, t, s);
                t.onAfterRender(m, e, i, n, r, s)
            }
            function Mt(t, e, i) {
                !0 !== e.isScene && (e = U);
                const n = q.get(t)
                  , r = d.state.lights
                  , s = d.state.shadowsArray
                  , a = r.state.version
                  , o = Q.getParameters(t, r.state, s, e, i)
                  , h = Q.getProgramCacheKey(o);
                let l = n.program
                  , c = !0;
                if (n.environment = t.isMeshStandardMaterial ? e.environment : null,
                n.fog = e.fog,
                n.envMap = Y.get(t.envMap || n.environment),
                void 0 === l)
                    t.addEventListener("dispose", gt);
                else if (l.cacheKey !== h)
                    vt(t);
                else if (n.lightsStateVersion !== a)
                    c = !1;
                else {
                    if (void 0 !== o.shaderID)
                        return;
                    c = !1
                }
                c && (o.uniforms = Q.getUniforms(t),
                t.onBeforeCompile(o, m),
                l = Q.acquireProgram(o, h),
                n.program = l,
                n.uniforms = o.uniforms,
                n.outputEncoding = o.outputEncoding);
                const u = n.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = it.numPlanes,
                n.numIntersection = it.numIntersection,
                u.clippingPlanes = it.uniform),
                n.needsLights = function(t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t),
                n.lightsStateVersion = a,
                n.needsLights && (u.ambientLightColor.value = r.state.ambient,
                u.lightProbe.value = r.state.probe,
                u.directionalLights.value = r.state.directional,
                u.directionalLightShadows.value = r.state.directionalShadow,
                u.spotLights.value = r.state.spot,
                u.spotLightShadows.value = r.state.spotShadow,
                u.rectAreaLights.value = r.state.rectArea,
                u.ltc_1.value = r.state.rectAreaLTC1,
                u.ltc_2.value = r.state.rectAreaLTC2,
                u.pointLights.value = r.state.point,
                u.pointLightShadows.value = r.state.pointShadow,
                u.hemisphereLights.value = r.state.hemi,
                u.directionalShadowMap.value = r.state.directionalShadowMap,
                u.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                u.spotShadowMap.value = r.state.spotShadowMap,
                u.spotShadowMatrix.value = r.state.spotShadowMatrix,
                u.pointShadowMap.value = r.state.pointShadowMap,
                u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                const p = n.program.getUniforms()
                  , f = fu.seqWithValue(p.seq, u);
                n.uniformsList = f
            }
            function Tt(t, e, i, n) {
                !0 !== e.isScene && (e = U),
                X.resetTextureUnits();
                const r = e.fog
                  , s = i.isMeshStandardMaterial ? e.environment : null
                  , a = null === _ ? m.outputEncoding : _.texture.encoding
                  , o = Y.get(i.envMap || s)
                  , h = q.get(i)
                  , l = d.state.lights;
                if (!0 === z && (!0 === B || t !== M)) {
                    const e = t === M && i.id === w;
                    it.setState(i, t, e)
                }
                i.version === h.__version ? i.fog && h.fog !== r || h.environment !== s || h.needsLights && h.lightsStateVersion !== l.state.version ? Mt(i, e, n) : void 0 === h.numClippingPlanes || h.numClippingPlanes === it.numPlanes && h.numIntersection === it.numIntersection ? (h.outputEncoding !== a || h.envMap !== o) && Mt(i, e, n) : Mt(i, e, n) : (Mt(i, e, n),
                h.__version = i.version);
                let c = !1
                  , u = !1
                  , p = !1;
                const f = h.program
                  , g = f.getUniforms()
                  , v = h.uniforms;
                if (W.useProgram(f.program) && (c = !0,
                u = !0,
                p = !0),
                i.id !== w && (w = i.id,
                u = !0),
                c || M !== t) {
                    if (g.setValue(lt, "projectionMatrix", t.projectionMatrix),
                    G.logarithmicDepthBuffer && g.setValue(lt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                    M !== t && (M = t,
                    u = !0,
                    p = !0),
                    i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                        const e = g.map.cameraPosition;
                        void 0 !== e && e.setValue(lt, F.setFromMatrixPosition(t.matrixWorld))
                    }
                    (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && g.setValue(lt, "isOrthographic", !0 === t.isOrthographicCamera),
                    (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || i.skinning) && g.setValue(lt, "viewMatrix", t.matrixWorldInverse)
                }
                if (i.skinning) {
                    g.setOptional(lt, n, "bindMatrix"),
                    g.setOptional(lt, n, "bindMatrixInverse");
                    const t = n.skeleton;
                    if (t) {
                        const e = t.bones;
                        if (G.floatVertexTextures) {
                            if (null === t.boneTexture) {
                                let i = Math.sqrt(4 * e.length);
                                i = uo.ceilPowerOfTwo(i),
                                i = Math.max(i, 4);
                                const n = new Float32Array(i * i * 4);
                                n.set(t.boneMatrices);
                                const r = new Yl(n,i,i,Gs,Ns);
                                t.boneMatrices = n,
                                t.boneTexture = r,
                                t.boneTextureSize = i
                            }
                            g.setValue(lt, "boneTexture", t.boneTexture, X),
                            g.setValue(lt, "boneTextureSize", t.boneTextureSize)
                        } else
                            g.setOptional(lt, t, "boneMatrices")
                    }
                }
                var y, x;
                return (u || h.receiveShadow !== n.receiveShadow) && (h.receiveShadow = n.receiveShadow,
                g.setValue(lt, "receiveShadow", n.receiveShadow)),
                u && (g.setValue(lt, "toneMappingExposure", m.toneMappingExposure),
                h.needsLights && (x = p,
                (y = v).ambientLightColor.needsUpdate = x,
                y.lightProbe.needsUpdate = x,
                y.directionalLights.needsUpdate = x,
                y.directionalLightShadows.needsUpdate = x,
                y.pointLights.needsUpdate = x,
                y.pointLightShadows.needsUpdate = x,
                y.spotLights.needsUpdate = x,
                y.spotLightShadows.needsUpdate = x,
                y.rectAreaLights.needsUpdate = x,
                y.hemisphereLights.needsUpdate = x),
                r && i.fog && K.refreshFogUniforms(v, r),
                K.refreshMaterialUniforms(v, i, P, L),
                fu.upload(lt, h.uniformsList, v, X)),
                i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (fu.upload(lt, h.uniformsList, v, X),
                i.uniformsNeedUpdate = !1),
                i.isSpriteMaterial && g.setValue(lt, "center", n.center),
                g.setValue(lt, "modelViewMatrix", n.modelViewMatrix),
                g.setValue(lt, "normalMatrix", n.normalMatrix),
                g.setValue(lt, "modelMatrix", n.matrixWorld),
                f
            }
            xt.setAnimationLoop((function(t) {
                dt.isPresenting || yt && yt(t)
            }
            )),
            "undefined" != typeof window && xt.setContext(window),
            this.setAnimationLoop = function(t) {
                yt = t,
                dt.setAnimationLoop(t),
                null === t ? xt.stop() : xt.start()
            }
            ,
            this.render = function(t, e) {
                let i, n;
                if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),
                i = arguments[2]),
                void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),
                n = arguments[3]),
                void 0 !== e && !0 !== e.isCamera)
                    return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!0 === g)
                    return;
                ht.resetDefaultState(),
                w = -1,
                M = null,
                !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                !0 === dt.enabled && !0 === dt.isPresenting && (e = dt.getCamera(e)),
                !0 === t.isScene && t.onBeforeRender(m, t, e, i || _),
                d = et.get(t, f.length),
                d.init(),
                f.push(d),
                k.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                N.setFromProjectionMatrix(k),
                B = this.localClippingEnabled,
                z = it.init(this.clippingPlanes, B, e),
                u = tt.get(t, p.length),
                u.init(),
                p.push(u),
                _t(t, e, 0, m.sortObjects),
                u.finish(),
                !0 === m.sortObjects && u.sort(C, R),
                !0 === z && it.beginShadows();
                const r = d.state.shadowsArray;
                pt.render(r, t, e),
                d.setupLights(),
                d.setupLightsView(e),
                !0 === z && it.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                void 0 !== i && this.setRenderTarget(i),
                nt.render(u, t, e, n);
                const s = u.opaque
                  , a = u.transparent;
                s.length > 0 && bt(s, t, e),
                a.length > 0 && bt(a, t, e),
                !0 === t.isScene && t.onAfterRender(m, t, e),
                null !== _ && (X.updateRenderTargetMipmap(_),
                X.updateMultisampleRenderTarget(_)),
                W.buffers.depth.setTest(!0),
                W.buffers.depth.setMask(!0),
                W.buffers.color.setMask(!0),
                W.setPolygonOffset(!1),
                f.pop(),
                d = f.length > 0 ? f[f.length - 1] : null,
                p.pop(),
                u = p.length > 0 ? p[p.length - 1] : null
            }
            ,
            this.setFramebuffer = function(t) {
                v !== t && null === _ && lt.bindFramebuffer(36160, t),
                v = t
            }
            ,
            this.getActiveCubeFace = function() {
                return y
            }
            ,
            this.getActiveMipmapLevel = function() {
                return x
            }
            ,
            this.getRenderTarget = function() {
                return _
            }
            ,
            this.setRenderTarget = function(t, e=0, i=0) {
                _ = t,
                y = e,
                x = i,
                t && void 0 === q.get(t).__webglFramebuffer && X.setupRenderTarget(t);
                let n = v
                  , r = !1
                  , s = !1;
                if (t) {
                    const i = t.texture;
                    (i.isDataTexture3D || i.isDataTexture2DArray) && (s = !0);
                    const a = q.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (n = a[e],
                    r = !0) : n = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : a,
                    T.copy(t.viewport),
                    E.copy(t.scissor),
                    S = t.scissorTest
                } else
                    T.copy(O).multiplyScalar(P).floor(),
                    E.copy(D).multiplyScalar(P).floor(),
                    S = I;
                if (b !== n && (lt.bindFramebuffer(36160, n),
                b = n),
                W.viewport(T),
                W.scissor(E),
                W.setScissorTest(S),
                r) {
                    const n = q.get(t.texture);
                    lt.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, i)
                } else if (s) {
                    const n = q.get(t.texture)
                      , r = e || 0;
                    lt.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, r)
                }
            }
            ,
            this.readRenderTargetPixels = function(t, e, i, n, r, s, a) {
                if (!t || !t.isWebGLRenderTarget)
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let o = q.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]),
                o) {
                    let a = !1;
                    o !== b && (lt.bindFramebuffer(36160, o),
                    a = !0);
                    try {
                        const a = t.texture
                          , o = a.format
                          , h = a.type;
                        if (o !== Gs && ot.convert(o) !== lt.getParameter(35739))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const l = h === zs && (j.has("EXT_color_buffer_half_float") || G.isWebGL2 && j.has("EXT_color_buffer_float"));
                        if (!(h === Ps || ot.convert(h) === lt.getParameter(35738) || h === Ns && (G.isWebGL2 || j.has("OES_texture_float") || j.has("WEBGL_color_buffer_float")) || l))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === lt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && lt.readPixels(e, i, n, r, ot.convert(o), ot.convert(h), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        a && lt.bindFramebuffer(36160, b)
                    }
                }
            }
            ,
            this.copyFramebufferToTexture = function(t, e, i=0) {
                const n = Math.pow(2, -i)
                  , r = Math.floor(e.image.width * n)
                  , s = Math.floor(e.image.height * n)
                  , a = ot.convert(e.format);
                X.setTexture2D(e, 0),
                lt.copyTexImage2D(3553, i, a, t.x, t.y, r, s, 0),
                W.unbindTexture()
            }
            ,
            this.copyTextureToTexture = function(t, e, i, n=0) {
                const r = e.image.width
                  , s = e.image.height
                  , a = ot.convert(i.format)
                  , o = ot.convert(i.type);
                X.setTexture2D(i, 0),
                lt.pixelStorei(37440, i.flipY),
                lt.pixelStorei(37441, i.premultiplyAlpha),
                lt.pixelStorei(3317, i.unpackAlignment),
                e.isDataTexture ? lt.texSubImage2D(3553, n, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? lt.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : lt.texSubImage2D(3553, n, t.x, t.y, a, o, e.image),
                0 === n && i.generateMipmaps && lt.generateMipmap(3553),
                W.unbindTexture()
            }
            ,
            this.copyTextureToTexture3D = function(t, e, i, n, r=0) {
                if (m.isWebGL1Renderer)
                    return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const {width: s, height: a, data: o} = i.image
                  , h = ot.convert(n.format)
                  , l = ot.convert(n.type);
                let c;
                if (n.isDataTexture3D)
                    X.setTexture3D(n, 0),
                    c = 32879;
                else {
                    if (!n.isDataTexture2DArray)
                        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    X.setTexture2DArray(n, 0),
                    c = 35866
                }
                lt.pixelStorei(37440, n.flipY),
                lt.pixelStorei(37441, n.premultiplyAlpha),
                lt.pixelStorei(3317, n.unpackAlignment);
                const u = lt.getParameter(3314)
                  , d = lt.getParameter(32878)
                  , p = lt.getParameter(3316)
                  , f = lt.getParameter(3315)
                  , g = lt.getParameter(32877);
                lt.pixelStorei(3314, s),
                lt.pixelStorei(32878, a),
                lt.pixelStorei(3316, t.min.x),
                lt.pixelStorei(3315, t.min.y),
                lt.pixelStorei(32877, t.min.z),
                lt.texSubImage3D(c, r, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, h, l, o),
                lt.pixelStorei(3314, u),
                lt.pixelStorei(32878, d),
                lt.pixelStorei(3316, p),
                lt.pixelStorei(3315, f),
                lt.pixelStorei(32877, g),
                0 === r && n.generateMipmaps && lt.generateMipmap(c),
                W.unbindTexture()
            }
            ,
            this.initTexture = function(t) {
                X.setTexture2D(t, 0),
                W.unbindTexture()
            }
            ,
            this.resetState = function() {
                W.reset(),
                ht.reset()
            }
            ,
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        id.prototype.isGroup = !0,
        Object.assign(nd.prototype, {
            constructor: nd,
            getHandSpace: function() {
                return null === this._hand && (this._hand = new id,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            },
            getTargetRaySpace: function() {
                return null === this._targetRay && (this._targetRay = new id,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1),
                this._targetRay
            },
            getGripSpace: function() {
                return null === this._grip && (this._grip = new id,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1),
                this._grip
            },
            dispatchEvent: function(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t),
                null !== this._grip && this._grip.dispatchEvent(t),
                null !== this._hand && this._hand.dispatchEvent(t),
                this
            },
            disconnect: function(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
            },
            update: function(t, e, i) {
                let n = null
                  , r = null
                  , s = null;
                const a = this._targetRay
                  , o = this._grip
                  , h = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState)
                    if (h && t.hand) {
                        s = !0;
                        for (const n of t.hand.values()) {
                            const t = e.getJointPose(n, i);
                            if (void 0 === h.joints[n.jointName]) {
                                const t = new id;
                                t.matrixAutoUpdate = !1,
                                t.visible = !1,
                                h.joints[n.jointName] = t,
                                h.add(t)
                            }
                            const r = h.joints[n.jointName];
                            null !== t && (r.matrix.fromArray(t.transform.matrix),
                            r.matrix.decompose(r.position, r.rotation, r.scale),
                            r.jointRadius = t.radius),
                            r.visible = null !== t
                        }
                        const n = h.joints["index-finger-tip"]
                          , r = h.joints["thumb-tip"]
                          , a = n.position.distanceTo(r.position)
                          , o = .02
                          , l = .005;
                        h.inputState.pinching && a > o + l ? (h.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !h.inputState.pinching && a <= o - l && (h.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else
                        null !== a && (n = e.getPose(t.targetRaySpace, i),
                        null !== n && (a.matrix.fromArray(n.transform.matrix),
                        a.matrix.decompose(a.position, a.rotation, a.scale))),
                        null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, i),
                        null !== r && (o.matrix.fromArray(r.transform.matrix),
                        o.matrix.decompose(o.position, o.rotation, o.scale)));
                return null !== a && (a.visible = null !== n),
                null !== o && (o.visible = null !== r),
                null !== h && (h.visible = null !== s),
                this
            }
        }),
        Object.assign(rd.prototype, ho.prototype),
        class extends ad {
        }
        .prototype.isWebGL1Renderer = !0;
        class od {
            constructor(t, e) {
                this.name = "",
                this.color = new qh(t),
                this.density = void 0 !== e ? e : 25e-5
            }
            clone() {
                return new od(this.color,this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        od.prototype.isFogExp2 = !0;
        class hd {
            constructor(t, e, i) {
                this.name = "",
                this.color = new qh(t),
                this.near = void 0 !== e ? e : 1,
                this.far = void 0 !== i ? i : 1e3
            }
            clone() {
                return new hd(this.color,this.near,this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        hd.prototype.isFog = !0;
        class ld extends wh {
            constructor() {
                super(),
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.overrideMaterial = null,
                this.autoUpdate = !0,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e),
                null !== t.background && (this.background = t.background.clone()),
                null !== t.environment && (this.environment = t.environment.clone()),
                null !== t.fog && (this.fog = t.fog.clone()),
                null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
                this.autoUpdate = t.autoUpdate,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)),
                null !== this.environment && (e.object.environment = this.environment.toJSON(t)),
                null !== this.fog && (e.object.fog = this.fog.toJSON()),
                e
            }
        }
        function cd(t, e) {
            this.array = t,
            this.stride = e,
            this.count = void 0 !== t ? t.length / e : 0,
            this.usage = so,
            this.updateRange = {
                offset: 0,
                count: -1
            },
            this.version = 0,
            this.uuid = uo.generateUUID()
        }
        ld.prototype.isScene = !0,
        Object.defineProperty(cd.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }),
        Object.assign(cd.prototype, {
            isInterleavedBuffer: !0,
            onUploadCallback: function() {},
            setUsage: function(t) {
                return this.usage = t,
                this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array),
                this.count = t.count,
                this.stride = t.stride,
                this.usage = t.usage,
                this
            },
            copyAt: function(t, e, i) {
                t *= this.stride,
                i *= e.stride;
                for (let n = 0, r = this.stride; n < r; n++)
                    this.array[t + n] = e.array[i + n];
                return this
            },
            set: function(t, e=0) {
                return this.array.set(t, e),
                this
            },
            clone: function(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = uo.generateUUID()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new cd(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),this.stride);
                return e.setUsage(this.usage),
                e
            },
            onUpload: function(t) {
                return this.onUploadCallback = t,
                this
            },
            toJSON: function(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = uo.generateUUID()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        });
        const ud = new Mo;
        function dd(t, e, i, n) {
            this.name = "",
            this.data = t,
            this.itemSize = e,
            this.offset = i,
            this.normalized = !0 === n
        }
        Object.defineProperties(dd.prototype, {
            count: {
                get: function() {
                    return this.data.count
                }
            },
            array: {
                get: function() {
                    return this.data.array
                }
            },
            needsUpdate: {
                set: function(t) {
                    this.data.needsUpdate = t
                }
            }
        }),
        Object.assign(dd.prototype, {
            isInterleavedBufferAttribute: !0,
            applyMatrix4: function(t) {
                for (let e = 0, i = this.data.count; e < i; e++)
                    ud.x = this.getX(e),
                    ud.y = this.getY(e),
                    ud.z = this.getZ(e),
                    ud.applyMatrix4(t),
                    this.setXYZ(e, ud.x, ud.y, ud.z);
                return this
            },
            setX: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e,
                this
            },
            setY: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e,
                this
            },
            setZ: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e,
                this
            },
            setW: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e,
                this
            },
            getX: function(t) {
                return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function(t, e, i) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = i,
                this
            },
            setXYZ: function(t, e, i, n) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = i,
                this.data.array[t + 2] = n,
                this
            },
            setXYZW: function(t, e, i, n, r) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = i,
                this.data.array[t + 2] = n,
                this.data.array[t + 3] = r,
                this
            },
            clone: function(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const i = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                            t.push(this.data.array[i + e])
                    }
                    return new Jh(new this.array.constructor(t),this.itemSize,this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                new dd(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            },
            toJSON: function(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const i = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                            t.push(this.data.array[i + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        });
        class pd extends Fh {
            constructor(t) {
                super(),
                this.type = "SpriteMaterial",
                this.color = new qh(16777215),
                this.map = null,
                this.alphaMap = null,
                this.rotation = 0,
                this.sizeAttenuation = !0,
                this.transparent = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.rotation = t.rotation,
                this.sizeAttenuation = t.sizeAttenuation,
                this
            }
        }
        let fd;
        pd.prototype.isSpriteMaterial = !0;
        const md = new Mo
          , gd = new Mo
          , vd = new Mo
          , yd = new po
          , xd = new po
          , _d = new $o
          , bd = new Mo
          , wd = new Mo
          , Md = new Mo
          , Td = new po
          , Ed = new po
          , Sd = new po;
        function Ad(t, e, i, n, r, s) {
            yd.subVectors(t, i).addScalar(.5).multiply(n),
            void 0 !== r ? (xd.x = s * yd.x - r * yd.y,
            xd.y = r * yd.x + s * yd.y) : xd.copy(yd),
            t.copy(e),
            t.x += xd.x,
            t.y += xd.y,
            t.applyMatrix4(_d)
        }
        (class extends wh {
            constructor(t) {
                if (super(),
                this.type = "Sprite",
                void 0 === fd) {
                    fd = new ml;
                    const t = new cd(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5);
                    fd.setIndex([0, 1, 2, 0, 2, 3]),
                    fd.setAttribute("position", new dd(t,3,0,!1)),
                    fd.setAttribute("uv", new dd(t,2,3,!1))
                }
                this.geometry = fd,
                this.material = void 0 !== t ? t : new pd,
                this.center = new po(.5,.5)
            }
            raycast(t, e) {
                null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                gd.setFromMatrixScale(this.matrixWorld),
                _d.copy(t.camera.matrixWorld),
                this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
                vd.setFromMatrixPosition(this.modelViewMatrix),
                t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && gd.multiplyScalar(-vd.z);
                const i = this.material.rotation;
                let n, r;
                0 !== i && (r = Math.cos(i),
                n = Math.sin(i));
                const s = this.center;
                Ad(bd.set(-.5, -.5, 0), vd, s, gd, n, r),
                Ad(wd.set(.5, -.5, 0), vd, s, gd, n, r),
                Ad(Md.set(.5, .5, 0), vd, s, gd, n, r),
                Td.set(0, 0),
                Ed.set(1, 0),
                Sd.set(1, 1);
                let a = t.ray.intersectTriangle(bd, wd, Md, !1, md);
                if (null === a && (Ad(wd.set(-.5, .5, 0), vd, s, gd, n, r),
                Ed.set(0, 1),
                a = t.ray.intersectTriangle(bd, Md, wd, !1, md),
                null === a))
                    return;
                const o = t.ray.origin.distanceTo(md);
                o < t.near || o > t.far || e.push({
                    distance: o,
                    point: md.clone(),
                    uv: Bh.getUV(md, bd, wd, Md, Td, Ed, Sd, new po),
                    face: null,
                    object: this
                })
            }
            copy(t) {
                return super.copy(t),
                void 0 !== t.center && this.center.copy(t.center),
                this.material = t.material,
                this
            }
        }
        ).prototype.isSprite = !0;
        const Ld = new Mo
          , Pd = new Mo;
        const Cd = new Mo
          , Rd = new _o
          , Od = new _o
          , Dd = new Mo
          , Id = new $o;
        function Nd(t, e) {
            Dl.call(this, t, e),
            this.type = "SkinnedMesh",
            this.bindMode = "attached",
            this.bindMatrix = new $o,
            this.bindMatrixInverse = new $o
        }
        function zd() {
            wh.call(this),
            this.type = "Bone"
        }
        Nd.prototype = Object.assign(Object.create(Dl.prototype), {
            constructor: Nd,
            isSkinnedMesh: !0,
            copy: function(t) {
                return Dl.prototype.copy.call(this, t),
                this.bindMode = t.bindMode,
                this.bindMatrix.copy(t.bindMatrix),
                this.bindMatrixInverse.copy(t.bindMatrixInverse),
                this.skeleton = t.skeleton,
                this
            },
            bind: function(t, e) {
                this.skeleton = t,
                void 0 === e && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                e = this.matrixWorld),
                this.bindMatrix.copy(e),
                this.bindMatrixInverse.copy(e).invert()
            },
            pose: function() {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function() {
                const t = new _o
                  , e = this.geometry.attributes.skinWeight;
                for (let i = 0, n = e.count; i < n; i++) {
                    t.x = e.getX(i),
                    t.y = e.getY(i),
                    t.z = e.getZ(i),
                    t.w = e.getW(i);
                    const n = 1 / t.manhattanLength();
                    n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0),
                    e.setXYZW(i, t.x, t.y, t.z, t.w)
                }
            },
            updateMatrixWorld: function(t) {
                Dl.prototype.updateMatrixWorld.call(this, t),
                "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            },
            boneTransform: function(t, e) {
                const i = this.skeleton
                  , n = this.geometry;
                Rd.fromBufferAttribute(n.attributes.skinIndex, t),
                Od.fromBufferAttribute(n.attributes.skinWeight, t),
                Cd.fromBufferAttribute(n.attributes.position, t).applyMatrix4(this.bindMatrix),
                e.set(0, 0, 0);
                for (let t = 0; t < 4; t++) {
                    const n = Od.getComponent(t);
                    if (0 !== n) {
                        const r = Rd.getComponent(t);
                        Id.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]),
                        e.addScaledVector(Dd.copy(Cd).applyMatrix4(Id), n)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }),
        zd.prototype = Object.assign(Object.create(wh.prototype), {
            constructor: zd,
            isBone: !0
        });
        const Bd = new $o
          , kd = new $o;
        class Fd {
            constructor(t=[], e=[]) {
                this.uuid = uo.generateUUID(),
                this.bones = t.slice(0),
                this.boneInverses = e,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.boneTextureSize = 0,
                this.frame = -1,
                this.init()
            }
            init() {
                const t = this.bones
                  , e = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * t.length),
                0 === e.length)
                    this.calculateInverses();
                else if (t.length !== e.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++)
                        this.boneInverses.push(new $o)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = new $o;
                    this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                    this.boneInverses.push(e)
                }
            }
            pose() {
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                }
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                    e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                    e.matrix.decompose(e.position, e.quaternion, e.scale))
                }
            }
            update() {
                const t = this.bones
                  , e = this.boneInverses
                  , i = this.boneMatrices
                  , n = this.boneTexture;
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n] ? t[n].matrixWorld : kd;
                    Bd.multiplyMatrices(r, e[n]),
                    Bd.toArray(i, 16 * n)
                }
                null !== n && (n.needsUpdate = !0)
            }
            clone() {
                return new Fd(this.bones,this.boneInverses)
            }
            getBoneByName(t) {
                for (let e = 0, i = this.bones.length; e < i; e++) {
                    const i = this.bones[e];
                    if (i.name === t)
                        return i
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(t, e) {
                this.uuid = t.uuid;
                for (let i = 0, n = t.bones.length; i < n; i++) {
                    const n = t.bones[i];
                    let r = e[n];
                    void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", n),
                    r = new zd),
                    this.bones.push(r),
                    this.boneInverses.push((new $o).fromArray(t.boneInverses[i]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                t.uuid = this.uuid;
                const e = this.bones
                  , i = this.boneInverses;
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = e[n];
                    t.bones.push(r.uuid);
                    const s = i[n];
                    t.boneInverses.push(s.toArray())
                }
                return t
            }
        }
        const Ud = new $o
          , Hd = new $o
          , jd = []
          , Gd = new Dl;
        function Wd(t, e, i) {
            Dl.call(this, t, e),
            this.instanceMatrix = new Jh(new Float32Array(16 * i),16),
            this.instanceColor = null,
            this.count = i,
            this.frustumCulled = !1
        }
        Wd.prototype = Object.assign(Object.create(Dl.prototype), {
            constructor: Wd,
            isInstancedMesh: !0,
            copy: function(t) {
                return Dl.prototype.copy.call(this, t),
                this.instanceMatrix.copy(t.instanceMatrix),
                null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
                this.count = t.count,
                this
            },
            getColorAt: function(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            },
            getMatrixAt: function(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            },
            raycast: function(t, e) {
                const i = this.matrixWorld
                  , n = this.count;
                if (Gd.geometry = this.geometry,
                Gd.material = this.material,
                void 0 !== Gd.material)
                    for (let r = 0; r < n; r++) {
                        this.getMatrixAt(r, Ud),
                        Hd.multiplyMatrices(i, Ud),
                        Gd.matrixWorld = Hd,
                        Gd.raycast(t, jd);
                        for (let t = 0, i = jd.length; t < i; t++) {
                            const i = jd[t];
                            i.instanceId = r,
                            i.object = this,
                            e.push(i)
                        }
                        jd.length = 0
                    }
            },
            setColorAt: function(t, e) {
                null === this.instanceColor && (this.instanceColor = new Jh(new Float32Array(3 * this.count),3)),
                e.toArray(this.instanceColor.array, 3 * t)
            },
            setMatrixAt: function(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            },
            updateMorphTargets: function() {},
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        class Vd extends Fh {
            constructor(t) {
                super(),
                this.type = "LineBasicMaterial",
                this.color = new qh(16777215),
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.morphTargets = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.linewidth = t.linewidth,
                this.linecap = t.linecap,
                this.linejoin = t.linejoin,
                this.morphTargets = t.morphTargets,
                this
            }
        }
        Vd.prototype.isLineBasicMaterial = !0;
        const qd = new Mo
          , Xd = new Mo
          , Yd = new $o
          , Zd = new Jo
          , Jd = new jo;
        function $d(t=new ml, e=new Vd) {
            wh.call(this),
            this.type = "Line",
            this.geometry = t,
            this.material = e,
            this.updateMorphTargets()
        }
        $d.prototype = Object.assign(Object.create(wh.prototype), {
            constructor: $d,
            isLine: !0,
            copy: function(t) {
                return wh.prototype.copy.call(this, t),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            },
            computeLineDistances: function() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position
                          , i = [0];
                        for (let t = 1, n = e.count; t < n; t++)
                            qd.fromBufferAttribute(e, t - 1),
                            Xd.fromBufferAttribute(e, t),
                            i[t] = i[t - 1],
                            i[t] += qd.distanceTo(Xd);
                        t.setAttribute("lineDistance", new sl(i,1))
                    } else
                        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else
                    t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            },
            raycast: function(t, e) {
                const i = this.geometry
                  , n = this.matrixWorld
                  , r = t.params.Line.threshold;
                if (null === i.boundingSphere && i.computeBoundingSphere(),
                Jd.copy(i.boundingSphere),
                Jd.applyMatrix4(n),
                Jd.radius += r,
                !1 === t.ray.intersectsSphere(Jd))
                    return;
                Yd.copy(n).invert(),
                Zd.copy(t.ray).applyMatrix4(Yd);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , a = s * s
                  , o = new Mo
                  , h = new Mo
                  , l = new Mo
                  , c = new Mo
                  , u = this.isLineSegments ? 2 : 1;
                if (i.isBufferGeometry) {
                    const n = i.index
                      , r = i.attributes.position;
                    if (null !== n) {
                        const i = n.array;
                        for (let n = 0, s = i.length - 1; n < s; n += u) {
                            const s = i[n]
                              , u = i[n + 1];
                            if (o.fromBufferAttribute(r, s),
                            h.fromBufferAttribute(r, u),
                            Zd.distanceSqToSegment(o, h, c, l) > a)
                                continue;
                            c.applyMatrix4(this.matrixWorld);
                            const d = t.ray.origin.distanceTo(c);
                            d < t.near || d > t.far || e.push({
                                distance: d,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else
                        for (let i = 0, n = r.count - 1; i < n; i += u) {
                            if (o.fromBufferAttribute(r, i),
                            h.fromBufferAttribute(r, i + 1),
                            Zd.distanceSqToSegment(o, h, c, l) > a)
                                continue;
                            c.applyMatrix4(this.matrixWorld);
                            const n = t.ray.origin.distanceTo(c);
                            n < t.near || n > t.far || e.push({
                                distance: n,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                } else
                    i.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            },
            updateMorphTargets: function() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , i = Object.keys(e);
                    if (i.length > 0) {
                        const t = e[i[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[i] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        });
        const Qd = new Mo
          , Kd = new Mo;
        function tp(t, e) {
            $d.call(this, t, e),
            this.type = "LineSegments"
        }
        tp.prototype = Object.assign(Object.create($d.prototype), {
            constructor: tp,
            isLineSegments: !0,
            computeLineDistances: function() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position
                          , i = [];
                        for (let t = 0, n = e.count; t < n; t += 2)
                            Qd.fromBufferAttribute(e, t),
                            Kd.fromBufferAttribute(e, t + 1),
                            i[t] = 0 === t ? 0 : i[t - 1],
                            i[t + 1] = i[t] + Qd.distanceTo(Kd);
                        t.setAttribute("lineDistance", new sl(i,1))
                    } else
                        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else
                    t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
        });
        (class extends $d {
            constructor(t, e) {
                super(t, e),
                this.type = "LineLoop"
            }
        }
        ).prototype.isLineLoop = !0;
        class ep extends Fh {
            constructor(t) {
                super(),
                this.type = "PointsMaterial",
                this.color = new qh(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.morphTargets = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.size = t.size,
                this.sizeAttenuation = t.sizeAttenuation,
                this.morphTargets = t.morphTargets,
                this
            }
        }
        ep.prototype.isPointsMaterial = !0;
        const ip = new $o
          , np = new Jo
          , rp = new jo
          , sp = new Mo;
        function ap(t=new ml, e=new ep) {
            wh.call(this),
            this.type = "Points",
            this.geometry = t,
            this.material = e,
            this.updateMorphTargets()
        }
        function op(t, e, i, n, r, s, a) {
            const o = np.distanceSqToPoint(t);
            if (o < i) {
                const i = new Mo;
                np.closestPointToPoint(t, i),
                i.applyMatrix4(n);
                const h = r.ray.origin.distanceTo(i);
                if (h < r.near || h > r.far)
                    return;
                s.push({
                    distance: h,
                    distanceToRay: Math.sqrt(o),
                    point: i,
                    index: e,
                    face: null,
                    object: a
                })
            }
        }
        ap.prototype = Object.assign(Object.create(wh.prototype), {
            constructor: ap,
            isPoints: !0,
            copy: function(t) {
                return wh.prototype.copy.call(this, t),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            },
            raycast: function(t, e) {
                const i = this.geometry
                  , n = this.matrixWorld
                  , r = t.params.Points.threshold;
                if (null === i.boundingSphere && i.computeBoundingSphere(),
                rp.copy(i.boundingSphere),
                rp.applyMatrix4(n),
                rp.radius += r,
                !1 === t.ray.intersectsSphere(rp))
                    return;
                ip.copy(n).invert(),
                np.copy(t.ray).applyMatrix4(ip);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , a = s * s;
                if (i.isBufferGeometry) {
                    const r = i.index
                      , s = i.attributes.position;
                    if (null !== r) {
                        const i = r.array;
                        for (let r = 0, o = i.length; r < o; r++) {
                            const o = i[r];
                            sp.fromBufferAttribute(s, o),
                            op(sp, o, a, n, t, e, this)
                        }
                    } else
                        for (let i = 0, r = s.count; i < r; i++)
                            sp.fromBufferAttribute(s, i),
                            op(sp, i, a, n, t, e, this)
                } else
                    console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            },
            updateMorphTargets: function() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , i = Object.keys(e);
                    if (i.length > 0) {
                        const t = e[i[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[i] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }),
        class extends yo {
            constructor(t, e, i, n, r, s, a, o, h) {
                super(t, e, i, n, r, s, a, o, h),
                this.format = void 0 !== a ? a : js,
                this.minFilter = void 0 !== s ? s : Ss,
                this.magFilter = void 0 !== r ? r : Ss,
                this.generateMipmaps = !1;
                const l = this;
                "requestVideoFrameCallback"in t && t.requestVideoFrameCallback((function e() {
                    l.needsUpdate = !0,
                    t.requestVideoFrameCallback(e)
                }
                ))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const t = this.image;
                !1 == "requestVideoFrameCallback"in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        .prototype.isVideoTexture = !0;
        class hp extends yo {
            constructor(t, e, i, n, r, s, a, o, h, l, c, u) {
                super(null, s, a, o, h, l, n, r, c, u),
                this.image = {
                    width: e,
                    height: i
                },
                this.mipmaps = t,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        hp.prototype.isCompressedTexture = !0,
        class extends yo {
            constructor(t, e, i, n, r, s, a, o, h) {
                super(t, e, i, n, r, s, a, o, h),
                this.needsUpdate = !0
            }
        }
        .prototype.isCanvasTexture = !0,
        class extends yo {
            constructor(t, e, i, n, r, s, a, o, h, l) {
                if ((l = void 0 !== l ? l : qs) !== qs && l !== Xs)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === i && l === qs && (i = Os),
                void 0 === i && l === Xs && (i = Us),
                super(null, n, r, s, a, o, l, i, h),
                this.image = {
                    width: t,
                    height: e
                },
                this.magFilter = void 0 !== a ? a : Ms,
                this.minFilter = void 0 !== o ? o : Ms,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        .prototype.isDepthTexture = !0;
        class lp extends ml {
            constructor(t=1, e=8, i=0, n=2 * Math.PI) {
                super(),
                this.type = "CircleGeometry",
                this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: i,
                    thetaLength: n
                },
                e = Math.max(3, e);
                const r = []
                  , s = []
                  , a = []
                  , o = []
                  , h = new Mo
                  , l = new po;
                s.push(0, 0, 0),
                a.push(0, 0, 1),
                o.push(.5, .5);
                for (let r = 0, c = 3; r <= e; r++,
                c += 3) {
                    const u = i + r / e * n;
                    h.x = t * Math.cos(u),
                    h.y = t * Math.sin(u),
                    s.push(h.x, h.y, h.z),
                    a.push(0, 0, 1),
                    l.x = (s[c] / t + 1) / 2,
                    l.y = (s[c + 1] / t + 1) / 2,
                    o.push(l.x, l.y)
                }
                for (let t = 1; t <= e; t++)
                    r.push(t, t + 1, 0);
                this.setIndex(r),
                this.setAttribute("position", new sl(s,3)),
                this.setAttribute("normal", new sl(a,3)),
                this.setAttribute("uv", new sl(o,2))
            }
        }
        new Mo,
        new Mo,
        new Mo,
        new Bh;
        function cp(t, e, i, n, r) {
            let s, a;
            if (r === function(t, e, i, n) {
                let r = 0;
                for (let s = e, a = i - n; s < i; s += n)
                    r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]),
                    a = s;
                return r
            }(t, e, i, n) > 0)
                for (s = e; s < i; s += n)
                    a = Rp(s, t[s], t[s + 1], a);
            else
                for (s = i - n; s >= e; s -= n)
                    a = Rp(s, t[s], t[s + 1], a);
            return a && Ep(a, a.next) && (Op(a),
            a = a.next),
            a
        }
        function up(t, e) {
            if (!t)
                return t;
            e || (e = t);
            let i, n = t;
            do {
                if (i = !1,
                n.steiner || !Ep(n, n.next) && 0 !== Tp(n.prev, n, n.next))
                    n = n.next;
                else {
                    if (Op(n),
                    n = e = n.prev,
                    n === n.next)
                        break;
                    i = !0
                }
            } while (i || n !== e);
            return e
        }
        function dp(t, e, i, n, r, s, a) {
            if (!t)
                return;
            !a && s && function(t, e, i, n) {
                let r = t;
                do {
                    null === r.z && (r.z = _p(r.x, r.y, e, i, n)),
                    r.prevZ = r.prev,
                    r.nextZ = r.next,
                    r = r.next
                } while (r !== t);
                r.prevZ.nextZ = null,
                r.prevZ = null,
                function(t) {
                    let e, i, n, r, s, a, o, h, l = 1;
                    do {
                        for (i = t,
                        t = null,
                        s = null,
                        a = 0; i; ) {
                            for (a++,
                            n = i,
                            o = 0,
                            e = 0; e < l && (o++,
                            n = n.nextZ,
                            n); e++)
                                ;
                            for (h = l; o > 0 || h > 0 && n; )
                                0 !== o && (0 === h || !n || i.z <= n.z) ? (r = i,
                                i = i.nextZ,
                                o--) : (r = n,
                                n = n.nextZ,
                                h--),
                                s ? s.nextZ = r : t = r,
                                r.prevZ = s,
                                s = r;
                            i = n
                        }
                        s.nextZ = null,
                        l *= 2
                    } while (a > 1)
                }(r)
            }(t, n, r, s);
            let o, h, l = t;
            for (; t.prev !== t.next; )
                if (o = t.prev,
                h = t.next,
                s ? fp(t, n, r, s) : pp(t))
                    e.push(o.i / i),
                    e.push(t.i / i),
                    e.push(h.i / i),
                    Op(t),
                    t = h.next,
                    l = h.next;
                else if ((t = h) === l) {
                    a ? 1 === a ? dp(t = mp(up(t), e, i), e, i, n, r, s, 2) : 2 === a && gp(t, e, i, n, r, s) : dp(up(t), e, i, n, r, s, 1);
                    break
                }
        }
        function pp(t) {
            const e = t.prev
              , i = t
              , n = t.next;
            if (Tp(e, i, n) >= 0)
                return !1;
            let r = t.next.next;
            for (; r !== t.prev; ) {
                if (wp(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && Tp(r.prev, r, r.next) >= 0)
                    return !1;
                r = r.next
            }
            return !0
        }
        function fp(t, e, i, n) {
            const r = t.prev
              , s = t
              , a = t.next;
            if (Tp(r, s, a) >= 0)
                return !1;
            const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x
              , h = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y
              , l = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x
              , c = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y
              , u = _p(o, h, e, i, n)
              , d = _p(l, c, e, i, n);
            let p = t.prevZ
              , f = t.nextZ;
            for (; p && p.z >= u && f && f.z <= d; ) {
                if (p !== t.prev && p !== t.next && wp(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Tp(p.prev, p, p.next) >= 0)
                    return !1;
                if (p = p.prevZ,
                f !== t.prev && f !== t.next && wp(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && Tp(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.nextZ
            }
            for (; p && p.z >= u; ) {
                if (p !== t.prev && p !== t.next && wp(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && Tp(p.prev, p, p.next) >= 0)
                    return !1;
                p = p.prevZ
            }
            for (; f && f.z <= d; ) {
                if (f !== t.prev && f !== t.next && wp(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && Tp(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.nextZ
            }
            return !0
        }
        function mp(t, e, i) {
            let n = t;
            do {
                const r = n.prev
                  , s = n.next.next;
                !Ep(r, s) && Sp(r, n, n.next, s) && Pp(r, s) && Pp(s, r) && (e.push(r.i / i),
                e.push(n.i / i),
                e.push(s.i / i),
                Op(n),
                Op(n.next),
                n = t = s),
                n = n.next
            } while (n !== t);
            return up(n)
        }
        function gp(t, e, i, n, r, s) {
            let a = t;
            do {
                let t = a.next.next;
                for (; t !== a.prev; ) {
                    if (a.i !== t.i && Mp(a, t)) {
                        let o = Cp(a, t);
                        return a = up(a, a.next),
                        o = up(o, o.next),
                        dp(a, e, i, n, r, s),
                        void dp(o, e, i, n, r, s)
                    }
                    t = t.next
                }
                a = a.next
            } while (a !== t)
        }
        function vp(t, e) {
            return t.x - e.x
        }
        function yp(t, e) {
            if (e = function(t, e) {
                let i = e;
                const n = t.x
                  , r = t.y;
                let s, a = -1 / 0;
                do {
                    if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                        const t = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                        if (t <= n && t > a) {
                            if (a = t,
                            t === n) {
                                if (r === i.y)
                                    return i;
                                if (r === i.next.y)
                                    return i.next
                            }
                            s = i.x < i.next.x ? i : i.next
                        }
                    }
                    i = i.next
                } while (i !== e);
                if (!s)
                    return null;
                if (n === a)
                    return s;
                const o = s
                  , h = s.x
                  , l = s.y;
                let c, u = 1 / 0;
                i = s;
                do {
                    n >= i.x && i.x >= h && n !== i.x && wp(r < l ? n : a, r, h, l, r < l ? a : n, r, i.x, i.y) && (c = Math.abs(r - i.y) / (n - i.x),
                    Pp(i, t) && (c < u || c === u && (i.x > s.x || i.x === s.x && xp(s, i))) && (s = i,
                    u = c)),
                    i = i.next
                } while (i !== o);
                return s
            }(t, e),
            e) {
                const i = Cp(e, t);
                up(e, e.next),
                up(i, i.next)
            }
        }
        function xp(t, e) {
            return Tp(t.prev, t, e.prev) < 0 && Tp(e.next, t, t.next) < 0
        }
        function _p(t, e, i, n, r) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }
        function bp(t) {
            let e = t
              , i = t;
            do {
                (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e),
                e = e.next
            } while (e !== t);
            return i
        }
        function wp(t, e, i, n, r, s, a, o) {
            return (r - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (n - o) - (i - a) * (e - o) >= 0 && (i - a) * (s - o) - (r - a) * (n - o) >= 0
        }
        function Mp(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
                let i = t;
                do {
                    if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && Sp(i, i.next, t, e))
                        return !0;
                    i = i.next
                } while (i !== t);
                return !1
            }(t, e) && (Pp(t, e) && Pp(e, t) && function(t, e) {
                let i = t
                  , n = !1;
                const r = (t.x + e.x) / 2
                  , s = (t.y + e.y) / 2;
                do {
                    i.y > s != i.next.y > s && i.next.y !== i.y && r < (i.next.x - i.x) * (s - i.y) / (i.next.y - i.y) + i.x && (n = !n),
                    i = i.next
                } while (i !== t);
                return n
            }(t, e) && (Tp(t.prev, t, e.prev) || Tp(t, e.prev, e)) || Ep(t, e) && Tp(t.prev, t, t.next) > 0 && Tp(e.prev, e, e.next) > 0)
        }
        function Tp(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }
        function Ep(t, e) {
            return t.x === e.x && t.y === e.y
        }
        function Sp(t, e, i, n) {
            const r = Lp(Tp(t, e, i))
              , s = Lp(Tp(t, e, n))
              , a = Lp(Tp(i, n, t))
              , o = Lp(Tp(i, n, e));
            return r !== s && a !== o || !(0 !== r || !Ap(t, i, e)) || !(0 !== s || !Ap(t, n, e)) || !(0 !== a || !Ap(i, t, n)) || !(0 !== o || !Ap(i, e, n))
        }
        function Ap(t, e, i) {
            return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
        }
        function Lp(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }
        function Pp(t, e) {
            return Tp(t.prev, t, t.next) < 0 ? Tp(t, e, t.next) >= 0 && Tp(t, t.prev, e) >= 0 : Tp(t, e, t.prev) < 0 || Tp(t, t.next, e) < 0
        }
        function Cp(t, e) {
            const i = new Dp(t.i,t.x,t.y)
              , n = new Dp(e.i,e.x,e.y)
              , r = t.next
              , s = e.prev;
            return t.next = e,
            e.prev = t,
            i.next = r,
            r.prev = i,
            n.next = i,
            i.prev = n,
            s.next = n,
            n.prev = s,
            n
        }
        function Rp(t, e, i, n) {
            const r = new Dp(t,e,i);
            return n ? (r.next = n.next,
            r.prev = n,
            n.next.prev = r,
            n.next = r) : (r.prev = r,
            r.next = r),
            r
        }
        function Op(t) {
            t.next.prev = t.prev,
            t.prev.next = t.next,
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }
        function Dp(t, e, i) {
            this.i = t,
            this.x = e,
            this.y = i,
            this.prev = null,
            this.next = null,
            this.z = null,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        const Ip = {
            area: function(t) {
                const e = t.length;
                let i = 0;
                for (let n = e - 1, r = 0; r < e; n = r++)
                    i += t[n].x * t[r].y - t[r].x * t[n].y;
                return .5 * i
            },
            isClockWise: function(t) {
                return Ip.area(t) < 0
            },
            triangulateShape: function(t, e) {
                const i = []
                  , n = []
                  , r = [];
                Np(t),
                zp(i, t);
                let s = t.length;
                e.forEach(Np);
                for (let t = 0; t < e.length; t++)
                    n.push(s),
                    s += e[t].length,
                    zp(i, e[t]);
                const a = function(t, e, i) {
                    i = i || 2;
                    const n = e && e.length
                      , r = n ? e[0] * i : t.length;
                    let s = cp(t, 0, r, i, !0);
                    const a = [];
                    if (!s || s.next === s.prev)
                        return a;
                    let o, h, l, c, u, d, p;
                    if (n && (s = function(t, e, i, n) {
                        const r = [];
                        let s, a, o, h, l;
                        for (s = 0,
                        a = e.length; s < a; s++)
                            o = e[s] * n,
                            h = s < a - 1 ? e[s + 1] * n : t.length,
                            l = cp(t, o, h, n, !1),
                            l === l.next && (l.steiner = !0),
                            r.push(bp(l));
                        for (r.sort(vp),
                        s = 0; s < r.length; s++)
                            yp(r[s], i),
                            i = up(i, i.next);
                        return i
                    }(t, e, s, i)),
                    t.length > 80 * i) {
                        o = l = t[0],
                        h = c = t[1];
                        for (let e = i; e < r; e += i)
                            u = t[e],
                            d = t[e + 1],
                            u < o && (o = u),
                            d < h && (h = d),
                            u > l && (l = u),
                            d > c && (c = d);
                        p = Math.max(l - o, c - h),
                        p = 0 !== p ? 1 / p : 0
                    }
                    return dp(s, a, i, o, h, p),
                    a
                }(i, n);
                for (let t = 0; t < a.length; t += 3)
                    r.push(a.slice(t, t + 3));
                return r
            }
        };
        function Np(t) {
            const e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }
        function zp(t, e) {
            for (let i = 0; i < e.length; i++)
                t.push(e[i].x),
                t.push(e[i].y)
        }
        class Bp extends ml {
            constructor(t, e) {
                super(),
                this.type = "ExtrudeGeometry",
                this.parameters = {
                    shapes: t,
                    options: e
                },
                t = Array.isArray(t) ? t : [t];
                const i = this
                  , n = []
                  , r = [];
                for (let e = 0, i = t.length; e < i; e++)
                    s(t[e]);
                function s(t) {
                    const s = []
                      , a = void 0 !== e.curveSegments ? e.curveSegments : 12
                      , o = void 0 !== e.steps ? e.steps : 1;
                    let h = void 0 !== e.depth ? e.depth : 100
                      , l = void 0 === e.bevelEnabled || e.bevelEnabled
                      , c = void 0 !== e.bevelThickness ? e.bevelThickness : 6
                      , u = void 0 !== e.bevelSize ? e.bevelSize : c - 2
                      , d = void 0 !== e.bevelOffset ? e.bevelOffset : 0
                      , p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                    const f = e.extrudePath
                      , m = void 0 !== e.UVGenerator ? e.UVGenerator : kp;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
                    h = e.amount);
                    let g, v, y, x, _, b = !1;
                    f && (g = f.getSpacedPoints(o),
                    b = !0,
                    l = !1,
                    v = f.computeFrenetFrames(o, !1),
                    y = new Mo,
                    x = new Mo,
                    _ = new Mo),
                    l || (p = 0,
                    c = 0,
                    u = 0,
                    d = 0);
                    const w = t.extractPoints(a);
                    let M = w.shape;
                    const T = w.holes;
                    if (!Ip.isClockWise(M)) {
                        M = M.reverse();
                        for (let t = 0, e = T.length; t < e; t++) {
                            const e = T[t];
                            Ip.isClockWise(e) && (T[t] = e.reverse())
                        }
                    }
                    const E = Ip.triangulateShape(M, T)
                      , S = M;
                    for (let t = 0, e = T.length; t < e; t++) {
                        const e = T[t];
                        M = M.concat(e)
                    }
                    function A(t, e, i) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                        e.clone().multiplyScalar(i).add(t)
                    }
                    const L = M.length
                      , P = E.length;
                    function C(t, e, i) {
                        let n, r, s;
                        const a = t.x - e.x
                          , o = t.y - e.y
                          , h = i.x - t.x
                          , l = i.y - t.y
                          , c = a * a + o * o
                          , u = a * l - o * h;
                        if (Math.abs(u) > Number.EPSILON) {
                            const u = Math.sqrt(c)
                              , d = Math.sqrt(h * h + l * l)
                              , p = e.x - o / u
                              , f = e.y + a / u
                              , m = ((i.x - l / d - p) * l - (i.y + h / d - f) * h) / (a * l - o * h);
                            n = p + a * m - t.x,
                            r = f + o * m - t.y;
                            const g = n * n + r * r;
                            if (g <= 2)
                                return new po(n,r);
                            s = Math.sqrt(g / 2)
                        } else {
                            let t = !1;
                            a > Number.EPSILON ? h > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? h < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(l) && (t = !0),
                            t ? (n = -o,
                            r = a,
                            s = Math.sqrt(c)) : (n = a,
                            r = o,
                            s = Math.sqrt(c / 2))
                        }
                        return new po(n / s,r / s)
                    }
                    const R = [];
                    for (let t = 0, e = S.length, i = e - 1, n = t + 1; t < e; t++,
                    i++,
                    n++)
                        i === e && (i = 0),
                        n === e && (n = 0),
                        R[t] = C(S[t], S[i], S[n]);
                    const O = [];
                    let D, I = R.concat();
                    for (let t = 0, e = T.length; t < e; t++) {
                        const e = T[t];
                        D = [];
                        for (let t = 0, i = e.length, n = i - 1, r = t + 1; t < i; t++,
                        n++,
                        r++)
                            n === i && (n = 0),
                            r === i && (r = 0),
                            D[t] = C(e[t], e[n], e[r]);
                        O.push(D),
                        I = I.concat(D)
                    }
                    for (let t = 0; t < p; t++) {
                        const e = t / p
                          , i = c * Math.cos(e * Math.PI / 2)
                          , n = u * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = A(S[t], R[t], n);
                            B(e.x, e.y, -i)
                        }
                        for (let t = 0, e = T.length; t < e; t++) {
                            const e = T[t];
                            D = O[t];
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = A(e[t], D[t], n);
                                B(r.x, r.y, -i)
                            }
                        }
                    }
                    const N = u + d;
                    for (let t = 0; t < L; t++) {
                        const e = l ? A(M[t], I[t], N) : M[t];
                        b ? (x.copy(v.normals[0]).multiplyScalar(e.x),
                        y.copy(v.binormals[0]).multiplyScalar(e.y),
                        _.copy(g[0]).add(x).add(y),
                        B(_.x, _.y, _.z)) : B(e.x, e.y, 0)
                    }
                    for (let t = 1; t <= o; t++)
                        for (let e = 0; e < L; e++) {
                            const i = l ? A(M[e], I[e], N) : M[e];
                            b ? (x.copy(v.normals[t]).multiplyScalar(i.x),
                            y.copy(v.binormals[t]).multiplyScalar(i.y),
                            _.copy(g[t]).add(x).add(y),
                            B(_.x, _.y, _.z)) : B(i.x, i.y, h / o * t)
                        }
                    for (let t = p - 1; t >= 0; t--) {
                        const e = t / p
                          , i = c * Math.cos(e * Math.PI / 2)
                          , n = u * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = A(S[t], R[t], n);
                            B(e.x, e.y, h + i)
                        }
                        for (let t = 0, e = T.length; t < e; t++) {
                            const e = T[t];
                            D = O[t];
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = A(e[t], D[t], n);
                                b ? B(r.x, r.y + g[o - 1].y, g[o - 1].x + i) : B(r.x, r.y, h + i)
                            }
                        }
                    }
                    function z(t, e) {
                        let i = t.length;
                        for (; --i >= 0; ) {
                            const n = i;
                            let r = i - 1;
                            r < 0 && (r = t.length - 1);
                            for (let t = 0, i = o + 2 * p; t < i; t++) {
                                const i = L * t
                                  , s = L * (t + 1);
                                F(e + n + i, e + r + i, e + r + s, e + n + s)
                            }
                        }
                    }
                    function B(t, e, i) {
                        s.push(t),
                        s.push(e),
                        s.push(i)
                    }
                    function k(t, e, r) {
                        U(t),
                        U(e),
                        U(r);
                        const s = n.length / 3
                          , a = m.generateTopUV(i, n, s - 3, s - 2, s - 1);
                        H(a[0]),
                        H(a[1]),
                        H(a[2])
                    }
                    function F(t, e, r, s) {
                        U(t),
                        U(e),
                        U(s),
                        U(e),
                        U(r),
                        U(s);
                        const a = n.length / 3
                          , o = m.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                        H(o[0]),
                        H(o[1]),
                        H(o[3]),
                        H(o[1]),
                        H(o[2]),
                        H(o[3])
                    }
                    function U(t) {
                        n.push(s[3 * t + 0]),
                        n.push(s[3 * t + 1]),
                        n.push(s[3 * t + 2])
                    }
                    function H(t) {
                        r.push(t.x),
                        r.push(t.y)
                    }
                    !function() {
                        const t = n.length / 3;
                        if (l) {
                            let t = 0
                              , e = L * t;
                            for (let t = 0; t < P; t++) {
                                const i = E[t];
                                k(i[2] + e, i[1] + e, i[0] + e)
                            }
                            t = o + 2 * p,
                            e = L * t;
                            for (let t = 0; t < P; t++) {
                                const i = E[t];
                                k(i[0] + e, i[1] + e, i[2] + e)
                            }
                        } else {
                            for (let t = 0; t < P; t++) {
                                const e = E[t];
                                k(e[2], e[1], e[0])
                            }
                            for (let t = 0; t < P; t++) {
                                const e = E[t];
                                k(e[0] + L * o, e[1] + L * o, e[2] + L * o)
                            }
                        }
                        i.addGroup(t, n.length / 3 - t, 0)
                    }(),
                    function() {
                        const t = n.length / 3;
                        let e = 0;
                        z(S, e),
                        e += S.length;
                        for (let t = 0, i = T.length; t < i; t++) {
                            const i = T[t];
                            z(i, e),
                            e += i.length
                        }
                        i.addGroup(t, n.length / 3 - t, 1)
                    }()
                }
                this.setAttribute("position", new sl(n,3)),
                this.setAttribute("uv", new sl(r,2)),
                this.computeVertexNormals()
            }
            toJSON() {
                const t = ml.prototype.toJSON.call(this);
                return function(t, e, i) {
                    if (i.shapes = [],
                    Array.isArray(t))
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            i.shapes.push(n.uuid)
                        }
                    else
                        i.shapes.push(t.uuid);
                    return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()),
                    i
                }(this.parameters.shapes, this.parameters.options, t)
            }
        }
        const kp = {
            generateTopUV: function(t, e, i, n, r) {
                const s = e[3 * i]
                  , a = e[3 * i + 1]
                  , o = e[3 * n]
                  , h = e[3 * n + 1]
                  , l = e[3 * r]
                  , c = e[3 * r + 1];
                return [new po(s,a), new po(o,h), new po(l,c)]
            },
            generateSideWallUV: function(t, e, i, n, r, s) {
                const a = e[3 * i]
                  , o = e[3 * i + 1]
                  , h = e[3 * i + 2]
                  , l = e[3 * n]
                  , c = e[3 * n + 1]
                  , u = e[3 * n + 2]
                  , d = e[3 * r]
                  , p = e[3 * r + 1]
                  , f = e[3 * r + 2]
                  , m = e[3 * s]
                  , g = e[3 * s + 1]
                  , v = e[3 * s + 2];
                return Math.abs(o - c) < .01 ? [new po(a,1 - h), new po(l,1 - u), new po(d,1 - f), new po(m,1 - v)] : [new po(o,1 - h), new po(c,1 - u), new po(p,1 - f), new po(g,1 - v)]
            }
        };
        function Fp(t, e, i) {
            ml.call(this),
            this.type = "ParametricGeometry",
            this.parameters = {
                func: t,
                slices: e,
                stacks: i
            };
            const n = []
              , r = []
              , s = []
              , a = []
              , o = 1e-5
              , h = new Mo
              , l = new Mo
              , c = new Mo
              , u = new Mo
              , d = new Mo;
            t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
            const p = e + 1;
            for (let n = 0; n <= i; n++) {
                const p = n / i;
                for (let i = 0; i <= e; i++) {
                    const n = i / e;
                    t(n, p, l),
                    r.push(l.x, l.y, l.z),
                    n - o >= 0 ? (t(n - o, p, c),
                    u.subVectors(l, c)) : (t(n + o, p, c),
                    u.subVectors(c, l)),
                    p - o >= 0 ? (t(n, p - o, c),
                    d.subVectors(l, c)) : (t(n, p + o, c),
                    d.subVectors(c, l)),
                    h.crossVectors(u, d).normalize(),
                    s.push(h.x, h.y, h.z),
                    a.push(n, p)
                }
            }
            for (let t = 0; t < i; t++)
                for (let i = 0; i < e; i++) {
                    const e = t * p + i
                      , r = t * p + i + 1
                      , s = (t + 1) * p + i + 1
                      , a = (t + 1) * p + i;
                    n.push(e, r, a),
                    n.push(r, s, a)
                }
            this.setIndex(n),
            this.setAttribute("position", new sl(r,3)),
            this.setAttribute("normal", new sl(s,3)),
            this.setAttribute("uv", new sl(a,2))
        }
        Fp.prototype = Object.create(ml.prototype),
        Fp.prototype.constructor = Fp;
        class Up extends ml {
            constructor(t, e=12) {
                super(),
                this.type = "ShapeGeometry",
                this.parameters = {
                    shapes: t,
                    curveSegments: e
                };
                const i = []
                  , n = []
                  , r = []
                  , s = [];
                let a = 0
                  , o = 0;
                if (!1 === Array.isArray(t))
                    h(t);
                else
                    for (let e = 0; e < t.length; e++)
                        h(t[e]),
                        this.addGroup(a, o, e),
                        a += o,
                        o = 0;
                function h(t) {
                    const a = n.length / 3
                      , h = t.extractPoints(e);
                    let l = h.shape;
                    const c = h.holes;
                    !1 === Ip.isClockWise(l) && (l = l.reverse());
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        !0 === Ip.isClockWise(e) && (c[t] = e.reverse())
                    }
                    const u = Ip.triangulateShape(l, c);
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        l = l.concat(e)
                    }
                    for (let t = 0, e = l.length; t < e; t++) {
                        const e = l[t];
                        n.push(e.x, e.y, 0),
                        r.push(0, 0, 1),
                        s.push(e.x, e.y)
                    }
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t]
                          , n = e[0] + a
                          , r = e[1] + a
                          , s = e[2] + a;
                        i.push(n, r, s),
                        o += 3
                    }
                }
                this.setIndex(i),
                this.setAttribute("position", new sl(n,3)),
                this.setAttribute("normal", new sl(r,3)),
                this.setAttribute("uv", new sl(s,2))
            }
            toJSON() {
                const t = ml.prototype.toJSON.call(this);
                return function(t, e) {
                    if (e.shapes = [],
                    Array.isArray(t))
                        for (let i = 0, n = t.length; i < n; i++) {
                            const n = t[i];
                            e.shapes.push(n.uuid)
                        }
                    else
                        e.shapes.push(t.uuid);
                    return e
                }(this.parameters.shapes, t)
            }
        }
        (class extends Fh {
            constructor(t) {
                super(),
                this.type = "ShadowMaterial",
                this.color = new qh(0),
                this.transparent = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this
            }
        }
        ).prototype.isShadowMaterial = !0;
        function Hp(t) {
            Fh.call(this),
            this.defines = {
                STANDARD: ""
            },
            this.type = "MeshStandardMaterial",
            this.color = new qh(16777215),
            this.roughness = 1,
            this.metalness = 0,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new qh(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = eo,
            this.normalScale = new po(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.roughnessMap = null,
            this.metalnessMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.envMapIntensity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.flatShading = !1,
            this.vertexTangents = !1,
            this.setValues(t)
        }
        function jp(t) {
            Hp.call(this),
            this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            },
            this.type = "MeshPhysicalMaterial",
            this.clearcoat = 0,
            this.clearcoatMap = null,
            this.clearcoatRoughness = 0,
            this.clearcoatRoughnessMap = null,
            this.clearcoatNormalScale = new po(1,1),
            this.clearcoatNormalMap = null,
            this.reflectivity = .5,
            Object.defineProperty(this, "ior", {
                get: function() {
                    return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                },
                set: function(t) {
                    this.reflectivity = uo.clamp(2.5 * (t - 1) / (t + 1), 0, 1)
                }
            }),
            this.sheen = null,
            this.transmission = 0,
            this.transmissionMap = null,
            this.setValues(t)
        }
        (class extends Hl {
            constructor(t) {
                super(t),
                this.type = "RawShaderMaterial"
            }
        }
        ).prototype.isRawShaderMaterial = !0,
        Hp.prototype = Object.create(Fh.prototype),
        Hp.prototype.constructor = Hp,
        Hp.prototype.isMeshStandardMaterial = !0,
        Hp.prototype.copy = function(t) {
            return Fh.prototype.copy.call(this, t),
            this.defines = {
                STANDARD: ""
            },
            this.color.copy(t.color),
            this.roughness = t.roughness,
            this.metalness = t.metalness,
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.roughnessMap = t.roughnessMap,
            this.metalnessMap = t.metalnessMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.envMapIntensity = t.envMapIntensity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this.flatShading = t.flatShading,
            this.vertexTangents = t.vertexTangents,
            this
        }
        ,
        jp.prototype = Object.create(Hp.prototype),
        jp.prototype.constructor = jp,
        jp.prototype.isMeshPhysicalMaterial = !0,
        jp.prototype.copy = function(t) {
            return Hp.prototype.copy.call(this, t),
            this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            },
            this.clearcoat = t.clearcoat,
            this.clearcoatMap = t.clearcoatMap,
            this.clearcoatRoughness = t.clearcoatRoughness,
            this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
            this.clearcoatNormalMap = t.clearcoatNormalMap,
            this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
            this.reflectivity = t.reflectivity,
            t.sheen ? this.sheen = (this.sheen || new qh).copy(t.sheen) : this.sheen = null,
            this.transmission = t.transmission,
            this.transmissionMap = t.transmissionMap,
            this
        }
        ;
        class Gp extends Fh {
            constructor(t) {
                super(),
                this.type = "MeshPhongMaterial",
                this.color = new qh(16777215),
                this.specular = new qh(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new qh(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = eo,
                this.normalScale = new po(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = ss,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.specular.copy(t.specular),
                this.shininess = t.shininess,
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this.flatShading = t.flatShading,
                this
            }
        }
        Gp.prototype.isMeshPhongMaterial = !0;
        (class extends Fh {
            constructor(t) {
                super(),
                this.defines = {
                    TOON: ""
                },
                this.type = "MeshToonMaterial",
                this.color = new qh(16777215),
                this.map = null,
                this.gradientMap = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new qh(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = eo,
                this.normalScale = new po(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.gradientMap = t.gradientMap,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.alphaMap = t.alphaMap,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this
            }
        }
        ).prototype.isMeshToonMaterial = !0;
        (class extends Fh {
            constructor(t) {
                super(),
                this.type = "MeshNormalMaterial",
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = eo,
                this.normalScale = new po(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this.flatShading = t.flatShading,
                this
            }
        }
        ).prototype.isMeshNormalMaterial = !0;
        (class extends Fh {
            constructor(t) {
                super(),
                this.type = "MeshLambertMaterial",
                this.color = new qh(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new qh(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = ss,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this
            }
        }
        ).prototype.isMeshLambertMaterial = !0;
        (class extends Fh {
            constructor(t) {
                super(),
                this.defines = {
                    MATCAP: ""
                },
                this.type = "MeshMatcapMaterial",
                this.color = new qh(16777215),
                this.matcap = null,
                this.map = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = eo,
                this.normalScale = new po(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    MATCAP: ""
                },
                this.color.copy(t.color),
                this.matcap = t.matcap,
                this.map = t.map,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.alphaMap = t.alphaMap,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this.flatShading = t.flatShading,
                this
            }
        }
        ).prototype.isMeshMatcapMaterial = !0;
        (class extends Vd {
            constructor(t) {
                super(),
                this.type = "LineDashedMaterial",
                this.scale = 1,
                this.dashSize = 3,
                this.gapSize = 1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.scale = t.scale,
                this.dashSize = t.dashSize,
                this.gapSize = t.gapSize,
                this
            }
        }
        ).prototype.isLineDashedMaterial = !0;
        const Wp = {
            arraySlice: function(t, e, i) {
                return Wp.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
            },
            convertArray: function(t, e, i) {
                return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                const e = t.length
                  , i = new Array(e);
                for (let t = 0; t !== e; ++t)
                    i[t] = t;
                return i.sort((function(e, i) {
                    return t[e] - t[i]
                }
                )),
                i
            },
            sortedArray: function(t, e, i) {
                const n = t.length
                  , r = new t.constructor(n);
                for (let s = 0, a = 0; a !== n; ++s) {
                    const n = i[s] * e;
                    for (let i = 0; i !== e; ++i)
                        r[a++] = t[n + i]
                }
                return r
            },
            flattenJSON: function(t, e, i, n) {
                let r = 1
                  , s = t[0];
                for (; void 0 !== s && void 0 === s[n]; )
                    s = t[r++];
                if (void 0 === s)
                    return;
                let a = s[n];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            a = s[n],
                            void 0 !== a && (e.push(s.time),
                            i.push.apply(i, a)),
                            s = t[r++]
                        } while (void 0 !== s);
                    else if (void 0 !== a.toArray)
                        do {
                            a = s[n],
                            void 0 !== a && (e.push(s.time),
                            a.toArray(i, i.length)),
                            s = t[r++]
                        } while (void 0 !== s);
                    else
                        do {
                            a = s[n],
                            void 0 !== a && (e.push(s.time),
                            i.push(a)),
                            s = t[r++]
                        } while (void 0 !== s)
            },
            subclip: function(t, e, i, n, r=30) {
                const s = t.clone();
                s.name = e;
                const a = [];
                for (let t = 0; t < s.tracks.length; ++t) {
                    const e = s.tracks[t]
                      , o = e.getValueSize()
                      , h = []
                      , l = [];
                    for (let t = 0; t < e.times.length; ++t) {
                        const s = e.times[t] * r;
                        if (!(s < i || s >= n)) {
                            h.push(e.times[t]);
                            for (let i = 0; i < o; ++i)
                                l.push(e.values[t * o + i])
                        }
                    }
                    0 !== h.length && (e.times = Wp.convertArray(h, e.times.constructor),
                    e.values = Wp.convertArray(l, e.values.constructor),
                    a.push(e))
                }
                s.tracks = a;
                let o = 1 / 0;
                for (let t = 0; t < s.tracks.length; ++t)
                    o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
                for (let t = 0; t < s.tracks.length; ++t)
                    s.tracks[t].shift(-1 * o);
                return s.resetDuration(),
                s
            },
            makeClipAdditive: function(t, e=0, i=t, n=30) {
                n <= 0 && (n = 30);
                const r = i.tracks.length
                  , s = e / n;
                for (let e = 0; e < r; ++e) {
                    const n = i.tracks[e]
                      , r = n.ValueTypeName;
                    if ("bool" === r || "string" === r)
                        continue;
                    const a = t.tracks.find((function(t) {
                        return t.name === n.name && t.ValueTypeName === r
                    }
                    ));
                    if (void 0 === a)
                        continue;
                    let o = 0;
                    const h = n.getValueSize();
                    n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = h / 3);
                    let l = 0;
                    const c = a.getValueSize();
                    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = c / 3);
                    const u = n.times.length - 1;
                    let d;
                    if (s <= n.times[0]) {
                        const t = o
                          , e = h - o;
                        d = Wp.arraySlice(n.values, t, e)
                    } else if (s >= n.times[u]) {
                        const t = u * h + o
                          , e = t + h - o;
                        d = Wp.arraySlice(n.values, t, e)
                    } else {
                        const t = n.createInterpolant()
                          , e = o
                          , i = h - o;
                        t.evaluate(s),
                        d = Wp.arraySlice(t.resultBuffer, e, i)
                    }
                    "quaternion" === r && (new wo).fromArray(d).normalize().conjugate().toArray(d);
                    const p = a.times.length;
                    for (let t = 0; t < p; ++t) {
                        const e = t * c + l;
                        if ("quaternion" === r)
                            wo.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                        else {
                            const t = c - 2 * l;
                            for (let i = 0; i < t; ++i)
                                a.values[e + i] -= d[i]
                        }
                    }
                }
                return t.blendMode = 2501,
                t
            }
        };
        function Vp(t, e, i, n) {
            this.parameterPositions = t,
            this._cachedIndex = 0,
            this.resultBuffer = void 0 !== n ? n : new e.constructor(i),
            this.sampleValues = e,
            this.valueSize = i
        }
        function qp(t, e, i, n) {
            Vp.call(this, t, e, i, n),
            this._weightPrev = -0,
            this._offsetPrev = -0,
            this._weightNext = -0,
            this._offsetNext = -0
        }
        function Xp(t, e, i, n) {
            Vp.call(this, t, e, i, n)
        }
        function Yp(t, e, i, n) {
            Vp.call(this, t, e, i, n)
        }
        Object.assign(Vp.prototype, {
            evaluate: function(t) {
                const e = this.parameterPositions;
                let i = this._cachedIndex
                  , n = e[i]
                  , r = e[i - 1];
                t: {
                    e: {
                        let s;
                        i: {
                            n: if (!(t < n)) {
                                for (let s = i + 2; ; ) {
                                    if (void 0 === n) {
                                        if (t < r)
                                            break n;
                                        return i = e.length,
                                        this._cachedIndex = i,
                                        this.afterEnd_(i - 1, t, r)
                                    }
                                    if (i === s)
                                        break;
                                    if (r = n,
                                    n = e[++i],
                                    t < n)
                                        break e
                                }
                                s = e.length;
                                break i
                            }
                            if (t >= r)
                                break t;
                            {
                                const a = e[1];
                                t < a && (i = 2,
                                r = a);
                                for (let s = i - 2; ; ) {
                                    if (void 0 === r)
                                        return this._cachedIndex = 0,
                                        this.beforeStart_(0, t, n);
                                    if (i === s)
                                        break;
                                    if (n = r,
                                    r = e[--i - 1],
                                    t >= r)
                                        break e
                                }
                                s = i,
                                i = 0
                            }
                        }
                        for (; i < s; ) {
                            const n = i + s >>> 1;
                            t < e[n] ? s = n : i = n + 1
                        }
                        if (n = e[i],
                        r = e[i - 1],
                        void 0 === r)
                            return this._cachedIndex = 0,
                            this.beforeStart_(0, t, n);
                        if (void 0 === n)
                            return i = e.length,
                            this._cachedIndex = i,
                            this.afterEnd_(i - 1, r, t)
                    }
                    this._cachedIndex = i,
                    this.intervalChanged_(i, r, n)
                }
                return this.interpolate_(i, r, t, n)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(t) {
                const e = this.resultBuffer
                  , i = this.sampleValues
                  , n = this.valueSize
                  , r = t * n;
                for (let t = 0; t !== n; ++t)
                    e[t] = i[r + t];
                return e
            },
            interpolate_: function() {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function() {}
        }),
        Object.assign(Vp.prototype, {
            beforeStart_: Vp.prototype.copySampleValue_,
            afterEnd_: Vp.prototype.copySampleValue_
        }),
        qp.prototype = Object.assign(Object.create(Vp.prototype), {
            constructor: qp,
            DefaultSettings_: {
                endingStart: Ga,
                endingEnd: Ga
            },
            intervalChanged_: function(t, e, i) {
                const n = this.parameterPositions;
                let r = t - 2
                  , s = t + 1
                  , a = n[r]
                  , o = n[s];
                if (void 0 === a)
                    switch (this.getSettings_().endingStart) {
                    case Wa:
                        r = t,
                        a = 2 * e - i;
                        break;
                    case Va:
                        r = n.length - 2,
                        a = e + n[r] - n[r + 1];
                        break;
                    default:
                        r = t,
                        a = i
                    }
                if (void 0 === o)
                    switch (this.getSettings_().endingEnd) {
                    case Wa:
                        s = t,
                        o = 2 * i - e;
                        break;
                    case Va:
                        s = 1,
                        o = i + n[1] - n[0];
                        break;
                    default:
                        s = t - 1,
                        o = e
                    }
                const h = .5 * (i - e)
                  , l = this.valueSize;
                this._weightPrev = h / (e - a),
                this._weightNext = h / (o - i),
                this._offsetPrev = r * l,
                this._offsetNext = s * l
            },
            interpolate_: function(t, e, i, n) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = t * a
                  , h = o - a
                  , l = this._offsetPrev
                  , c = this._offsetNext
                  , u = this._weightPrev
                  , d = this._weightNext
                  , p = (i - e) / (n - e)
                  , f = p * p
                  , m = f * p
                  , g = -u * m + 2 * u * f - u * p
                  , v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1
                  , y = (-1 - d) * m + (1.5 + d) * f + .5 * p
                  , x = d * m - d * f;
                for (let t = 0; t !== a; ++t)
                    r[t] = g * s[l + t] + v * s[h + t] + y * s[o + t] + x * s[c + t];
                return r
            }
        }),
        Xp.prototype = Object.assign(Object.create(Vp.prototype), {
            constructor: Xp,
            interpolate_: function(t, e, i, n) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = t * a
                  , h = o - a
                  , l = (i - e) / (n - e)
                  , c = 1 - l;
                for (let t = 0; t !== a; ++t)
                    r[t] = s[h + t] * c + s[o + t] * l;
                return r
            }
        }),
        Yp.prototype = Object.assign(Object.create(Vp.prototype), {
            constructor: Yp,
            interpolate_: function(t) {
                return this.copySampleValue_(t - 1)
            }
        });
        class Zp {
            constructor(t, e, i, n) {
                if (void 0 === t)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t,
                this.times = Wp.convertArray(e, this.TimeBufferType),
                this.values = Wp.convertArray(i, this.ValueBufferType),
                this.setInterpolation(n || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let i;
                if (e.toJSON !== this.toJSON)
                    i = e.toJSON(t);
                else {
                    i = {
                        name: t.name,
                        times: Wp.convertArray(t.times, Array),
                        values: Wp.convertArray(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (i.interpolation = e)
                }
                return i.type = t.ValueTypeName,
                i
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new Yp(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new Xp(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new qp(this.times,this.values,this.getValueSize(),t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                case Ua:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Ha:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case ja:
                    e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation)
                            throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e),
                    this
                }
                return this.createInterpolant = e,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return Ua;
                case this.InterpolantFactoryMethodLinear:
                    return Ha;
                case this.InterpolantFactoryMethodSmooth:
                    return ja
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let i = 0, n = e.length; i !== n; ++i)
                        e[i] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let i = 0, n = e.length; i !== n; ++i)
                        e[i] *= t
                }
                return this
            }
            trim(t, e) {
                const i = this.times
                  , n = i.length;
                let r = 0
                  , s = n - 1;
                for (; r !== n && i[r] < t; )
                    ++r;
                for (; -1 !== s && i[s] > e; )
                    --s;
                if (++s,
                0 !== r || s !== n) {
                    r >= s && (s = Math.max(s, 1),
                    r = s - 1);
                    const t = this.getValueSize();
                    this.times = Wp.arraySlice(i, r, s),
                    this.values = Wp.arraySlice(this.values, r * t, s * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                t = !1);
                const i = this.times
                  , n = this.values
                  , r = i.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                t = !1);
                let s = null;
                for (let e = 0; e !== r; e++) {
                    const n = i[e];
                    if ("number" == typeof n && isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n),
                        t = !1;
                        break
                    }
                    if (null !== s && s > n) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, s),
                        t = !1;
                        break
                    }
                    s = n
                }
                if (void 0 !== n && Wp.isTypedArray(n))
                    for (let e = 0, i = n.length; e !== i; ++e) {
                        const i = n[e];
                        if (isNaN(i)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, i),
                            t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = Wp.arraySlice(this.times)
                  , e = Wp.arraySlice(this.values)
                  , i = this.getValueSize()
                  , n = this.getInterpolation() === ja
                  , r = t.length - 1;
                let s = 1;
                for (let a = 1; a < r; ++a) {
                    let r = !1;
                    const o = t[a];
                    if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                        if (n)
                            r = !0;
                        else {
                            const t = a * i
                              , n = t - i
                              , s = t + i;
                            for (let a = 0; a !== i; ++a) {
                                const i = e[t + a];
                                if (i !== e[n + a] || i !== e[s + a]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (a !== s) {
                            t[s] = t[a];
                            const n = a * i
                              , r = s * i;
                            for (let t = 0; t !== i; ++t)
                                e[r + t] = e[n + t]
                        }
                        ++s
                    }
                }
                if (r > 0) {
                    t[s] = t[r];
                    for (let t = r * i, n = s * i, a = 0; a !== i; ++a)
                        e[n + a] = e[t + a];
                    ++s
                }
                return s !== t.length ? (this.times = Wp.arraySlice(t, 0, s),
                this.values = Wp.arraySlice(e, 0, s * i)) : (this.times = t,
                this.values = e),
                this
            }
            clone() {
                const t = Wp.arraySlice(this.times, 0)
                  , e = Wp.arraySlice(this.values, 0)
                  , i = new (0,
                this.constructor)(this.name,t,e);
                return i.createInterpolant = this.createInterpolant,
                i
            }
        }
        Zp.prototype.TimeBufferType = Float32Array,
        Zp.prototype.ValueBufferType = Float32Array,
        Zp.prototype.DefaultInterpolation = Ha;
        class Jp extends Zp {
        }
        Jp.prototype.ValueTypeName = "bool",
        Jp.prototype.ValueBufferType = Array,
        Jp.prototype.DefaultInterpolation = Ua,
        Jp.prototype.InterpolantFactoryMethodLinear = void 0,
        Jp.prototype.InterpolantFactoryMethodSmooth = void 0;
        class $p extends Zp {
        }
        $p.prototype.ValueTypeName = "color";
        class Qp extends Zp {
        }
        function Kp(t, e, i, n) {
            Vp.call(this, t, e, i, n)
        }
        Qp.prototype.ValueTypeName = "number",
        Kp.prototype = Object.assign(Object.create(Vp.prototype), {
            constructor: Kp,
            interpolate_: function(t, e, i, n) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = (i - e) / (n - e);
                let h = t * a;
                for (let t = h + a; h !== t; h += 4)
                    wo.slerpFlat(r, 0, s, h - a, s, h, o);
                return r
            }
        });
        class tf extends Zp {
            InterpolantFactoryMethodLinear(t) {
                return new Kp(this.times,this.values,this.getValueSize(),t)
            }
        }
        tf.prototype.ValueTypeName = "quaternion",
        tf.prototype.DefaultInterpolation = Ha,
        tf.prototype.InterpolantFactoryMethodSmooth = void 0;
        class ef extends Zp {
        }
        ef.prototype.ValueTypeName = "string",
        ef.prototype.ValueBufferType = Array,
        ef.prototype.DefaultInterpolation = Ua,
        ef.prototype.InterpolantFactoryMethodLinear = void 0,
        ef.prototype.InterpolantFactoryMethodSmooth = void 0;
        class nf extends Zp {
        }
        nf.prototype.ValueTypeName = "vector";
        class rf {
            constructor(t, e=-1, i, n=2500) {
                this.name = t,
                this.tracks = i,
                this.duration = e,
                this.blendMode = n,
                this.uuid = uo.generateUUID(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = []
                  , i = t.tracks
                  , n = 1 / (t.fps || 1);
                for (let t = 0, r = i.length; t !== r; ++t)
                    e.push(sf(i[t]).scale(n));
                const r = new this(t.name,t.duration,e,t.blendMode);
                return r.uuid = t.uuid,
                r
            }
            static toJSON(t) {
                const e = []
                  , i = t.tracks
                  , n = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e,
                    uuid: t.uuid,
                    blendMode: t.blendMode
                };
                for (let t = 0, n = i.length; t !== n; ++t)
                    e.push(Zp.toJSON(i[t]));
                return n
            }
            static CreateFromMorphTargetSequence(t, e, i, n) {
                const r = e.length
                  , s = [];
                for (let t = 0; t < r; t++) {
                    let a = []
                      , o = [];
                    a.push((t + r - 1) % r, t, (t + 1) % r),
                    o.push(0, 1, 0);
                    const h = Wp.getKeyframeOrder(a);
                    a = Wp.sortedArray(a, 1, h),
                    o = Wp.sortedArray(o, 1, h),
                    n || 0 !== a[0] || (a.push(r),
                    o.push(o[0])),
                    s.push(new Qp(".morphTargetInfluences[" + e[t].name + "]",a,o).scale(1 / i))
                }
                return new this(t,-1,s)
            }
            static findByName(t, e) {
                let i = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    i = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < i.length; t++)
                    if (i[t].name === e)
                        return i[t];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, i) {
                const n = {}
                  , r = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, i = t.length; e < i; e++) {
                    const i = t[e]
                      , s = i.name.match(r);
                    if (s && s.length > 1) {
                        const t = s[1];
                        let e = n[t];
                        e || (n[t] = e = []),
                        e.push(i)
                    }
                }
                const s = [];
                for (const t in n)
                    s.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
                return s
            }
            static parseAnimation(t, e) {
                if (!t)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const i = function(t, e, i, n, r) {
                    if (0 !== i.length) {
                        const s = []
                          , a = [];
                        Wp.flattenJSON(i, s, a, n),
                        0 !== s.length && r.push(new t(e,s,a))
                    }
                }
                  , n = []
                  , r = t.name || "default"
                  , s = t.fps || 30
                  , a = t.blendMode;
                let o = t.length || -1;
                const h = t.hierarchy || [];
                for (let t = 0; t < h.length; t++) {
                    const r = h[t].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < r.length; e++)
                                if (r[e].morphTargets)
                                    for (let i = 0; i < r[e].morphTargets.length; i++)
                                        t[r[e].morphTargets[i]] = -1;
                            for (const i in t) {
                                const t = []
                                  , s = [];
                                for (let n = 0; n !== r[e].morphTargets.length; ++n) {
                                    const n = r[e];
                                    t.push(n.time),
                                    s.push(n.morphTarget === i ? 1 : 0)
                                }
                                n.push(new Qp(".morphTargetInfluence[" + i + "]",t,s))
                            }
                            o = t.length * (s || 1)
                        } else {
                            const s = ".bones[" + e[t].name + "]";
                            i(nf, s + ".position", r, "pos", n),
                            i(tf, s + ".quaternion", r, "rot", n),
                            i(nf, s + ".scale", r, "scl", n)
                        }
                }
                return 0 === n.length ? null : new this(r,o,n,a)
            }
            resetDuration() {
                let t = 0;
                for (let e = 0, i = this.tracks.length; e !== i; ++e) {
                    const i = this.tracks[e];
                    t = Math.max(t, i.times[i.times.length - 1])
                }
                return this.duration = t,
                this
            }
            trim() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++)
                    t = t && this.tracks[e].validate();
                return t
            }
            optimize() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++)
                    t.push(this.tracks[e].clone());
                return new this.constructor(this.name,this.duration,t,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function sf(t) {
            if (void 0 === t.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function(t) {
                switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Qp;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return nf;
                case "color":
                    return $p;
                case "quaternion":
                    return tf;
                case "bool":
                case "boolean":
                    return Jp;
                case "string":
                    return ef
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = []
                  , i = [];
                Wp.flattenJSON(t.keys, e, i, "value"),
                t.times = e,
                t.values = i
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
        }
        const af = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled)
                    return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };
        function of(t, e, i) {
            const n = this;
            let r, s = !1, a = 0, o = 0;
            const h = [];
            this.onStart = void 0,
            this.onLoad = t,
            this.onProgress = e,
            this.onError = i,
            this.itemStart = function(t) {
                o++,
                !1 === s && void 0 !== n.onStart && n.onStart(t, a, o),
                s = !0
            }
            ,
            this.itemEnd = function(t) {
                a++,
                void 0 !== n.onProgress && n.onProgress(t, a, o),
                a === o && (s = !1,
                void 0 !== n.onLoad && n.onLoad())
            }
            ,
            this.itemError = function(t) {
                void 0 !== n.onError && n.onError(t)
            }
            ,
            this.resolveURL = function(t) {
                return r ? r(t) : t
            }
            ,
            this.setURLModifier = function(t) {
                return r = t,
                this
            }
            ,
            this.addHandler = function(t, e) {
                return h.push(t, e),
                this
            }
            ,
            this.removeHandler = function(t) {
                const e = h.indexOf(t);
                return -1 !== e && h.splice(e, 2),
                this
            }
            ,
            this.getHandler = function(t) {
                for (let e = 0, i = h.length; e < i; e += 2) {
                    const i = h[e]
                      , n = h[e + 1];
                    if (i.global && (i.lastIndex = 0),
                    i.test(t))
                        return n
                }
                return null
            }
        }
        const hf = new of;
        function lf(t) {
            this.manager = void 0 !== t ? t : hf,
            this.crossOrigin = "anonymous",
            this.withCredentials = !1,
            this.path = "",
            this.resourcePath = "",
            this.requestHeader = {}
        }
        Object.assign(lf.prototype, {
            load: function() {},
            loadAsync: function(t, e) {
                const i = this;
                return new Promise((function(n, r) {
                    i.load(t, n, e, r)
                }
                ))
            },
            parse: function() {},
            setCrossOrigin: function(t) {
                return this.crossOrigin = t,
                this
            },
            setWithCredentials: function(t) {
                return this.withCredentials = t,
                this
            },
            setPath: function(t) {
                return this.path = t,
                this
            },
            setResourcePath: function(t) {
                return this.resourcePath = t,
                this
            },
            setRequestHeader: function(t) {
                return this.requestHeader = t,
                this
            }
        });
        const cf = {};
        function uf(t) {
            lf.call(this, t)
        }
        function df(t) {
            lf.call(this, t)
        }
        uf.prototype = Object.assign(Object.create(lf.prototype), {
            constructor: uf,
            load: function(t, e, i, n) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = this
                  , s = af.get(t);
                if (void 0 !== s)
                    return r.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        r.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                if (void 0 !== cf[t])
                    return void cf[t].push({
                        onLoad: e,
                        onProgress: i,
                        onError: n
                    });
                const a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                let o;
                if (a) {
                    const i = a[1]
                      , s = !!a[2];
                    let o = a[3];
                    o = decodeURIComponent(o),
                    s && (o = atob(o));
                    try {
                        let n;
                        const s = (this.responseType || "").toLowerCase();
                        switch (s) {
                        case "arraybuffer":
                        case "blob":
                            const t = new Uint8Array(o.length);
                            for (let e = 0; e < o.length; e++)
                                t[e] = o.charCodeAt(e);
                            n = "blob" === s ? new Blob([t.buffer],{
                                type: i
                            }) : t.buffer;
                            break;
                        case "document":
                            const e = new DOMParser;
                            n = e.parseFromString(o, i);
                            break;
                        case "json":
                            n = JSON.parse(o);
                            break;
                        default:
                            n = o
                        }
                        setTimeout((function() {
                            e && e(n),
                            r.manager.itemEnd(t)
                        }
                        ), 0)
                    } catch (e) {
                        setTimeout((function() {
                            n && n(e),
                            r.manager.itemError(t),
                            r.manager.itemEnd(t)
                        }
                        ), 0)
                    }
                } else {
                    cf[t] = [],
                    cf[t].push({
                        onLoad: e,
                        onProgress: i,
                        onError: n
                    }),
                    o = new XMLHttpRequest,
                    o.open("GET", t, !0),
                    o.addEventListener("load", (function(e) {
                        const i = this.response
                          , n = cf[t];
                        if (delete cf[t],
                        200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                            af.add(t, i);
                            for (let t = 0, e = n.length; t < e; t++) {
                                const e = n[t];
                                e.onLoad && e.onLoad(i)
                            }
                            r.manager.itemEnd(t)
                        } else {
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                i.onError && i.onError(e)
                            }
                            r.manager.itemError(t),
                            r.manager.itemEnd(t)
                        }
                    }
                    ), !1),
                    o.addEventListener("progress", (function(e) {
                        const i = cf[t];
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t];
                            n.onProgress && n.onProgress(e)
                        }
                    }
                    ), !1),
                    o.addEventListener("error", (function(e) {
                        const i = cf[t];
                        delete cf[t];
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t];
                            n.onError && n.onError(e)
                        }
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }
                    ), !1),
                    o.addEventListener("abort", (function(e) {
                        const i = cf[t];
                        delete cf[t];
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t];
                            n.onError && n.onError(e)
                        }
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }
                    ), !1),
                    void 0 !== this.responseType && (o.responseType = this.responseType),
                    void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials),
                    o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (const t in this.requestHeader)
                        o.setRequestHeader(t, this.requestHeader[t]);
                    o.send(null)
                }
                return r.manager.itemStart(t),
                o
            },
            setResponseType: function(t) {
                return this.responseType = t,
                this
            },
            setMimeType: function(t) {
                return this.mimeType = t,
                this
            }
        }),
        df.prototype = Object.assign(Object.create(lf.prototype), {
            constructor: df,
            load: function(t, e, i, n) {
                const r = this
                  , s = []
                  , a = new hp
                  , o = new uf(this.manager);
                o.setPath(this.path),
                o.setResponseType("arraybuffer"),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(r.withCredentials);
                let h = 0;
                function l(l) {
                    o.load(t[l], (function(t) {
                        const i = r.parse(t, !0);
                        s[l] = {
                            width: i.width,
                            height: i.height,
                            format: i.format,
                            mipmaps: i.mipmaps
                        },
                        h += 1,
                        6 === h && (1 === i.mipmapCount && (a.minFilter = Ss),
                        a.image = s,
                        a.format = i.format,
                        a.needsUpdate = !0,
                        e && e(a))
                    }
                    ), i, n)
                }
                if (Array.isArray(t))
                    for (let e = 0, i = t.length; e < i; ++e)
                        l(e);
                else
                    o.load(t, (function(t) {
                        const i = r.parse(t, !0);
                        if (i.isCubemap) {
                            const t = i.mipmaps.length / i.mipmapCount;
                            for (let e = 0; e < t; e++) {
                                s[e] = {
                                    mipmaps: []
                                };
                                for (let t = 0; t < i.mipmapCount; t++)
                                    s[e].mipmaps.push(i.mipmaps[e * i.mipmapCount + t]),
                                    s[e].format = i.format,
                                    s[e].width = i.width,
                                    s[e].height = i.height
                            }
                            a.image = s
                        } else
                            a.image.width = i.width,
                            a.image.height = i.height,
                            a.mipmaps = i.mipmaps;
                        1 === i.mipmapCount && (a.minFilter = Ss),
                        a.format = i.format,
                        a.needsUpdate = !0,
                        e && e(a)
                    }
                    ), i, n);
                return a
            }
        });
        class pf extends lf {
            constructor(t) {
                super(t)
            }
            load(t, e, i, n) {
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = this
                  , s = af.get(t);
                if (void 0 !== s)
                    return r.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        r.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                function o() {
                    a.removeEventListener("load", o, !1),
                    a.removeEventListener("error", h, !1),
                    af.add(t, this),
                    e && e(this),
                    r.manager.itemEnd(t)
                }
                function h(e) {
                    a.removeEventListener("load", o, !1),
                    a.removeEventListener("error", h, !1),
                    n && n(e),
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                return a.addEventListener("load", o, !1),
                a.addEventListener("error", h, !1),
                "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
                r.manager.itemStart(t),
                a.src = t,
                a
            }
        }
        class ff extends lf {
            constructor(t) {
                super(t)
            }
            load(t, e, i, n) {
                const r = new ql
                  , s = new pf(this.manager);
                s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path);
                let a = 0;
                function o(i) {
                    s.load(t[i], (function(t) {
                        r.images[i] = t,
                        a++,
                        6 === a && (r.needsUpdate = !0,
                        e && e(r))
                    }
                    ), void 0, n)
                }
                for (let e = 0; e < t.length; ++e)
                    o(e);
                return r
            }
        }
        function mf(t) {
            lf.call(this, t)
        }
        function gf(t) {
            lf.call(this, t)
        }
        function vf() {
            this.type = "Curve",
            this.arcLengthDivisions = 200
        }
        mf.prototype = Object.assign(Object.create(lf.prototype), {
            constructor: mf,
            load: function(t, e, i, n) {
                const r = this
                  , s = new Yl
                  , a = new uf(this.manager);
                return a.setResponseType("arraybuffer"),
                a.setRequestHeader(this.requestHeader),
                a.setPath(this.path),
                a.setWithCredentials(r.withCredentials),
                a.load(t, (function(t) {
                    const i = r.parse(t);
                    i && (void 0 !== i.image ? s.image = i.image : void 0 !== i.data && (s.image.width = i.width,
                    s.image.height = i.height,
                    s.image.data = i.data),
                    s.wrapS = void 0 !== i.wrapS ? i.wrapS : bs,
                    s.wrapT = void 0 !== i.wrapT ? i.wrapT : bs,
                    s.magFilter = void 0 !== i.magFilter ? i.magFilter : Ss,
                    s.minFilter = void 0 !== i.minFilter ? i.minFilter : Ss,
                    s.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1,
                    void 0 !== i.encoding && (s.encoding = i.encoding),
                    void 0 !== i.flipY && (s.flipY = i.flipY),
                    void 0 !== i.format && (s.format = i.format),
                    void 0 !== i.type && (s.type = i.type),
                    void 0 !== i.mipmaps && (s.mipmaps = i.mipmaps,
                    s.minFilter = Ls),
                    1 === i.mipmapCount && (s.minFilter = Ss),
                    s.needsUpdate = !0,
                    e && e(s, i))
                }
                ), i, n),
                s
            }
        }),
        gf.prototype = Object.assign(Object.create(lf.prototype), {
            constructor: gf,
            load: function(t, e, i, n) {
                const r = new yo
                  , s = new pf(this.manager);
                return s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path),
                s.load(t, (function(i) {
                    r.image = i;
                    const n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                    r.format = n ? js : Gs,
                    r.needsUpdate = !0,
                    void 0 !== e && e(r)
                }
                ), i, n),
                r
            }
        }),
        Object.assign(vf.prototype, {
            getPoint: function() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            },
            getPointAt: function(t, e) {
                const i = this.getUtoTmapping(t);
                return this.getPoint(i, e)
            },
            getPoints: function(t=5) {
                const e = [];
                for (let i = 0; i <= t; i++)
                    e.push(this.getPoint(i / t));
                return e
            },
            getSpacedPoints: function(t=5) {
                const e = [];
                for (let i = 0; i <= t; i++)
                    e.push(this.getPointAt(i / t));
                return e
            },
            getLength: function() {
                const t = this.getLengths();
                return t[t.length - 1]
            },
            getLengths: function(t) {
                if (void 0 === t && (t = this.arcLengthDivisions),
                this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                const e = [];
                let i, n = this.getPoint(0), r = 0;
                e.push(0);
                for (let s = 1; s <= t; s++)
                    i = this.getPoint(s / t),
                    r += i.distanceTo(n),
                    e.push(r),
                    n = i;
                return this.cacheArcLengths = e,
                e
            },
            updateArcLengths: function() {
                this.needsUpdate = !0,
                this.getLengths()
            },
            getUtoTmapping: function(t, e) {
                const i = this.getLengths();
                let n = 0;
                const r = i.length;
                let s;
                s = e || t * i[r - 1];
                let a, o = 0, h = r - 1;
                for (; o <= h; )
                    if (n = Math.floor(o + (h - o) / 2),
                    a = i[n] - s,
                    a < 0)
                        o = n + 1;
                    else {
                        if (!(a > 0)) {
                            h = n;
                            break
                        }
                        h = n - 1
                    }
                if (n = h,
                i[n] === s)
                    return n / (r - 1);
                const l = i[n];
                return (n + (s - l) / (i[n + 1] - l)) / (r - 1)
            },
            getTangent: function(t, e) {
                const i = 1e-4;
                let n = t - i
                  , r = t + i;
                n < 0 && (n = 0),
                r > 1 && (r = 1);
                const s = this.getPoint(n)
                  , a = this.getPoint(r)
                  , o = e || (s.isVector2 ? new po : new Mo);
                return o.copy(a).sub(s).normalize(),
                o
            },
            getTangentAt: function(t, e) {
                const i = this.getUtoTmapping(t);
                return this.getTangent(i, e)
            },
            computeFrenetFrames: function(t, e) {
                const i = new Mo
                  , n = []
                  , r = []
                  , s = []
                  , a = new Mo
                  , o = new $o;
                for (let e = 0; e <= t; e++) {
                    const i = e / t;
                    n[e] = this.getTangentAt(i, new Mo),
                    n[e].normalize()
                }
                r[0] = new Mo,
                s[0] = new Mo;
                let h = Number.MAX_VALUE;
                const l = Math.abs(n[0].x)
                  , c = Math.abs(n[0].y)
                  , u = Math.abs(n[0].z);
                l <= h && (h = l,
                i.set(1, 0, 0)),
                c <= h && (h = c,
                i.set(0, 1, 0)),
                u <= h && i.set(0, 0, 1),
                a.crossVectors(n[0], i).normalize(),
                r[0].crossVectors(n[0], a),
                s[0].crossVectors(n[0], r[0]);
                for (let e = 1; e <= t; e++) {
                    if (r[e] = r[e - 1].clone(),
                    s[e] = s[e - 1].clone(),
                    a.crossVectors(n[e - 1], n[e]),
                    a.length() > Number.EPSILON) {
                        a.normalize();
                        const t = Math.acos(uo.clamp(n[e - 1].dot(n[e]), -1, 1));
                        r[e].applyMatrix4(o.makeRotationAxis(a, t))
                    }
                    s[e].crossVectors(n[e], r[e])
                }
                if (!0 === e) {
                    let e = Math.acos(uo.clamp(r[0].dot(r[t]), -1, 1));
                    e /= t,
                    n[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                    for (let i = 1; i <= t; i++)
                        r[i].applyMatrix4(o.makeRotationAxis(n[i], e * i)),
                        s[i].crossVectors(n[i], r[i])
                }
                return {
                    tangents: n,
                    normals: r,
                    binormals: s
                }
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions,
                this
            },
            toJSON: function() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return t.arcLengthDivisions = this.arcLengthDivisions,
                t.type = this.type,
                t
            },
            fromJSON: function(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions,
                this
            }
        });
        class yf extends vf {
            constructor(t=0, e=0, i=1, n=1, r=0, s=2 * Math.PI, a=!1, o=0) {
                super(),
                this.type = "EllipseCurve",
                this.aX = t,
                this.aY = e,
                this.xRadius = i,
                this.yRadius = n,
                this.aStartAngle = r,
                this.aEndAngle = s,
                this.aClockwise = a,
                this.aRotation = o
            }
            getPoint(t, e) {
                const i = e || new po
                  , n = 2 * Math.PI;
                let r = this.aEndAngle - this.aStartAngle;
                const s = Math.abs(r) < Number.EPSILON;
                for (; r < 0; )
                    r += n;
                for (; r > n; )
                    r -= n;
                r < Number.EPSILON && (r = s ? 0 : n),
                !0 !== this.aClockwise || s || (r === n ? r = -n : r -= n);
                const a = this.aStartAngle + t * r;
                let o = this.aX + this.xRadius * Math.cos(a)
                  , h = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    const t = Math.cos(this.aRotation)
                      , e = Math.sin(this.aRotation)
                      , i = o - this.aX
                      , n = h - this.aY;
                    o = i * t - n * e + this.aX,
                    h = i * e + n * t + this.aY
                }
                return i.set(o, h)
            }
            copy(t) {
                return super.copy(t),
                this.aX = t.aX,
                this.aY = t.aY,
                this.xRadius = t.xRadius,
                this.yRadius = t.yRadius,
                this.aStartAngle = t.aStartAngle,
                this.aEndAngle = t.aEndAngle,
                this.aClockwise = t.aClockwise,
                this.aRotation = t.aRotation,
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.aX = this.aX,
                t.aY = this.aY,
                t.xRadius = this.xRadius,
                t.yRadius = this.yRadius,
                t.aStartAngle = this.aStartAngle,
                t.aEndAngle = this.aEndAngle,
                t.aClockwise = this.aClockwise,
                t.aRotation = this.aRotation,
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.aX = t.aX,
                this.aY = t.aY,
                this.xRadius = t.xRadius,
                this.yRadius = t.yRadius,
                this.aStartAngle = t.aStartAngle,
                this.aEndAngle = t.aEndAngle,
                this.aClockwise = t.aClockwise,
                this.aRotation = t.aRotation,
                this
            }
        }
        yf.prototype.isEllipseCurve = !0;
        class xf extends yf {
            constructor(t, e, i, n, r, s) {
                super(t, e, i, i, n, r, s),
                this.type = "ArcCurve"
            }
        }
        function _f() {
            let t = 0
              , e = 0
              , i = 0
              , n = 0;
            function r(r, s, a, o) {
                t = r,
                e = a,
                i = -3 * r + 3 * s - 2 * a - o,
                n = 2 * r - 2 * s + a + o
            }
            return {
                initCatmullRom: function(t, e, i, n, s) {
                    r(e, i, s * (i - t), s * (n - e))
                },
                initNonuniformCatmullRom: function(t, e, i, n, s, a, o) {
                    let h = (e - t) / s - (i - t) / (s + a) + (i - e) / a
                      , l = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
                    h *= a,
                    l *= a,
                    r(e, i, h, l)
                },
                calc: function(r) {
                    const s = r * r;
                    return t + e * r + i * s + n * (s * r)
                }
            }
        }
        xf.prototype.isArcCurve = !0;
        const bf = new Mo
          , wf = new _f
          , Mf = new _f
          , Tf = new _f;
        class Ef extends vf {
            constructor(t=[], e=!1, i="centripetal", n=.5) {
                super(),
                this.type = "CatmullRomCurve3",
                this.points = t,
                this.closed = e,
                this.curveType = i,
                this.tension = n
            }
            getPoint(t, e=new Mo) {
                const i = e
                  , n = this.points
                  , r = n.length
                  , s = (r - (this.closed ? 0 : 1)) * t;
                let a, o, h = Math.floor(s), l = s - h;
                this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / r) + 1) * r : 0 === l && h === r - 1 && (h = r - 2,
                l = 1),
                this.closed || h > 0 ? a = n[(h - 1) % r] : (bf.subVectors(n[0], n[1]).add(n[0]),
                a = bf);
                const c = n[h % r]
                  , u = n[(h + 1) % r];
                if (this.closed || h + 2 < r ? o = n[(h + 2) % r] : (bf.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]),
                o = bf),
                "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const t = "chordal" === this.curveType ? .5 : .25;
                    let e = Math.pow(a.distanceToSquared(c), t)
                      , i = Math.pow(c.distanceToSquared(u), t)
                      , n = Math.pow(u.distanceToSquared(o), t);
                    i < 1e-4 && (i = 1),
                    e < 1e-4 && (e = i),
                    n < 1e-4 && (n = i),
                    wf.initNonuniformCatmullRom(a.x, c.x, u.x, o.x, e, i, n),
                    Mf.initNonuniformCatmullRom(a.y, c.y, u.y, o.y, e, i, n),
                    Tf.initNonuniformCatmullRom(a.z, c.z, u.z, o.z, e, i, n)
                } else
                    "catmullrom" === this.curveType && (wf.initCatmullRom(a.x, c.x, u.x, o.x, this.tension),
                    Mf.initCatmullRom(a.y, c.y, u.y, o.y, this.tension),
                    Tf.initCatmullRom(a.z, c.z, u.z, o.z, this.tension));
                return i.set(wf.calc(l), Mf.calc(l), Tf.calc(l)),
                i
            }
            copy(t) {
                super.copy(t),
                this.points = [];
                for (let e = 0, i = t.points.length; e < i; e++) {
                    const i = t.points[e];
                    this.points.push(i.clone())
                }
                return this.closed = t.closed,
                this.curveType = t.curveType,
                this.tension = t.tension,
                this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, i = this.points.length; e < i; e++) {
                    const i = this.points[e];
                    t.points.push(i.toArray())
                }
                return t.closed = this.closed,
                t.curveType = this.curveType,
                t.tension = this.tension,
                t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.points = [];
                for (let e = 0, i = t.points.length; e < i; e++) {
                    const i = t.points[e];
                    this.points.push((new Mo).fromArray(i))
                }
                return this.closed = t.closed,
                this.curveType = t.curveType,
                this.tension = t.tension,
                this
            }
        }
        function Sf(t, e, i, n, r) {
            const s = .5 * (n - e)
              , a = .5 * (r - i)
              , o = t * t;
            return (2 * i - 2 * n + s + a) * (t * o) + (-3 * i + 3 * n - 2 * s - a) * o + s * t + i
        }
        function Af(t, e, i, n) {
            return function(t, e) {
                const i = 1 - t;
                return i * i * e
            }(t, e) + function(t, e) {
                return 2 * (1 - t) * t * e
            }(t, i) + function(t, e) {
                return t * t * e
            }(t, n)
        }
        function Lf(t, e, i, n, r) {
            return function(t, e) {
                const i = 1 - t;
                return i * i * i * e
            }(t, e) + function(t, e) {
                const i = 1 - t;
                return 3 * i * i * t * e
            }(t, i) + function(t, e) {
                return 3 * (1 - t) * t * t * e
            }(t, n) + function(t, e) {
                return t * t * t * e
            }(t, r)
        }
        Ef.prototype.isCatmullRomCurve3 = !0;
        class Pf extends vf {
            constructor(t=new po, e=new po, i=new po, n=new po) {
                super(),
                this.type = "CubicBezierCurve",
                this.v0 = t,
                this.v1 = e,
                this.v2 = i,
                this.v3 = n
            }
            getPoint(t, e=new po) {
                const i = e
                  , n = this.v0
                  , r = this.v1
                  , s = this.v2
                  , a = this.v3;
                return i.set(Lf(t, n.x, r.x, s.x, a.x), Lf(t, n.y, r.y, s.y, a.y)),
                i
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this.v3.copy(t.v3),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t.v3 = this.v3.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this.v3.fromArray(t.v3),
                this
            }
        }
        Pf.prototype.isCubicBezierCurve = !0;
        class Cf extends vf {
            constructor(t=new Mo, e=new Mo, i=new Mo, n=new Mo) {
                super(),
                this.type = "CubicBezierCurve3",
                this.v0 = t,
                this.v1 = e,
                this.v2 = i,
                this.v3 = n
            }
            getPoint(t, e=new Mo) {
                const i = e
                  , n = this.v0
                  , r = this.v1
                  , s = this.v2
                  , a = this.v3;
                return i.set(Lf(t, n.x, r.x, s.x, a.x), Lf(t, n.y, r.y, s.y, a.y), Lf(t, n.z, r.z, s.z, a.z)),
                i
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this.v3.copy(t.v3),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t.v3 = this.v3.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this.v3.fromArray(t.v3),
                this
            }
        }
        Cf.prototype.isCubicBezierCurve3 = !0;
        class Rf extends vf {
            constructor(t=new po, e=new po) {
                super(),
                this.type = "LineCurve",
                this.v1 = t,
                this.v2 = e
            }
            getPoint(t, e=new po) {
                const i = e;
                return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
                i.multiplyScalar(t).add(this.v1)),
                i
            }
            getPointAt(t, e) {
                return this.getPoint(t, e)
            }
            getTangent(t, e) {
                const i = e || new po;
                return i.copy(this.v2).sub(this.v1).normalize(),
                i
            }
            copy(t) {
                return super.copy(t),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        Rf.prototype.isLineCurve = !0;
        class Of extends vf {
            constructor(t=new po, e=new po, i=new po) {
                super(),
                this.type = "QuadraticBezierCurve",
                this.v0 = t,
                this.v1 = e,
                this.v2 = i
            }
            getPoint(t, e=new po) {
                const i = e
                  , n = this.v0
                  , r = this.v1
                  , s = this.v2;
                return i.set(Af(t, n.x, r.x, s.x), Af(t, n.y, r.y, s.y)),
                i
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        Of.prototype.isQuadraticBezierCurve = !0;
        class Df extends vf {
            constructor(t=new Mo, e=new Mo, i=new Mo) {
                super(),
                this.type = "QuadraticBezierCurve3",
                this.v0 = t,
                this.v1 = e,
                this.v2 = i
            }
            getPoint(t, e=new Mo) {
                const i = e
                  , n = this.v0
                  , r = this.v1
                  , s = this.v2;
                return i.set(Af(t, n.x, r.x, s.x), Af(t, n.y, r.y, s.y), Af(t, n.z, r.z, s.z)),
                i
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        Df.prototype.isQuadraticBezierCurve3 = !0;
        class If extends vf {
            constructor(t=[]) {
                super(),
                this.type = "SplineCurve",
                this.points = t
            }
            getPoint(t, e=new po) {
                const i = e
                  , n = this.points
                  , r = (n.length - 1) * t
                  , s = Math.floor(r)
                  , a = r - s
                  , o = n[0 === s ? s : s - 1]
                  , h = n[s]
                  , l = n[s > n.length - 2 ? n.length - 1 : s + 1]
                  , c = n[s > n.length - 3 ? n.length - 1 : s + 2];
                return i.set(Sf(a, o.x, h.x, l.x, c.x), Sf(a, o.y, h.y, l.y, c.y)),
                i
            }
            copy(t) {
                super.copy(t),
                this.points = [];
                for (let e = 0, i = t.points.length; e < i; e++) {
                    const i = t.points[e];
                    this.points.push(i.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, i = this.points.length; e < i; e++) {
                    const i = this.points[e];
                    t.points.push(i.toArray())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.points = [];
                for (let e = 0, i = t.points.length; e < i; e++) {
                    const i = t.points[e];
                    this.points.push((new po).fromArray(i))
                }
                return this
            }
        }
        If.prototype.isSplineCurve = !0;
        var Nf = Object.freeze({
            __proto__: null,
            ArcCurve: xf,
            CatmullRomCurve3: Ef,
            CubicBezierCurve: Pf,
            CubicBezierCurve3: Cf,
            EllipseCurve: yf,
            LineCurve: Rf,
            LineCurve3: class extends vf {
                constructor(t=new Mo, e=new Mo) {
                    super(),
                    this.type = "LineCurve3",
                    this.isLineCurve3 = !0,
                    this.v1 = t,
                    this.v2 = e
                }
                getPoint(t, e=new Mo) {
                    const i = e;
                    return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
                    i.multiplyScalar(t).add(this.v1)),
                    i
                }
                getPointAt(t, e) {
                    return this.getPoint(t, e)
                }
                copy(t) {
                    return super.copy(t),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v1 = this.v1.toArray(),
                    t.v2 = this.v2.toArray(),
                    t
                }
                fromJSON(t) {
                    return super.fromJSON(t),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
                }
            }
            ,
            QuadraticBezierCurve: Of,
            QuadraticBezierCurve3: Df,
            SplineCurve: If
        });
        class zf extends vf {
            constructor() {
                super(),
                this.type = "CurvePath",
                this.curves = [],
                this.autoClose = !1
            }
            add(t) {
                this.curves.push(t)
            }
            closePath() {
                const t = this.curves[0].getPoint(0)
                  , e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new Rf(e,t))
            }
            getPoint(t) {
                const e = t * this.getLength()
                  , i = this.getCurveLengths();
                let n = 0;
                for (; n < i.length; ) {
                    if (i[n] >= e) {
                        const t = i[n] - e
                          , r = this.curves[n]
                          , s = r.getLength()
                          , a = 0 === s ? 0 : 1 - t / s;
                        return r.getPointAt(a)
                    }
                    n++
                }
                return null
            }
            getLength() {
                const t = this.getCurveLengths();
                return t[t.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.cacheLengths = null,
                this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                const t = [];
                let e = 0;
                for (let i = 0, n = this.curves.length; i < n; i++)
                    e += this.curves[i].getLength(),
                    t.push(e);
                return this.cacheLengths = t,
                t
            }
            getSpacedPoints(t=40) {
                const e = [];
                for (let i = 0; i <= t; i++)
                    e.push(this.getPoint(i / t));
                return this.autoClose && e.push(e[0]),
                e
            }
            getPoints(t=12) {
                const e = [];
                let i;
                for (let n = 0, r = this.curves; n < r.length; n++) {
                    const s = r[n]
                      , a = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t
                      , o = s.getPoints(a);
                    for (let t = 0; t < o.length; t++) {
                        const n = o[t];
                        i && i.equals(n) || (e.push(n),
                        i = n)
                    }
                }
                return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]),
                e
            }
            copy(t) {
                super.copy(t),
                this.curves = [];
                for (let e = 0, i = t.curves.length; e < i; e++) {
                    const i = t.curves[e];
                    this.curves.push(i.clone())
                }
                return this.autoClose = t.autoClose,
                this
            }
            toJSON() {
                const t = super.toJSON();
                t.autoClose = this.autoClose,
                t.curves = [];
                for (let e = 0, i = this.curves.length; e < i; e++) {
                    const i = this.curves[e];
                    t.curves.push(i.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.autoClose = t.autoClose,
                this.curves = [];
                for (let e = 0, i = t.curves.length; e < i; e++) {
                    const i = t.curves[e];
                    this.curves.push((new Nf[i.type]).fromJSON(i))
                }
                return this
            }
        }
        class Bf extends zf {
            constructor(t) {
                super(),
                this.type = "Path",
                this.currentPoint = new po,
                t && this.setFromPoints(t)
            }
            setFromPoints(t) {
                this.moveTo(t[0].x, t[0].y);
                for (let e = 1, i = t.length; e < i; e++)
                    this.lineTo(t[e].x, t[e].y);
                return this
            }
            moveTo(t, e) {
                return this.currentPoint.set(t, e),
                this
            }
            lineTo(t, e) {
                const i = new Rf(this.currentPoint.clone(),new po(t,e));
                return this.curves.push(i),
                this.currentPoint.set(t, e),
                this
            }
            quadraticCurveTo(t, e, i, n) {
                const r = new Of(this.currentPoint.clone(),new po(t,e),new po(i,n));
                return this.curves.push(r),
                this.currentPoint.set(i, n),
                this
            }
            bezierCurveTo(t, e, i, n, r, s) {
                const a = new Pf(this.currentPoint.clone(),new po(t,e),new po(i,n),new po(r,s));
                return this.curves.push(a),
                this.currentPoint.set(r, s),
                this
            }
            splineThru(t) {
                const e = [this.currentPoint.clone()].concat(t)
                  , i = new If(e);
                return this.curves.push(i),
                this.currentPoint.copy(t[t.length - 1]),
                this
            }
            arc(t, e, i, n, r, s) {
                const a = this.currentPoint.x
                  , o = this.currentPoint.y;
                return this.absarc(t + a, e + o, i, n, r, s),
                this
            }
            absarc(t, e, i, n, r, s) {
                return this.absellipse(t, e, i, i, n, r, s),
                this
            }
            ellipse(t, e, i, n, r, s, a, o) {
                const h = this.currentPoint.x
                  , l = this.currentPoint.y;
                return this.absellipse(t + h, e + l, i, n, r, s, a, o),
                this
            }
            absellipse(t, e, i, n, r, s, a, o) {
                const h = new yf(t,e,i,n,r,s,a,o);
                if (this.curves.length > 0) {
                    const t = h.getPoint(0);
                    t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                }
                this.curves.push(h);
                const l = h.getPoint(1);
                return this.currentPoint.copy(l),
                this
            }
            copy(t) {
                return super.copy(t),
                this.currentPoint.copy(t.currentPoint),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.currentPoint = this.currentPoint.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.currentPoint.fromArray(t.currentPoint),
                this
            }
        }
        class kf extends Bf {
            constructor(t) {
                super(t),
                this.uuid = uo.generateUUID(),
                this.type = "Shape",
                this.holes = []
            }
            getPointsHoles(t) {
                const e = [];
                for (let i = 0, n = this.holes.length; i < n; i++)
                    e[i] = this.holes[i].getPoints(t);
                return e
            }
            extractPoints(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            }
            copy(t) {
                super.copy(t),
                this.holes = [];
                for (let e = 0, i = t.holes.length; e < i; e++) {
                    const i = t.holes[e];
                    this.holes.push(i.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.uuid = this.uuid,
                t.holes = [];
                for (let e = 0, i = this.holes.length; e < i; e++) {
                    const i = this.holes[e];
                    t.holes.push(i.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.uuid = t.uuid,
                this.holes = [];
                for (let e = 0, i = t.holes.length; e < i; e++) {
                    const i = t.holes[e];
                    this.holes.push((new Bf).fromJSON(i))
                }
                return this
            }
        }
        class Ff extends wh {
            constructor(t, e=1) {
                super(),
                this.type = "Light",
                this.color = new qh(t),
                this.intensity = e
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.intensity = t.intensity,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(),
                e.object.intensity = this.intensity,
                void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (e.object.distance = this.distance),
                void 0 !== this.angle && (e.object.angle = this.angle),
                void 0 !== this.decay && (e.object.decay = this.decay),
                void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                e
            }
        }
        Ff.prototype.isLight = !0;
        (class extends Ff {
            constructor(t, e, i) {
                super(t, i),
                this.type = "HemisphereLight",
                this.position.copy(wh.DefaultUp),
                this.updateMatrix(),
                this.groundColor = new qh(e)
            }
            copy(t) {
                return Ff.prototype.copy.call(this, t),
                this.groundColor.copy(t.groundColor),
                this
            }
        }
        ).prototype.isHemisphereLight = !0;
        const Uf = new $o
          , Hf = new Mo
          , jf = new Mo;
        class Gf {
            constructor(t) {
                this.camera = t,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.mapSize = new po(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new $o,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new $l,
                this._frameExtents = new po(1,1),
                this._viewportCount = 1,
                this._viewports = [new _o(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera
                  , i = this.matrix;
                Hf.setFromMatrixPosition(t.matrixWorld),
                e.position.copy(Hf),
                jf.setFromMatrixPosition(t.target.matrixWorld),
                e.lookAt(jf),
                e.updateMatrixWorld(),
                Uf.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(Uf),
                i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                i.multiply(e.projectionMatrix),
                i.multiply(e.matrixWorldInverse)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            copy(t) {
                return this.camera = t.camera.clone(),
                this.bias = t.bias,
                this.radius = t.radius,
                this.mapSize.copy(t.mapSize),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias),
                0 !== this.normalBias && (t.normalBias = this.normalBias),
                1 !== this.radius && (t.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
                t.camera = this.camera.toJSON(!1).object,
                delete t.camera.matrix,
                t
            }
        }
        class Wf extends Gf {
            constructor() {
                super(new Gl(50,1,.5,500)),
                this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera
                  , i = 2 * uo.RAD2DEG * t.angle * this.focus
                  , n = this.mapSize.width / this.mapSize.height
                  , r = t.distance || e.far;
                i === e.fov && n === e.aspect && r === e.far || (e.fov = i,
                e.aspect = n,
                e.far = r,
                e.updateProjectionMatrix()),
                super.updateMatrices(t)
            }
        }
        Wf.prototype.isSpotLightShadow = !0;
        (class extends Ff {
            constructor(t, e, i=0, n=Math.PI / 3, r=0, s=1) {
                super(t, e),
                this.type = "SpotLight",
                this.position.copy(wh.DefaultUp),
                this.updateMatrix(),
                this.target = new wh,
                this.distance = i,
                this.angle = n,
                this.penumbra = r,
                this.decay = s,
                this.shadow = new Wf
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            copy(t) {
                return super.copy(t),
                this.distance = t.distance,
                this.angle = t.angle,
                this.penumbra = t.penumbra,
                this.decay = t.decay,
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        ).prototype.isSpotLight = !0;
        const Vf = new $o
          , qf = new Mo
          , Xf = new Mo;
        class Yf extends Gf {
            constructor() {
                super(new Gl(90,1,.5,500)),
                this._frameExtents = new po(4,2),
                this._viewportCount = 6,
                this._viewports = [new _o(2,1,1,1), new _o(0,1,1,1), new _o(3,1,1,1), new _o(1,1,1,1), new _o(3,0,1,1), new _o(1,0,1,1)],
                this._cubeDirections = [new Mo(1,0,0), new Mo(-1,0,0), new Mo(0,0,1), new Mo(0,0,-1), new Mo(0,1,0), new Mo(0,-1,0)],
                this._cubeUps = [new Mo(0,1,0), new Mo(0,1,0), new Mo(0,1,0), new Mo(0,1,0), new Mo(0,0,1), new Mo(0,0,-1)]
            }
            updateMatrices(t, e=0) {
                const i = this.camera
                  , n = this.matrix;
                qf.setFromMatrixPosition(t.matrixWorld),
                i.position.copy(qf),
                Xf.copy(i.position),
                Xf.add(this._cubeDirections[e]),
                i.up.copy(this._cubeUps[e]),
                i.lookAt(Xf),
                i.updateMatrixWorld(),
                n.makeTranslation(-qf.x, -qf.y, -qf.z),
                Vf.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(Vf)
            }
        }
        Yf.prototype.isPointLightShadow = !0;
        (class extends Ff {
            constructor(t, e, i=0, n=1) {
                super(t, e),
                this.type = "PointLight",
                this.distance = i,
                this.decay = n,
                this.shadow = new Yf
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            copy(t) {
                return super.copy(t),
                this.distance = t.distance,
                this.decay = t.decay,
                this.shadow = t.shadow.clone(),
                this
            }
        }
        ).prototype.isPointLight = !0;
        class Zf extends jl {
            constructor(t=-1, e=1, i=1, n=-1, r=.1, s=2e3) {
                super(),
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = t,
                this.right = e,
                this.top = i,
                this.bottom = n,
                this.near = r,
                this.far = s,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.left = t.left,
                this.right = t.right,
                this.top = t.top,
                this.bottom = t.bottom,
                this.near = t.near,
                this.far = t.far,
                this.zoom = t.zoom,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this
            }
            setViewOffset(t, e, i, n, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = i,
                this.view.offsetY = n,
                this.view.width = r,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom)
                  , e = (this.top - this.bottom) / (2 * this.zoom)
                  , i = (this.right + this.left) / 2
                  , n = (this.top + this.bottom) / 2;
                let r = i - t
                  , s = i + t
                  , a = n + e
                  , o = n - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX,
                    s = r + t * this.view.width,
                    a -= e * this.view.offsetY,
                    o = a - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = wh.prototype.toJSON.call(this, t);
                return e.object.zoom = this.zoom,
                e.object.left = this.left,
                e.object.right = this.right,
                e.object.top = this.top,
                e.object.bottom = this.bottom,
                e.object.near = this.near,
                e.object.far = this.far,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e
            }
        }
        Zf.prototype.isOrthographicCamera = !0;
        class Jf extends Gf {
            constructor() {
                super(new Zf(-5,5,5,-5,.5,500))
            }
        }
        Jf.prototype.isDirectionalLightShadow = !0;
        (class extends Ff {
            constructor(t, e) {
                super(t, e),
                this.type = "DirectionalLight",
                this.position.copy(wh.DefaultUp),
                this.updateMatrix(),
                this.target = new wh,
                this.shadow = new Jf
            }
            copy(t) {
                return super.copy(t),
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        ).prototype.isDirectionalLight = !0;
        (class extends Ff {
            constructor(t, e) {
                super(t, e),
                this.type = "AmbientLight"
            }
        }
        ).prototype.isAmbientLight = !0;
        (class extends Ff {
            constructor(t, e, i=10, n=10) {
                super(t, e),
                this.type = "RectAreaLight",
                this.width = i,
                this.height = n
            }
            copy(t) {
                return super.copy(t),
                this.width = t.width,
                this.height = t.height,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.width = this.width,
                e.object.height = this.height,
                e
            }
        }
        ).prototype.isRectAreaLight = !0;
        class $f {
            constructor() {
                this.coefficients = [];
                for (let t = 0; t < 9; t++)
                    this.coefficients.push(new Mo)
            }
            set(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].copy(t[e]);
                return this
            }
            zero() {
                for (let t = 0; t < 9; t++)
                    this.coefficients[t].set(0, 0, 0);
                return this
            }
            getAt(t, e) {
                const i = t.x
                  , n = t.y
                  , r = t.z
                  , s = this.coefficients;
                return e.copy(s[0]).multiplyScalar(.282095),
                e.addScaledVector(s[1], .488603 * n),
                e.addScaledVector(s[2], .488603 * r),
                e.addScaledVector(s[3], .488603 * i),
                e.addScaledVector(s[4], i * n * 1.092548),
                e.addScaledVector(s[5], n * r * 1.092548),
                e.addScaledVector(s[6], .315392 * (3 * r * r - 1)),
                e.addScaledVector(s[7], i * r * 1.092548),
                e.addScaledVector(s[8], .546274 * (i * i - n * n)),
                e
            }
            getIrradianceAt(t, e) {
                const i = t.x
                  , n = t.y
                  , r = t.z
                  , s = this.coefficients;
                return e.copy(s[0]).multiplyScalar(.886227),
                e.addScaledVector(s[1], 1.023328 * n),
                e.addScaledVector(s[2], 1.023328 * r),
                e.addScaledVector(s[3], 1.023328 * i),
                e.addScaledVector(s[4], .858086 * i * n),
                e.addScaledVector(s[5], .858086 * n * r),
                e.addScaledVector(s[6], .743125 * r * r - .247708),
                e.addScaledVector(s[7], .858086 * i * r),
                e.addScaledVector(s[8], .429043 * (i * i - n * n)),
                e
            }
            add(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].add(t.coefficients[e]);
                return this
            }
            addScaledSH(t, e) {
                for (let i = 0; i < 9; i++)
                    this.coefficients[i].addScaledVector(t.coefficients[i], e);
                return this
            }
            scale(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].multiplyScalar(t);
                return this
            }
            lerp(t, e) {
                for (let i = 0; i < 9; i++)
                    this.coefficients[i].lerp(t.coefficients[i], e);
                return this
            }
            equals(t) {
                for (let e = 0; e < 9; e++)
                    if (!this.coefficients[e].equals(t.coefficients[e]))
                        return !1;
                return !0
            }
            copy(t) {
                return this.set(t.coefficients)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            fromArray(t, e=0) {
                const i = this.coefficients;
                for (let n = 0; n < 9; n++)
                    i[n].fromArray(t, e + 3 * n);
                return this
            }
            toArray(t=[], e=0) {
                const i = this.coefficients;
                for (let n = 0; n < 9; n++)
                    i[n].toArray(t, e + 3 * n);
                return t
            }
            static getBasisAt(t, e) {
                const i = t.x
                  , n = t.y
                  , r = t.z;
                e[0] = .282095,
                e[1] = .488603 * n,
                e[2] = .488603 * r,
                e[3] = .488603 * i,
                e[4] = 1.092548 * i * n,
                e[5] = 1.092548 * n * r,
                e[6] = .315392 * (3 * r * r - 1),
                e[7] = 1.092548 * i * r,
                e[8] = .546274 * (i * i - n * n)
            }
        }
        $f.prototype.isSphericalHarmonics3 = !0;
        class Qf extends Ff {
            constructor(t=new $f, e=1) {
                super(void 0, e),
                this.sh = t
            }
            copy(t) {
                return super.copy(t),
                this.sh.copy(t.sh),
                this
            }
            fromJSON(t) {
                return this.intensity = t.intensity,
                this.sh.fromArray(t.sh),
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.sh = this.sh.toArray(),
                e
            }
        }
        Qf.prototype.isLightProbe = !0;
        function Kf() {
            ml.call(this),
            this.type = "InstancedBufferGeometry",
            this.instanceCount = 1 / 0
        }
        function tm(t, e, i, n) {
            "number" == typeof i && (n = i,
            i = !1,
            console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
            Jh.call(this, t, e, i),
            this.meshPerAttribute = n || 1
        }
        function em(t) {
            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
            "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            lf.call(this, t),
            this.options = {
                premultiplyAlpha: "none"
            }
        }
        Kf.prototype = Object.assign(Object.create(ml.prototype), {
            constructor: Kf,
            isInstancedBufferGeometry: !0,
            copy: function(t) {
                return ml.prototype.copy.call(this, t),
                this.instanceCount = t.instanceCount,
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                const t = ml.prototype.toJSON.call(this);
                return t.instanceCount = this.instanceCount,
                t.isInstancedBufferGeometry = !0,
                t
            }
        }),
        tm.prototype = Object.assign(Object.create(Jh.prototype), {
            constructor: tm,
            isInstancedBufferAttribute: !0,
            copy: function(t) {
                return Jh.prototype.copy.call(this, t),
                this.meshPerAttribute = t.meshPerAttribute,
                this
            },
            toJSON: function() {
                const t = Jh.prototype.toJSON.call(this);
                return t.meshPerAttribute = this.meshPerAttribute,
                t.isInstancedBufferAttribute = !0,
                t
            }
        }),
        em.prototype = Object.assign(Object.create(lf.prototype), {
            constructor: em,
            isImageBitmapLoader: !0,
            setOptions: function(t) {
                return this.options = t,
                this
            },
            load: function(t, e, i, n) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = this
                  , s = af.get(t);
                if (void 0 !== s)
                    return r.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        r.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                const a = {};
                a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                a.headers = this.requestHeader,
                fetch(t, a).then((function(t) {
                    return t.blob()
                }
                )).then((function(t) {
                    return createImageBitmap(t, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                }
                )).then((function(i) {
                    af.add(t, i),
                    e && e(i),
                    r.manager.itemEnd(t)
                }
                )).catch((function(e) {
                    n && n(e),
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                )),
                r.manager.itemStart(t)
            }
        });
        let im;
        class nm extends lf {
            constructor(t) {
                super(t)
            }
            load(t, e, i, n) {
                const r = this
                  , s = new uf(this.manager);
                s.setResponseType("arraybuffer"),
                s.setPath(this.path),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(t, (function(i) {
                    try {
                        const t = i.slice(0);
                        (void 0 === im && (im = new (window.AudioContext || window.webkitAudioContext)),
                        im).decodeAudioData(t, (function(t) {
                            e(t)
                        }
                        ))
                    } catch (e) {
                        n ? n(e) : console.error(e),
                        r.manager.itemError(t)
                    }
                }
                ), i, n)
            }
        }
        (class extends Qf {
            constructor(t, e, i=1) {
                super(void 0, i);
                const n = (new qh).set(t)
                  , r = (new qh).set(e)
                  , s = new Mo(n.r,n.g,n.b)
                  , a = new Mo(r.r,r.g,r.b)
                  , o = Math.sqrt(Math.PI)
                  , h = o * Math.sqrt(.75);
                this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
                this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(h)
            }
        }
        ).prototype.isHemisphereLightProbe = !0,
        class extends Qf {
            constructor(t, e=1) {
                super(void 0, e);
                const i = (new qh).set(t);
                this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
        }
        .prototype.isAmbientLightProbe = !0,
        new $o,
        new $o;
        class rm {
            constructor(t, e, i) {
                let n, r, s;
                switch (this.binding = t,
                this.valueSize = i,
                e) {
                case "quaternion":
                    n = this._slerp,
                    r = this._slerpAdditive,
                    s = this._setAdditiveIdentityQuaternion,
                    this.buffer = new Float64Array(6 * i),
                    this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    n = this._select,
                    r = this._select,
                    s = this._setAdditiveIdentityOther,
                    this.buffer = new Array(5 * i);
                    break;
                default:
                    n = this._lerp,
                    r = this._lerpAdditive,
                    s = this._setAdditiveIdentityNumeric,
                    this.buffer = new Float64Array(5 * i)
                }
                this._mixBufferRegion = n,
                this._mixBufferRegionAdditive = r,
                this._setIdentity = s,
                this._origIndex = 3,
                this._addIndex = 4,
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                this.useCount = 0,
                this.referenceCount = 0
            }
            accumulate(t, e) {
                const i = this.buffer
                  , n = this.valueSize
                  , r = t * n + n;
                let s = this.cumulativeWeight;
                if (0 === s) {
                    for (let t = 0; t !== n; ++t)
                        i[r + t] = i[t];
                    s = e
                } else {
                    s += e;
                    const t = e / s;
                    this._mixBufferRegion(i, r, 0, t, n)
                }
                this.cumulativeWeight = s
            }
            accumulateAdditive(t) {
                const e = this.buffer
                  , i = this.valueSize
                  , n = i * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(),
                this._mixBufferRegionAdditive(e, n, 0, t, i),
                this.cumulativeWeightAdditive += t
            }
            apply(t) {
                const e = this.valueSize
                  , i = this.buffer
                  , n = t * e + e
                  , r = this.cumulativeWeight
                  , s = this.cumulativeWeightAdditive
                  , a = this.binding;
                if (this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                r < 1) {
                    const t = e * this._origIndex;
                    this._mixBufferRegion(i, n, t, 1 - r, e)
                }
                s > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
                for (let t = e, r = e + e; t !== r; ++t)
                    if (i[t] !== i[t + e]) {
                        a.setValue(i, n);
                        break
                    }
            }
            saveOriginalState() {
                const t = this.binding
                  , e = this.buffer
                  , i = this.valueSize
                  , n = i * this._origIndex;
                t.getValue(e, n);
                for (let t = i, r = n; t !== r; ++t)
                    e[t] = e[n + t % i];
                this._setIdentity(),
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            }
            _setAdditiveIdentityNumeric() {
                const t = this._addIndex * this.valueSize
                  , e = t + this.valueSize;
                for (let i = t; i < e; i++)
                    this.buffer[i] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(),
                this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const t = this._origIndex * this.valueSize
                  , e = this._addIndex * this.valueSize;
                for (let i = 0; i < this.valueSize; i++)
                    this.buffer[e + i] = this.buffer[t + i]
            }
            _select(t, e, i, n, r) {
                if (n >= .5)
                    for (let n = 0; n !== r; ++n)
                        t[e + n] = t[i + n]
            }
            _slerp(t, e, i, n) {
                wo.slerpFlat(t, e, t, e, t, i, n)
            }
            _slerpAdditive(t, e, i, n, r) {
                const s = this._workIndex * r;
                wo.multiplyQuaternionsFlat(t, s, t, e, t, i),
                wo.slerpFlat(t, e, t, e, t, s, n)
            }
            _lerp(t, e, i, n, r) {
                const s = 1 - n;
                for (let a = 0; a !== r; ++a) {
                    const r = e + a;
                    t[r] = t[r] * s + t[i + a] * n
                }
            }
            _lerpAdditive(t, e, i, n, r) {
                for (let s = 0; s !== r; ++s) {
                    const r = e + s;
                    t[r] = t[r] + t[i + s] * n
                }
            }
        }
        const sm = "\\[\\]\\.:\\/"
          , am = new RegExp("[" + sm + "]","g")
          , om = "[^" + sm + "]"
          , hm = "[^" + sm.replace("\\.", "") + "]"
          , lm = /((?:WC+[\/:])*)/.source.replace("WC", om)
          , cm = /(WCOD+)?/.source.replace("WCOD", hm)
          , um = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", om)
          , dm = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", om)
          , pm = new RegExp("^" + lm + cm + um + dm + "$")
          , fm = ["material", "materials", "bones"];
        function mm(t, e, i) {
            const n = i || gm.parseTrackName(e);
            this._targetGroup = t,
            this._bindings = t.subscribe_(e, n)
        }
        function gm(t, e, i) {
            this.path = e,
            this.parsedPath = i || gm.parseTrackName(e),
            this.node = gm.findNode(t, this.parsedPath.nodeName) || t,
            this.rootNode = t
        }
        Object.assign(mm.prototype, {
            getValue: function(t, e) {
                this.bind();
                const i = this._targetGroup.nCachedObjects_
                  , n = this._bindings[i];
                void 0 !== n && n.getValue(t, e)
            },
            setValue: function(t, e) {
                const i = this._bindings;
                for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
                    i[n].setValue(t, e)
            },
            bind: function() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
                    t[e].bind()
            },
            unbind: function() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
                    t[e].unbind()
            }
        }),
        Object.assign(gm, {
            Composite: mm,
            create: function(t, e, i) {
                return t && t.isAnimationObjectGroup ? new gm.Composite(t,e,i) : new gm(t,e,i)
            },
            sanitizeNodeName: function(t) {
                return t.replace(/\s/g, "_").replace(am, "")
            },
            parseTrackName: function(t) {
                const e = pm.exec(t);
                if (!e)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const i = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }
                  , n = i.nodeName && i.nodeName.lastIndexOf(".");
                if (void 0 !== n && -1 !== n) {
                    const t = i.nodeName.substring(n + 1);
                    -1 !== fm.indexOf(t) && (i.nodeName = i.nodeName.substring(0, n),
                    i.objectName = t)
                }
                if (null === i.propertyName || 0 === i.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return i
            },
            findNode: function(t, e) {
                if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                    return t;
                if (t.skeleton) {
                    const i = t.skeleton.getBoneByName(e);
                    if (void 0 !== i)
                        return i
                }
                if (t.children) {
                    const i = function(t) {
                        for (let n = 0; n < t.length; n++) {
                            const r = t[n];
                            if (r.name === e || r.uuid === e)
                                return r;
                            const s = i(r.children);
                            if (s)
                                return s
                        }
                        return null
                    }
                      , n = i(t.children);
                    if (n)
                        return n
                }
                return null
            }
        }),
        Object.assign(gm.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(t, e) {
                t[e] = this.node[this.propertyName]
            }
            , function(t, e) {
                const i = this.resolvedProperty;
                for (let n = 0, r = i.length; n !== r; ++n)
                    t[e++] = i[n]
            }
            , function(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            , function(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            ],
            SetterByBindingTypeAndVersioning: [[function(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            , function(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.needsUpdate = !0
            }
            , function(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            ], [function(t, e) {
                const i = this.resolvedProperty;
                for (let n = 0, r = i.length; n !== r; ++n)
                    i[n] = t[e++]
            }
            , function(t, e) {
                const i = this.resolvedProperty;
                for (let n = 0, r = i.length; n !== r; ++n)
                    i[n] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            , function(t, e) {
                const i = this.resolvedProperty;
                for (let n = 0, r = i.length; n !== r; ++n)
                    i[n] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            ], [function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            , function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.needsUpdate = !0
            }
            , function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            ], [function(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            , function(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.needsUpdate = !0
            }
            , function(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            ]],
            getValue: function(t, e) {
                this.bind(),
                this.getValue(t, e)
            },
            setValue: function(t, e) {
                this.bind(),
                this.setValue(t, e)
            },
            bind: function() {
                let t = this.node;
                const e = this.parsedPath
                  , i = e.objectName
                  , n = e.propertyName;
                let r = e.propertyIndex;
                if (t || (t = gm.findNode(this.rootNode, e.nodeName) || this.rootNode,
                this.node = t),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !t)
                    return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (i) {
                    let n = e.objectIndex;
                    switch (i) {
                    case "materials":
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (let e = 0; e < t.length; e++)
                            if (t[e].name === n) {
                                n = e;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[i])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[i]
                    }
                    if (void 0 !== n) {
                        if (void 0 === t[n])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[n]
                    }
                }
                const s = t[n];
                if (void 0 === s) {
                    const i = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", t)
                }
                let a = this.Versioning.None;
                this.targetObject = t,
                void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                let o = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === n) {
                        if (!t.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.isBufferGeometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                        if (!t.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                    }
                    o = this.BindingType.ArrayElement,
                    this.resolvedProperty = s,
                    this.propertyIndex = r
                } else
                    void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray,
                    this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray,
                    this.resolvedProperty = s) : this.propertyName = n;
                this.getValue = this.GetterByBindingType[o],
                this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
            },
            unbind: function() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }),
        Object.assign(gm.prototype, {
            _getValue_unbound: gm.prototype.getValue,
            _setValue_unbound: gm.prototype.setValue
        });
        class vm {
            constructor(t, e, i=null, n=e.blendMode) {
                this._mixer = t,
                this._clip = e,
                this._localRoot = i,
                this.blendMode = n;
                const r = e.tracks
                  , s = r.length
                  , a = new Array(s)
                  , o = {
                    endingStart: Ga,
                    endingEnd: Ga
                };
                for (let t = 0; t !== s; ++t) {
                    const e = r[t].createInterpolant(null);
                    a[t] = e,
                    e.settings = o
                }
                this._interpolantSettings = o,
                this._interpolants = a,
                this._propertyBindings = new Array(s),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = 2201,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this),
                this
            }
            stop() {
                return this._mixer._deactivateAction(this),
                this.reset()
            }
            reset() {
                return this.paused = !1,
                this.enabled = !0,
                this.time = 0,
                this._loopCount = -1,
                this._startTime = null,
                this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(t) {
                return this._startTime = t,
                this
            }
            setLoop(t, e) {
                return this.loop = t,
                this.repetitions = e,
                this
            }
            setEffectiveWeight(t) {
                return this.weight = t,
                this._effectiveWeight = this.enabled ? t : 0,
                this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(t) {
                return this._scheduleFading(t, 0, 1)
            }
            fadeOut(t) {
                return this._scheduleFading(t, 1, 0)
            }
            crossFadeFrom(t, e, i) {
                if (t.fadeOut(e),
                this.fadeIn(e),
                i) {
                    const i = this._clip.duration
                      , n = t._clip.duration
                      , r = n / i
                      , s = i / n;
                    t.warp(1, r, e),
                    this.warp(s, 1, e)
                }
                return this
            }
            crossFadeTo(t, e, i) {
                return t.crossFadeFrom(this, e, i)
            }
            stopFading() {
                const t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null,
                this._mixer._takeBackControlInterpolant(t)),
                this
            }
            setEffectiveTimeScale(t) {
                return this.timeScale = t,
                this._effectiveTimeScale = this.paused ? 0 : t,
                this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(t) {
                return this.timeScale = this._clip.duration / t,
                this.stopWarping()
            }
            syncWith(t) {
                return this.time = t.time,
                this.timeScale = t.timeScale,
                this.stopWarping()
            }
            halt(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }
            warp(t, e, i) {
                const n = this._mixer
                  , r = n.time
                  , s = this.timeScale;
                let a = this._timeScaleInterpolant;
                null === a && (a = n._lendControlInterpolant(),
                this._timeScaleInterpolant = a);
                const o = a.parameterPositions
                  , h = a.sampleValues;
                return o[0] = r,
                o[1] = r + i,
                h[0] = t / s,
                h[1] = e / s,
                this
            }
            stopWarping() {
                const t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null,
                this._mixer._takeBackControlInterpolant(t)),
                this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(t, e, i, n) {
                if (!this.enabled)
                    return void this._updateWeight(t);
                const r = this._startTime;
                if (null !== r) {
                    const n = (t - r) * i;
                    if (n < 0 || 0 === i)
                        return;
                    this._startTime = null,
                    e = i * n
                }
                e *= this._updateTimeScale(t);
                const s = this._updateTime(e)
                  , a = this._updateWeight(t);
                if (a > 0) {
                    const t = this._interpolants
                      , e = this._propertyBindings;
                    if (2501 === this.blendMode)
                        for (let i = 0, n = t.length; i !== n; ++i)
                            t[i].evaluate(s),
                            e[i].accumulateAdditive(a);
                    else
                        for (let i = 0, r = t.length; i !== r; ++i)
                            t[i].evaluate(s),
                            e[i].accumulate(n, a)
                }
            }
            _updateWeight(t) {
                let e = 0;
                if (this.enabled) {
                    e = this.weight;
                    const i = this._weightInterpolant;
                    if (null !== i) {
                        const n = i.evaluate(t)[0];
                        e *= n,
                        t > i.parameterPositions[1] && (this.stopFading(),
                        0 === n && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e,
                e
            }
            _updateTimeScale(t) {
                let e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    const i = this._timeScaleInterpolant;
                    null !== i && (e *= i.evaluate(t)[0],
                    t > i.parameterPositions[1] && (this.stopWarping(),
                    0 === e ? this.paused = !0 : this.timeScale = e))
                }
                return this._effectiveTimeScale = e,
                e
            }
            _updateTime(t) {
                const e = this._clip.duration
                  , i = this.loop;
                let n = this.time + t
                  , r = this._loopCount;
                const s = 2202 === i;
                if (0 === t)
                    return -1 === r ? n : s && 1 == (1 & r) ? e - n : n;
                if (2200 === i) {
                    -1 === r && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1));
                    t: {
                        if (n >= e)
                            n = e;
                        else {
                            if (!(n < 0)) {
                                this.time = n;
                                break t
                            }
                            n = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = n,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === r && (t >= 0 ? (r = 0,
                    this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
                    n >= e || n < 0) {
                        const i = Math.floor(n / e);
                        n -= e * i,
                        r += Math.abs(i);
                        const a = this.repetitions - r;
                        if (a <= 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            n = t > 0 ? e : 0,
                            this.time = n,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                        else {
                            if (1 === a) {
                                const e = t < 0;
                                this._setEndings(e, !e, s)
                            } else
                                this._setEndings(!1, !1, s);
                            this._loopCount = r,
                            this.time = n,
                            this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: i
                            })
                        }
                    } else
                        this.time = n;
                    if (s && 1 == (1 & r))
                        return e - n
                }
                return n
            }
            _setEndings(t, e, i) {
                const n = this._interpolantSettings;
                i ? (n.endingStart = Wa,
                n.endingEnd = Wa) : (n.endingStart = t ? this.zeroSlopeAtStart ? Wa : Ga : Va,
                n.endingEnd = e ? this.zeroSlopeAtEnd ? Wa : Ga : Va)
            }
            _scheduleFading(t, e, i) {
                const n = this._mixer
                  , r = n.time;
                let s = this._weightInterpolant;
                null === s && (s = n._lendControlInterpolant(),
                this._weightInterpolant = s);
                const a = s.parameterPositions
                  , o = s.sampleValues;
                return a[0] = r,
                o[0] = e,
                a[1] = r + t,
                o[1] = i,
                this
            }
        }
        (class extends ho {
            constructor(t) {
                super(),
                this._root = t,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
            }
            _bindAction(t, e) {
                const i = t._localRoot || this._root
                  , n = t._clip.tracks
                  , r = n.length
                  , s = t._propertyBindings
                  , a = t._interpolants
                  , o = i.uuid
                  , h = this._bindingsByRootAndName;
                let l = h[o];
                void 0 === l && (l = {},
                h[o] = l);
                for (let t = 0; t !== r; ++t) {
                    const r = n[t]
                      , h = r.name;
                    let c = l[h];
                    if (void 0 !== c)
                        s[t] = c;
                    else {
                        if (c = s[t],
                        void 0 !== c) {
                            null === c._cacheIndex && (++c.referenceCount,
                            this._addInactiveBinding(c, o, h));
                            continue
                        }
                        const n = e && e._propertyBindings[t].binding.parsedPath;
                        c = new rm(gm.create(i, h, n),r.ValueTypeName,r.getValueSize()),
                        ++c.referenceCount,
                        this._addInactiveBinding(c, o, h),
                        s[t] = c
                    }
                    a[t].resultBuffer = c.buffer
                }
            }
            _activateAction(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        const e = (t._localRoot || this._root).uuid
                          , i = t._clip.uuid
                          , n = this._actionsByClip[i];
                        this._bindAction(t, n && n.knownActions[0]),
                        this._addInactiveAction(t, i, e)
                    }
                    const e = t._propertyBindings;
                    for (let t = 0, i = e.length; t !== i; ++t) {
                        const i = e[t];
                        0 == i.useCount++ && (this._lendBinding(i),
                        i.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            }
            _deactivateAction(t) {
                if (this._isActiveAction(t)) {
                    const e = t._propertyBindings;
                    for (let t = 0, i = e.length; t !== i; ++t) {
                        const i = e[t];
                        0 == --i.useCount && (i.restoreOriginalState(),
                        this._takeBackBinding(i))
                    }
                    this._takeBackAction(t)
                }
            }
            _initMemoryManager() {
                this._actions = [],
                this._nActiveActions = 0,
                this._actionsByClip = {},
                this._bindings = [],
                this._nActiveBindings = 0,
                this._bindingsByRootAndName = {},
                this._controlInterpolants = [],
                this._nActiveControlInterpolants = 0;
                const t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(t) {
                const e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            }
            _addInactiveAction(t, e, i) {
                const n = this._actions
                  , r = this._actionsByClip;
                let s = r[e];
                if (void 0 === s)
                    s = {
                        knownActions: [t],
                        actionByRoot: {}
                    },
                    t._byClipCacheIndex = 0,
                    r[e] = s;
                else {
                    const e = s.knownActions;
                    t._byClipCacheIndex = e.length,
                    e.push(t)
                }
                t._cacheIndex = n.length,
                n.push(t),
                s.actionByRoot[i] = t
            }
            _removeInactiveAction(t) {
                const e = this._actions
                  , i = e[e.length - 1]
                  , n = t._cacheIndex;
                i._cacheIndex = n,
                e[n] = i,
                e.pop(),
                t._cacheIndex = null;
                const r = t._clip.uuid
                  , s = this._actionsByClip
                  , a = s[r]
                  , o = a.knownActions
                  , h = o[o.length - 1]
                  , l = t._byClipCacheIndex;
                h._byClipCacheIndex = l,
                o[l] = h,
                o.pop(),
                t._byClipCacheIndex = null,
                delete a.actionByRoot[(t._localRoot || this._root).uuid],
                0 === o.length && delete s[r],
                this._removeInactiveBindingsForAction(t)
            }
            _removeInactiveBindingsForAction(t) {
                const e = t._propertyBindings;
                for (let t = 0, i = e.length; t !== i; ++t) {
                    const i = e[t];
                    0 == --i.referenceCount && this._removeInactiveBinding(i)
                }
            }
            _lendAction(t) {
                const e = this._actions
                  , i = t._cacheIndex
                  , n = this._nActiveActions++
                  , r = e[n];
                t._cacheIndex = n,
                e[n] = t,
                r._cacheIndex = i,
                e[i] = r
            }
            _takeBackAction(t) {
                const e = this._actions
                  , i = t._cacheIndex
                  , n = --this._nActiveActions
                  , r = e[n];
                t._cacheIndex = n,
                e[n] = t,
                r._cacheIndex = i,
                e[i] = r
            }
            _addInactiveBinding(t, e, i) {
                const n = this._bindingsByRootAndName
                  , r = this._bindings;
                let s = n[e];
                void 0 === s && (s = {},
                n[e] = s),
                s[i] = t,
                t._cacheIndex = r.length,
                r.push(t)
            }
            _removeInactiveBinding(t) {
                const e = this._bindings
                  , i = t.binding
                  , n = i.rootNode.uuid
                  , r = i.path
                  , s = this._bindingsByRootAndName
                  , a = s[n]
                  , o = e[e.length - 1]
                  , h = t._cacheIndex;
                o._cacheIndex = h,
                e[h] = o,
                e.pop(),
                delete a[r],
                0 === Object.keys(a).length && delete s[n]
            }
            _lendBinding(t) {
                const e = this._bindings
                  , i = t._cacheIndex
                  , n = this._nActiveBindings++
                  , r = e[n];
                t._cacheIndex = n,
                e[n] = t,
                r._cacheIndex = i,
                e[i] = r
            }
            _takeBackBinding(t) {
                const e = this._bindings
                  , i = t._cacheIndex
                  , n = --this._nActiveBindings
                  , r = e[n];
                t._cacheIndex = n,
                e[n] = t,
                r._cacheIndex = i,
                e[i] = r
            }
            _lendControlInterpolant() {
                const t = this._controlInterpolants
                  , e = this._nActiveControlInterpolants++;
                let i = t[e];
                return void 0 === i && (i = new Xp(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
                i.__cacheIndex = e,
                t[e] = i),
                i
            }
            _takeBackControlInterpolant(t) {
                const e = this._controlInterpolants
                  , i = t.__cacheIndex
                  , n = --this._nActiveControlInterpolants
                  , r = e[n];
                t.__cacheIndex = n,
                e[n] = t,
                r.__cacheIndex = i,
                e[i] = r
            }
            clipAction(t, e, i) {
                const n = e || this._root
                  , r = n.uuid;
                let s = "string" == typeof t ? rf.findByName(n, t) : t;
                const a = null !== s ? s.uuid : t
                  , o = this._actionsByClip[a];
                let h = null;
                if (void 0 === i && (i = null !== s ? s.blendMode : 2500),
                void 0 !== o) {
                    const t = o.actionByRoot[r];
                    if (void 0 !== t && t.blendMode === i)
                        return t;
                    h = o.knownActions[0],
                    null === s && (s = h._clip)
                }
                if (null === s)
                    return null;
                const l = new vm(this,s,e,i);
                return this._bindAction(l, h),
                this._addInactiveAction(l, a, r),
                l
            }
            existingAction(t, e) {
                const i = e || this._root
                  , n = i.uuid
                  , r = "string" == typeof t ? rf.findByName(i, t) : t
                  , s = r ? r.uuid : t
                  , a = this._actionsByClip[s];
                return void 0 !== a && a.actionByRoot[n] || null
            }
            stopAllAction() {
                const t = this._actions;
                for (let e = this._nActiveActions - 1; e >= 0; --e)
                    t[e].stop();
                return this
            }
            update(t) {
                t *= this.timeScale;
                const e = this._actions
                  , i = this._nActiveActions
                  , n = this.time += t
                  , r = Math.sign(t)
                  , s = this._accuIndex ^= 1;
                for (let a = 0; a !== i; ++a)
                    e[a]._update(n, t, r, s);
                const a = this._bindings
                  , o = this._nActiveBindings;
                for (let t = 0; t !== o; ++t)
                    a[t].apply(s);
                return this
            }
            setTime(t) {
                this.time = 0;
                for (let t = 0; t < this._actions.length; t++)
                    this._actions[t].time = 0;
                return this.update(t)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(t) {
                const e = this._actions
                  , i = t.uuid
                  , n = this._actionsByClip
                  , r = n[i];
                if (void 0 !== r) {
                    const t = r.knownActions;
                    for (let i = 0, n = t.length; i !== n; ++i) {
                        const n = t[i];
                        this._deactivateAction(n);
                        const r = n._cacheIndex
                          , s = e[e.length - 1];
                        n._cacheIndex = null,
                        n._byClipCacheIndex = null,
                        s._cacheIndex = r,
                        e[r] = s,
                        e.pop(),
                        this._removeInactiveBindingsForAction(n)
                    }
                    delete n[i]
                }
            }
            uncacheRoot(t) {
                const e = t.uuid
                  , i = this._actionsByClip;
                for (const t in i) {
                    const n = i[t].actionByRoot[e];
                    void 0 !== n && (this._deactivateAction(n),
                    this._removeInactiveAction(n))
                }
                const n = this._bindingsByRootAndName[e];
                if (void 0 !== n)
                    for (const t in n) {
                        const e = n[t];
                        e.restoreOriginalState(),
                        this._removeInactiveBinding(e)
                    }
            }
            uncacheAction(t, e) {
                const i = this.existingAction(t, e);
                null !== i && (this._deactivateAction(i),
                this._removeInactiveAction(i))
            }
        }
        ).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class ym {
            constructor(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
                t = arguments[1]),
                this.value = t
            }
            clone() {
                return new ym(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }
        function xm(t, e, i) {
            cd.call(this, t, e),
            this.meshPerAttribute = i || 1
        }
        function _m(t, e, i, n, r) {
            this.buffer = t,
            this.type = e,
            this.itemSize = i,
            this.elementSize = n,
            this.count = r,
            this.version = 0
        }
        function bm(t, e, i=0, n=1 / 0) {
            this.ray = new Jo(t,e),
            this.near = i,
            this.far = n,
            this.camera = null,
            this.layers = new hh,
            this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            },
            Object.defineProperties(this.params, {
                PointCloud: {
                    get: function() {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                        this.Points
                    }
                }
            })
        }
        function wm(t, e) {
            return t.distance - e.distance
        }
        function Mm(t, e, i, n) {
            if (t.layers.test(e.layers) && t.raycast(e, i),
            !0 === n) {
                const n = t.children;
                for (let t = 0, r = n.length; t < r; t++)
                    Mm(n[t], e, i, !0)
            }
        }
        xm.prototype = Object.assign(Object.create(cd.prototype), {
            constructor: xm,
            isInstancedInterleavedBuffer: !0,
            copy: function(t) {
                return cd.prototype.copy.call(this, t),
                this.meshPerAttribute = t.meshPerAttribute,
                this
            },
            clone: function(t) {
                const e = cd.prototype.clone.call(this, t);
                return e.meshPerAttribute = this.meshPerAttribute,
                e
            },
            toJSON: function(t) {
                const e = cd.prototype.toJSON.call(this, t);
                return e.isInstancedInterleavedBuffer = !0,
                e.meshPerAttribute = this.meshPerAttribute,
                e
            }
        }),
        Object.defineProperty(_m.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }),
        Object.assign(_m.prototype, {
            isGLBufferAttribute: !0,
            setBuffer: function(t) {
                return this.buffer = t,
                this
            },
            setType: function(t, e) {
                return this.type = t,
                this.elementSize = e,
                this
            },
            setItemSize: function(t) {
                return this.itemSize = t,
                this
            },
            setCount: function(t) {
                return this.count = t,
                this
            }
        }),
        Object.assign(bm.prototype, {
            set: function(t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function(t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(),
                this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
                this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
            },
            intersectObject: function(t, e=!1, i=[]) {
                return Mm(t, this, i, e),
                i.sort(wm),
                i
            },
            intersectObjects: function(t, e=!1, i=[]) {
                for (let n = 0, r = t.length; n < r; n++)
                    Mm(t[n], this, i, e);
                return i.sort(wm),
                i
            }
        });
        const Tm = new po;
        class Em {
            constructor(t=new po(1 / 0,1 / 0), e=new po(-1 / 0,-1 / 0)) {
                this.min = t,
                this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, i = t.length; e < i; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const i = Tm.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(i),
                this.max.copy(t).add(i),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0,
                this.max.x = this.max.y = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(t) {
                return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"),
                t = new po),
                this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"),
                t = new po),
                this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            }
            expandByVector(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }
            getParameter(t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"),
                e = new po),
                e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }
            clampPoint(t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"),
                e = new po),
                e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return Tm.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            intersect(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this
            }
            union(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            }
            translate(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        function Sm(t) {
            wh.call(this),
            this.material = t,
            this.render = function() {}
            ,
            this.hasPositions = !1,
            this.hasNormals = !1,
            this.hasColors = !1,
            this.hasUvs = !1,
            this.positionArray = null,
            this.normalArray = null,
            this.colorArray = null,
            this.uvArray = null,
            this.count = 0
        }
        Em.prototype.isBox2 = !0,
        Sm.prototype = Object.create(wh.prototype),
        Sm.prototype.constructor = Sm,
        Sm.prototype.isImmediateRenderObject = !0;
        const Am = new Mo
          , Lm = new $o
          , Pm = new $o;
        function Cm(t) {
            const e = [];
            t && t.isBone && e.push(t);
            for (let i = 0; i < t.children.length; i++)
                e.push.apply(e, Cm(t.children[i]));
            return e
        }
        const Rm = new Float32Array(1)
          , Om = (new Int32Array(Rm.buffer),
        Math.pow(2, 8),
        [.125, .215, .35, .446, .526, .582])
          , Dm = 5 + Om.length
          , Im = new Xh({
            side: Ar,
            depthWrite: !1,
            depthTest: !1
        })
          , {_lodPlanes: Nm, _sizeLods: zm, _sigmas: Bm} = (new Dl(new Nl,Im),
        km());
        function km() {
            const t = []
              , e = []
              , i = [];
            let n = 8;
            for (let r = 0; r < Dm; r++) {
                const s = Math.pow(2, n);
                e.push(s);
                let a = 1 / s;
                r > 4 ? a = Om[r - 8 + 4 - 1] : 0 == r && (a = 0),
                i.push(a);
                const o = 1 / (s - 1)
                  , h = -o / 2
                  , l = 1 + o / 2
                  , c = [h, h, l, h, l, l, h, h, l, l, h, l]
                  , u = 6
                  , d = 6
                  , p = 3
                  , f = 2
                  , m = 1
                  , g = new Float32Array(p * d * u)
                  , v = new Float32Array(f * d * u)
                  , y = new Float32Array(m * d * u);
                for (let t = 0; t < u; t++) {
                    const e = t % 3 * 2 / 3 - 1
                      , i = t > 2 ? 0 : -1
                      , n = [e, i, 0, e + 2 / 3, i, 0, e + 2 / 3, i + 1, 0, e, i, 0, e + 2 / 3, i + 1, 0, e, i + 1, 0];
                    g.set(n, p * d * t),
                    v.set(c, f * d * t);
                    const r = [t, t, t, t, t, t];
                    y.set(r, m * d * t)
                }
                const x = new ml;
                x.setAttribute("position", new Jh(g,p)),
                x.setAttribute("uv", new Jh(v,f)),
                x.setAttribute("faceIndex", new Jh(y,m)),
                t.push(x),
                n > 4 && n--
            }
            return {
                _lodPlanes: t,
                _sizeLods: e,
                _sigmas: i
            }
        }
        Math.sqrt(5),
        vf.create = function(t, e) {
            return console.log("THREE.Curve.create() has been deprecated"),
            t.prototype = Object.create(vf.prototype),
            t.prototype.constructor = t,
            t.prototype.getPoint = e,
            t
        }
        ,
        Bf.prototype.fromPoints = function(t) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(t)
        }
        ,
        class extends tp {
            constructor(t=10, e=10, i=4473924, n=8947848) {
                i = new qh(i),
                n = new qh(n);
                const r = e / 2
                  , s = t / e
                  , a = t / 2
                  , o = []
                  , h = [];
                for (let t = 0, l = 0, c = -a; t <= e; t++,
                c += s) {
                    o.push(-a, 0, c, a, 0, c),
                    o.push(c, 0, -a, c, 0, a);
                    const e = t === r ? i : n;
                    e.toArray(h, l),
                    l += 3,
                    e.toArray(h, l),
                    l += 3,
                    e.toArray(h, l),
                    l += 3,
                    e.toArray(h, l),
                    l += 3
                }
                const l = new ml;
                l.setAttribute("position", new sl(o,3)),
                l.setAttribute("color", new sl(h,3)),
                super(l, new Vd({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "GridHelper"
            }
        }
        .prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }
        ,
        class extends tp {
            constructor(t) {
                const e = Cm(t)
                  , i = new ml
                  , n = []
                  , r = []
                  , s = new qh(0,0,1)
                  , a = new qh(0,1,0);
                for (let t = 0; t < e.length; t++) {
                    const i = e[t];
                    i.parent && i.parent.isBone && (n.push(0, 0, 0),
                    n.push(0, 0, 0),
                    r.push(s.r, s.g, s.b),
                    r.push(a.r, a.g, a.b))
                }
                i.setAttribute("position", new sl(n,3)),
                i.setAttribute("color", new sl(r,3)),
                super(i, new Vd({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })),
                this.type = "SkeletonHelper",
                this.isSkeletonHelper = !0,
                this.root = t,
                this.bones = e,
                this.matrix = t.matrixWorld,
                this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(t) {
                const e = this.bones
                  , i = this.geometry
                  , n = i.getAttribute("position");
                Pm.copy(this.root.matrixWorld).invert();
                for (let t = 0, i = 0; t < e.length; t++) {
                    const r = e[t];
                    r.parent && r.parent.isBone && (Lm.multiplyMatrices(Pm, r.matrixWorld),
                    Am.setFromMatrixPosition(Lm),
                    n.setXYZ(i, Am.x, Am.y, Am.z),
                    Lm.multiplyMatrices(Pm, r.parent.matrixWorld),
                    Am.setFromMatrixPosition(Lm),
                    n.setXYZ(i + 1, Am.x, Am.y, Am.z),
                    i += 2)
                }
                i.getAttribute("position").needsUpdate = !0,
                super.updateMatrixWorld(t)
            }
        }
        .prototype.update = function() {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }
        ,
        lf.prototype.extractUrlBase = function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            function(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            }(t)
        }
        ,
        lf.Handlers = {
            add: function() {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            },
            get: function() {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        },
        Em.prototype.center = function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        }
        ,
        Em.prototype.empty = function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
        ,
        Em.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        }
        ,
        Em.prototype.size = function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
        ,
        So.prototype.center = function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        }
        ,
        So.prototype.empty = function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
        ,
        So.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        }
        ,
        So.prototype.isIntersectionSphere = function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        }
        ,
        So.prototype.size = function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
        ,
        jo.prototype.empty = function() {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
        ,
        $l.prototype.setFromMatrix = function(t) {
            return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
            this.setFromProjectionMatrix(t)
        }
        ,
        uo.random16 = function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
            Math.random()
        }
        ,
        uo.nearestPowerOfTwo = function(t) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
            uo.floorPowerOfTwo(t)
        }
        ,
        uo.nextPowerOfTwo = function(t) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
            uo.ceilPowerOfTwo(t)
        }
        ,
        fo.prototype.flattenToArrayOffset = function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        }
        ,
        fo.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            t.applyMatrix3(this)
        }
        ,
        fo.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        }
        ,
        fo.prototype.applyToBufferAttribute = function(t) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
            t.applyMatrix3(this)
        }
        ,
        fo.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
        ,
        fo.prototype.getInverse = function(t) {
            return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
            this.copy(t).invert()
        }
        ,
        $o.prototype.extractPosition = function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(t)
        }
        ,
        $o.prototype.flattenToArrayOffset = function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        }
        ,
        $o.prototype.getPosition = function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
            (new Mo).setFromMatrixColumn(this, 3)
        }
        ,
        $o.prototype.setRotationFromQuaternion = function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(t)
        }
        ,
        $o.prototype.multiplyToArray = function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        }
        ,
        $o.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        $o.prototype.multiplyVector4 = function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        $o.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        }
        ,
        $o.prototype.rotateAxis = function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            t.transformDirection(this)
        }
        ,
        $o.prototype.crossVector = function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        $o.prototype.translate = function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }
        ,
        $o.prototype.rotateX = function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }
        ,
        $o.prototype.rotateY = function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }
        ,
        $o.prototype.rotateZ = function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }
        ,
        $o.prototype.rotateByAxis = function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }
        ,
        $o.prototype.applyToBufferAttribute = function(t) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        $o.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        }
        ,
        $o.prototype.makeFrustum = function(t, e, i, n, r, s) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(t, e, n, i, r, s)
        }
        ,
        $o.prototype.getInverse = function(t) {
            return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
            this.copy(t).invert()
        }
        ,
        Sh.prototype.isIntersectionLine = function(t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
            this.intersectsLine(t)
        }
        ,
        wo.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
            t.applyQuaternion(this)
        }
        ,
        wo.prototype.inverse = function() {
            return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
            this.invert()
        }
        ,
        Jo.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        }
        ,
        Jo.prototype.isIntersectionPlane = function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(t)
        }
        ,
        Jo.prototype.isIntersectionSphere = function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        }
        ,
        Bh.prototype.area = function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
            this.getArea()
        }
        ,
        Bh.prototype.barycoordFromPoint = function(t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            this.getBarycoord(t, e)
        }
        ,
        Bh.prototype.midpoint = function(t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
            this.getMidpoint(t)
        }
        ,
        Bh.prototypenormal = function(t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            this.getNormal(t)
        }
        ,
        Bh.prototype.plane = function(t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
            this.getPlane(t)
        }
        ,
        Bh.barycoordFromPoint = function(t, e, i, n, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            Bh.getBarycoord(t, e, i, n, r)
        }
        ,
        Bh.normal = function(t, e, i, n) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            Bh.getNormal(t, e, i, n)
        }
        ,
        kf.prototype.extractAllPoints = function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(t)
        }
        ,
        kf.prototype.extrude = function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new Bp(this,t)
        }
        ,
        kf.prototype.makeGeometry = function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new Up(this,t)
        }
        ,
        po.prototype.fromAttribute = function(t, e, i) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, i)
        }
        ,
        po.prototype.distanceToManhattan = function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        }
        ,
        po.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
        ,
        Mo.prototype.setEulerFromRotationMatrix = function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }
        ,
        Mo.prototype.setEulerFromQuaternion = function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }
        ,
        Mo.prototype.getPositionFromMatrix = function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(t)
        }
        ,
        Mo.prototype.getScaleFromMatrix = function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(t)
        }
        ,
        Mo.prototype.getColumnFromMatrix = function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(e, t)
        }
        ,
        Mo.prototype.applyProjection = function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(t)
        }
        ,
        Mo.prototype.fromAttribute = function(t, e, i) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, i)
        }
        ,
        Mo.prototype.distanceToManhattan = function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        }
        ,
        Mo.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
        ,
        _o.prototype.fromAttribute = function(t, e, i) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, i)
        }
        ,
        _o.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
        ,
        wh.prototype.getChildByName = function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(t)
        }
        ,
        wh.prototype.renderDepth = function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }
        ,
        wh.prototype.translate = function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(e, t)
        }
        ,
        wh.prototype.getWorldRotation = function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
        ,
        wh.prototype.applyMatrix = function(t) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(t)
        }
        ,
        Object.defineProperties(wh.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                    this.rotation.order
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                    this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }),
        Dl.prototype.setDrawMode = function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
        ,
        Object.defineProperties(Dl.prototype, {
            drawMode: {
                get: function() {
                    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                    0
                },
                set: function() {
                    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }
        }),
        Object.defineProperties(class extends wh {
            constructor() {
                super(),
                this._currentLevel = 0,
                this.type = "LOD",
                Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    },
                    isLOD: {
                        value: !0
                    }
                }),
                this.autoUpdate = !0
            }
            copy(t) {
                super.copy(t, !1);
                const e = t.levels;
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    this.addLevel(i.object.clone(), i.distance)
                }
                return this.autoUpdate = t.autoUpdate,
                this
            }
            addLevel(t, e=0) {
                e = Math.abs(e);
                const i = this.levels;
                let n;
                for (n = 0; n < i.length && !(e < i[n].distance); n++)
                    ;
                return i.splice(n, 0, {
                    distance: e,
                    object: t
                }),
                this.add(t),
                this
            }
            getCurrentLevel() {
                return this._currentLevel
            }
            getObjectForDistance(t) {
                const e = this.levels;
                if (e.length > 0) {
                    let i, n;
                    for (i = 1,
                    n = e.length; i < n && !(t < e[i].distance); i++)
                        ;
                    return e[i - 1].object
                }
                return null
            }
            raycast(t, e) {
                if (this.levels.length > 0) {
                    Ld.setFromMatrixPosition(this.matrixWorld);
                    const i = t.ray.origin.distanceTo(Ld);
                    this.getObjectForDistance(i).raycast(t, e)
                }
            }
            update(t) {
                const e = this.levels;
                if (e.length > 1) {
                    Ld.setFromMatrixPosition(t.matrixWorld),
                    Pd.setFromMatrixPosition(this.matrixWorld);
                    const i = Ld.distanceTo(Pd) / t.zoom;
                    let n, r;
                    for (e[0].object.visible = !0,
                    n = 1,
                    r = e.length; n < r && i >= e[n].distance; n++)
                        e[n - 1].object.visible = !1,
                        e[n].object.visible = !0;
                    for (this._currentLevel = n - 1; n < r; n++)
                        e[n].object.visible = !1
                }
            }
            toJSON(t) {
                const e = super.toJSON(t);
                !1 === this.autoUpdate && (e.object.autoUpdate = !1),
                e.object.levels = [];
                const i = this.levels;
                for (let t = 0, n = i.length; t < n; t++) {
                    const n = i[t];
                    e.object.levels.push({
                        object: n.object.uuid,
                        distance: n.distance
                    })
                }
                return e
            }
        }
        .prototype, {
            objects: {
                get: function() {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                    this.levels
                }
            }
        }),
        Object.defineProperty(Fd.prototype, "useVertexTexture", {
            get: function() {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            },
            set: function() {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            }
        }),
        Nd.prototype.initBones = function() {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }
        ,
        Object.defineProperty(vf.prototype, "__arcLengthDivisions", {
            get: function() {
                return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
                this.arcLengthDivisions
            },
            set: function(t) {
                console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
                this.arcLengthDivisions = t
            }
        }),
        Gl.prototype.setLens = function(t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
            void 0 !== e && (this.filmGauge = e),
            this.setFocalLength(t)
        }
        ,
        Object.defineProperties(Ff.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                    this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                    this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                    this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                    this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                    this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                    this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                    this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                    this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                    this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                    this.shadow.mapSize.height = t
                }
            }
        }),
        Object.defineProperties(Jh.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                    this.array.length
                }
            },
            dynamic: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                    this.usage === ao
                },
                set: function() {
                    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                    this.setUsage(ao)
                }
            }
        }),
        Jh.prototype.setDynamic = function(t) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === t ? ao : so),
            this
        }
        ,
        Jh.prototype.copyIndicesArray = function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
        ,
        Jh.prototype.setArray = function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
        ,
        ml.prototype.addIndex = function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(t)
        }
        ,
        ml.prototype.addAttribute = function(t, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
            e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            this.setIndex(e),
            this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            this.setAttribute(t, new Jh(arguments[1],arguments[2])))
        }
        ,
        ml.prototype.addDrawCall = function(t, e, i) {
            void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(t, e)
        }
        ,
        ml.prototype.clearDrawCalls = function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        }
        ,
        ml.prototype.computeOffsets = function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
        ,
        ml.prototype.removeAttribute = function(t) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
            this.deleteAttribute(t)
        }
        ,
        ml.prototype.applyMatrix = function(t) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(t)
        }
        ,
        Object.defineProperties(ml.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                    this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                    this.groups
                }
            }
        }),
        Object.defineProperties(Kf.prototype, {
            maxInstancedCount: {
                get: function() {
                    return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                    this.instanceCount
                },
                set: function(t) {
                    console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                    this.instanceCount = t
                }
            }
        }),
        Object.defineProperties(bm.prototype, {
            linePrecision: {
                get: function() {
                    return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                    this.params.Line.threshold
                },
                set: function(t) {
                    console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                    this.params.Line.threshold = t
                }
            }
        }),
        Object.defineProperties(cd.prototype, {
            dynamic: {
                get: function() {
                    return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                    this.usage === ao
                },
                set: function(t) {
                    console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                    this.setUsage(t)
                }
            }
        }),
        cd.prototype.setDynamic = function(t) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === t ? ao : so),
            this
        }
        ,
        cd.prototype.setArray = function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
        ,
        Bp.prototype.getArrays = function() {
            console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
        }
        ,
        Bp.prototype.addShapeList = function() {
            console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
        }
        ,
        Bp.prototype.addShape = function() {
            console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
        }
        ,
        ld.prototype.dispose = function() {
            console.error("THREE.Scene: .dispose() has been removed.")
        }
        ,
        Object.defineProperties(ym.prototype, {
            dynamic: {
                set: function() {
                    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                }
            },
            onUpdate: {
                value: function() {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                    this
                }
            }
        }),
        Object.defineProperties(Fh.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."),
                    new qh
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                    this.flatShading = 1 === t
                }
            },
            stencilMask: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                    this.stencilFuncMask
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                    this.stencilFuncMask = t
                }
            }
        }),
        Object.defineProperties(Gp.prototype, {
            metal: {
                get: function() {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                    !1
                },
                set: function() {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }),
        Object.defineProperties(jp.prototype, {
            transparency: {
                get: function() {
                    return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
                    this.transmission
                },
                set: function(t) {
                    console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
                    this.transmission = t
                }
            }
        }),
        Object.defineProperties(Hl.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                    this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                    this.extensions.derivatives = t
                }
            }
        }),
        ad.prototype.clearTarget = function(t, e, i, n) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
            this.setRenderTarget(t),
            this.clear(e, i, n)
        }
        ,
        ad.prototype.animate = function(t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
            this.setAnimationLoop(t)
        }
        ,
        ad.prototype.getCurrentRenderTarget = function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        }
        ,
        ad.prototype.getMaxAnisotropy = function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        }
        ,
        ad.prototype.getPrecision = function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        }
        ,
        ad.prototype.resetGLState = function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        }
        ,
        ad.prototype.supportsFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        }
        ,
        ad.prototype.supportsHalfFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        }
        ,
        ad.prototype.supportsStandardDerivatives = function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        }
        ,
        ad.prototype.supportsCompressedTextureS3TC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        }
        ,
        ad.prototype.supportsCompressedTexturePVRTC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }
        ,
        ad.prototype.supportsBlendMinMax = function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        }
        ,
        ad.prototype.supportsVertexTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        }
        ,
        ad.prototype.supportsInstancedArrays = function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        }
        ,
        ad.prototype.enableScissorTest = function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(t)
        }
        ,
        ad.prototype.initMaterial = function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }
        ,
        ad.prototype.addPrePlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }
        ,
        ad.prototype.addPostPlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }
        ,
        ad.prototype.updateShadowMap = function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
        ,
        ad.prototype.setFaceCulling = function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
        ,
        ad.prototype.allocTextureUnit = function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        }
        ,
        ad.prototype.setTexture = function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        }
        ,
        ad.prototype.setTexture2D = function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        }
        ,
        ad.prototype.setTextureCube = function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }
        ,
        ad.prototype.getActiveMipMapLevel = function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
            this.getActiveMipmapLevel()
        }
        ,
        Object.defineProperties(ad.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                    this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                    this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                    this.getContext()
                }
            },
            vr: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                    this.xr
                }
            },
            gammaInput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                    !1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            },
            gammaOutput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                    !1
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                    this.outputEncoding = !0 === t ? Xa : qa
                }
            },
            toneMappingWhitePoint: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
                    1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                }
            }
        }),
        Object.defineProperties($u.prototype, {
            cullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }),
        Object.defineProperties(bo.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                    this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                    this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                    this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                    this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                    this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                    this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                    this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                    this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                    this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                    this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                    this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                    this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                    this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                    this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                    this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                    this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                    this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                    this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                    this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                    this.texture.generateMipmaps = t
                }
            }
        }),
        Object.defineProperties(class extends wh {
            constructor(t) {
                super(),
                this.type = "Audio",
                this.listener = t,
                this.context = t.context,
                this.gain = this.context.createGain(),
                this.gain.connect(t.getInput()),
                this.autoplay = !1,
                this.buffer = null,
                this.detune = 0,
                this.loop = !1,
                this.loopStart = 0,
                this.loopEnd = 0,
                this.offset = 0,
                this.duration = void 0,
                this.playbackRate = 1,
                this.isPlaying = !1,
                this.hasPlaybackControl = !0,
                this.source = null,
                this.sourceType = "empty",
                this._startedAt = 0,
                this._progress = 0,
                this._connected = !1,
                this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(t) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "audioNode",
                this.source = t,
                this.connect(),
                this
            }
            setMediaElementSource(t) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaNode",
                this.source = this.context.createMediaElementSource(t),
                this.connect(),
                this
            }
            setMediaStreamSource(t) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaStreamNode",
                this.source = this.context.createMediaStreamSource(t),
                this.connect(),
                this
            }
            setBuffer(t) {
                return this.buffer = t,
                this.sourceType = "buffer",
                this.autoplay && this.play(),
                this
            }
            play(t=0) {
                if (!0 === this.isPlaying)
                    return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl)
                    return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + t;
                const e = this.context.createBufferSource();
                return e.buffer = this.buffer,
                e.loop = this.loop,
                e.loopStart = this.loopStart,
                e.loopEnd = this.loopEnd,
                e.onended = this.onEnded.bind(this),
                e.start(this._startedAt, this._progress + this.offset, this.duration),
                this.isPlaying = !0,
                this.source = e,
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            }
            pause() {
                if (!1 !== this.hasPlaybackControl)
                    return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                    !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                    this.source.stop(),
                    this.source.onended = null,
                    this.isPlaying = !1),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (!1 !== this.hasPlaybackControl)
                    return this._progress = 0,
                    this.source.stop(),
                    this.source.onended = null,
                    this.isPlaying = !1,
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++)
                        this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else
                    this.source.connect(this.getOutput());
                return this._connected = !0,
                this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++)
                        this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else
                    this.source.disconnect(this.getOutput());
                return this._connected = !1,
                this
            }
            getFilters() {
                return this.filters
            }
            setFilters(t) {
                return t || (t = []),
                !0 === this._connected ? (this.disconnect(),
                this.filters = t.slice(),
                this.connect()) : this.filters = t.slice(),
                this
            }
            setDetune(t) {
                if (this.detune = t,
                void 0 !== this.source.detune)
                    return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                    this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(t) {
                return this.setFilters(t ? [t] : [])
            }
            setPlaybackRate(t) {
                if (!1 !== this.hasPlaybackControl)
                    return this.playbackRate = t,
                    !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
                !1) : this.loop
            }
            setLoop(t) {
                if (!1 !== this.hasPlaybackControl)
                    return this.loop = t,
                    !0 === this.isPlaying && (this.source.loop = this.loop),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(t) {
                return this.loopStart = t,
                this
            }
            setLoopEnd(t) {
                return this.loopEnd = t,
                this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
                this
            }
        }
        .prototype, {
            load: {
                value: function(t) {
                    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                    const e = this;
                    return (new nm).load(t, (function(t) {
                        e.setBuffer(t)
                    }
                    )),
                    this
                }
            },
            startTime: {
                set: function() {
                    console.warn("THREE.Audio: .startTime is now .play( delay ).")
                }
            }
        }),
        Vl.prototype.updateCubeMap = function(t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
            this.update(t, e)
        }
        ,
        Vl.prototype.clear = function(t, e, i, n) {
            return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
            this.renderTarget.clear(t, e, i, n)
        }
        ,
        go.crossOrigin = void 0,
        go.loadTexture = function(t, e, i, n) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            const r = new gf;
            r.setCrossOrigin(this.crossOrigin);
            const s = r.load(t, i, void 0, n);
            return e && (s.mapping = e),
            s
        }
        ,
        go.loadTextureCube = function(t, e, i, n) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            const r = new ff;
            r.setCrossOrigin(this.crossOrigin);
            const s = r.load(t, i, void 0, n);
            return e && (s.mapping = e),
            s
        }
        ,
        go.loadCompressedTexture = function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }
        ,
        go.loadCompressedTextureCube = function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }
        ,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: "126"
            }
        })),
        "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "126");
        var Fm = i(1590)
          , Um = i.n(Fm);


          /* END */
        class Hm extends (Um()) {
            constructor({loader: t, manager: e, data: i}) {
                super(),
                this.loader = t,
                this.manager = e,
                this.data = i,
                window.TEXTURES = [],
                this.length = 0,
                this.text = Pn(".preloader p span"),
                this.preloader = Pn(".preloader"),
                this.navAbout = Pn(".nav_about"),
                this.navProjects = Pn(".nav_projects"),
                this.createLoader()
            }
            intro() {
                bn.to(".preloader--v1", {
                    y: "-100%",
                    stagger: .025,
                    duration: 1,
                    delay: .25,
                    ease: "Expo.easeOut"
                }),
                bn.to(".preloader--v2", {
                    y: "0",
                    stagger: .025,
                    duration: 1,
                    delay: .35,
                    ease: "Expo.easeOut"
                }),
                setTimeout((()=>{
                    this.played = !0
                }
                ), 1300)
            }
            createLoader() {
                this.data.medias.forEach(((t,e)=>{
                    const i = new Image;
                    i.src = t,
                    i.crossOrigin = "anonymous",
                    i.onload = e=>{
                        const n = this.loader.load(i.src);
                        n.minFilter = Ss,
                        n.magFilter = Ss,
                        window.TEXTURES[t] = [n, i.naturalWidth, i.naturalHeight, i],
                        this.onAssetsLoaded()
                    }
                }
                ))
            }
            hide() {
                const t = window.location.pathname;
                t.indexOf("projects") > -1 && (this.navProjects.style.border = "1px solid rgba(255,255,255,0.3)"),
                t.indexOf("about") > -1 && (this.navAbout.style.border = "1px solid rgba(255,255,255,0.3)"),
                bn.to("header", {
                    y: 0,
                    delay: 1.99,
                    ease: "Expo.easeOut",
                    duration: 1.9
                })
            }
            onAssetsLoaded() {
                this.length += 1;
                const t = this.length / this.data.medias.length
                  , e = Math.round(100 * t);
                this.text.innerHTML = e < 10 ? `00 ${e}%` : e < 100 ? `0 ${e}%` : e > 100 ? "100%" : `${e}%`,
                this.manager.onProgress = async(t,i,n)=>{
                    i === n && e >= 100 && (this.hide(),
                    setTimeout((()=>{
                        this.emit("completed")
                    }
                    ), 200))
                }
            }
        }
        class jm {
            constructor({el: t, geometry: e, loader: i, scene: n}) {
                this.el = t,
                this.geometry = e,
                this.loader = i,
                this.scene = n,
                this.s = 0,
                this.createMesh()
            }
            createMesh() {
                this.material = new Hl({
                    extensions: {
                        derivatives: "#extension GL_OES_standard_derivatives : enable"
                    },
                    vertexShader: "#define GLSLIFY 1\nuniform vec2 hl;\nuniform float b;\nuniform vec2 r;\n\nvarying vec2 vUv;\nvarying float bb;\n\n float eq(float x) {\nreturn x < 0.5 ? 16. * x * x * x * x * x : 1. - pow(-2. * x + 2., 5.) / 2.;\n}\n\nvoid main() {\n  vUv = uv;\n  vec2 w = uv;\n  vec2 v = uv;\n  vec3 pos = position;\n  float fc = r.x / r.y;\n  w.x -= 0.5;\n  w.x *= fc;\n  w.x += 0.5;\n  v.x -= 0.5;\n  v.x *= fc;\n  v.x += 0.5;\n  float  hz =(hl.x - 0.5) * ( fc * 0.5);\n  float x2 = hl.x + hz;\n  float dt = distance(v, vec2(x2, hl.y));\n  dt *= .5;\n  dt *= .3;\n  dt *= 4.5;\n  float tr = min(1., dt + 0.3);\n  float hhl = eq(tr);\n  pos.y -= b  * 0.045 * hhl;\n  pos.y += b  * 0.045;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}",
                    fragmentShader: "#define GLSLIFY 1\nuniform vec2 hover;\nuniform sampler2D tex;\nuniform float b;\nuniform float p;\nuniform float a;\n\nvarying vec2 vUv;\nvarying float bb;\n\nfloat ea(float x) {\nreturn x < 0.5 ? 8. * x * x * x * x : 1. - pow(-2. * x + 2., 4.) / 2.;\n}\n\nfloat aastep(float threshold, float value) {\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\nfloat ln(float a, float b, float lw, float et){\n\tfloat hlw = lw * 0.9855;\n\treturn smoothstep(a - hlw - et, a - hlw, b) -\n\tsmoothstep(a + hlw, a+ hlw + et, b);\n}\n\nvoid main()\t{\n\tfloat alpha = 1.;\n\tfloat et = ea(p);\n\tfloat cut = 0.001;\n\talpha *= aastep(cut, vUv.x);\n\talpha *= 1. - aastep(1. - cut, vUv.x);\n\talpha *= aastep(cut, vUv.y);\n\talpha *= 1. - aastep(1. - cut, vUv.y);\n\tvec3 color = vec3(1.);\n\tvec3 c =  color * ln(vUv.y, 0.5,0.0001,0.001) * alpha;\n\tgl_FragColor.rgb = c;\n\tgl_FragColor.a = mix(0.,c.r, step(vUv.x, et)) * a * alpha;\n}",
                    uniforms: {
                        hl: {
                            value: new po
                        },
                        b: {
                            value: 0
                        },
                        p: {
                            value: 0
                        },
                        a: {
                            value: 1
                        },
                        r: {
                            value: new po(0,800)
                        }
                    },
                    transparent: !0
                }),
                this.mesh = new Dl(this.geometry,this.material),
                this.scene.add(this.mesh)
            }
            hide() {
                bn.to(this.material.uniforms.a, {
                    value: 0,
                    duration: .3,
                    ease: "Expo.easeInout"
                })
            }
            ai() {
                bn.to(this.material.uniforms.p, {
                    value: 1,
                    duration: 2.5
                })
            }
            cb() {
                this.b = Ln(this.el);
                const {top: t} = this.b;
                this.top = t + this.s,
                this.us()
            }
            us() {
                const {width: t, height: e} = this.b;
                this.mesh.scale.set(t, 800, 1),
                this.material.uniforms.r.value.x = t,
                this.ux(),
                this.uy()
            }
            rs(t) {
                this.v = t,
                this.cb()
            }
            ux() {
                const {left: t, width: e} = this.b
                  , {w: i} = this.v;
                this.mesh.position.x = t - i / 2 + e / 2
            }
            uy(t=0) {
                if (!this.b || !this.v)
                    return;
                const {top: e, height: i} = this.b
                  , {h: n} = this.v;
                this.mesh.position.y = t - this.top + n / 2 - i / 2
            }
            update(t) {
                this.b && this.v && (this.s = t,
                this.uy(t),
                this.played || this.b.top - t - this.v.h + this.b.height / 2 + 150 <= 0 && (this.ai(),
                this.played = !0))
            }
            destroy() {
                this.scene.remove(this.mesh)
            }
        }
        const Gm = (t,e,i,n)=>t - e + i / 2 - n / 2
          , Wm = (t,e,i,n,r,s)=>{
            let a = t;
            for (let t = 0; t < a.length; t += 3)
                a[t] *= .9,
                a[t + 1] *= .9;
            let o = i * e - .5
              , h = (1 - n) * e - .5
              , l = e / 4;
            for (let t = 0; t < e; t++)
                for (let i = 0; i < e; i++) {
                    let n = (o - t) ** 2 + (h - i) ** 2;
                    if (n < l ** 2) {
                        let o = 3 * (t + e * i)
                          , h = l / Math.sqrt(n);
                        h = Rn(h, 0, 10),
                        a[o] += 3 * r * h,
                        a[o + 1] -= 3 * s * h
                    }
                }
        }
          ,
        class qm {
            constructor({el: t, loader: e, geometry: i, scene: n, index: r, title: s, cl: a, box: o, description: h, label: l}) {
                this.el = t,
                this.loader = e,
                this.geometry = i,
                this.scene = n,
                this.index = r,
                this.box = o,
                this.description = h,
                this.label = l,
                this.cl = a,
                this.projectNbr = Pn(".home_featured_nbr p span"),
                this.titleRef = Pn(".home_featured_title_1"),
                this.span = Pn("span", this.box),
                this.s = 0,
                this.mouse = {
                    x: -10,
                    y: 10,
                    prevX: 0,
                    prevY: 0,
                    vX: 0,
                    vY: 0
                },
                this.mouse1 = new po(-10,10),
                this.createMesh(),
                this.ael()
            }
            useRegex() {
                return /<br>/i.test(input)
            }
            replace() {
                this.useRegex(this.title.innerHtml)
            }
            hide() {
                bn.to(this.material.uniforms.al, {
                    value: 0,
                    duration: .75,
                    ease: "Expo.easeInout"
                })
            }
            createPix() {
                this.nbr = 10;
                const t = this.nbr
                  , e = this.nbr
                  , i = t * e
                  , n = new Float32Array(3 * i);
                for (let t = 0; t < i; t++) {
                    const e = 3 * t;
                    let i = Math.random()
                      , r = 255 * Math.random();
                    n[e] = i,
                    n[e + 1] = r,
                    n[e + 2] = i
                }
                this.texture = new Yl(n,t,e,js,Ns),
                this.texture.magFilter = this.texture.minFilter = Ms
            }
            createMesh() {
                this.createPix();
                const t = this.el.getAttribute("data-src")
                  , e = window.TEXTURES[t]
                  , i = e[0];
                this.material = new Hl({
                    vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 p;\n\nvoid main() {\n  vUv = uv;\n  vec3 pos = position;\n\n  p = pos;\n  \n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}",
                    fragmentShader: "#define GLSLIFY 1\nuniform vec2 co;\nuniform vec2 r;\nuniform sampler2D tex;\nuniform sampler2D dtx;\nuniform float time;\nuniform float ud;\nuniform float al;\nuniform float ddd;\nuniform vec2 ps;\nuniform vec2 ns;\n\nvarying vec2 vUv;\nvarying vec3 p;\n\nfloat cc(in vec2 _st, in float _radius, in float blurriness){\n\tvec2 dist = _st;\n\treturn 1.-smoothstep(_radius-(_radius*blurriness), _radius+(_radius*blurriness), dot(dist,dist)*4.0);\n}\n\nfloat rb( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b+r,0.0))-r;\n}\n\nfloat z(in vec2 q) {\n    return fract(sin(dot(q.xy, vec2(12.9898, 78.233)))*43758.5453123);\n}\nfloat aa(vec2 q) {\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(z(i+vec2(0.0, 0.0)), z(i+vec2(1.0, 0.0)), u.x), mix(z(i+vec2(0.0, 1.0)), z(i+vec2(1.0, 1.0)), u.x), u.y);\n}\nfloat a(in vec2 q) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 k = vec2(100.0);\n    mat2 r = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for(int i = 0;i<5;++i) {\n        v += a*aa(q);\n        q = r*q*2.0+k;\n        a *= 0.5;\n    }\n    return v;\n}\n\n  vec2 gu(vec2 uv, vec2 ns, vec2 ps){\n    vec2 tu = uv - vec2(0.5);\n\n    float pa = ps.x/ps.y;\n    float ta = ns.x/ns.y;\n    if(pa<ta){\n        tu = tu*vec2(pa/ta,1.);\n    } else{\n        tu = tu*vec2(1.,ta/pa);\n    }\n\n    tu += vec2(0.5);\n    return tu;\n}\n\nfloat PI = 3.1415926353;\n\nvoid main()\t{\n\tvec2 uv = gu(vUv,ns, ps);\n\tvec2 pa = gl_FragCoord.xy;\n\tvec2 ct = vec2(0.5);\n\tfloat ra = 40.;\n\n\tvec2 rs = ps * 0.5;\n\tfloat cr = rb((vUv * ps) - rs, rs, ra);\n\tcr = clamp(cr, 0.0, 1.0);\n\tvec4 br = vec4(0.,0.,0.,0.);\n\n\tuv.y -= ud;\n\tuv -= 0.5;\n\tuv *= 0.8;\n\tuv += 0.5;\n\tvec2 fr = r * dr;\n\tvec2 st = pa / fr.xy - ct;\n\tst.y *= r.y / r.x;\n\tvec2 m = co;\n\tm *= -ct.x;\n\tm.y *= r.y / r.x;\n\tvec4 t = mix(texture2D(tex, uv), br, cr);\n\tvec2 m1 = vec2(time * -0.1, time * 0.08);\n\tvec2 m2 = vec2(time * 0.1, time * -0.08);\n\tfloat n = a(vec2(uv.x * 20., uv.y * 20. + m1));\n\t// n += x(vec2(uv.y * 30., uv.x * 30. + n + m2));\n\t// n += x(vec2(uv.y * 40., uv.x * 40. + n + m1));\n\tn = fract(n);\n\tvec2 clp = st + m;\n\tfloat c = cc(clp, 0.018, 16.1) * 3.5;\n\tfloat fm = smoothstep(1.1, 3.5, n + pow(c, 2.));\t\n\tvec4 color = texture2D(tex, uv);\n\tvec4 of = texture2D(dtx, vUv);\n\tvec4 tt = mix(texture2D(tex, uv - 0.1 * (of.rg)), br, cr);\n\tfloat r1 = 1. - tt.r;\n\tfloat g1 = 1. - tt.g;\n\tfloat b1 = 1. - tt.b;\n\tvec4 us = vec4(r1,r1,r1,t.a);\n\tgl_FragColor = mix(mix(mix(vec4(mix(t,us,step(1.,fm))), br, 1. - al), mix(vec4(0.,0.,0.,1.), br, cr), 0.7 * ddd), br, 1. - al);\n}",
                    defines: {
                        dr: window.devicePixelRatio.toFixed(1)
                    },
                    uniforms: {
                        time: {
                            value: 0
                        },
                        ud: {
                            value: 0
                        },
                        ddd: {
                            value: 0
                        },
                        tex: {
                            value: i
                        },
                        co: {
                            value: this.mouse1
                        },
                        dtx: {
                            value: this.texture
                        },
                        r: {
                            value: new po(window.innerWidth,window.innerHeight)
                        },
                        s: {
                            value: 0
                        },
                        ps: {
                            value: new po
                        },
                        ns: {
                            value: new po(e[1],e[2])
                        },
                        al: {
                            value: 1
                        }
                    },
                    transparent: !0
                }),
                this.material.depthTest = !1,
                this.mesh = new Dl(this.geometry,this.material),
                this.scene.add(this.mesh)
            }
            show() {}
            onEnter(t) {
                this.index === t ? (bn.to(this.material.uniforms.ddd, {
                    value: 0,
                    ease: "Power1.easeOut"
                }),
                bn.killTweensOf(this.box),
                bn.killTweensOf(this.description),
                bn.killTweensOf(this.label),
                bn.to([this.box, this.description, this.label], {
                    opacity: 1,
                    ease: "Power1.easeOut"
                }),
                bn.fromTo(this.span, {
                    y: "100%"
                }, {
                    y: 0,
                    ease: "Power1.easeOut"
                })) : bn.to(this.material.uniforms.ddd, {
                    value: 1,
                    ease: "Power1.easeOut"
                })
            }
            onLeave(t) {
                bn.to(this.material.uniforms.ddd, {
                    value: 0,
                    ease: "Power1.easeOut"
                }),
                this.index === t && (bn.killTweensOf(this.box),
                bn.killTweensOf(this.description),
                bn.killTweensOf(this.label),
                bn.to([this.box, this.description, this.label], {
                    opacity: 0,
                    duration: .25,
                    ease: "Power1.easeOut"
                }),
                bn.to(this.span, {
                    y: "-100%",
                    ease: "Power1.easeOut"
                }))
            }
            onMove(t) {
                const {w: e, h: i} = this.v;
                bn.to(this.mouse1, {
                    x: t.clientX / e * 2 - 1,
                    y: -t.clientY / i * 2 + 1,
                    duration: .6
                })
            }
            onImgMove(t) {
                this.mouse.x = (t.pageX - this.b.left) / this.b.width,
                this.mouse.y = (t.pageY - (this.top - this.s)) / this.b.height,
                this.mouse.vX = this.mouse.x - this.mouse.prevX,
                this.mouse.vY = this.mouse.y - this.mouse.prevY,
                this.mouse.prevX = this.mouse.x,
                this.mouse.prevY = this.mouse.y
            }
            cb() {
                this.b = Ln(this.el);
                const {top: t} = this.b;
                this.top = t + this.s,
                this.us()
            }
            us() {
                const {width: t, height: e} = this.b;
                this.mesh.scale.set(t, e, 1),
                this.material.uniforms.ps.value.x = t,
                this.material.uniforms.ps.value.y = e,
                this.ux(),
                this.uy()
            }
            rs(t) {
                this.v = t,
                this.cb(),
                this.material.uniforms.r.value.x = window.innerWidth,
                this.material.uniforms.r.value.y = window.innerHeight
            }
            ux(t=0) {
                const {left: e, width: i} = this.b
                  , {w: n} = this.v;
                this.mesh.position.x = e - n / 2 + i
            }
            uy(t=0) {
                const {height: e, top: i} = this.b
                  , {h: n} = this.v;
                this.mesh.position.y = t - this.top + n / 2 - e / 2
            }
            pDisp() {
                let {x: t, y: e, vX: i, vY: n} = this.mouse;
                Wm(this.texture.image.data, this.nbr, t, e, this.mouse.vX, this.mouse.vY),
                this.mouse.vX *= .5,
                this.mouse.vY *= .5,
                this.texture.needsUpdate = !0
            }
            update(t) {
                const {top: e} = this.b
                  , {h: i} = this.v;
                this.played || e - t - i / 2 <= 0 && 0 === this.index && (this.played = !0,
                this.show()),
                this.s = t,
                this.pDisp(),
                this.uy(t)
            }
            ael() {
                Wn(zn, this.onImgMove.bind(this), this.el)
            }
            rel() {
                Vn(Bn, this.onEnter.bind(this), this.el),
                Vn(kn, this.onLeave.bind(this), this.el),
                Vn(zn, this.onImgMove.bind(this), this.el)
            }
        }
        class Xm {
            constructor({scene: t, loader: e, geometry: i, camera: n, first: r}) {
                this.scene = t,
                this.loader = e,
                this.geometry = i,
                this.camera = n,
                this.first = r,
                this.aboutimage = Pn(".home_about_img"),
                this.about = Pn(".home_about"),
                this.connectTitle = Pn(".home_contact_connect"),
                this.mouse = {
                    x: -10,
                    y: 10,
                    prevX: 0,
                    prevY: 0,
                    vX: 0,
                    vY: 0
                },
                this.raycaster = new bm,
                this.m = new po,
                this.mouse1 = new po(-10,10),
                this.s = 0,
                this.group = new id,
                this.scene.add(this.group),
                this.createCl(),
                this.intro(),
                this.createLines(),
                this.createMesh(),
                this.createMedias(),
                this.ael()
            }
            createCl() {
                const t = [...Cn(".home_hero_c .circAn")]
                  , e = [...Cn(".home_contact .circAn")]
                  , i = [...Cn(".home_about .circAn")]
                  , n = [...Cn(".home_featured .circAn")];
                this.heroCl = Sn()(t, (t=>new ir({
                    el: t
                }))),
                this.contactCl = Sn()(e, (t=>new ir({
                    el: t
                }))),
                this.aboutCl = Sn()(i, (t=>new ir({
                    el: t
                }))),
                this.featuredCl = Sn()(n, (t=>new ir({
                    el: t
                })))
            }
            intro() {
                const t = Cn(".home_hero_description span span")
                  , e = Cn(".home_f span")
                  , i = Cn(".home_s span");
                let n = 0;
                n = this.first ? 0 : 300,
                setTimeout((()=>{
                    bn.to(e, {
                        y: "-101%",
                        stagger: .025,
                        duration: 1,
                        delay: .25,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(i, {
                        y: "0",
                        stagger: .025,
                        duration: 1,
                        delay: .35,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(t, {
                        y: "0",
                        stagger: .055,
                        duration: 1.45,
                        delay: .9,
                        ease: "Power3.easeOut"
                    }),
                    this.heroCl.forEach((t=>t.go())),
                    bn.fromTo(".home_hero_arrow", {
                        opacity: 0,
                        y: "-125%"
                    }, {
                        opacity: 1,
                        y: "-50%",
                        duration: 1.55,
                        delay: .85,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(".home_hero_scroll_text", {
                        y: 0,
                        duration: 1.4,
                        delay: .55,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(".home_hero_scroll_arrow", {
                        opacity: 1,
                        y: "0.4rem",
                        x: "0.4rem",
                        delay: .55,
                        ease: "Expo.easeOut"
                    })
                }
                ), n)
            }
            hide() {
                this.store.forEach((t=>t.hide())),
                this.lineAnim.forEach((t=>t.hide())),
                bn.to(this.material.uniforms.al, {
                    value: 0,
                    duration: .75,
                    ease: "Expo.easeInout"
                })
            }
            aboutRev() {
                setTimeout((()=>{
                    this.aboutCl.forEach((t=>t.go()))
                }
                ), 600),
                bn.to(".home_hero_scroll_text", {
                    y: 0,
                    duration: 1.4,
                    delay: .55,
                    ease: "Expo.easeOut"
                }),
                bn.to(".home_about_rv", {
                    y: 0,
                    duration: 1,
                    ease: "Power3.easeOut",
                    delay: .5
                }),
                bn.to(".home_about .btn_inner_text p", {
                    opacity: 1,
                    delay: 1.6,
                    duration: .5
                }),
                bn.to(".home_about_description span span", {
                    y: 0,
                    stagger: .055,
                    duration: 1.45,
                    delay: .9,
                    ease: "Power3.easeOut"
                })
            }
            featIntro() {
                this.featuredCl.forEach((t=>t.go())),
                bn.to(".home_feature_intro_description span span", {
                    y: 0,
                    delay: .1,
                    duration: 1.2,
                    ease: "Power3.easeOut",
                    stagger: .12
                }),
                bn.to(".home_featured .btn_inner_text p", {
                    opacity: 1,
                    delay: 1,
                    duration: .5
                }),
                bn.to(".home_featured_header p", {
                    y: 0,
                    ease: "Power3.easeOut"
                })
            }
            contactTextAnim() {
                bn.to(".home_contact_title_el1 span", {
                    y: "-100%",
                    duration: 1.5,
                    stagger: .04,
                    delay: .2,
                    ease: "Expo.easeOut"
                }),
                bn.to(".home_contact_title_el2 span", {
                    y: "0",
                    duration: 1.5,
                    stagger: .04,
                    delay: .2,
                    ease: "Expo.easeOut"
                }),
                bn.to(".home_contact_mail span", {
                    y: 0,
                    duration: 1.5,
                    delay: .2,
                    ease: "Expo.easeOut"
                }),
                this.contactCl.forEach((t=>t.go())),
                bn.to(".home_contact .btn_inner_text p", {
                    opacity: 1,
                    delay: 1,
                    duration: .5
                })
            }
            createPix() {
                this.nbr = 16;
                const t = this.nbr
                  , e = this.nbr
                  , i = t * e
                  , n = new Float32Array(3 * i);
                for (let t = 0; t < i; t++) {
                    const e = 3 * t;
                    let i = Math.random()
                      , r = 255 * Math.random();
                    n[e] = i,
                    n[e + 1] = r,
                    n[e + 2] = i
                }
                this.texture = new Yl(n,t,e,js,Ns),
                this.texture.magFilter = this.texture.minFilter = Ms
            }
            createLines() {
                const t = [...Cn(".glLineP")];
                this.lineAnim = Sn()(t, (t=>new jm({
                    el: t,
                    geometry: this.geometry,
                    loader: this.loader,
                    scene: this.group
                })))
            }
            createMedias() {
                this.images = [...Cn(".home_featured_img_media")];
                const t = [...Cn(".home_featured_t")]
                  , e = new tc(1,1,1,1);
                e.translate(-.5, 0, 0);
                const i = [...Cn(".home_featured_title_all_c")]
                  , n = [...Cn(".home_featured_description")]
                  , r = [...Cn(".home_featured_labels")];
                this.store = Sn()(this.images, ((s,a)=>new qm({
                    el: s,
                    loader: this.loader,
                    geometry: e,
                    scene: this.group,
                    index: a,
                    title: t[a],
                    cl: this.featuredCl,
                    box: i[a],
                    description: n[a],
                    label: r[a]
                })))
            }
            createMesh() {
                this.createPix();
                const t = Pn("img", this.aboutimage).getAttribute("data-src")
                  , e = window.TEXTURES[t]
                  , i = e[0];
                this.material = new Hl({
                    vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 p;\n\nvoid main() {\n  vUv = uv;\n  vec3 pos = position;\n\n  p = pos;\n  \n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}",
                    fragmentShader: "#define GLSLIFY 1\nuniform vec2 co;\nuniform vec2 r;\nuniform sampler2D tex;\nuniform sampler2D dtx;\nuniform float time;\nuniform float ud;\nuniform float al;\nuniform float ddd;\nuniform vec2 ps;\nuniform vec2 ns;\n\nvarying vec2 vUv;\nvarying vec3 p;\n\nfloat cc(in vec2 _st, in float _radius, in float blurriness){\n\tvec2 dist = _st;\n\treturn 1.-smoothstep(_radius-(_radius*blurriness), _radius+(_radius*blurriness), dot(dist,dist)*4.0);\n}\n\nfloat rb( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b+r,0.0))-r;\n}\n\nfloat z(in vec2 q) {\n    return fract(sin(dot(q.xy, vec2(12.9898, 78.233)))*43758.5453123);\n}\nfloat bb(vec2 q) {\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(z(i+vec2(0.0, 0.0)), z(i+vec2(1.0, 0.0)), u.x), mix(z(i+vec2(0.0, 1.0)), z(i+vec2(1.0, 1.0)), u.x), u.y);\n}\nfloat b(in vec2 q) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 k = vec2(100.0);\n    mat2 r = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for(int i = 0;i<5;++i) {\n        v += a*bb(q);\n        q = r*q*2.0+k;\n        a *= 0.5;\n    }\n    return v;\n}\n\n  vec2 gu(vec2 uv, vec2 ns, vec2 ps){\n    vec2 tu = uv - vec2(0.5);\n\n    float pa = ps.x/ps.y;\n    float ta = ns.x/ns.y;\n    if(pa<ta){\n        tu = tu*vec2(pa/ta,1.);\n    } else{\n        tu = tu*vec2(1.,ta/pa);\n    }\n\n    tu += vec2(0.5);\n    return tu;\n}\n\nfloat PI = 3.1415926353;\n\nvoid main()\t{\n\tvec2 uv = gu(vUv,ns, ps);\n\tvec2 pa = gl_FragCoord.xy;\n\tvec2 ct = vec2(0.5);\n\tfloat ra = 40.;\n\n\tvec2 rs = ps * 0.5;\n\tfloat cr = rb((vUv * ps) - rs, rs, ra);\n\tcr = clamp(cr, 0.0, 1.0);\n\tvec4 br = vec4(0.,0.,0.,0.);\n\n\tuv.y -= ud;\n\tuv -= 0.5;\n\tuv *= 0.8;\n\tuv += 0.5;\n\tvec2 fr = r * dr;\n\tvec2 st = pa / fr.xy - ct;\n\tst.y *= r.y / r.x;\n\tvec2 m = co;\n\tm *= -ct.x;\n\tm.y *= r.y / r.x;\n\tvec4 t = mix(texture2D(tex, uv), br, cr);\n\tvec2 m1 = vec2(time * -0.1, time * 0.08);\n\tvec2 m2 = vec2(time * 0.1, time * -0.08);\n\tfloat n = b(vec2(uv.x * 20., uv.y * 20. + m1));\n\t// n += x(vec2(uv.y * 30., uv.x * 30. + n + m2));\n\t// n += x(vec2(uv.y * 40., uv.x * 40. + n + m1));\n\tn = fract(n);\n\tvec2 clp = st + m;\n\tfloat c = cc(clp, 0.018, 16.1) * 3.5;\n\tfloat fm = smoothstep(1.1, 3.5, n + pow(c, 2.));\t\n\tvec4 color = texture2D(tex, uv);\n\tvec4 of = texture2D(dtx, vUv);\n\tvec4 tt = mix(texture2D(tex, uv - 0.1 * (of.rg)), br, cr);\n\tfloat r1 = 1. - tt.r;\n\tfloat g1 = 1. - tt.g;\n\tfloat b1 = 1. - tt.b;\n\tvec4 us = vec4(r1,r1,r1,t.a);\n\tgl_FragColor = mix(mix(mix(vec4(mix(t,us,step(1.,fm))), br, 1. - al), mix(vec4(0.,0.,0.,1.), br, cr), 0.7 * ddd), br, 1. - al);\n}",
                    defines: {
                        dr: window.devicePixelRatio.toFixed(1)
                    },
                    uniforms: {
                        time: {
                            value: 0
                        },
                        ud: {
                            valur: 0
                        },
                        ddd: {
                            valur: 0
                        },
                        tex: {
                            value: i
                        },
                        co: {
                            value: this.mouse1
                        },
                        dtx: {
                            value: this.texture
                        },
                        r: {
                            value: new po(window.innerWidth,window.innerHeight)
                        },
                        ps: {
                            value: new po
                        },
                        ns: {
                            value: new po(e[1],e[2])
                        },
                        al: {
                            value: 1
                        }
                    },
                    transparent: !0
                }),
                this.material.depthTest = !1,
                this.mesh = new Dl(this.geometry,this.material),
                this.group.add(this.mesh)
            }
            cb() {
                this.b = Ln(this.aboutimage),
                this.top = this.b.top + this.s,
                this.us()
            }
            us() {
                const {width: t, height: e} = this.b;
                this.mesh.scale.set(t, e, 1),
                this.material.uniforms.ps.value.x = t,
                this.material.uniforms.ps.value.y = e,
                this.ux(),
                this.uy()
            }
            rs(t) {
                this.v = t,
                this.cb(),
                this.store.forEach((e=>e.rs(t))),
                this.heroCl.forEach((t=>t.rs())),
                this.contactCl.forEach((t=>t.rs())),
                this.aboutCl.forEach((t=>t.rs())),
                this.featuredCl.forEach((t=>t.rs())),
                this.lineAnim.forEach((t=>t.rs(this.v))),
                this.ib = Ln(this.aboutimage),
                this.ibTop = this.ib.top + this.s,
                this.tb = Ln(this.connectTitle).top,
                this.abB = Ln(this.about),
                this.tbTop = this.tb + this.s,
                this.abBT = this.abB.top + this.s,
                this.featT = Ln(Pn(".home_featured")).top + this.s,
                this.material.uniforms.r.value.x = window.innerWidth,
                this.material.uniforms.r.value.y = window.innerHeight
            }
            onMove(t) {
                if (!this.v)
                    return;
                const {w: e, h: i} = this.v;
                bn.to(this.mouse1, {
                    x: t.clientX / e * 2 - 1,
                    y: -t.clientY / i * 2 + 1,
                    duration: .6
                }),
                this.store.forEach((e=>e.onMove(t))),
                this.m.x = t.clientX / e * 2 - 1,
                this.m.y = -t.clientY / i * 2 + 1,
                this.raycaster.setFromCamera(this.m, this.camera);
                const n = this.raycaster.intersectObjects(this.group.children);
                if (n.length > 0) {
                    const t = n[0].object;
                    if (!t.material.uniforms.hl)
                        return;
                    bn.to(t.material.uniforms.hl.value, {
                        y: n[0].uv.y
                    }),
                    bn.to(t.material.uniforms.hl.value, {
                        x: n[0].uv.x
                    }),
                    n[0].uv.y > .5 ? bn.to(t.material.uniforms.b, {
                        value: -1.5,
                        ease: "Expo.easeOut",
                        duration: 1.2
                    }) : bn.to(t.material.uniforms.b, {
                        value: 1.5,
                        ease: "Expo.easeOut",
                        duration: 1.2
                    })
                }
            }
            onImgMove(t) {
                this.mouse.x = (t.pageX - this.ib.left) / this.ib.width,
                this.mouse.y = (t.pageY - (this.ibTop - this.s)) / this.ib.height,
                this.mouse.vX = this.mouse.x - this.mouse.prevX,
                this.mouse.vY = this.mouse.y - this.mouse.prevY,
                this.mouse.prevX = this.mouse.x,
                this.mouse.prevY = this.mouse.y
            }
            ux() {
                const {left: t, width: e} = this.b
                  , {h: i, w: n} = this.v;
                this.mesh.position.x = t - n / 2 + e / 2
            }
            uy(t=0) {
                if (!this.b || !this.v)
                    return;
                const {top: e, height: i} = this.b
                  , {h: n, w: r} = this.v;
                this.mesh.position.y = t - this.top + n / 2 - i / 2
            }
            pDisp() {
                let {x: t, y: e, vX: i, vY: n} = this.mouse;
                Wm(this.texture.image.data, this.nbr, t, e, this.mouse.vX, this.mouse.vY),
                this.mouse.vX *= .5,
                this.mouse.vY *= .5,
                this.texture.needsUpdate = !0
            }
            ai() {
                const {h: t} = this.v
                  , {height: e} = this.b
                  , {y: i} = this.mesh.position;
                i < t / 2 + e / 2 && i > -t / 2 - e / 2 && (this.sc = i / (t / 2 + e / 2),
                this.dc = 1 - Math.abs(this.sc)),
                this.ud = On(this.sc, -1, 1, -.1, .1),
                this.material.uniforms.ud.value = this.ud
            }
            update(t, e, i) {
                if (!this.b || !this.v)
                    return;
                this.s = t,
                this.pDisp(),
                this.material.uniforms.time.value = i,
                this.material.uniforms.ddd.value = 0,
                this.uy(t);
                const {h: n} = this.v;
                this.ai(),
                this.lineAnim.forEach((e=>e.update(t))),
                this.store.forEach((e=>e.update(t))),
                this.heroCl.forEach((t=>t.update())),
                this.contactCl.forEach((t=>t.update())),
                this.aboutCl.forEach((t=>t.update())),
                this.featuredCl.forEach((t=>t.update())),
                this.abPlayed || (this.abBT - this.s) / n < .9 && (this.abPlayed = !0,
                this.aboutRev()),
                this.featPlayed || (this.featT - this.s) / n < .8 && (this.featPlayed = !0,
                this.featIntro()),
                this.played || this.tbTop - t - n / 1.5 <= 0 && (this.played = !0,
                this.contactTextAnim())
            }
            ael() {
                Wn(zn, this.onImgMove.bind(this), this.aboutimage),
                this.images.forEach(((t,e)=>{
                    t.addEventListener("mouseenter", (t=>{
                        this.store.forEach((t=>t.onEnter(e)))
                    }
                    ))
                }
                )),
                this.images.forEach(((t,e)=>{
                    t.addEventListener("mouseleave", (t=>{
                        this.store.forEach((t=>t.onLeave(e)))
                    }
                    ))
                }
                ))
            }
            rel() {
                Vn(zn, this.onImgMove.bind(this), this.aboutimage),
                this.store.forEach((t=>t.rel()))
            }
            destroy() {
                this.rel(),
                this.scene.remove(this.group),
                this.store.forEach((t=>t.rel()))
            }
        }
        class Ym {
            constructor({scene: t, loader: e, geometry: i, camera: n, first: r}) {
                this.scene = t,
                this.loader = e,
                this.geometry = i,
                this.camera = n,
                this.first = r,
                this.heroImg = Pn(".about_hero_img"),
                this.contact = Pn(".about_contact"),
                this.brands = Pn(".about_brands_big"),
                this.skills = Pn(".about_skill"),
                this.group = new id,
                this.scene.add(this.group),
                this.raycaster = new bm,
                this.m = new po,
                this.mouse = {
                    x: -10,
                    y: 10,
                    prevX: 0,
                    prevY: 0,
                    vX: 0,
                    vY: 0
                },
                this.mouse1 = new po(-10,10),
                this.s = 0,
                this.createCl(),
                this.createLines(),
                this.createMesh(),
                this.ael(),
                this.intro()
            }
            createCl() {
                const t = [...Cn(".about_contact .circAn")];
                this.contactCl = Sn()(t, (t=>new ir({
                    el: t
                })))
            }
            createLines() {
                const t = [...Cn(".glLineP")];
                this.lineAnim = Sn()(t, (t=>new jm({
                    el: t,
                    geometry: this.geometry,
                    loader: this.loader,
                    scene: this.group
                })))
            }
            intro() {
                let t = 0;
                t = this.first ? 0 : 400,
                setTimeout((()=>{
                    bn.to(this.material.uniforms.a, {
                        value: 1,
                        duration: 1,
                        ease: "Power2.easeInOut"
                    }),
                    bn.to(this.material.uniforms.o, {
                        value: 0,
                        duration: 1.8,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(this.material.uniforms.s, {
                        value: 1,
                        delay: 0,
                        duration: 1.8,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(this.material.uniforms.s1, {
                        value: 1,
                        delay: 0,
                        duration: 1.8,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(".about_hero_title", {
                        y: 0,
                        opacity: 1,
                        duration: 2.2,
                        ease: "Expo.easeOut"
                    }),
                    bn.to(".about_hero_description span span", {
                        y: 0,
                        stagger: .05,
                        duration: 1.8,
                        delay: .75,
                        ease: "Expo.easeOut"
                    })
                }
                ), t)
            }
            contactTextAnim() {
                bn.to(".home_contact_title_el1 span", {
                    y: "-100%",
                    duration: 1.5,
                    stagger: .04,
                    delay: .2,
                    ease: "Expo.easeOut"
                }),
                bn.to(".home_contact_title_el2 span", {
                    y: "0",
                    duration: 1.5,
                    stagger: .04,
                    delay: .2,
                    ease: "Expo.easeOut"
                }),
                bn.to(".home_contact_mail span", {
                    y: 0,
                    duration: 1.5,
                    delay: .2,
                    ease: "Expo.easeOut"
                }),
                this.contactCl.forEach((t=>t.go())),
                bn.to(".home_contact .btn_inner_text p", {
                    opacity: 1,
                    delay: 1,
                    duration: .5
                })
            }
            createPix() {
                this.nbr = 16;
                const t = this.nbr
                  , e = this.nbr
                  , i = t * e
                  , n = new Float32Array(3 * i);
                for (let t = 0; t < i; t++) {
                    const e = 3 * t;
                    let i = 0
                      , r = 0;
                    n[e] = i,
                    n[e + 1] = r,
                    n[e + 2] = i
                }
                this.texture = new Yl(n,t,e,js,Ns),
                this.texture.magFilter = this.texture.minFilter = Ms
            }
            createMesh() {
                this.createPix();
                const t = Pn(".about_hero_img img").getAttribute("data-src")
                  , e = window.TEXTURES[t]
                  , i = e[0];
                this.material = new Hl({
                    vertexShader: "#define GLSLIFY 1\nuniform float o;\nuniform float s;\n\nvarying vec2 vUv;\nvarying vec3 p;\n\nvoid main() {\n  vUv = uv;\n  vec3 pos = position;\n  pos.y -= o;\n  pos.xy *= s;\n  \n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}",
                    fragmentShader: "#define GLSLIFY 1\nuniform vec2 co;\nuniform vec2 r;\nuniform vec2 ps;\nuniform vec2 ns;\nuniform sampler2D tex;\nuniform sampler2D dtx;\nuniform float time;\nuniform float a;\nuniform float s;\nuniform float s1;\n\nvarying vec2 vUv;\nvarying vec3 p;\n\n  vec2 gu(vec2 uv, vec2 ns, vec2 ps){\n    vec2 tu = uv - vec2(0.5);\n\n    float pa = ps.x/ps.y;\n    float ta = ns.x/ns.y;\n    if(pa<ta){\n        tu = tu*vec2(pa/ta,1.);\n    } else{\n        tu = tu*vec2(1.,ta/pa);\n    }\n\n    tu += vec2(0.5);\n    return tu;\n}\n\nfloat cc(in vec2 _st, in float _radius, in float blurriness){\n\tvec2 dist = _st;\n\treturn 1.-smoothstep(_radius-(_radius*blurriness), _radius+(_radius*blurriness), dot(dist,dist)*4.0);\n}\n\nfloat rb( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b+r,0.0))-r;\n}\n\nfloat z(in vec2 q) {\n    return fract(sin(dot(q.xy, vec2(12.9898, 78.233)))*43758.5453123);\n}\nfloat bb(vec2 q) {\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(z(i+vec2(0.0, 0.0)), z(i+vec2(1.0, 0.0)), u.x), mix(z(i+vec2(0.0, 1.0)), z(i+vec2(1.0, 1.0)), u.x), u.y);\n}\nfloat b(in vec2 q) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 k = vec2(100.0);\n    mat2 r = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for(int i = 0;i<5;++i) {\n        v += a*bb(q);\n        q = r*q*2.0+k;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat PI = 3.1415926353;\n\nvoid main()\t{\n\tvec2 pa = gl_FragCoord.xy;\n\tvec2 ct = vec2(0.5);\n\tfloat ra = 40.;\n\tvec2 rs = ps * 0.5;\n\tfloat cr = rb((vUv * ps) - rs, rs, ra);\n\tcr = clamp(cr, 0.0, 1.0);\n\tvec4 br = vec4(0.,0.,0.,0.);\n    vec2 fr = r * dr;\n\tvec2 st = pa / fr.xy - ct;\n\tst.y *= r.y / r.x;\n\tvec2 m = co;\n\tm *= -ct.x;\n\tm.y *= r.y / r.x;\n\tvec2 uv = gu(vUv, ns, ps);\n\tuv -= 0.5;\n\tuv *= s1;\n\tuv += 0.5;\n\tvec4 t = mix(texture2D(tex, uv), br, cr);\n\tvec2 m1 = vec2(time * -0.1, time * 0.08);\n\tvec2 m2 = vec2(time * 0.1, time * -0.08);\n\tfloat n = b(vec2(uv.x * 20., uv.y * 20. + m1));\n\t// n += x(vec2(uv.y * 5., uv.x * 5. + n + m2));\n\t// n += x(vec2(uv.y * 40., uv.x * 40. + n + m1));\n\tn = fract(n);\n\tvec2 clp = st + m;\n\tfloat c = cc(clp, 0.030, 14.1) * 3.5;\n\tfloat fm = smoothstep(1.1, 3.5, n + pow(c, 2.));\t\n\tvec4 color = texture2D(tex, uv);\n\tvec4 of = texture2D(dtx, uv);\n\tvec4 tt = mix(texture2D(tex, uv - .07 * (of.xy)), br, cr);\n\tfloat r1 = 1. - tt.r;\n\tfloat g1 = 1. - tt.g;\n\tfloat b1 = 1. - tt.b;\n\tvec4 us = vec4(r1,r1,r1,t.a);\n \tgl_FragColor = mix(vec4(mix(t,us,step(1.,fm))), br, 1. - a);\n}",
                    defines: {
                        dr: window.devicePixelRatio.toFixed(1)
                    },
                    uniforms: {
                        time: {
                            value: 0
                        },
                        tex: {
                            value: i
                        },
                        co: {
                            value: this.mouse1
                        },
                        dtx: {
                            value: this.texture
                        },
                        r: {
                            value: new po(window.innerWidth,window.innerHeight)
                        },
                        ns: {
                            value: new po(e[1],e[2])
                        },
                        ps: {
                            value: new po
                        },
                        a: {
                            value: 0
                        },
                        s: {
                            value: .58
                        },
                        s1: {
                            value: .35
                        },
                        o: {
                            value: .6
                        }
                    },
                    transparent: !0
                }),
                this.mesh = new Dl(this.geometry,this.material),
                this.group.add(this.mesh)
            }
            hide() {
                const t = this.mesh.position.y;
                this.stop = !0;
                const e = window.innerWidth / 1440 * 10;
                bn.to(this.mesh.position, {
                    y: t + 30 * e,
                    duration: 1.2,
                    ease: "Power3.easeInOut"
                }),
                bn.to(this.material.uniforms.a, {
                    value: 0,
                    delay: 0,
                    duration: .5,
                    ease: "Expo.easeInout"
                }),
                this.lineAnim.forEach((t=>t.hide()))
            }
            bioTextAnim() {
                this.played = !0;
                const t = Cn(".about_bio p span span");
                bn.to(t, {
                    y: 0,
                    duration: 1.5,
                    stagger: .07,
                    delay: .2,
                    ease: "Expo.easeOut"
                })
            }
            brandsRev() {
                bn.to(".about_brand_arrow_c span", {
                    y: 0,
                    duration: 1.5,
                    stagger: .03,
                    ease: "Expo.easeOut"
                }),
                bn.to(".about_brands .about_list_dot", {
                    opacity: 1,
                    duration: 1.5,
                    stagger: .03,
                    ease: "Expo.easeOut",
                    delay: .3
                })
            }
            skillsRev() {
                bn.to(".about_skill span", {
                    y: 0,
                    duration: 1.5,
                    stagger: .03,
                    ease: "Expo.easeOut"
                }),
                bn.to(".about_skill .about_list_dot", {
                    opacity: 1,
                    duration: 1.5,
                    stagger: .03,
                    ease: "Expo.easeOut",
                    delay: .3
                })
            }
            cb() {
                this.b = Ln(this.heroImg),
                this.top = this.b.top + this.s,
                this.ib = Ln(this.heroImg),
                this.ibTop = this.ib.top + this.s,
                this.us()
            }
            us() {
                const {width: t, height: e} = this.b;
                this.mesh.scale.set(t, e, 1),
                this.material.uniforms.ps.value.x = t,
                this.material.uniforms.ps.value.y = e,
                this.ux(),
                this.uy()
            }
            rs(t) {
                this.v = t,
                this.cb(),
                this.contactCl.forEach((t=>t.rs())),
                this.lineAnim.forEach((e=>e.rs(t))),
                this.bioT = Ln(Pn(".about_description_text")),
                this.ctB = Ln(this.contact),
                this.trigger = this.bioT.top - t.h + this.bioT.height / 3,
                this.brandsT = Ln(this.brands).top + this.s,
                this.skillsT = Ln(this.skills).top + this.s,
                this.material.uniforms.r.value.x = window.innerWidth,
                this.material.uniforms.r.value.y = window.innerHeight
            }
            onImgMove(t) {
                this.mouse.x = (t.pageX - this.ib.left) / this.ib.width,
                this.mouse.y = (t.pageY - (this.ibTop - this.s)) / this.ib.height,
                this.mouse.vX = this.mouse.x - this.mouse.prevX,
                this.mouse.vY = this.mouse.y - this.mouse.prevY,
                this.mouse.prevX = this.mouse.x,
                this.mouse.prevY = this.mouse.y
            }
            onMove(t) {
                if (!this.v)
                    return;
                const {w: e, h: i} = this.v;
                bn.to(this.mouse1, {
                    x: t.clientX / e * 2 - 1,
                    y: -t.clientY / i * 2 + 1,
                    duration: .6
                }),
                this.m.x = t.clientX / e * 2 - 1,
                this.m.y = -t.clientY / i * 2 + 1,
                this.raycaster.setFromCamera(this.m, this.camera);
                const n = this.raycaster.intersectObjects(this.group.children);
                if (n.length > 0) {
                    const t = n[0].object;
                    if (!t.material.uniforms.hl)
                        return;
                    bn.to(t.material.uniforms.hl.value, {
                        y: n[0].uv.y
                    }),
                    bn.to(t.material.uniforms.hl.value, {
                        x: n[0].uv.x
                    }),
                    n[0].uv.y > .5 ? bn.to(t.material.uniforms.b, {
                        value: -1.5,
                        ease: "Expo.easeOut",
                        duration: 1.2
                    }) : bn.to(t.material.uniforms.b, {
                        value: 1.5,
                        ease: "Expo.easeOut",
                        duration: 1.2
                    })
                }
            }
            ux() {
                const {left: t, width: e} = this.b
                  , {h: i, w: n} = this.v
                  , r = ((t,e,i,n)=>-0 + e - i / 2 + n / 2)(0, t, n, e);
                this.mesh.position.x = r
            }
            uy(t=0) {
                if (!this.b)
                    return;
                const {top: e, height: i} = this.b
                  , {h: n, w: r} = this.v
                  , s = Gm(t, this.top, n, i);
                this.mesh.position.y = s
            }
            pDisp() {
                let {x: t, y: e, vX: i, vY: n} = this.mouse;
                Wm(this.texture.image.data, this.nbr, t, e, this.mouse.vX, this.mouse.vY),
                this.mouse.vX *= .5,
                this.mouse.vY *= .5,
                this.texture.needsUpdate = !0
            }
            update(t, e, i) {
                if (!this.b || !this.v)
                    return;
                if (this.stop)
                    return;
                this.material.uniforms.time.value = i,
                this.s = t,
                this.pDisp(),
                this.uy(this.s);
                const {h: n} = this.v
                  , {top: r} = this.ctB;
                this.contactCl.forEach((t=>t.update())),
                this.lineAnim.forEach((e=>e.update(t))),
                this.brandsPlayed || (this.brandsT - t) / n < .8 && (this.brandsPlayed = !0,
                this.brandsRev()),
                this.skillsPlayed || (this.skillsT - t) / n < .9 && (this.skillsPlayed = !0,
                this.skillsRev()),
                this.played || this.trigger - this.s <= 0 && this.bioTextAnim(),
                this.ctPlayed || r - t - n / 2 <= 0 && (this.ctPlayed = !0,
                this.contactTextAnim())
            }
            ael() {
                Wn(zn, this.onImgMove.bind(this), this.heroImg)
            }
            rel() {
                Vn(zn, this.onImgMove.bind(this), this.heroImg)
            }
            destroy() {
                this.rel(),
                this.scene.remove(this.group)
            }
        }
        class Zm {
            constructor({image: t, scene: e, loader: i, geometry: n, bullet: r, title: s, description: a, nbr: o, line: h, index: l}) {
                this.image = t,
                this.scene = e,
                this.loader = i,
                this.geometry = n,
                this.bullet = r,
                this.title = s,
                this.description = a,
                this.nbr = o,
                this.line = h,
                this.index = l,
                this.dc = 0,
                this.img = Pn(".projects_img_media", this.image.parentElement),
                this.img2 = Pn(".projects_next_page_img", this.image.parentElement),
                this.createMesh()
            }
            intro() {
                bn.to(this.material.uniforms.al, {
                    value: 1,
                    duration: 1,
                    ease: "Power2.easeInOut"
                }),
                bn.to(this.material.uniforms.scale, {
                    value: 1,
                    delay: 0,
                    duration: 1,
                    ease: "Power2.easeOut",
                    onComplete: ()=>{
                        setTimeout((()=>{
                            this.material.visible = !0
                        }
                        ), 100)
                    }
                })
            }
            hide() {
                bn.to(this.material.uniforms.al, {
                    value: 0,
                    duration: .3,
                    ease: "Expo.easeInout"
                })
            }
            createMesh() {
                const t = this.img.getAttribute("data-src")
                  , e = window.TEXTURES[t]
                  , i = this.img2.getAttribute("data-src")
                  , n = window.TEXTURES[i]
                  , r = e[0]
                  , s = n[0];
                this.material = new Hl({
                    vertexShader: "#define GLSLIFY 1\nuniform vec2 rs;\nuniform float dc;\nuniform float strength;\nuniform float arr;\nuniform float fc;\nuniform float t;\nuniform float a1;\nuniform float a2;\nuniform float p1;\n\nvarying vec2 vUv;\nvarying float forw;\n\nfloat ea(float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat eq(float x) {\nreturn x < 0.5 ? 8. * x * x * x * x : 1. - pow(-2. * x + 2., 4.) / 2.;\n}\n\nvoid main() {\n  float pi = 3.14159265359;\n  vUv = uv;\n  vec3 aps = position;\n  vec2 ct = vec2(0.5);\n  float aa = uv.x + 1.;\n  aa -= uv.y * p1 * 2.;\n  aa = abs(aa);\n  float ab = 0.05;\n  float cp = min(2. * t, 2. * (1. - t));\n  float md = length(ct);\n  float g = distance(vUv, ct);\n  float nd = g / md;\n  float z = nd * 55.;\n  float c = -nd * 150.;\n  float fm = mix(c, z, t);\n  float dt = distance(vec2(aa, ab), vec2(a1,a2));\n  dt *= .25;\n  dt *= 0.3;\n  dt *= 4.5;\n  float tr = min(1., dt + 0.3);\n  float hl = eq(tr);\n  aps.z -= 210. * hl;\n  aps.z += 210.;\n  forw = hl;\n\n  // aps.z += fm * cp * .5;\n\n  \n\n  aps.y *= dc;\n  aps.y -= sin(uv.x * pi + 0.25) * (arr);\n  vec4 np = modelViewMatrix * vec4(aps, 1.0 );\n  np.z += sin(np.y / (rs.y) * pi + pi / 2.0) * 450. * abs(strength);\n  np.z += sin(np.x /(rs.x) * pi + pi / 2.0) * 180. * abs(strength);\n  gl_Position = projectionMatrix * np;\n}",
                    fragmentShader: "#define GLSLIFY 1\nuniform sampler2D tex;\nuniform sampler2D tex2;\nuniform float dc;\nuniform float scale;\nuniform float hover;\nuniform float time;\nuniform float arr;\nuniform float t;\nuniform float t2;\nuniform vec2 ns;\nuniform vec2 ns2;\nuniform vec2 ps;\nuniform vec2 ps1;\nuniform float al;\nuniform float p1;\nuniform float z;\n\nvarying vec2 vUv;\nvarying float forw;\n\nfloat ub( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b+r,0.0))-r;\n}\n\n  vec2 gu(vec2 uv, vec2 ns, vec2 ps){\n    vec2 tu = uv - vec2(0.5);\n\n    float pa = ps.x/ps.y;\n    float ta = ns.x/ns.y;\n    if(pa<ta){\n        tu = tu*vec2(pa/ta,1.);\n    } else{\n        tu = tu*vec2(1.,ta/pa);\n    }\n\n    tu += vec2(0.5);\n    return tu;\n}\n\nvoid main(){\n    vec2 uv = gu(vUv, mix(ns, ns2, t), ps);\n    vec2 uv1 = gu(vUv, ns, ps1);\n    vec2 uv2 = gu(vUv, ns2, ps);\n    uv2 -= 0.5;\n    // uv2 *= 0.8 + (0.2 * p1);\n    uv2 *= 0.8 + (0.2 * z);\n    uv2 += 0.5;\n    vec2 hs = ps * 0.5;\n    float rd = 40.;\n    float bd = ub((vUv * ps) - hs, hs, rd);\n    bd = clamp(bd, 0.0, 1.);\n    vec4 br = vec4(0.,0.,0.,0.);\n    uv1.y -= 0.5;\n    uv1.y *= dc;\n    uv1.y += 0.5;\n    uv1 -= 0.5;\n    uv1 *= scale;\n    uv1 += 0.5;\n    vec4 t = mix(mix(texture2D(tex, uv1), br, bd), br, 1. - al * clamp(dc + 0.15,0.,1.));\n    vec4 tb =  mix(mix(texture2D(tex2, uv2), br, bd), br, 1. - al); \n    float f = smoothstep(0.,1. - vUv.y, (-vUv.x  + 1. + vUv.x * p1 * 1.) * p1);\n    gl_FragColor = mix(t, tb, f);\n}",
                    uniforms: {
                        time: {
                            value: 0
                        },
                        tex: {
                            value: r
                        },
                        tex2: {
                            value: s
                        },
                        dc: {
                            value: 1
                        },
                        p: {
                            value: 0
                        },
                        p1: {
                            value: 0
                        },
                        s: {
                            value: .8
                        },
                        a: {
                            value: 0
                        },
                        scale: {
                            value: .7
                        },
                        hover: {
                            value: 0
                        },
                        strength: {
                            value: 0
                        },
                        arr: {
                            value: 0
                        },
                        t: {
                            value: 0
                        },
                        z: {
                            value: 0
                        },
                        t2: {
                            value: 0
                        },
                        fc: {
                            value: 1
                        },
                        al: {
                            value: 0
                        },
                        a1: {
                            value: -0
                        },
                        a2: {
                            value: .8
                        },
                        c1: {
                            value: new po(.1,0)
                        },
                        c2: {
                            value: new po(.9,1)
                        },
                        ns: {
                            value: new po(e[1],e[2])
                        },
                        ns2: {
                            value: new po(n[1],n[2])
                        },
                        ps: {
                            value: new po
                        },
                        ps1: {
                            value: new po
                        },
                        rs: {
                            value: new po(window.innerWidth,window.innerHeight)
                        }
                    },
                    transparent: !0,
                    visible: (this.index,
                    !0)
                }),
                this.material.depthTest = !1,
                this.mesh = new Dl(this.geometry,this.material),
                this.scene.add(this.mesh)
            }
            cb() {
                const {width: t, height: e} = this.b;
                this.material.uniforms.ps.value.x = t,
                this.material.uniforms.ps.value.y = e,
                this.material.uniforms.ps1.value.x = t,
                this.material.uniforms.ps1.value.y = e,
                this.material.uniforms.rs.value.x = window.innerWidth,
                this.material.uniforms.rs.value.y = window.innerHeight,
                Pn("img", this.image),
                this.us()
            }
            us() {
                const {height: t, width: e} = this.b;
                this.mesh.scale.set(e, t, 1),
                this.ux(),
                this.uy()
            }
            onClick(t) {
                this.stop = !0,
                this.index === t ? (bn.to(this.mesh.position, {
                    x: this.fX,
                    y: this.fY,
                    duration: 1.7,
                    ease: "Power2.easeInOut"
                }),
                bn.to(this.mesh.scale, {
                    x: this.w,
                    y: this.h,
                    duration: 1.7,
                    ease: "Power2.easeInOut"
                }),
                bn.to(this.material.uniforms.p1, {
                    value: 1,
                    duration: 1.95,
                    delay: .36,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.material.uniforms.z, {
                    value: 1,
                    duration: 1.95,
                    delay: .2,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.material.uniforms.a1, {
                    value: 3,
                    duration: 4.25,
                    delay: 0,
                    ease: "Power2.easeOut"
                }),
                bn.to(this.material.uniforms.a2, {
                    value: -1,
                    duration: 4.25,
                    delay: 0,
                    ease: "Power2.easeOut"
                }),
                bn.to(this.material.uniforms.t, {
                    value: 1,
                    duration: 2.5,
                    delay: 0,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.material.uniforms.dc, {
                    value: 1,
                    duration: .5,
                    delay: 0,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.material.uniforms.arr, {
                    value: 0,
                    duration: .5,
                    delay: 0,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.material.uniforms.strength, {
                    value: 0,
                    duration: .5,
                    delay: 0,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.material.uniforms.scale, {
                    value: 1,
                    duration: .5,
                    delay: 0,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.mesh.rotation, {
                    y: 0,
                    z: 0,
                    ease: "Power1.easeInOut",
                    duration: 1
                }),
                bn.to(this.material.uniforms.ps.value, {
                    x: this.w,
                    y: this.h,
                    duration: 1.35,
                    delay: 0,
                    ease: "Power1.easeInOut"
                })) : bn.to(this.material.uniforms.al, {
                    value: 0,
                    duration: .3,
                    ease: "Expo.easeInout"
                })
            }
            rs(t, e, i, n, r, s) {
                this.isRs = !0,
                this.v = t,
                this.image.style.transform = "translate3d(0,0, 0)",
                this.b = Ln(this.image),
                this.ct = 0,
                this.dt = 0,
                this.s = 0,
                this.dc = this.sc = 0,
                setTimeout((()=>{
                    this.w = i,
                    this.h = n,
                    this.fX = r - t.w / 2 + i / 2,
                    this.fY = -s + t.h / 2 - n / 2,
                    this.container = e;
                    const {top: a, height: o, bottom: h} = this.b;
                    this.top = o + a,
                    this.bottom = h - o - t.h,
                    this.cb(),
                    this.isRs = !1
                }
                ), 2)
            }
            ux(t=0) {
                const {left: e, width: i} = this.b
                  , {w: n} = this.v;
                this.mesh.position.x = e - n / 2 + i / 2
            }
            uy(t=0) {
                const {height: e, top: i} = this.b
                  , {h: n} = this.v;
                this.mesh.position.y = t - i + n / 2 - e / 2
            }
            ai(t) {
                if (this.isClicked)
                    return;
                const {height: e} = this.b
                  , {y: i} = this.mesh.position
                  , {h: n} = this.v;
                if (i < n / 2 + e / 2 && i > -n / 2 - e / 2) {
                    this.sc = i / (n / 2 + e / 2);
                    let t = 1 - Math.abs(this.sc);
                    this.dc = On(t, 0, 1, 0, 1)
                }
                t || bn.to(this.material.uniforms.dc, {
                    value: this.dc,
                    duration: .1
                })
            }
            update(t, e, i, n, r, s, a, o) {
                if (this.isRs)
                    return;
                if (this.stop)
                    return;
                this.s = t - this.dt,
                this.temp = n,
                this.material.uniforms.time.value = o;
                let h = On(this.dc, 1, .35, 1, 0)
                  , l = On(this.dc, 1, .7, 1, 0);
                0 === this.index ? this.transform = On(this.sc, -.8, .8, -1, 1) : this.transform = On(this.sc, -.6, .6, -1, 1),
                this.image.style.transform = `translate3d(0, ${-this.s}px, 0)`,
                r || (this.bullet.style.transform = `scale(${.5 * h + 1}, ${0 * h + 1})`),
                this.bullet.style.opacity = h + .4,
                this.nbr.style.transform = this.title.style.transform = `translateY(${100 * this.transform}%)`,
                this.nbr.style.opacity = this.title.style.opacity = h,
                this.description.style.opacity = l,
                "l" === e && this.top - this.s < 0 && (this.ct += 1,
                this.dt = (this.container + 25) * this.ct),
                "r" === e && this.bottom - this.s > 0 && (this.ct -= 1,
                this.dt = (this.container + 25) * this.ct),
                this.material.uniforms.strength.value = i,
                this.material.uniforms.arr.value = s,
                this.mesh.rotation.z = .15 * s,
                this.mesh.rotation.y = .5 * s,
                this.uy(this.s),
                this.ai(r)
            }
            destroy(t) {
                t === this.index ? this.mesh.name = "transition" : this.scene.remove(this.mesh)
            }
        }
        i.p;
        let Jm = {
            ps: 0
        }
          , $m = 0
          , Qm = 0
          , Km = 0
          , tg = 0
          , eg = 0
          , ig = "l"
          , ng = 0;
        class rg {
            constructor({scene: t, loader: e, geometry: i, first: n}) {
                this.scene = t,
                this.loader = e,
                this.geometry = i,
                this.first = n,
                this.page = Pn(".projects"),
                this.images = [...Cn(".projects_project_link")],
                this.container = Pn(".projects_images_c"),
                this.bulletsContainer = Pn(".projects_bullets_c"),
                this.titles = [...Cn(".projects_titles_c h2 .n1")],
                this.descriptions = [...Cn(".projects_description_label ")],
                this.titleContainer = Pn(".projects_titles_c"),
                this.descriptionsContainer = Pn(".projects_descriptions_c"),
                this.wheel = !0,
                this.currentTest = 0,
                this.s = {
                    c: 0,
                    t: 0,
                    e: .12
                },
                this.createBullets(),
                this.createNumbersAndLines(),
                this.createMedias(),
                this.ael(),
                this.intro()
            }
            intro() {
                let t = 0;
                t = this.first ? 0 : 500,
                setTimeout((()=>{
                    this.store.forEach((t=>t.intro())),
                    bn.to("header", {
                        opacity: 1,
                        duration: 1,
                        ease: "Power2.easeInOut",
                        onComplete: ()=>this.wheel = !1
                    }),
                    bn.fromTo(".projects_wrapper", {
                        opacity: 0
                    }, {
                        opacity: 1,
                        duration: .38,
                        delay: .2
                    }),
                    bn.to(".projects_count_c", {
                        opacity: 1
                    }),
                    bn.to(".projects_titles_c", {
                        opacity: 1
                    }),
                    bn.to("  .projects_unederLine_c", {
                        opacity: 1
                    }),
                    bn.to("  .projects_bullets_c", {
                        opacity: 1
                    }),
                    this.start = !0
                }
                ), t)
            }
            createBullets() {
                this.bulletContainer = Pn(".projects_bullets_c"),
                this.bullets = [],
                this.images.forEach((t=>{
                    const e = document.createElement("div");
                    e.classList.add("projects_bullet"),
                    this.bulletContainer.appendChild(e),
                    this.bullets.push(e)
                }
                ))
            }
            createNumbersAndLines() {
                const t = Pn(".projects_count_c")
                  , e = Pn("p", t);
                this.linesContainer = Pn(".projects_unederLine_c"),
                this.nbrs = [],
                this.lines = [],
                this.images.forEach(((t,i)=>{
                    const n = document.createElement("span")
                      , r = document.createElement("div");
                    n.classList.add("projects_case_nbr"),
                    r.classList.add("projects_case_underline"),
                    n.textContent = i + 1,
                    e.appendChild(n),
                    this.linesContainer.appendChild(r),
                    this.nbrs.push(n),
                    this.lines.push(r)
                }
                ))
            }
            createMedias() {
                this.store = Sn()(this.images, ((t,e)=>new Zm({
                    image: t,
                    scene: this.scene,
                    loader: this.loader,
                    geometry: this.geometry,
                    bullet: this.bullets[e],
                    title: this.titles[e],
                    description: this.descriptions[e],
                    nbr: this.nbrs[e],
                    line: this.lines[e],
                    index: e
                })))
            }
            hide(t) {
                this.out = !0,
                t >= 0 ? this.store.forEach((e=>e.onClick(t))) : this.store.forEach((t=>t.hide()))
            }
            onWheel(t) {
                this.wheel || this.stop || ($m += .4 * t * 3e-4,
                this.s.t += t)
            }
            setSizes(t) {}
            rs(t) {
                this.isRs = !0,
                t.w / t.h < 1.8 ? (bn.to(".projects_img", {
                    width: "80rem",
                    height: "45rem",
                    duration: 0,
                    delay: 0
                }),
                bn.to(".projects_images_c", {
                    left: "calc(50% - 40rem)",
                    top: "calc(50% - 22.5rem)",
                    duration: 0,
                    delay: 0
                })) : (bn.to(".projects_img", {
                    width: "120vh",
                    height: "65vh",
                    duration: 0,
                    delay: 0
                }),
                bn.to(".projects_images_c", {
                    left: "calc(50% - 60vh)",
                    top: "calc(50% - 32.5vh)",
                    duration: 0,
                    delay: 0
                })),
                this.store.forEach((t=>t.image.style.transform = "translate(0,0,0")),
                $m = 0,
                Jm.ps = 0,
                this.s.c = this.s.t = 0;
                const e = Pn(".projects_project_ref")
                  , i = Pn(".projTest")
                  , n = Ln(i).height;
                this.bulletContainer.style.height = (this.bullets.length + 1) * n / 1.5 + 10.5 * this.bullets.length + "px",
                this.bRef = Ln(e);
                const {width: r, height: s, left: a, top: o} = this.bRef
                  , h = Pn(".projects_descriptions_c");
                this.b = Ln(this.images[0]),
                this.wrapper = Ln(this.container).height,
                h.style.bottom = "auto",
                h.style.top = `calc(${Ln(this.images[0].parentElement).bottom}px + 2rem)`,
                this.store.forEach((e=>e.rs(t, this.wrapper, r, s, a, o))),
                setTimeout((()=>{
                    this.isRs = !1
                }
                ), 10)
            }
            onClick(t) {
                t === Km && (this.wheel = !0)
            }
            onEnter() {
                this.out || (this.stop = !0,
                this.store.forEach((t=>{
                    bn.to(t.material.uniforms.scale, {
                        value: .85
                    }),
                    bn.to(t.material.uniforms.hover, {
                        value: 1
                    }),
                    bn.to(t.material.uniforms.dc, {
                        value: 1
                    })
                }
                )),
                this.bullets.forEach(((t,e)=>{
                    bn.killTweensOf(t),
                    bn.to(t, {
                        scaleX: 3,
                        scaleY: 2.7
                    }),
                    0 !== e && bn.to(t, {
                        y: .6 * e + "rem"
                    })
                }
                )))
            }
            onLeave() {
                this.out || (setTimeout((()=>{
                    this.stop = !1
                }
                ), 250),
                this.bullets.forEach(((t,e)=>{
                    bn.killTweensOf(t),
                    e === this.index ? bn.to(t, {
                        scaleX: 1.5,
                        scaleY: 1,
                        y: 0
                    }) : bn.to(t, {
                        scaleX: 1,
                        scaleY: 1,
                        y: 0
                    })
                }
                )),
                this.store.forEach(((t,e)=>{
                    e !== this.index && bn.to(t.material.uniforms.dc, {
                        value: 0
                    }),
                    bn.to(t.material.uniforms.scale, {
                        value: 1
                    }),
                    bn.to(t.material.uniforms.hover, {
                        value: 0
                    })
                }
                )))
            }
            onBulletEnter(t) {
                if (!this.out && (this.index = t,
                t !== Km))
                    if (t > Km) {
                        const e = t - Km;
                        bn.to(Jm, {
                            ps: Math.round(Jm.ps + e)
                        })
                    } else {
                        const e = Km - t;
                        bn.to(Jm, {
                            ps: Math.round(Jm.ps - e)
                        })
                    }
            }
            update(t) {
                if (!this.b || !this.start)
                    return;
                if (this.isRs)
                    return;
                if (this.out)
                    return;
                this.s.c = bn.utils.interpolate(this.s.c, this.s.t, this.s.e);
                const e = this.descriptionsContainer
                  , {height: i} = this.b
                  , n = this.images.length;
                Jm.ps += $m;
                let r = Qm - Jm.ps;
                Qm = Jm.ps,
                $m *= .8,
                this.of = this.crt - $m;
                let s = Math.round(Jm.ps);
                Km = s,
                Km = Km < 0 ? Math.abs(s * (n - 1) % n) : s % n;
                let a = s - Jm.ps;
                if (!this.stop) {
                    let t = this.s.c - this.s.t;
                    ng = On(Math.abs(t), 300, 1500, 0, .25),
                    eg = bn.utils.interpolate(eg, ng, .075),
                    tg = eg * Math.sign(t),
                    Math.abs(t) < 5 ? e.style.opacity = 1 : e.style.opacity = 0
                }
                Jm.ps += Math.sign(a) * Math.pow(Math.abs(a), .7) * .015,
                ig = -1 === Math.sign(r) ? "l" : "r",
                this.store.forEach((e=>e.update(Jm.ps * (i + 25), ig, eg, Km, this.stop, tg, t)))
            }
            ael() {
                Wn(Bn, this.onEnter.bind(this), this.bulletsContainer),
                Wn(kn, this.onLeave.bind(this), this.bulletsContainer),
                this.bullets.forEach(((t,e)=>{
                    t.addEventListener("mouseenter", (t=>{
                        this.onBulletEnter(e)
                    }
                    ))
                }
                )),
                this.images.forEach(((t,e)=>{
                    t.addEventListener("click", (()=>{
                        this.onClick(e)
                    }
                    ))
                }
                ))
            }
            rel() {
                Vn(Bn, this.onEnter.bind(this), this.bulletsContainer),
                Vn(kn, this.onLeave.bind(this), this.bulletsContainer)
            }
            destroy(t) {
                this.rel(),
                this.store.forEach((e=>e.destroy(t)))
            }
        }
        class sg {
            constructor({el: t, scene: e, geometry: i, index: n, length: r}) {
                this.el = t,
                this.scene = e,
                this.geometry = i,
                this.nbr = n,
                this.length = r,
                this.s = 0,
                this.r1 = this.el.classList.contains("r1"),
                this.r2 = this.el.classList.contains("r2"),
                this.bn = this.el.classList.contains("img_banner"),
                this.createMesh()
            }
            hide() {
                bn.to(this.material.uniforms.a, {
                    value: 0,
                    duration: .5,
                    ease: "Expo.easeInout"
                })
            }
            createMesh() {
                const t = this.el.getAttribute("data-src")
                  , e = window.TEXTURES[t];
                this.el.classList.contains("para") && (this.para = !0);
                const i = e[0];
                this.uniforms = {
                    time: {
                        value: 0
                    },
                    tex: {
                        value: i
                    },
                    tex2: {
                        value: null
                    },
                    p: {
                        value: 0
                    },
                    r: {
                        value: 0 === this.nbr ? 40 : this.bn ? 0 : 25
                    },
                    a: {
                        value: 0
                    },
                    ud: {
                        value: 0
                    },
                    sc: {
                        value: 0 === this.nbr ? .5 : 1
                    },
                    ns: {
                        value: new po(e[1],e[2])
                    },
                    ns2: {
                        value: new po(0,0)
                    },
                    ps: {
                        value: new po
                    }
                },
                this.material = new Hl({
                    vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vec3 pos = position;\n\n  \n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}",
                    fragmentShader: "#define GLSLIFY 1\nuniform sampler2D tex;\nuniform float a;\nuniform float r;\nuniform float ud;\nuniform float sc;\nuniform vec2 ns;\nuniform vec2 ps;\n\nvarying vec2 vUv;\n\nvec2 gu(vec2 uv, vec2 ns, vec2 ps){\n    vec2 tu = uv - vec2(0.5);\n\n    float pa = ps.x/ps.y;\n    float ta = ns.x/ns.y;\n    if(pa<ta){\n        tu = tu*vec2(pa/ta,1.);\n    } else{\n        tu = tu*vec2(1.,ta/pa);\n    }\n\n    tu += vec2(0.5);\n    return tu;\n}\n\nfloat ub( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b+r,0.0))-r;\n}\n\nvoid main(){\n     vec2 hs = ps * 0.5;\n    float bd = ub((vUv * ps) - hs, hs, r);\n    bd = clamp(bd, 0.0, 1.);\n    vec4 br = vec4(0.,0.,0.,0.);\n    vec2 uv = gu(vUv, ns, ps);\n    uv -= 0.5;\n    uv *= sc;\n    uv += 0.5;\n    uv.y += ud;\n    vec4 t = texture2D(tex, uv);\n    gl_FragColor = mix(mix(t, br, bd), br, 1. - a);\n    // gl_FragColor.a = a;\n}",
                    uniforms: this.uniforms,
                    transparent: !0
                }),
                this.mesh = new Dl(this.geometry,this.material),
                this.scene.add(this.mesh)
            }
            cb() {
                this.b = Ln(this.el);
                const {top: t} = this.b;
                this.top = t + this.s,
                this.us()
            }
            us() {
                const {width: t, height: e} = this.b;
                this.mesh.scale.set(t, e, 1),
                this.material.uniforms.ps.value.x = t,
                this.material.uniforms.ps.value.y = e,
                this.ux(),
                this.uy()
            }
            rs(t) {
                this.v = t,
                this.cb()
            }
            ux() {
                const {left: t, width: e} = this.b
                  , {w: i} = this.v;
                this.mesh.position.x = t - i / 2 + e / 2
            }
            uy(t=0) {
                if (!this.b || !this.v)
                    return;
                const {height: e, top: i} = this.b
                  , {h: n} = this.v
                  , r = Gm(t, this.top, n, e);
                this.mesh.position.y = r
            }
            ai() {
                if (!this.para)
                    return;
                if (!this.b || !this.v)
                    return;
                const {h: t} = this.v
                  , {height: e} = this.b
                  , {y: i} = this.mesh.position;
                i < t / 2 + e / 2 && i > -t / 2 - e / 2 && (this.sc = i / (t / 2 + e / 2),
                this.dc = 1 - Math.abs(this.sc)),
                this.ud = On(this.sc, -1, 1, -.12, .12),
                this.material.uniforms.ud.value = this.ud
            }
            update(t) {
                this.b && this.v && (this.s = t,
                this.ai(),
                this.uy(t))
            }
        }
        class ag {
            constructor({el: t, scene: e, geometry: i, index: n, length: r}) {
                this.el = t,
                this.scene = e,
                this.geometry = i,
                this.img1 = Pn(".project_next_project_img", this.el),
                this.img2 = Pn(".project_next_next_project_img", this.el),
                this.s = 0,
                this.createMesh()
            }
            hide() {
                bn.to(this.material.uniforms.a, {
                    value: 0,
                    duration: .5,
                    ease: "Expo.easeInout"
                })
            }
            createMesh() {
                const t = this.img1.getAttribute("data-src")
                  , e = window.TEXTURES[t]
                  , i = this.img2.getAttribute("data-src")
                  , n = window.TEXTURES[i]
                  , r = e[0]
                  , s = n[0];
                this.uniforms = {
                    time: {
                        value: 0
                    },
                    tex: {
                        value: r
                    },
                    tex2: {
                        value: s
                    },
                    p: {
                        value: 0
                    },
                    p2: {
                        value: 0
                    },
                    fc: {
                        value: 1
                    },
                    a: {
                        value: 1
                    },
                    a1: {
                        value: 2
                    },
                    a2: {
                        value: 1
                    },
                    p1: {
                        value: 0
                    },
                    ns: {
                        value: new po(e[1],e[2])
                    },
                    ns2: {
                        value: new po(n[1],n[2])
                    },
                    ps: {
                        value: new po
                    },
                    ps1: {
                        value: new po
                    }
                },
                this.material = new Hl({
                    vertexShader: "#define GLSLIFY 1\nuniform float p;\nuniform float fc;\nuniform float a1;\nuniform float a2;\nuniform float p1;\n\nvarying vec2 vUv;\nvarying float forw;\n\nfloat eq(float x) {\nreturn x < 0.5 ? 8. * x * x * x * x : 1. - pow(-2. * x + 2., 4.) / 2.;\n}\n\nvoid main() {\n  vUv = uv;\n  vec2 ct = vec2(0.5);\n  vec3 aps = position;\n  float cp = min(2. * p, 2. * (1. - p));\n  float zl = abs(uv.y - p1);\n  float aa = uv.x + p1 * 0.5 * zl;\n  float ab = uv.y * 0.05;\n  float g = distance(vUv, ct);\n  float md = length(ct);\n  float nd = g / md;\n  float z = nd * 55.;\n  float c = -nd * 150.;\n  float fm = mix(c, z, p);\n  float dt = distance(vec2(aa, ab), vec2(a1 * 1., a2));\n  dt *= .35;\n  dt *= 0.3;\n  dt *= 4.5;\n  float tr = min(1., dt + 0.3);\n  float hl = eq(tr);\n  aps.z -= 190. * hl;\n  aps.z += 190.;\n  forw = hl;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( aps, 1.0 );\n}",
                    fragmentShader: "#define GLSLIFY 1\nuniform sampler2D tex;\nuniform sampler2D tex2;\nuniform float p;\nuniform float p2;\nuniform float a;\nuniform vec2 ns;\nuniform vec2 ns2;\nuniform vec2 ps;\nuniform vec2 ps1;\nuniform float p1;\n\nvarying vec2 vUv;\n\nfloat ub( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b+r,0.0))-r;\n}\n\nvec2 gu(vec2 uv, vec2 ns, vec2 ps){\n    vec2 tu = uv - vec2(0.5);\n\n    float pa = ps.x/ps.y;\n    float ta = ns.x/ns.y;\n    if(pa<ta){\n        tu = tu*vec2(pa/ta,1.);\n    } else{\n        tu = tu*vec2(1.,ta/pa);\n    }\n\n    tu += vec2(0.5);\n    return tu;\n}\n\nvoid main(){\n    vec2 hr = ps * 0.5;\n    float r = 40.;\n    float b = ub((vUv * ps) - hr, hr, r);\n    b = clamp(b, 0.0, 1.);\n    vec4 br = vec4(0.,0.,0.,0.);\n    vec2 uv = gu(vUv, mix(ns, ns2, p), mix(ps, ps1, p));\n    vec2 uv1 = gu(vUv, ns, mix(ps1, ps, p));\n    vec2 uv2 = gu(vUv, ns2, ps);\n    vec4 t = mix(mix(texture2D(tex, uv1),br, b), br, 1. - a);\n    vec4 t2 = mix(mix(texture2D(tex2, uv2), br, b), br, 1. - a);\n    float f = smoothstep(0.,1. - vUv.x, (vUv.y  + 1. - vUv.y * p1 * 1.) * p1);\n    gl_FragColor =  mix(t, t2, f);\n}",
                    uniforms: this.uniforms,
                    transparent: !0
                }),
                this.mesh = new Dl(this.geometry,this.material),
                this.scene.add(this.mesh)
            }
            cb() {
                this.b = Ln(Pn(".project_next_project_img"));
                const {top: t} = this.b;
                this.top = t + this.s,
                this.us()
            }
            us() {
                const {width: t, height: e} = this.b;
                this.mesh.scale.set(t, e, 1),
                this.material.uniforms.ps.value.x = t,
                this.material.uniforms.ps.value.y = e,
                this.material.uniforms.ps1.value.x = t,
                this.material.uniforms.ps1.value.y = e,
                this.ux(),
                this.uy()
            }
            onClick() {
                this.out = !0,
                this.mesh.name = "transition",
                bn.to(this.mesh.position, {
                    x: this.fX,
                    y: this.fY,
                    duration: 1.53,
                    delay: 0,
                    ease: "Power2.easeInOut"
                }),
                bn.to(this.mesh.scale, {
                    x: this.w,
                    y: this.h,
                    duration: 1.35,
                    delay: 0,
                    ease: "Power2.easeInOut"
                }),
                bn.to(this.material.uniforms.p1, {
                    value: 1,
                    duration: 1.755,
                    delay: .36,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.material.uniforms.a1, {
                    value: -1,
                    duration: 4.095,
                    delay: 0,
                    ease: "Power2.easeOut"
                }),
                bn.to(this.material.uniforms.a2, {
                    value: -.8,
                    duration: 4.095,
                    delay: 0,
                    ease: "Power2.easeOut"
                }),
                bn.to(this.material.uniforms.p, {
                    value: 1,
                    duration: 2.25,
                    delay: .2,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.material.uniforms.fc, {
                    value: -1.5,
                    duration: 2.79,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.material.uniforms.p2, {
                    value: 1,
                    delay: .225,
                    duration: 1.53,
                    ease: "Power1.easeInOut"
                }),
                bn.to(this.material.uniforms.ps.value, {
                    x: this.w,
                    y: this.h,
                    duration: 1.215,
                    delay: 0,
                    ease: "Power1.easeInOut"
                })
            }
            rs(t, e, i, n, r) {
                this.v = t,
                this.cb(),
                this.w = e,
                this.h = i,
                this.fX = n - t.w / 2 + e / 2,
                this.fY = -r + t.h / 2 - i / 2
            }
            ux() {
                const {left: t, width: e} = this.b
                  , {w: i} = this.v;
                this.mesh.position.x = t - i / 2 + e / 2
            }
            uy(t=0) {
                if (!this.b || !this.v)
                    return;
                const {height: e, top: i} = this.b
                  , {h: n} = this.v;
                this.mesh.position.y = t - this.top + n / 2 - e / 2
            }
            update(t) {
                this.s = t,
                this.out || this.uy(t)
            }
            destroy() {
                this.scene.remove(this.mesh)
            }
        }
        class og {
            constructor({el: t}) {
                this.el = t,
                this.text = Pn(".sticky_text", this.el),
                this.s = 0
            }
            rs() {
                this.b = Ln(this.el),
                this.hB = Ln(Pn("header")).height;
                const {top: t, bottom: e} = this.b;
                this.t = t + this.s,
                this.bt = e + this.s,
                this.th = Ln(this.text).height
            }
            update(t) {
                this.s = t,
                this.t - t - this.hB - 75 < 0 && this.bt - t - 1.5 * this.th - 75 > 0 ? this.text.style.transform = `translateY(${t - this.t + this.hB + 75}px)` : this.t - t - this.hB - 75 > 0 && (this.text.style.transform = "translateY(0px)")
            }
        }
        class hg {
            constructor({el: t}) {
                this.el = t,
                this.mouse = {
                    x: {
                        current: 0,
                        target: 0,
                        ease: .12
                    },
                    y: {
                        current: 0,
                        target: 0,
                        ease: .12
                    }
                }
            }
            onMove(t) {
                this.mouse.x.target = t.pageX,
                this.mouse.y.target = t.pageY
            }
            update() {
                this.mouse.y.current += (this.mouse.y.target - this.mouse.y.current) * this.mouse.y.ease,
                this.mouse.x.current += (this.mouse.x.target - this.mouse.x.current) * this.mouse.x.ease,
                this.el.style.transform = `translate(${this.mouse.x.current}px, ${this.mouse.y.current}px)`
            }
        }
        class lg {
            constructor({el: t, scene: e, geometry: i, index: n}) {
                this.el = t,
                this.scene = e,
                this.geometry = i,
                this.index = n,
                this.s = 0,
                this.createMesh()
            }
            hide() {
                bn.to(this.material.uniforms.a, {
                    value: 0,
                    duration: .3,
                    ease: "Expo.easeInout"
                })
            }
            createMesh() {
                const t = this.el.getAttribute("data-src")
                  , e = window.TEXTURES[t]
                  , i = e[0];
                this.el.classList.contains("para") && (this.para = !0),
                this.uniforms = {
                    time: {
                        value: 0
                    },
                    tex: {
                        value: i
                    },
                    tex2: {
                        value: null
                    },
                    p: {
                        value: 0
                    },
                    r: {
                        value: 0 === this.nbr ? 55 : 25
                    },
                    a: {
                        value: 1
                    },
                    s: {
                        value: 0
                    },
                    ud: {
                        value: 0
                    },
                    bd: {
                        value: 0
                    },
                    ns: {
                        value: new po(e[1],e[2])
                    },
                    ns2: {
                        value: new po(0,0)
                    },
                    ps: {
                        value: new po
                    }
                },
                this.material = new Hl({
                    vertexShader: "#define GLSLIFY 1\nuniform float bd;\n\nvarying vec2 vUv;\n\nvoid main() {\n  float pi = 3.14159265359;\n  vUv = uv;\n  vec3 pos = position;\n  pos.x -= .25 * sin(uv.y * pi + 0.25) * (bd * .5);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}",
                    fragmentShader: "#define GLSLIFY 1\nuniform sampler2D tex;\nuniform float a;\nuniform float r;\nuniform float s;\nuniform float ud;\nuniform float bd;\nuniform vec2 ns;\nuniform vec2 ps;\n\nvarying vec2 vUv;\n\nvec2 gu(vec2 uv, vec2 ns, vec2 ps){\n    vec2 tu = uv - vec2(0.5);\n\n    float pa = ps.x/ps.y;\n    float ta = ns.x/ns.y;\n    if(pa<ta){\n        tu = tu*vec2(pa/ta,1.);\n    } else{\n        tu = tu*vec2(1.,ta/pa);\n    }\n\n    tu += vec2(0.5);\n    return tu;\n}\n\nfloat udRoundBox( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b+r,0.0))-r;\n}\n\nvoid main(){\n    vec2 halfRes = ps * 0.5;\n    float border = udRoundBox((vUv * ps) - halfRes, halfRes, r);\n    border = clamp(border, 0.0, 1.);\n    vec4 br = vec4(0.,0.,0.,0.);\n    vec2 uv = gu(vUv, ns, ps);\n    uv -= 0.5;\n    uv *= 1. - (0.1 * 1.);\n    uv += 0.5;\n    uv.x += ud * 1.35;\n    vec4 t = texture2D(tex, uv);\n    gl_FragColor = mix(mix(t, br, border), br, 1. - a);\n}",
                    uniforms: this.uniforms,
                    transparent: !0
                }),
                this.mesh = new Dl(this.geometry,this.material),
                this.scene.add(this.mesh)
            }
            onDown() {
                bn.to(this.material.uniforms.s, {
                    value: 1
                })
            }
            onUp() {
                bn.to(this.material.uniforms.s, {
                    value: 0
                })
            }
            cb() {
                this.b = Ln(this.el);
                const {top: t} = this.b;
                this.top = t + this.s,
                this.us()
            }
            us() {
                const {width: t, height: e} = this.b;
                this.mesh.scale.set(t, e, 1),
                this.material.uniforms.ps.value.x = t,
                this.material.uniforms.ps.value.y = e,
                this.uy(),
                this.ux()
            }
            rs(t, e) {
                this.v = t,
                this.el.style.transform = "translateX(0)",
                this.cb(),
                this.c = e;
                const {left: i, right: n, width: r} = this.b;
                this.ct = 0,
                this.dt = 0,
                this.s = 0,
                this.left = r + i,
                this.right = n - r - t.w
            }
            ux(t=0) {
                if (!this.b || !this.v)
                    return;
                const {left: e, width: i} = this.b
                  , {w: n} = this.v;
                this.mesh.position.x = -t + e - n / 2 + i / 2
            }
            uy(t=0) {
                if (!this.b || !this.v)
                    return;
                const {height: e, top: i} = this.b
                  , {h: n} = this.v;
                this.mesh.position.y = t - this.top + n / 2 - e / 2
            }
            ai() {
                if (!this.b || !this.v)
                    return;
                const {w: t} = this.v
                  , {width: e} = this.b
                  , {x: i} = this.mesh.position;
                i < t / 2 + e / 2 && i > -t / 2 - e / 2 && (this.sc = i / (t / 2 + e / 2),
                this.dc = 1 - Math.abs(this.sc)),
                this.ud = On(this.sc, -1, 1, -.16, .16),
                this.material.uniforms.ud.value = this.ud
            }
            update(t, e, i, n) {
                this.s = t,
                this.material.uniforms.bd.value = n,
                this.dr = e - this.dt,
                "l" === i && this.left - this.dr < 0 && (this.ct += 1,
                this.dt = this.c * this.ct),
                "r" === i && this.right - this.dr > 0 && (this.ct -= 1,
                this.dt = this.c * this.ct),
                this.ai(),
                this.uy(t),
                this.ux(this.dr)
            }
        }
        class cg {
            constructor({scene: t, loader: e, geometry: i, camera: n, line: r}) {
                this.scene = t,
                this.loader = e,
                this.geometry = i,
                this.camera = n,
                this.line = r,
                this.raycaster = new bm,
                this.mouse = new po,
                this.group = new id,
                this.scene.add(this.group),
                this.textRef = Pn(".project_mobile_scroll_text"),
                this.nextType = Pn(".project_next_project_type p "),
                this.scroll = 0,
                this.drag = {
                    current: 0,
                    target: 0,
                    ease: .075
                },
                this.si = "l",
                this.intro(),
                this.createSlideShow(),
                this.createMedias(),
                this.createStick(),
                this.createT(),
                this.createCl(),
                this.destroyTransitionnedMesh(),
                this.createLines(),
                this.ael()
            }
            intro() {}
            createStick() {
                const t = [...Cn(".project_row_stick")];
                1 === t.length ? this.stick = new og({
                    el: t[0]
                }) : t.length > 1 && (this.sticks = Sn()(t, (t=>new og({
                    el: t
                }))))
            }
            createCl() {
                const t = [...Cn(".project_next_case_c .circAn")];
                this.projectCl = Sn()(t, (t=>new ir({
                    el: t
                })))
            }
            nextReveal() {
                this.projectCl.forEach((t=>t.go())),
                this.nextType && bn.to(this.nextType, {
                    y: 0,
                    duration: 1.5,
                    delay: .45,
                    ease: "Expo.easeOut"
                }),
                bn.to(".project_next_project_label span", {
                    y: 0,
                    duration: 1.5,
                    delay: .2,
                    ease: "Expo.easeOut"
                }),
                bn.to(".next2 span", {
                    y: "-100%",
                    duration: 1.5,
                    stagger: .04,
                    delay: .2,
                    ease: "Expo.easeOut"
                }),
                bn.to(".next1 span", {
                    y: "0",
                    duration: 1.5,
                    stagger: .04,
                    delay: .2,
                    ease: "Expo.easeOut"
                }),
                bn.to(".project_next_case_c .home_featured_btn_text.innerArrow.btn_inner_text p", {
                    opacity: 1,
                    delay: 1,
                    duration: .5
                })
            }
            hide(t) {
                this.lineAnim.forEach((t=>t.hide())),
                this.slideStore && this.slideStore.forEach((t=>t.hide())),
                t > 0 ? (this.tr.onClick(),
                this.store.forEach((t=>t.hide()))) : (this.store.forEach((t=>t.hide())),
                this.tr.hide(),
                this.toRemove = !0)
            }
            createLines() {
                const t = [...Cn(".glLineP")];
                this.lineAnim = Sn()(t, (t=>new jm({
                    el: t,
                    geometry: this.geometry,
                    loader: this.loader,
                    scene: this.group
                })))
            }
            destroyTransitionnedMesh() {
                const t = this.scene.getObjectByName("transition");
                void 0 !== t ? setTimeout((()=>{
                    this.scene.remove(t),
                    this.store.forEach((t=>{
                        t.material.uniforms.a.value = 1
                    }
                    )),
                    this.store[0].material.uniforms.sc.value = 1,
                    bn.to(".project_hero_img", {
                        autoAlpha: 1,
                        delay: 0,
                        duration: 0
                    })
                }
                ), 400) : (this.store.forEach((t=>{
                    bn.to(t.material.uniforms.a, {
                        value: 1,
                        delay: .65,
                        duration: 1,
                        ease: "Power2.easeOut"
                    })
                }
                )),
                bn.to(this.store[0].material.uniforms.sc, {
                    value: 1,
                    duration: 1.5,
                    delay: 0,
                    ease: "Power2.easeOut"
                }))
            }
            createT() {
                const t = Pn(".project_next_case");
                this.tr = new ag({
                    el: t,
                    scene: this.scene,
                    geometry: this.geometry
                })
            }
            createMedias() {
                this.images = [...Cn(".project_gl")],
                this.store = Sn()(this.images, ((t,e)=>new sg({
                    el: t,
                    scene: this.group,
                    geometry: this.geometry,
                    index: e,
                    length: this.images.length
                })))
            }
            createSlideShow() {
                if (this.slideC = Pn(".project_row_slideshow"),
                this.slideC) {
                    this.createCursor(),
                    this.dragZone = this.slideC.parentElement;
                    const t = [...Cn(".project_row_slideshow_media img")];
                    this.slideStore = Sn()(t, ((t,e)=>new lg({
                        el: t,
                        scene: this.group,
                        geometry: this.geometry,
                        index: e
                    })))
                }
            }
            createCursor() {
                const t = Pn(".project_drag_cs_cvs.circAn")
                  , e = Pn(".project_drag_cs");
                this.arrL = Pn(" .project_drag_cs_trl"),
                this.arrR = Pn(" .project_drag_cs_trd"),
                this.cursorCl = new ir({
                    el: t
                }),
                this.cursor = new hg({
                    el: e
                })
            }
            challengeRv() {
                bn.to(".project_description span span", {
                    y: 0,
                    stagger: .08,
                    duration: 1.8,
                    delay: .3,
                    ease: "Expo.easeOut"
                }),
                bn.to(".project_description_title_rv", {
                    y: 0,
                    duration: .5,
                    delay: .6,
                    stagger: .1,
                    ease: "Expo.easeOut"
                }),
                bn.to(".project_description_header_rv", {
                    y: 0,
                    duration: .8,
                    delay: .4,
                    ease: "Expo.easeOut"
                })
            }
            indexReveal() {
                bn.to(".project_hero_roles_title span", {
                    y: 0,
                    delay: .38,
                    duration: .1,
                    ease: "Power3.easeOut"
                }),
                bn.to(".project_hero_roles span span", {
                    y: 0,
                    stagger: .08,
                    delay: .4,
                    duration: 1,
                    ease: "Expo.easeOut"
                }),
                this.cta && (bn.to(".project_view_cta rect", {
                    strokeDashoffset: 0,
                    duration: 1,
                    ease: "Expo.easeInOut"
                }),
                bn.to(".project_view_cta_text p", {
                    y: 0,
                    duration: .5,
                    delay: .8
                }),
                bn.to(".project_view_cta_arrow", {
                    y: 0,
                    x: 0,
                    opacity: 1,
                    duration: .5,
                    delay: .8,
                    ease: "Power2.easeInOut"
                }))
            }
            onEnter() {}
            onSLiderEnter() {
                this.in || (this.in = !0,
                this.cursorCl.gocl(),
                bn.to([this.arrL, this.arrR], {
                    x: 0,
                    opacity: 1
                }))
            }
            onDown(t) {
                this.isDown = !0,
                t.preventDefault(),
                bn.to(this.arrL, {
                    x: "3.5rem"
                }),
                bn.to(this.arrR, {
                    x: "-3.5rem"
                }),
                this.slideStore.forEach((t=>t.onDown())),
                this.cursorCl.scd(),
                this.posX = t.clientX
            }
            onMove(t) {
                if (!this.v)
                    return;
                this.isDown && (t.preventDefault(),
                this.distanceX = this.posX - t.clientX,
                this.posX = t.clientX,
                this.drag.target += 2.3 * this.distanceX),
                this.cursor && this.cursor.onMove(t);
                const {w: e, h: i} = this.v;
                this.mouse.x = t.clientX / e * 2 - 1,
                this.mouse.y = -t.clientY / i * 2 + 1,
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const n = this.raycaster.intersectObjects(this.group.children);
                if (n.length > 0) {
                    const t = n[0].object;
                    if (!t.material.uniforms.hl)
                        return;
                    bn.to(t.material.uniforms.hl.value, {
                        y: n[0].uv.y
                    }),
                    bn.to(t.material.uniforms.hl.value, {
                        x: n[0].uv.x
                    }),
                    n[0].uv.y > .5 ? bn.to(t.material.uniforms.b, {
                        value: -1.5,
                        ease: "Expo.easeOut",
                        duration: 1.2
                    }) : bn.to(t.material.uniforms.b, {
                        value: 1.5,
                        ease: "Expo.easeOut",
                        duration: 1.2
                    })
                }
            }
            onUp() {
                this.isDown = !1,
                this.cursorCl.scu(),
                bn.to([this.arrL, this.arrR], {
                    x: 0
                }),
                this.slideStore.forEach((t=>t.onUp()))
            }
            onSLiderLeave() {
                this.in && (this.in = !1,
                this.cursorCl.ungo(),
                bn.to([this.arrL, this.arrR], {
                    opacity: 0
                }),
                bn.to(this.arrL, {
                    x: "-2rem"
                }),
                bn.to(this.arrR, {
                    x: "2rem"
                }))
            }
            onWheel(t) {}
            rs(t, e, i, n, r) {
                this.v = t,
                this.store.forEach((e=>e.rs(t))),
                this.isRs = !0,
                this.cursorCl && this.cursorCl.rs(),
                this.textRef && (this.textRef.style.transform = "translateY(0px)"),
                this.lineAnim.forEach((e=>e.rs(t))),
                this.nextT = Ln(Pn(".project_next_case")).top,
                this.trigger = this.nextT - t.h / 2,
                this.projectCl.forEach((t=>t.rs())),
                this.rolesB = Ln(Pn(".project_hero_roles")).top + this.scroll,
                this.challengeB = Ln(Pn(".project_description_challenge")).top + this.scroll,
                this.stick && this.stick.rs(),
                this.sticks && this.sticks.forEach((t=>t.rs()));
                const s = Pn(".projects_project_ref");
                this.bRef = Ln(s);
                const {width: a, height: o, left: h, top: l} = this.bRef;
                if (this.slideC) {
                    this.cf = Ln(Pn(".project_cf")).width,
                    this.c = Ln(this.slideC).width,
                    this.sliderB = Ln(this.slideC);
                    const {bottom: e, top: i} = this.sliderB;
                    this.top = i + this.scroll,
                    this.bottom = e + this.scroll,
                    this.slideStore.forEach((e=>e.rs(t, this.c)))
                }
                this.tr.rs(t, a, o, h, l),
                this.isRs = !1
            }
            update(t, e) {
                if (!this.isRs) {
                    if (this.stick && this.stick.update(t),
                    this.sticks && this.sticks.forEach((e=>e.update(t))),
                    this.scroll = t,
                    this.played || (this.rolesB - this.scroll) / window.innerHeight < .85 && (this.played = !0,
                    this.indexReveal()),
                    this.challengePlayed || (this.challengeB - this.scroll) / window.innerHeight < .85 && (this.challengePlayed = !0,
                    this.challengeRv()),
                    this.nextPlayed || this.trigger - t <= 0 && (this.nextPlayed = !0,
                    this.nextReveal()),
                    this.cursorCl && (this.cursorCl.update(),
                    this.cursor.update()),
                    this.lineAnim.forEach((e=>e.update(t))),
                    this.store.forEach((e=>e.update(t))),
                    this.slideC) {
                        this.top - t - this.cursor.mouse.y.current < 0 && this.bottom - t - this.cursor.mouse.y.current > 0 ? this.onSLiderEnter() : this.onSLiderLeave(),
                        this.drag.current = bn.utils.interpolate(this.drag.current, this.drag.target, this.drag.ease),
                        this.drag.target > this.drag.current ? this.si = "l" : this.si = "r";
                        let e = this.drag.target - this.drag.current
                          , i = On(e, -600, 600, -.4, .4);
                        this.slideStore.forEach((e=>e.update(t, this.drag.current, this.si, i)))
                    }
                    this.tr.update(t),
                    this.projectCl.forEach((t=>t.update()))
                }
            }
            ael() {
                this.cta = Pn(".project_view_cta"),
                this.cta && Wn(Bn, this.onEnter.bind(this), this.cta),
                this.slideC && (Wn(In, this.onDown.bind(this), this.dragZone),
                Wn(Nn, this.onUp.bind(this), document.documentElement),
                Wn(kn, this.onUp.bind(this), this.dragZone),
                Wn(Gn, this.onUp.bind(this), document.documentElement))
            }
            rel() {
                this.cta && Vn(Bn, this.onEnter.bind(this), this.cta),
                this.slideC && (Vn(In, this.onDown.bind(this), this.dragZone),
                Vn(Nn, this.onUp.bind(this), document.documentElement),
                Vn(kn, this.onUp.bind(this), this.dragZone),
                Vn(Gn, this.onUp.bind(this), document.documentElement))
            }
            destroy() {
                this.rel(),
                this.scene.remove(this.group),
                this.toRemove && this.tr.destroy()
            }
        }
        class ug {
            constructor({fc: t, r: e}) {
                this.fc = t,
                this.r = e,
                this.intro()
            }
            intro() {
                const t = [...Cn(".about_contact .circAn")];
                this.contactCl = Sn()(t, (t=>new ir({
                    el: t
                }))),
                bn.to(this.fc, {
                    value: .115,
                    duration: 1.5,
                    ease: "Power3.easeInOut",
                    delay: .2
                }),
                bn.to(this.r, {
                    value: 40,
                    duration: 1.5,
                    ease: "Power3.easeInOut",
                    delay: .2
                }),
                this.contactCl.forEach((t=>t.go())),
                bn.to(".contact .about_contact", {
                    opacity: 1,
                    delay: .5
                }),
                bn.to(".footer_c", {
                    y: "-100%",
                    duration: 1.5,
                    stagger: .04,
                    delay: .5,
                    ease: "Expo.easeOut"
                }),
                bn.to(".home_contact_title_el1 span", {
                    y: "-100%",
                    duration: 1.5,
                    stagger: .04,
                    delay: .5,
                    ease: "Expo.easeOut"
                }),
                bn.to(".home_contact_title_el2 span", {
                    y: "0",
                    duration: 1.5,
                    stagger: .04,
                    delay: .5,
                    ease: "Expo.easeOut"
                }),
                bn.to(".home_contact_mail span", {
                    y: 0,
                    duration: 1.5,
                    delay: .5,
                    ease: "Expo.easeOut"
                }),
                bn.to(".home_contact .btn_inner_text p", {
                    opacity: 1,
                    delay: 1,
                    duration: .8
                })
            }
            rs() {
                this.contactCl.forEach((t=>t.rs()))
            }
            update() {
                this.contactCl.forEach((t=>t.update()))
            }
        }
        class dg {
            constructor() {
                this.cursor = Pn(".cursor"),
                this.mouse = {
                    x: 0,
                    y: 0
                },
                this.ael()
            }
            onDown() {
                bn.killTweensOf(".cursor_top"),
                bn.killTweensOf(".cursor_bottom"),
                bn.killTweensOf(".cursor_left"),
                bn.killTweensOf(".cursor_right"),
                bn.to(".cursor_top", {
                    y: "0.4rem",
                    ease: "Power2.easeOut"
                }),
                bn.to(".cursor_bottom", {
                    y: "-0.4rem",
                    ease: "Power2.easeOut"
                }),
                bn.to(".cursor_right", {
                    x: "-0.4rem",
                    ease: "Power2.easeOut"
                }),
                bn.to(".cursor_left", {
                    x: "0.4rem",
                    ease: "Power2.easeOut"
                })
            }
            onUp() {
                bn.killTweensOf(".cursor_top"),
                bn.killTweensOf(".cursor_bottom"),
                bn.killTweensOf(".cursor_left"),
                bn.killTweensOf(".cursor_right"),
                bn.to(".cursor_top", {
                    y: "0",
                    ease: "Power2.easeOut"
                }),
                bn.to(".cursor_bottom", {
                    y: "-0",
                    ease: "Power2.easeOut"
                }),
                bn.to(".cursor_right", {
                    x: "-0",
                    ease: "Power2.easeOut"
                }),
                bn.to(".cursor_left", {
                    x: "0",
                    ease: "Power2.easeOut"
                })
            }
            onMove(t) {
                this.mouse.x = t.pageX,
                this.mouse.y = t.pageY
            }
            update() {
                this.cursor.style.transform = `translate(${this.mouse.x}px, ${this.mouse.y}px)`
            }
            ael() {
                Wn("pointerdown", this.onDown.bind(this)),
                Wn(Gn, this.onUp.bind(this))
            }
        }
        class pg extends (Um()) {
            constructor({template: t, data: e}) {
                super(),
                this.template = t,
                this.data = e,
                this.dispScene = new ld,
                this.scene = new ld,
                this.container = document.getElementById("gl"),
                this.width = this.container.offsetWidth,
                this.height = this.container.offsetHeight,
                this.renderer = new ad({
                    alpha: !0,
                    antialias: !0
                }),
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
                this.renderer.setSize(this.width, this.height),
                this.container.appendChild(this.renderer.domElement),
                this.camera = new Gl(70,window.innerWidth / window.innerHeight,100,2e3),
                this.camera.position.set(0, 0, 600),
                this.manager = new of,
                this.loader = new gf(this.manager),
                this.time = 0,
                this.mouse = new po,
                this.prevMouse = new po,
                this.total = 100,
                this.currentSmoke = 0,
                this.s = 0,
                this.renderTex = new bo(this.width,this.height,{
                    minFilter: Ss,
                    magFilter: Ss,
                    format: Gs
                }),
                this.navAbout = Pn(".nav_about"),
                this.navProjects = Pn(".nav_projects"),
                this.navInnerP = Pn(".link_inner", this.navProjects),
                this.navOuterP = Pn(".link_outer", this.navProjects),
                this.navHoverP = Pn(".cta_hover", this.navProjects),
                this.navInnerA = Pn(".link_inner", this.navAbout),
                this.navOuterA = Pn(".link_outer", this.navAbout),
                this.navHoverA = Pn(".cta_hover", this.navAbout),
                this.createPreloader(),
                this.createGeometry(),
                this.createCursor(),
                this.addBg()
            }
            createPreloader() {
                this.preloader = new Hm({
                    loader: this.loader,
                    manager: this.manager,
                    data: this.data
                }),
                this.preloader.once("completed", (()=>{
                    this.emit("rs"),
                    this.destroyPreloader(),
                    this.addSmoke()
                }
                ))
            }
            destroyPreloader() {
                setTimeout((()=>{
                    this.intro(),
                    setTimeout((()=>{
                        this.onChangeEnd(this.template, null, !0),
                        this.rs(),
                        this.emit("scroll")
                    }
                    ), 1300)
                }
                ), 250)
            }
            intro() {
                const t = Pn(".preloader")
                  , e = Pn(".it_bg");
                bn.to(".preloader--v1", {
                    y: "-100%",
                    stagger: .025,
                    duration: 1,
                    delay: .25,
                    ease: "Expo.easeOut"
                }),
                bn.to(".preloader--v2", {
                    y: "0",
                    stagger: .025,
                    duration: 1,
                    delay: .35,
                    ease: "Expo.easeOut"
                }),
                bn.to(".preloader p span", {
                    y: "-100%",
                    delay: .4,
                    duration: 1,
                    ease: "Expo.easeOut"
                }),
                bn.to(".preloader_i--k", {
                    x: "11.5rem",
                    delay: 1,
                    duration: .67,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_fl_c", {
                    x: "42.5rem",
                    delay: 1,
                    duration: .67,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_i--p", {
                    x: "-43.5rem",
                    delay: 1,
                    duration: .67,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_i--k", {
                    opacity: "0",
                    delay: 1.61,
                    duration: .1,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_fl_c", {
                    opacity: "0",
                    delay: 1.61,
                    duration: .1,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_i--p", {
                    opacity: "0",
                    delay: 1.61,
                    duration: .1,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_ll_c", {
                    scale: "1.4",
                    delay: 1.48,
                    duration: .5,
                    ease: "Expo.easeInOut"
                }),
                bn.to(".preloader_fl_c", {
                    scale: "1.4",
                    delay: 1.48,
                    duration: .5,
                    ease: "Expo.easeInOut"
                }),
                bn.to(".preloader_bg", {
                    opacity: 0,
                    delay: .2,
                    duration: 0
                }),
                bn.to(".preloader--v1", {
                    y: "-100%",
                    stagger: .025,
                    duration: 1,
                    delay: .25,
                    ease: "Expo.easeOut"
                }),
                bn.to(".preloader--v2", {
                    y: "0",
                    stagger: .025,
                    duration: 1,
                    delay: .35,
                    ease: "Expo.easeOut"
                }),
                bn.to(".preloader_i--k", {
                    x: "11.5rem",
                    delay: 1,
                    duration: .67,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_fl_c", {
                    x: "42.5rem",
                    delay: 1,
                    duration: .67,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_i--p", {
                    x: "-48.5rem",
                    delay: 1,
                    duration: .67,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_i--k", {
                    opacity: "0",
                    delay: 1.61,
                    duration: .1,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_fl_c", {
                    opacity: "0",
                    delay: 1.61,
                    duration: .1,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_i--p", {
                    opacity: "0",
                    delay: 1.61,
                    duration: .1,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_ll_c", {
                    scale: "1.4",
                    delay: 1.48,
                    duration: .5,
                    ease: "Expo.easeInOut"
                }),
                bn.to(".preloader_fl_c", {
                    scale: "1.4",
                    delay: 1.48,
                    duration: .5,
                    ease: "Expo.easeInOut"
                }),
                bn.to(".preloader_bg", {
                    opacity: 0,
                    delay: 1,
                    duration: 0
                }),
                bn.to(".preloader p span", {
                    y: "-100%",
                    delay: 1.4,
                    duration: .6,
                    ease: "Power3.easeOut",
                    onComplete: ()=>{
                        t.parentElement.removeChild(t)
                    }
                }),
                setTimeout((()=>{
                    e.parentElement.removeChild(e)
                }
                ), 2600),
                bn.to(this.material.uniforms.t, {
                    value: 1,
                    delay: 1.2,
                    duration: 1.9
                }),
                bn.to(this.material.uniforms.t2, {
                    value: 1,
                    delay: 1.2,
                    duration: 1.99
                })
            }
            createGeometry() {
                this.geometry = new tc(1,1,30,30)
            }
            createHome(t) {
                this.home = new Xm({
                    scene: this.scene,
                    loader: this.loader,
                    geometry: this.geometry,
                    camera: this.camera,
                    first: t
                })
            }
            destroyHome() {
                this.home && (this.home.destroy(),
                this.home = null)
            }
            createAbout(t) {
                this.about = new Ym({
                    scene: this.scene,
                    loader: this.loader,
                    geometry: this.geometry,
                    camera: this.camera,
                    first: t
                })
            }
            destroyAbout() {
                this.about && (this.about.destroy(),
                this.about = null)
            }
            createContact(t) {
                this.contact = new ug({
                    fc: this.material.uniforms.fc,
                    r: this.material.uniforms.r
                })
            }
            destroyContact() {
                this.contact && (this.contact = null)
            }
            createpProjects(t) {
                this.projects = new rg({
                    scene: this.scene,
                    loader: this.loader,
                    geometry: this.geometry,
                    first: t
                })
            }
            destroypProjects(t) {
                this.projects && (this.projects.destroy(t),
                this.projects = null)
            }
            createpProject() {
                this.project = new cg({
                    scene: this.scene,
                    loader: this.loader,
                    geometry: this.geometry,
                    camera: this.camera
                })
            }
            destroypProject() {
                this.project && (this.project.destroy(),
                this.project = null)
            }
            onChangeEnd(t, e=null, i) {
                this.stopBord = !1,
                this.s = 0,
                "home" === t ? this.createHome(i) : this.destroyHome(),
                "contact" === t ? this.createContact() : this.destroyContact(),
                "about" === t ? this.createAbout(i) : this.destroyAbout(),
                "projects" === t ? this.createpProjects() : this.destroypProjects(e),
                "project" === t ? (this.nexProj && this.destroypProject(),
                this.createpProject()) : this.destroypProject(e)
            }
            transIn() {
                return this.material.uniforms.st.value = 0,
                bn.to(this.material.uniforms.pt, {
                    value: 1,
                    duration: 1.2,
                    ease: "Power3.easeInOut"
                }),
                bn.to("header", {
                    y: "-100%",
                    scale: .9,
                    duration: 1.2,
                    onComplete: ()=>this.material.uniforms.st.value = 1,
                    ease: "Power3.easeInOut"
                }),
                new Promise((t=>{
                    bn.to("header", {
                        opacity: 1,
                        duration: .98,
                        onComplete: t,
                        ease: "Power3.easeInOut"
                    })
                }
                ))
            }
            transOut() {
                const t = window.location.pathname;
                return t.indexOf("projects") > -1 ? (this.navProjects.style.border = "1px solid rgba(255,255,255,0.3)",
                this.navAbout.style.border = "1px solid rgba(255,255,255,0)",
                this.navInnerP.style.transform = "translateY(-100%)",
                this.navOuterP.style.transform = "translateY(0)",
                this.navHoverP.style.transform = "scale(0) translateY(75%)") : t.indexOf("about") > -1 ? (this.navAbout.style.border = "1px solid rgba(255,255,255,0.3)",
                this.navProjects.style.border = "1px solid rgba(255,255,255,0)",
                this.navInnerA.style.transform = "translateY(-100%)",
                this.navOuterA.style.transform = "translateY(0)",
                this.navHoverA.style.transform = "scale(0) translateY(75%)") : (this.navAbout.style.border = "1px solid rgba(255,255,255,0)",
                this.navProjects.style.border = "1px solid rgba(255,255,255,0)"),
                this.material.uniforms.st.value = 1,
                bn.to("header", {
                    y: 0,
                    scale: 1,
                    duration: 1.2,
                    onComplete: ()=>this.material.uniforms.st.value = 0,
                    ease: "Power3.easeInOut"
                }),
                bn.to(this.material.uniforms.pt, {
                    value: 0,
                    duration: 1.2,
                    ease: "Power3.easeInOut"
                }),
                new Promise((t=>{
                    bn.to("header", {
                        opacity: 1,
                        duration: .7,
                        onComplete: t,
                        ease: "Power2.easeInOut"
                    })
                }
                ))
            }
            resetUrl() {
                bn.to(this.navProjects, {
                    border: "1px solid rgba(255,255,255,0)",
                    duration: .3,
                    ease: "Power2.easeOut"
                })
            }
            onChangeStart(t=null) {
                this.stopBord = !0,
                bn.to(this.material.uniforms.fc, {
                    value: 0,
                    ease: "Power1.easeOut"
                }),
                bn.to(this.material.uniforms.r, {
                    value: 0,
                    ease: "Power1.easeOut"
                }),
                this.home && this.home.hide(),
                this.about && this.about.hide(),
                this.projects && this.projects.hide(t),
                this.project && this.project.hide(t),
                this.project ? this.nexProj = !0 : this.nexProj = !1
            }
            createCursor() {
                this.cursor = new dg
            }
            addSmoke() {
                this.smoke = !0;
                const t = this.data.data.media
                  , e = window.TEXTURES[t][0]
                  , i = new lp(55,57);
                this.dispM = [];
                for (let t = 0; t < this.total; t++) {
                    let t = new Dl(i,new Xh({
                        map: e,
                        transparent: !0,
                        blending: Rr,
                        depthTest: !1,
                        depthWrite: !1
                    }));
                    t.visible = !1,
                    this.dispM.push(t),
                    this.dispScene.add(t)
                }
            }
            addBg() {
                this.material = new Hl({
                    extensions: {
                        derivatives: "#extension GL_OES_standard_derivatives : enable"
                    },
                    uniforms: {
                        time: {
                            value: 0
                        },
                        tex: {
                            value: null
                        },
                        t: {
                            value: 0
                        },
                        t2: {
                            value: 0
                        },
                        pt: {
                            value: 0
                        },
                        st: {
                            value: 0
                        },
                        ps: {
                            value: new po(window.innerWidth,window.innerHeight)
                        },
                        r: {
                            value: 0
                        },
                        fc: {
                            value: 0
                        },
                        vc1: {
                            value: new po(.5,.5)
                        },
                        vc2: {
                            value: new po(0,1)
                        },
                        vc3: {
                            value: new po(1,0)
                        },
                        c1: {
                            value: new _o(0,0,0,1)
                        },
                        c2: {
                            value: new _o(.3,.3,.3,.95)
                        }
                    },
                    transparent: !0,
                    vertexShader: "#define GLSLIFY 1\nuniform float t;\nuniform float t2;\nuniform float time;\nuniform float pt;\n\nvarying vec2 vUv;\n\n float ea1(float x) {\n  return x < 0.5 ? 16. * x * x * x * x * x : 1. - pow(-2. * x + 2., 5.) / 2.;\n}\n\nfloat ea2(float x) {\nreturn x < 0.5 ? 8. * x * x * x * x : 1. - pow(-2. * x + 2., 4.) / 2.;\n}\n\nfloat pi = 3.14159265359;\n\nvoid main() {\n  vUv = uv;\n  vec3 pos = position;\n  pos.z -= 85.;\n  vec2 ct = vec2(0.5);\n  float p = ea1(t);\n  float p2 = ea2(t2);\n  float np = min(2. * p2, 2. * (1. - p2));\n  pos.y -= .15 * sin(uv.x * pi + 0.25) * np;\n  pos.y += 1. * (1. - p);\n  float nPt = min(2. * pt, 2. * (1. - pt));\n  // pos.x *= 1. -(0.05 * (pt));\n  float dist = distance(vUv, ct);\n  float md = length(ct);\n  float nd = dist / md;\n  float b = nd * 150.;\n  float c = -nd * 150.;\n  float fm = mix(c, b, pt);\n  // pos.z -= fm * nPt;\n\n  float dt = distance(vec2(uv), vec2(0.5)) * 1.25;\n\n  pos.z -= dt * 85. * pt;\n  pos.y *= 1. + (0.11 * pt);\n\n  \n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}",
                    fragmentShader: "#define GLSLIFY 1\n#define PI 3.14159265359\n#define PI2 6.28318530718\nuniform float time;\nuniform float pt;\nuniform float st;\nuniform sampler2D tex;\nuniform vec2 ps;\nuniform float r;\nuniform float fc;\nuniform vec2 vc1;\nuniform vec2 vc2;\nuniform vec2 vc3;\nuniform vec4 c1;\nuniform vec4 c2;\n\nvarying vec2 vUv;\n\nfloat rand(vec2 st){\n\treturn fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat ns(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat ub( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b+r,0.0))-r;\n}\n\nvec4 la(vec4 frg, vec4 bc) {\n    return frg * frg.a + bc * (1.0 - frg.a);\n}\n\nfloat aastep(float threshold, float value) {\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\nfloat sw(vec2 pt, vec2 center, float radius, float line_width, float edge_thickness, float side){\n  vec2 d = pt - center;\n  float theta = time * .25 * side;\n  vec2 p = vec2(cos(theta), -sin(theta))*radius;\n  float h = clamp( dot(d,p)/dot(p,p), 0.0, 1.0 );\n  //float h = dot(d,p)/dot(p,p);\n  float l = length(d - p*h);\n\n  float gradient = 0.0;\n  const float gradient_angle = PI * .25;\n\n  if (length(d)<radius){\n    float angle = mod(theta + atan(d.y, d.x), PI2);\n    gradient = clamp(gradient_angle - angle, 0.0, gradient_angle)/gradient_angle * 0.5;\n  }\n\n  return gradient + 1.0 - smoothstep(line_width, line_width+edge_thickness, l);\n}\n\nvoid main()\t{\n    vec2 m = vUv;\n    vec2 m2 = vUv;\n\n    vec4 n = texture2D(tex, vUv);\n    float z = n.r * 2. * PI;\n    vec2 dr = vec2(sin(z));\n    vec2 uv = vUv + dr * n.r * 0.1;\n    float d1 = distance(uv, vc1);\n    float d2 = distance(uv, vc2);\n    float d3 = distance(uv, vc3);\n    float gr = mix(-0.2, 0.2, rand(uv + sin(time)));\n    vec2 mv = vec2(time *0.05, time * -0.05);\n    float f = ns((uv * d1 * 2.) + mv);\n    f += ns((uv * d2 * 2.5) + vec2(time * -0.075, time * 0.05));\n    f += gr;\n    f = smoothstep(0., 2., f);\n    // f = fract(f);\n    float mx = smoothstep(0., 0.1, f) - smoothstep(0.5, 1., f);\n    vec4 color = mix(c1, c2, f);\n    float nPt = min(2. * pt, 2. * (1. - pt));\n    float u = .3 * sin(m.x * PI + 0.25) * nPt;\n    float d = -.3 * sin(m.x * PI + 0.25) * nPt;\n    m.y -= mix(u, d, st);\n    float ft = step(m.y, pt);\n    vec2 rs = ps * (0.5 - vec2(fc * 0.35, fc));\n    vec2 rs2 = ps * (0.5 - vec2(fc * 0.35, fc));\n    float ra = r;\n    vec2 yl = vUv;\n    yl.y += 0.002;\n    yl.x += 0.00125;\n    float cr = ub(((vUv - vec2(fc * 0.35, fc * 0.75)) * ps) - rs, rs, ra);\n    float cr2 = ub(((yl - vec2(fc * 0.35, fc * 0.75)) * vec2(ps.x * 0.99725, ps.y * 0.995)) - rs2, rs2, ra);\n    cr = clamp(cr, 0.0, 1.);\n    cr2 = clamp(cr2, 0.0, 1.);\n    vec4 br = vec4(0.,0.,0.,0.);\n    vec4 s1 =  mix(color, vec4(0.,0.,0., 1.), ft);\n    vec3 brcl = vec3(77. / 255.);\n    brcl += sw(yl, vec2(0.5), 1.5, 0.00003,0.00001, 1.) * vec3(85./255.);\n    vec4 final = mix(s1, la(mix(vec4(brcl,1.), vec4(0.), cr2),vec4(0.,0.,0.,1.)), cr);\n\n    float alpha = 1.;\n    float cut = 0.001;\n    alpha *= aastep(cut, m2.x);\n    alpha *= 1. - aastep(1. - cut, m2.x);\n     alpha *= aastep(cut, m2.y);\n    alpha *= 1. - aastep(1. - cut, m2.y);\n\n    gl_FragColor =  vec4(final.rgb, alpha);\n}"
                }),
                this.mesh = new Dl(this.geometry,this.material),
                this.mesh.scale.set(window.innerWidth, window.innerHeight, 1),
                this.scene.add(this.mesh)
            }
            rs() {
                const t = {
                    h: window.innerHeight,
                    w: window.innerWidth
                };
                this.material.uniforms.ps.value.x = window.innerWidth,
                this.material.uniforms.ps.value.y = window.innerHeight,
                this.mesh.scale.set(1.15 * t.w, 1.148 * t.h, 1),
                this.width = this.container.offsetWidth,
                this.height = this.container.offsetHeight,
                this.camera.fov = 2 * Math.atan(this.height / 2 / 600) * (180 / Math.PI),
                this.renderer.setSize(this.width, this.height),
                this.camera.aspect = this.width / this.height,
                this.camera.updateProjectionMatrix(),
                this.home && this.home.rs(t),
                this.about && this.about.rs(t),
                this.contact && this.contact.rs(t),
                this.projects && this.projects.rs(t),
                this.project && this.project.rs(t),
                this.footer = Pn(".footer"),
                this.case = Pn(".project"),
                this.footer && !this.case && (this.footerB = Ln(this.footer).bottom + this.s)
            }
            onWheel(t) {
                this.projects && this.projects.onWheel(t),
                this.project && this.project.onWheel(t)
            }
            onMove(t) {
                this.mouse.x = t.clientX - this.width / 2,
                this.mouse.y = this.height / 2 - t.clientY,
                this.cursor && this.cursor.onMove(t),
                this.home && this.home.onMove(t),
                this.about && this.about.onMove(t),
                this.project && this.project.onMove(t)
            }
            mPos() {
                Math.abs(this.mouse.x - this.prevMouse.x) < 1 && this.mouse.y - this.prevMouse.y < 1 || (this.currentSmoke = (this.currentSmoke + 1) % this.total,
                this.nwD(this.mouse.x, this.mouse.y, this.currentSmoke)),
                this.prevMouse.x = this.mouse.x,
                this.prevMouse.y = this.mouse.y
            }
            nwD(t, e, i) {
                let n = this.dispM[i];
                n.visible = !0,
                n.scale.x = .15,
                n.scale.y = .15,
                n.rotation.x = 0,
                n.rotation.y = 0,
                n.position.x = t - .9,
                n.position.y = e,
                n.material.opacity = .5
            }
            update(t, e) {
                if (this.time += .05,
                this.s = t,
                this.home && this.home.update(t, e, this.time),
                this.about && this.about.update(t, e, this.time),
                this.projects && this.projects.update(this.time),
                this.contact && this.contact.update(),
                this.project && this.project.update(t, e, this.time),
                this.cursor && this.cursor.update(),
                this.renderer.setRenderTarget(this.renderTex),
                this.renderer.render(this.dispScene, this.camera),
                this.material.uniforms.tex.value = this.renderTex.texture,
                this.material.uniforms.time.value = this.time,
                this.renderer.setRenderTarget(null),
                this.renderer.clear(),
                this.renderer.render(this.scene, this.camera),
                this.footer && !this.contact && !this.case && !this.stopBord && !this.clamp) {
                    const t = (this.footerB - this.s - window.innerHeight) / window.innerHeight;
                    this.fc = On(t, .1, 0, 0, .115),
                    this.fc2 = On(t, .1, 0, 0, 40),
                    this.material.uniforms.fc.value = this.fc,
                    this.material.uniforms.r.value = this.fc2
                }
                this.smoke && (this.mPos(),
                this.dispM.forEach((t=>{
                    t.visible && (t.rotation.z += .02,
                    t.material.opacity *= .96,
                    t.material.opacity < .002 && (t.visible = !1),
                    t.scale.x = .98 * t.scale.x + .109,
                    t.scale.y = t.scale.x)
                }
                )))
            }
        }
        class fg {
            constructor() {
                this.burger = Pn(".header_burger"),
                this.menu = Pn(".menu--touch"),
                this.menuItems = [...Cn(".menu_nav_item--touch a span")],
                this.menuBorders = [...Cn(".menu_nav_item--touch ")],
                this.menuLink = [...Cn(".menu_nav_link--touch")],
                this.footerItems = [...Cn(".menu_footer_nav_item a")],
                this.line = Pn(".menu_marquee_footer_line--touch"),
                this.marqueeEl = Pn(".menu_marquee_text span"),
                this.l1 = Pn(".header_burger_l1"),
                this.l2 = Pn(".header_burger_l2"),
                this.l3 = Pn(".header_burger_l3"),
                this.state = {
                    open: !1
                },
                this.ael()
            }
            selUrl() {
                const t = window.location.pathname;
                "/" === window.location.pathname ? this.menuBorders.forEach(((t,e)=>{
                    t.style.border = 0 === e ? "1px solid rgba(255,255,255,0)" : "1px solid rgba(255,255,255,0.3)"
                }
                )) : t.indexOf("about") > -1 ? this.menuBorders.forEach(((t,e)=>{
                    t.style.border = 2 === e ? "1px solid rgba(255,255,255,0)" : "1px solid rgba(255,255,255,0.3)"
                }
                )) : t.indexOf("projects") > -1 ? this.menuBorders.forEach(((t,e)=>{
                    t.style.border = 1 === e ? "1px solid rgba(255,255,255,0)" : "1px solid rgba(255,255,255,0.3)"
                }
                )) : this.menuBorders.forEach((t=>t.style.border = "1px solid rgba(255,255,255,0.3)"))
            }
            loadImg() {
                [...Cn("[data-touch]")].forEach((t=>{
                    const e = t.getAttribute("data-touch");
                    t.src = window.TEXTURES[e][0].src,
                    t.crossOrigin = "anonymous",
                    t.style.visibility = "visible"
                }
                ))
            }
            onMenuItemClick(t) {
                this.menuLink.forEach(((t,e)=>{
                    bn.to(t, {
                        opacity: 1
                    })
                }
                )),
                setTimeout((()=>{
                    this.onClick()
                }
                ), 250)
            }
            onClick() {
                this.isAn || (this.isAn = !0,
                bn.to(this.burger, {
                    rotate: "90deg",
                    duration: .3
                }),
                this.state.open ? (bn.to(this.menu, {
                    autoAlpha: 0,
                    duration: .3,
                    ease: "Power1.easeOut",
                    onComplete: ()=>this.isAn = !1
                }),
                bn.to(this.burger, {
                    rotate: "0",
                    duration: .3
                }),
                bn.to(this.l2, {
                    scaleX: 1,
                    duration: .2,
                    ease: "Power1.easeOut"
                }),
                bn.to(this.l1, {
                    rotate: "0",
                    x: "0",
                    y: "0",
                    duration: .3,
                    ease: "Power1.easeOut"
                }),
                bn.to(this.l3, {
                    rotate: "0",
                    scaleX: 1,
                    duration: .3,
                    ease: "Power1.easeOut"
                }),
                this.state.open = !1) : (bn.to(this.l2, {
                    scaleX: 0,
                    duration: .2,
                    ease: "Power1.easeOut"
                }),
                bn.to(this.l1, {
                    rotate: "-45deg",
                    x: "0.72rem",
                    y: "1.5rem",
                    duration: .3,
                    ease: "Power1.easeOut"
                }),
                bn.to(this.l3, {
                    rotate: "45deg",
                    duration: .3,
                    ease: "Power1.easeOut"
                }),
                bn.to(this.menu, {
                    autoAlpha: 1,
                    duration: .3,
                    ease: "Power1.easeOut",
                    onComplete: ()=>this.isAn = !1
                }),
                bn.fromTo(this.line, {
                    scaleX: 0
                }, {
                    scaleX: 1,
                    delay: .25,
                    duration: .45,
                    ease: "Power2.easeOut"
                }),
                bn.fromTo(this.menuItems, {
                    y: "100%"
                }, {
                    y: 0,
                    stagger: .08,
                    duration: .6,
                    delay: .1,
                    ease: "Power3.easeOut"
                }),
                bn.fromTo(this.marqueeEl, {
                    y: "100%"
                }, {
                    y: 0,
                    duration: .6,
                    delay: .28,
                    ease: "Power3.easeOut"
                }),
                bn.fromTo(this.footerItems, {
                    y: "100%"
                }, {
                    y: 0,
                    stagger: .08,
                    duration: .8,
                    delay: .1,
                    ease: "Power3.easeOut"
                }),
                bn.fromTo(this.marqueeEl, {
                    autoAlpha: 0
                }, {
                    autoAlpha: 1,
                    delay: .3,
                    duration: .2
                }),
                this.state.open = !0))
            }
            update() {}
            ael() {
                Wn(Fn, this.onClick.bind(this), this.burger),
                this.menuLink.forEach(((t,e)=>{
                    t.addEventListener("click", (t=>{
                        this.onMenuItemClick(e)
                    }
                    ))
                }
                ))
            }
        }
        class mg extends (Um()) {
            constructor({data: t}) {
                super(),
                this.data = t,
                window.TEXTURES = [],
                this.length = 0,
                this.text = Pn(".preloader p span"),
                this.createPreloader()
            }
            intro() {
                gsap.to(".preloader--v1", {
                    y: "-100%",
                    stagger: .025,
                    duration: 1,
                    delay: .25,
                    ease: "Expo.easeOut"
                }),
                gsap.to(".preloader--v2", {
                    y: "0",
                    stagger: .025,
                    duration: 1,
                    delay: .35,
                    ease: "Expo.easeOut"
                }),
                setTimeout((()=>{
                    this.played = !0
                }
                ), 1300)
            }
            createPreloader() {
                this.data.medias.forEach((t=>{
                    const e = new Image;
                    e.src = t,
                    e.crossOrigin = "anonymous",
                    e.onload = i=>{
                        window.TEXTURES[t] = [e],
                        this.onAssetsLoaded()
                    }
                }
                ))
            }
            onAssetsLoaded() {
                this.length += 1;
                const t = this.length / this.data.medias.length
                  , e = Math.round(100 * t);
                this.text.innerHTML = e < 10 ? `00 ${e}%` : e < 100 ? `0 ${e}%` : `${e}%`,
                100 === e && setTimeout((()=>{
                    this.emit("completed")
                }
                ), 200)
            }
        }
        var gg = i(7320)
          , vg = i.n(gg);
        class yg {
            constructor(t) {
                console.log("%c Dev by - Alex -  https://alexfrisondeisla.com", "background: #1A1A1B; color: #F7ECDD;"),
                this.mouse = {
                    x: 0,
                    y: 0
                },
                this.wheel = !1,
                this.prevScrollpos = 0,
                this.m = 1,
                this.e = {
                    p: 0
                },
                this.navAbout = Pn(".nav_about"),
                this.navProjects = Pn(".nav_projects"),
                this.navInnerP = Pn(".link_inner", this.navProjects),
                this.navOuterP = Pn(".link_outer", this.navProjects),
                this.navHoverP = Pn(".cta_hover", this.navProjects),
                this.navInnerA = Pn(".link_inner", this.navAbout),
                this.navOuterA = Pn(".link_outer", this.navAbout),
                this.navHoverA = Pn(".cta_hover", this.navAbout),
                Jn.isPhone() ? this.nav = Pn(".header--touch") : this.nav = Pn(".header"),
                this.steBg(),
                this.sniff(),
                this.setScrollHistory(),
                this.createMenu(),
                this.createPages(t)
            }
            steBg() {
                const t = document;
                (t=>{
                    const e = navigator.userAgent;
                    return /Mobi|Android|iPad|iPhone/.test(e) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1
                }
                )() && (t.documentElement.classList.contains("desktop") && t.documentElement.classList.remove("desktop") && t.documentElement.classList.add("tablet"),
                setTimeout((()=>{
                    const e = t.createElement("video");
                    e.classList.add("m-bg"),
                    e.src = "/mbBG.mp4",
                    document.body.appendChild(e),
                    e.muted = !0,
                    e.playsInline = !0,
                    e.loop = !0,
                    e.autoplay = !0,
                    e.play()
                }
                ), 2e3))
            }
            sniff() {
                const t = [...Cn(".preloader span")];
                document.fonts.ready.then((()=>{
                    t.forEach((t=>t.style.opacity = 1))
                }
                ));
                const e = -1 < navigator.userAgent.toLowerCase().indexOf("firefox")
                  , i = -1 != navigator.appVersion.indexOf("Win")
                  , n = navigator.userAgent.toLowerCase().match(/version\/[\d.]+.*safari/);
                this.m = n ? 2 : e || i ? 2.5 : 1
            }
            async ld() {
                const t = await fetch(window.location.origin + "/data.json");
                await t.json()
            }
            createPreloader(t) {}
            destroyPreloader() {
                Pn(".home_hero_title"),
                setTimeout((()=>{
                    this.intro(),
                    setTimeout((()=>{
                        this.ShowPage(!0),
                        Jn.isPhone() && this.menu.selUrl(),
                        this.rs()
                    }
                    ), 0)
                }
                ), 0)
            }
            intro() {
                let t = 0
                  , e = 0
                  , i = 0;
                t = Jn.isPhone() ? 3.5 : 7,
                e = Jn.isPhone() ? 13.5 : 27,
                i = Jn.isPhone() ? -13 : -26,
                this.preloadetHTML = Pn(".preloader"),
                bn.to(".preloader--v1", {
                    y: "-100%",
                    stagger: .025,
                    duration: 2,
                    delay: .5,
                    ease: "Expo.easeOut"
                }),
                bn.to(".preloader--v2", {
                    y: "0",
                    stagger: .025,
                    duration: 2,
                    delay: .75,
                    ease: "Expo.easeOut"
                }),
                bn.to(".preloader_i--k", {
                    x: `${t}rem`,
                    delay: 1,
                    duration: .67,
                    delay: 1.8,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_fl_c", {
                    x: `${e}rem`,
                    delay: 1,
                    duration: .67,
                    delay: 1.8,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader_i--p", {
                    x: `${i}rem`,
                    delay: 1,
                    duration: .67,
                    delay: 1.8,
                    ease: "Expo.easeIn"
                }),
                bn.to(".preloader p span", {
                    display: "none",
                    delay: 0,
                    duration: 0,
                    ease: "Power3.easeOut"
                }),
                bn.to(this.e, {
                    p: 1,
                    delay: 2.39,
                    duration: 1.8
                }),
                Jn.isTablet() && bn.to("header", {
                    y: 0,
                    delay: 3.39,
                    duration: 1.3,
                    ease: "Power3.easeOut"
                })
            }
            setScrollHistory() {
                Jn.isDesktop() || "scrollRestoration"in history && (history.scrollRestoration = "manual")
            }
            createMenu() {
                Jn.isPhone() && (this.menu = new fg)
            }
            createMarquee() {
                this.createMarqueeData(),
                Jn.isPhone()
            }
            createMarqueeData = ()=>{
                const {marquee: t, socials: e} = this.dt.data;
                [...Cn(".header_marquee_text.marquee_anim span")].forEach((e=>e.innerHTML = t));
                const i = [...Cn(".menu_footer_nav_items a")];
                [...Cn(".menu_marquee_text.marquee_anim span")].forEach((e=>e.innerHTML = t)),
                i.forEach(((t,i)=>{
                    0 === i ? t.setAttribute("href", e.mail) : 1 === i ? t.setAttribute("href", e.ig) : 2 === i ? t.setAttribute("href", e.tw) : 3 === i && t.setAttribute("href", e.in)
                }
                ))
            }
            ;
            async createPages(t) {
                this.content = Pn(".app"),
                this.dt = t,
                this.r = new wn({
                    dt: t
                }),
                this.template = "home",
                this.r.rt({});
                const {cpblt: e, html: i, template: n} = this.r;
                this.pages = {
                    home: new pr,
                    about: new fr,
                    projects: new gr,
                    project: new vr,
                    not_found: new yr,
                    welcome: new Kn,
                    contact: new xr
                },
                this.createMarquee(),
                this.createContent(i, n, e)
            }
            createContent(t, e, i) {
                this.content = Pn(".app");
                const {content: n, page: r} = this;
                n.innerHTML = t,
                this.page = this.pages[e],
                this.page.create(!1, !0, i),
                this.page.show(),
                this.createCanvas(this.dt),
                this.createPreloader(this.dt),
                Jn.isDesktop() && (window.location.pathname.indexOf("project/") > -1 ? this.canvas.once("rs", (t=>{
                    this.rs()
                }
                )) : this.rs()),
                this.addEvents(),
                this.update(),
                (Jn.isPhone() || Jn.isTablet()) && this.destroyPreloader(),
                this.addLinks()
            }
            createCanvas(t) {
                Jn.isDesktop() && (this.canvas = new pg({
                    template: this.r.template,
                    data: t
                }),
                this.canvas.once("scroll", (t=>{
                    this.wheel = !0
                }
                )))
            }
            ShowPage(t) {
                this.page.intro(t)
            }
            onWheel(t) {
                if (!Jn.isDesktop())
                    return;
                if (!this.wheel)
                    return;
                const e = vg()(t)
                  , {pixelY: i} = e;
                this.delta = i * this.m,
                this.page && this.page.onWheel(this.delta),
                this.canvas && this.canvas.onWheel(this.delta)
            }
            onScroll(t) {
                this.currentScrollPos = this.content.scrollTop,
                this.page.onScroll(this.content.scrollTop),
                this.currentScrollPos > this.prevScrollpos && this.currentScrollPos > 0 && this.currentScrollPos < this.page.scroll.limit ? "-100%" !== this.nav.style.top && (this.nav.style.transform = "translateY(-100%)") : this.nav.style.transform = "translateY(0)",
                this.prevScrollpos = this.currentScrollPos
            }
            onStart(t) {
                this.isDown = !0,
                t.preventDefault(),
                this.touchY = t.touches[0].clientY
            }
            onTouchMove(t) {
                this.isDown && (t.preventDefault(),
                this.distance = 2.8 * (this.touchY - t.touches[0].clientY),
                setTimeout((()=>{
                    this.distance = 0
                }
                ), 50),
                this.touchY = t.touches[0].clientY,
                this.page && this.page.onTouchMove(this.distance))
            }
            onEnd() {
                this.isDown = !1
            }
            onMove(t) {
                this.mouse.x = t.clientX,
                this.mouse.y = t.clientY,
                this.canvas && this.canvas.onMove(t)
            }
            onPopState() {
                clearTimeout(this.timer1),
                clearTimeout(this.timer2),
                clearTimeout(this.timer3);
                let {canvas: t, content: e, menu: i} = this;
                const n = window.location.pathname;
                n.indexOf("projects") > -1 ? (this.navProjects.style.border = "1px solid rgba(255,255,255,0.3)",
                this.navAbout.style.border = "1px solid rgba(255,255,255,0)",
                this.navInnerP.style.transform = "translateY(-100%)",
                this.navOuterP.style.transform = "translateY(0)",
                this.navHoverP.style.transform = "scale(0) translateY(75%)") : n.indexOf("about") > -1 ? (this.navAbout.style.border = "1px solid rgba(255,255,255,0.3)",
                this.navProjects.style.border = "1px solid rgba(255,255,255,0)",
                this.navInnerA.style.transform = "translateY(-100%)",
                this.navOuterA.style.transform = "translateY(0)",
                this.navHoverA.style.transform = "scale(0) translateY(75%)") : (this.navAbout.style.border = "1px solid rgba(255,255,255,0)",
                this.navProjects.style.border = "1px solid rgba(255,255,255,0)"),
                this.r.template = void 0,
                this.r.rt({
                    url: n
                });
                const {cpblt: r, html: s, template: a} = this.r;
                this.cpblt = r,
                this.page.hide();
                const o = this.content.querySelector("div");
                o.parentElement.removeChild(o),
                e.insertAdjacentHTML("beforeend", s),
                this.page = this.pages[a];
                const {page: h} = this;
                h.create(!1, !1, this.cpblt),
                t && t.onChangeStart(),
                t && t.onChangeEnd(a),
                i && this.content.scrollTo(0, 0),
                this.rs(),
                i && i.selUrl(),
                h.show(),
                !Jn.isDesktop() && h.intro(),
                this.addLinks()
            }
            async onChange({url: t, push: e=!0, transition: i=null}) {
                this.r.template = void 0,
                this.r.rt({
                    url: t
                });
                const {cpblt: n, html: r, template: s} = this.r
                  , {content: a, canvas: o} = this;
                if (this.cpblt = n,
                this.menu && (this.page.hide(),
                Jn.isDesktop() || setTimeout((()=>{
                    a.scrollTo(0, 0)
                }
                ), 250)),
                e && window.history.pushState({}, "", t),
                o && null === i) {
                    o.onChangeStart(parseInt(i)),
                    this.page.hide(),
                    await o.transIn();
                    const t = a.querySelector("div");
                    t.parentElement.removeChild(t),
                    a.insertAdjacentHTML("beforeend", r),
                    this.page = this.pages[s],
                    this.page.create(!1, !1, this.cpblt),
                    o && (o.onChangeEnd(s),
                    await o.transOut()),
                    this.rs()
                }
                if (o && null !== i) {
                    o.onChangeStart(parseInt(i)),
                    document.documentElement.style.cursor = "none",
                    await this.page.hide();
                    const t = a.querySelector("div");
                    t.parentElement.removeChild(t),
                    a.insertAdjacentHTML("beforeend", r),
                    this.page = this.pages[s],
                    this.page.create(!0),
                    o.resetUrl(),
                    this.timer1 = setTimeout((async()=>{
                        o.onChangeEnd(s, parseInt(i)),
                        this.rs(),
                        await this.page.show(),
                        this.addLinks();
                        const t = [...Cn("a")];
                        document.documentElement.style.pointerEvents = "all",
                        t.forEach((t=>{
                            t.style.cursor = "none",
                            t.style.pointerEvents = "all"
                        }
                        )),
                        setTimeout((()=>{
                            this.wheel = !0
                        }
                        ), 100)
                    }
                    ), 1500)
                } else {
                    if (!Jn.isDesktop()) {
                        const t = a.querySelector("div");
                        t.parentElement.removeChild(t),
                        a.insertAdjacentHTML("beforeend", r),
                        this.page = this.pages[s],
                        this.page.create(!1, !1, this.cpblt),
                        this.menu && !0 === this.menu.state.open && this.menu.onClick(),
                        a.scrollTo(0, 0),
                        this.rs(),
                        this.menu && this.menu.selUrl(),
                        this.page.intro()
                    }
                    await this.page.show(),
                    this.wheel = !0,
                    this.timer3 = setTimeout((()=>{
                        const t = [...Cn("a")];
                        document.documentElement.style.pointerEvents = "all",
                        t.forEach((t=>{
                            t.style.cursor = "none",
                            t.style.pointerEvents = "all"
                        }
                        )),
                        document.documentElement.style.cursor = "none"
                    }
                    ), 450),
                    this.addLinks()
                }
            }
            rs() {
                const t = {
                    h: window.innerHeight,
                    w: window.innerWidth
                };
                let e = .01 * window.innerHeight;
                document.documentElement.style.setProperty("--vh", e + "px"),
                this.page && this.page.rs(t),
                this.canvas && this.canvas.rs(t)
            }
            update() {
                this.preloadetHTML && (this.preloadetHTML.style.transform = `translateY(${-100 * this.i(this.e.p)}%)`),
                this.page && this.page.update(this.mouse, this.page.scroll.current),
                this.canvas && this.canvas.update(this.page.scroll.current, this.page.scroll.target),
                this.menu && this.menu.update(),
                window.requestAnimationFrame(this.update.bind(this))
            }
            i(t) {
                return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
            }
            addEvents() {
                Wn("resize", this.rs.bind(this)),
                Jn.isDesktop() && (Wn("wheel", this.onWheel.bind(this)),
                Wn(zn, this.onMove.bind(this))),
                Wn("scroll", this.onScroll.bind(this), this.content),
                Wn("popstate", this.onPopState.bind(this)),
                Jn.isDesktop() || (Wn(Un, this.onStart.bind(this)),
                Wn(Hn, this.onTouchMove.bind(this)),
                Wn(jn, this.onEnd.bind(this)))
            }
            addLinks() {
                const t = [...Cn("a")];
                Tn()(t, (t=>{
                    t.onclick = e=>{
                        if (t.classList.contains("ext"))
                            return t.rel = "noopener",
                            void (t.target = "_blank");
                        let i = null;
                        i = t.hasAttribute("data-tindex") ? t.getAttribute("data-tindex") : null;
                        const {href: n} = t;
                        if (n !== window.location.origin + window.location.pathname) {
                            e.preventDefault(),
                            this.wheel = !1;
                            const t = [...Cn("a")];
                            document.documentElement.style.pointerEvents = "none",
                            t.forEach((t=>{
                                t.style.cursor = "none",
                                t.style.pointerEvents = "none"
                            }
                            )),
                            document.documentElement.style.cursor = "none",
                            this.onChange({
                                url: n,
                                transition: i
                            })
                        } else
                            e.preventDefault()
                    }
                }
                ))
            }
        }
        (async()=>{
            const t = window.location.origin
              , e = await (async t=>{
                const e = await fetch(t + "/d");
                return await e.json()
            }
            )(t);
            new yg(e)
        }
        )()
    }
    )()
}
)();
